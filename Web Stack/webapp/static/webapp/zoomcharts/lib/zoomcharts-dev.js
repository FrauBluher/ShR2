// DVSL Charting library, version 1.4.3.
// GIT revision: 39dcd08e27eaf7746b0517895dbe1a0da21b85a9
// (c) 2013 - 2015 Data Visualization Software Lab
//
// http://zoomcharts.com
//
//
// 3rd party software license acknowledgement:
// moment.js
// version : 2.0.0
// author : Tim Wood
// license : MIT
// momentjs.com
//
// CssColorParser.js
// author : Dean McNamee <dean@gmail.com>, 2012.
// license : MIT
// github.com/deanm/css-color-parser-js


(function(){
// Generated by CoffeeScript 1.8.0
var Netchart_Graph;

Netchart_Graph = (function() {
  function Netchart_Graph(chart, layer) {
    this.chart = chart;
    this.layer = layer;
    this.settings = this.chart.settings;
    this.idToNode = {};
    this.idToLink = {};
    this.state = {};
    this.userLoading = false;
  }

  Netchart_Graph.prototype.exportCoordinates = function(nodesDataList) {
    var n, node, _i, _len;
    for (_i = 0, _len = nodesDataList.length; _i < _len; _i++) {
      node = nodesDataList[_i];
      n = this.idToNode[node.id];
      if (n) {
        node.x = n.x;
        node.y = n.y;
      }
    }
  };

  Netchart_Graph.prototype.save = function() {
    var id, node, state, _ref;
    state = {};
    _ref = this.idToNode;
    for (id in _ref) {
      node = _ref[id];
      state[node.id] = {
        x: node.x,
        y: node.y,
        r: node.currentHHeight,
        w: node.currentHwidth
      };
    }
    return state;
  };

  Netchart_Graph.prototype.restore = function(state) {
    var id, n, s;
    this.state = {};
    for (id in state) {
      s = state[id];
      if (this.idToNode.hasOwnProperty(id)) {
        n = this.idToNode[id];
        n.x = s.x;
        n.y = s.y;
        n.hHeight = s.r;
        n.hWidth = s.w ? s.w : s.r;
      } else {
        this.state[id] = s;
      }
    }
  };

  Netchart_Graph.prototype.lockNode = function(nodeId, x, y) {
    var n;
    if (!this.idToNode.hasOwnProperty(nodeId)) {
      return this.chart.error("Locking nonexistant node: " + nodeId);
    } else {
      n = this.idToNode[nodeId];
      n.userLock = true;
      if (x !== void 0 && y !== void 0) {
        n.x = x;
        n.y = y;
      }
      return this.layer.touchNode(n);
    }
  };

  Netchart_Graph.prototype.unlockNode = function(nodeId) {
    var n;
    if (!this.idToNode.hasOwnProperty(nodeId)) {
      return this.chart.error("Locking nonexistant node: " + nodeId);
    } else {
      n = this.idToNode[nodeId];
      n.userLock = false;
      return this.layer.touchNode(n);
    }
  };

  Netchart_Graph.prototype.addNode = function(nodeId) {
    var data, n, s, sceneData;
    n = this.layer.addNode(nodeId);
    this.idToNode[nodeId] = n;
    sceneData = this.chart.getData("default");
    data = sceneData.getNodeData(nodeId);
    if (!data) {
      throw "Internal error";
    }
    n.data = data;
    n.dataLinks = sceneData.getNodeLinksRaw(nodeId);
    n.dataLinksFiltered = [];
    if (data.x != null) {
      n.x = data.x;
    }
    if (data.y != null) {
      n.y = data.y;
    }
    if (this.state.hasOwnProperty(nodeId)) {
      s = this.state[nodeId];
      delete this.state[nodeId];
      n.x = s.x;
      n.y = s.y;
      n.hHeight = s.r;
      n.hHwidth = s.w ? s.w : s.r;
    }
    return n;
  };

  Netchart_Graph.prototype.tryAddLink = function(linkData) {
    var link;
    if (this.idToLink.hasOwnProperty(linkData.id)) {
      link = this.idToLink[linkData.id];
      if (link.data !== linkData) {
        link.data = linkData;
        this.layer.touchLink(link);
      }
      return link;
    }
    if (this.idToNode.hasOwnProperty(linkData.from) && this.idToNode.hasOwnProperty(linkData.to)) {
      link = this.layer.addLink(linkData.id, linkData.from, linkData.to);
      link.data = linkData;
      this.idToLink[linkData.id] = link;
      link.from = this.idToNode[linkData.from];
      link.from.links.push(link);
      this.layer.touchNode(link.from);
      link.to = this.idToNode[linkData.to];
      link.to.links.push(link);
      this.layer.touchNode(link.to);
      return link;
    } else {
      return null;
    }
  };

  Netchart_Graph.prototype.removeNode = function(nodeId) {
    var link, node, other, sceneData, _i, _len, _ref;
    if (!this.idToNode.hasOwnProperty(nodeId)) {
      return;
    }
    node = this.idToNode[nodeId];
    _ref = node.links;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      link = _ref[_i];
      delete this.idToLink[link.id];
      other = link.otherEnd(node);
      if (other !== node) {
        Base_Helpers.removeFromArray(other.links, link);
        this.layer.touchNode(other);
      }
      this.layer.removeLink(link);
    }
    node.links = [];
    delete this.idToNode[nodeId];
    this.layer.removeNode(node);
    sceneData = this.chart.getData("default");
    return sceneData.nodeRemoved(nodeId);
  };

  Netchart_Graph.prototype.removeLink = function(linkId) {
    var link;
    if (this.idToLink.hasOwnProperty(linkId)) {
      link = this.idToLink[linkId];
      delete this.idToLink[linkId];
      Base_Helpers.removeFromArray(link.from.links, link);
      Base_Helpers.removeFromArray(link.to.links, link);
      this.layer.touchNode(link.from);
      this.layer.touchNode(link.to);
      return this.layer.removeLink(link);
    }
  };

  Netchart_Graph.prototype.removeAll = function() {
    return this.replaceGraph({}, {});
  };

  Netchart_Graph.prototype.exportData = function() {
    var id, l, links, n, nodes, _ref, _ref1;
    nodes = [];
    links = [];
    _ref = this.idToNode;
    for (id in _ref) {
      n = _ref[id];
      nodes.push(n.data);
    }
    _ref1 = this.idToLink;
    for (id in _ref1) {
      l = _ref1[id];
      links.push(l.data);
    }
    return {
      "nodes": nodes,
      "links": links
    };
  };

  Netchart_Graph.prototype.replaceGraph = function(nodesSet, expandedLinks) {
    var existingLink, existingNode, fromId, id, idToLink, idToNode, isNewGraph, l, link, linkData, links, newIdToLink, node, oldLinks, oldNodes, toId, _, _i, _len, _ref;
    isNewGraph = true;
    newIdToLink = {};
    _ref = this.idToNode;
    for (id in _ref) {
      node = _ref[id];
      l = node.links;
      while (l.length > 0) {
        l.pop();
      }
    }
    oldNodes = this.idToNode;
    this.idToNode = idToNode = {};
    for (id in nodesSet) {
      _ = nodesSet[id];
      existingNode = oldNodes[id];
      if (existingNode) {
        isNewGraph = false;
        idToNode[id] = existingNode;
      } else {
        existingNode = this.addNode(id);
      }
      if (expandedLinks.hasOwnProperty(id)) {
        existingNode.dataLinksFiltered = links = expandedLinks[id];
        for (_i = 0, _len = links.length; _i < _len; _i++) {
          l = links[_i];
          newIdToLink[l.id] = l;
        }
      }
    }
    oldLinks = this.idToLink;
    this.idToLink = idToLink = {};
    for (id in newIdToLink) {
      linkData = newIdToLink[id];
      existingLink = oldLinks[id];
      if (existingLink) {
        fromId = linkData.from;
        toId = linkData.to;
        if (idToNode.hasOwnProperty(fromId) && idToNode.hasOwnProperty(toId)) {
          idToNode[fromId].links.push(existingLink);
          idToNode[toId].links.push(existingLink);
          idToLink[id] = existingLink;
        }
      } else {
        this.tryAddLink(linkData);
      }
    }
    for (id in oldLinks) {
      link = oldLinks[id];
      if (!idToLink.hasOwnProperty(id)) {
        this.layer.touchNode(link.from);
        this.layer.touchNode(link.to);
        this.layer.removeLink(link);
      }
    }
    for (id in oldNodes) {
      node = oldNodes[id];
      if (!idToNode.hasOwnProperty(id)) {
        this.layer.removeNode(node);
      }
    }
    return isNewGraph;
  };

  Netchart_Graph.prototype.updateGraphWithNewData = function(nodesWithNewData, linksWithNewData) {
    var data, id, link, newData, node, sceneData, _results;
    sceneData = this.chart.getData("default");
    if (nodesWithNewData) {
      for (id in nodesWithNewData) {
        newData = nodesWithNewData[id];
        if (this.idToNode.hasOwnProperty(id)) {
          node = this.idToNode[id];
          node.data = sceneData.getNodeData(id);
          node.dataLinks = sceneData.getNodeLinksRaw(id);
          if (newData.x != null) {
            node.x = newData.x;
          }
          if (newData.y != null) {
            node.y = newData.y;
          }
          this.layer.touchNode(node);
        }
      }
    }
    if (linksWithNewData) {
      _results = [];
      for (id in linksWithNewData) {
        data = linksWithNewData[id];
        if (this.idToLink.hasOwnProperty(id)) {
          link = this.idToLink[id];
          link.data = sceneData.getLinkData(id);
          _results.push(this.layer.touchLink(link));
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    }
  };

  return Netchart_Graph;

})();
var builtinImages = {
    "no-data-light.png": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEYAAABPCAYAAABWIbNMAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyJpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNiAoV2luZG93cykiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6NzIyQjVERERFNTYzMTFFMkFCQzA5QTIyQ0RFNjkyMTYiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6NzIyQjVEREVFNTYzMTFFMkFCQzA5QTIyQ0RFNjkyMTYiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDo3MjJCNUREQkU1NjMxMUUyQUJDMDlBMjJDREU2OTIxNiIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDo3MjJCNUREQ0U1NjMxMUUyQUJDMDlBMjJDREU2OTIxNiIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/PqaQJv8AAA0dSURBVHja7FwLVJTHFV5w0YVdwAVUXFACCqiVl9IjEkTemAKmFhCDSQFBLIoHKb6NJ7WnNqipJoqJNTWa06MmimiaaMFXQFN8YagaFRFFLYLgCzHJgsuj34VZsq67sC9w18Occ8+/O/PPnTvff+fOvfPP/EZtbW2cpUuXcuRTdnY2R5WkqK6SxAWNA00CuYNcQI4gAYjP7vmR0U3QddBF0AlQKahFEVNV5VRHZuLJ5fRsMgH9BvQW6A2QhWxhv379GoyNjRu4XO49ekAtLS1mra2tfFx9Uewrc+sT0EHQTlCBMpB0mXoKGNKCFNAfQcMYCE8sLCyKBg0a9IOjo+M1V1fXapFI9BhFzSAJyIjJw62urhaWlZWJKisrR92/f9/t6dOnHgArHmVEt0DrQdtAPxsKMMQvFbQKZGNkZNQsFAoLXVxcjoWFhZ0xMzOrQz6BUU+dgko3K1FlLkCj4WUJsmpsbBx0+PDhX1+9ejWsvr7eD9q1EfnLQCvAYwfub9NnYMaCdoDGEyBDhgz5KigoKNfd3Z3sRDXoITrRpqINaGbDh+gOOm40derU70EHS0tLPQsLC6Pr6ureAECfoXw27k/BPVf0EZg00AbQAAyXc9COzd7e3mfw/zaEFmvLnAH6kAgAlHt5eZ0tKSnZV1BQMB/DbCLyS3BPOso+0wtgIEw/XD4EpcOINsFubExISPgc/8tQ1iPjnwF9FSDcBkBXduzYkVhRUZEC7dmGsjEoW6SLocXVQsD+bJaIMTExuRceHr7Sz88vH/lVnF5IDPhzAKG2qKjo0tGjR/8skUiykDcUZUnIf6YNf2NNNQV2ZBeBwuPxbsTHx6cBlC96CxS5dGfy5Mk7IyMjM6G1BFY8ZNsOWYxehsZsgupGA5RbycnJc4cNG1YEQZo4Lymh7RaAkgQfyIzAwZWm9Tts5uodjYEQZGjT+vfvXx0dHZ0BUI6/ZFDMoCEHAEawubn593FxcbMxtB90FC2d2SvAoCE3CPEhGdqQkJBlbm5uBcp8kV5K7aBAe0MJlJSUlAwPD4/9AQEBy5AvAW2BfM49CgwaAB7Gn0OI/s7Ozp/4+/vnIbtJn0CB73QK+eLg4OA9I0eO3IoyAWTWyN6oDAwaSIa6ekGI80lJSX9jwZ6+gSKNoRrgNqwTCAQXIPPr+P/7HgEGiJtDiPdJPX19fSmcrdJjUDpmFS73to+PTzbubQGtRR9MdQ4MtGU+BLFGAHgwMDDw3/oOijTBDn5jY2NTgPsHI4hN0ikwQJqWDjIIebj5m/D7J0MARbq+4+npmYN65AkvIjupM2CgLREYp4MRJZ+AwS3WJ1DIf+muIgxxkaWlZXFLS8tr6EugzoCBCibSFYLsw6XRkEBh6Wfcn8fsTqJOgEHj3Obm5hBaaQsNDd1vgKC0J/g1e6EtP6EvkaoOJ+NutGU8hOJbWFicFYlENYYICiVHR8e7bOoeiD65aQ0M3P4QuvL5fDJybYYICkutAOY0/UC4EKo1MBBuPF2hMWcMGJT2BF6n2GTipTUwGJNOdLW2tr5oyKAwYC7RFbOTi9bAgMkwMrwRERE1hgwKpZiYmFsU/KJPIq2BgZC0vkExUbMhg8JSE73DggE21woYikjBhAdm4lcAFKmzKkY7plprDNOatlcBFHX7ohQYWmkHwo00nF4FUGRMg1hrjYHgtH5q9iqAwiYTc2YztQNmwIABNWA2EAILDB0U8LdFmzw4rTVaAwMv8Q67jjZkUNobNjMbw7z5W1oDA2aXGTC+hgwKS7TEyeHxeFe0BgYe70k2NgMNHBTqw2S62trantQamNDQ0O/oBZZEIpnMVvIMEhS0xUMffMiLj4qKOq01MOjA44EDB/6HwnUAFG6IoDDHLop2atEqJMxDgy4cvDaoXh5bm5ltiKAw2Wl3F0ckEuXqZAWPUnh4+AEY3zpE2hHolKOhgYI2XTCMQjAb3Y2MjDyoM2DQoVogvQ+d7MflcpcYEihMW1ZQP4cPH77LwsLioc6AoeEUFBSUgwbqYdmT0cFRhgIK2vWEbXmbXvJPmTJlC0eNVUiVFoZdXV2vOTk5bUeHuTBkHxsIKEaQdTPkMXZxcdlib29/S536qr6Aapk+ffpGWPRyPIFANJqsz6CwlAlZffl8/g8zZsz4BP9bewIYWhq87e/v/yc8hWcAYRM67a6voKBtb8iUTa9M4IutxFCqVnuKVydqDwgI+BrDinZTmaLhQ7T3RA9BcYBMX0Emk7Fjx27w8fEp0Mj3UfP+HxMSEjYMHTqUZik7CHBez0AZDJmOQSaRnZ3dl/Hx8ZuRLe4NYCjdTU9Pf9fKyuo4BKD1DbGfn99qPQDlNYDyHWQaQTsc0tLS3kP2PY29ZQ19g7LU1NTFAOdbGDjT/Pz8jyDY2JdsU04BFGcCZd68eYvhc13TKozQtCJiqNKsrKxMNqzsSTBkz+F0HJborWQEUGhvbzFksMWUvDszM3ORqanpJa3jKy3qtkJzLmRkZKxwc3Nby/agkBN1HPSrXgCF3igWgj7AcJZ4enr+FUP8Pch0iaOD18nGOlDjazNnzvxo2rRpafBzriIrAPRf0FbQyB4AxJXTcSTnLMhfIBBcio2NTYWvQpuaruuqEa6Oxnh1dnZ27rhx48p3794dXVZWNgtBJ0Xj5AgeAP0TRFvUNN3lyQNFcDo2GUbSAyU3f/To0f+Ii4vbz7REp++/uDo0gLRd/TQAuvPkyZMjeXl5UZWVldHPnj37HfKJ6IxSESPaJEDa9VgJOyGI1mh9QJMZtZ+Ooyh5xIgR+6ChXyMopKXXHnl9rPMTbkx77iUlJV0FKLlHjhzxgQYFPnr0yBdB6Ju45U1Zvwh0n13JaNPhrcGcX85ISmfBJ5gBD0FDCsPCws5ixrmB7Gq01arJmciXAgwDh+KS/0HoqoiIiEugbwDS0JMnT46BFo2GRjmIxWJRU1PTYIBlgxllOBlMGHAxQHhKK/mwV1WY+W6MGjXq4sSJE6/DwNYy7Xis6oGwlwpMN0+MOvCICJ29EhwcfI5mek7HmUl6kWfKZJDK0cyI9vrR7tCnbLg9VaPNngVGjWPDKsdanF+O8+l9Mub0pT5g+oDpA6YPmD5g+oDpA6YPmFcqST3fEhDtAveGu31TzgOOxWUPaDrK9srkUwS8hJE0HQXtZWsxXSUpT0VpDbHvou4NJuscmXbGsz50l6xkIvpOPujXVoXAIFrlNzc3CxHE0W6AcbI3ILQf2NDQ0H6VAcUJ9x5FwFfj6ek5PyYmpn2BaO3atZGIov/OGlTaOSlPJyen1ampqZ0beXJzc51LS0v/gMCSDnd4K6hK+U4mJibX6dUr7tvKYidqf4r0pvXr10+vq6ub5e3t3SmbNJpnoc5zfBQ9yM5YiXYz0ilZVFyChtZ0BTsBiKDw0apVqzLwtxx1GpiA5Tk5Oa1VVVWkRTe705wHDx7Q10IKZILDUzwer6a4uHg7ZMmWBxcP8B1E4jVWVlZ5tbW1S9gDuMna7+QjEAiC6FpRUXERZSde6LQcH3rQ8iOl08ZAoPOEIDq9jA0TZcFlKph62dnZ0SdJSqSgsLLK9PT0daampqUAOl2D5YqGyMjIQ3w+vwj14+XLoSG/NTMzKxEKhf9i6zTxmtgPVfgYy9z8bMKECXTC3Rj0qTKm0BR/0i4MgS+VdK4KwNAuLDf2RNUFR4z2ScWHydWPxQOxoM4kJiaWEvj4P1sDXFTi89ysRE/L2tr6C/qgBTO6ipINEG7/glAXQ62Mrnjytpo8UdR/IF+f1J9s2ty5c/cTeAz84czwqj7bKOGD3+O7mq7FWVlZ77MhtU7RkCKNAnBd7hyQSCTt324BH40WwiBoi1x9Ie26NDc3/xYytT8QLy+vbaS56OjbarBWmY8iP6bSwcEhB52nl+Nr5Qtp5yMEt+sGGAdmt+o1tAGWsvUheBqpf319fTxb8Go7duxYKeQQgKJVdtrU4KPQwUtJSdmJKfUQmKQ0Nja6y5YB7WI68wPEQ7oAJoC0bsGCBRq950F9D1J3aX08oLeIH2aOKbJkb2+/kdmiWBWHaJd8ZM2HMlV/OGnSpL/k5+d7QcjnPhiRmZm5a+XKleRrvMscuhd8DfhErw8ZMmSNhh/uckJ9P9i63az+eLQ11tLS8mPZqZ1N75eXL18+C5rwDurs7YavQj60foyZtJMPc1CVhwQApgRT8hZSPbmie2z2GokGjsgZP/ItjsA/2AMAczSZMZiPVLFw4cI1zM5EkA1YvHjxB4pmQBjoQrbrW9gV4674IHXykdrVrmIlCSz3VlR4YYs5zV6rV6+Ox7C6y1zx9vEKAxZFaonGV6ryvSp4v1uldTkdr08+pZdocBznkE/E7E0yCS39/4I1FQppk5AF2Y9u7JZafIzYoS/6lhy9SbygoI4HyJaVye83kX5ItHMIsnu6A8WW8X3hYbC65TJ5/ozvZSW8rFn4QHWknXZkstEOjAZN+Bj17Mk+w03/F2AAHZMD17Q4OMAAAAAASUVORK5CYII=",
    "no-data-dark.png": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEYAAABPCAYAAABWIbNMAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyJpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNiAoV2luZG93cykiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6NUI0RTA2RDZFNTYzMTFFMkJDOTdGRTQ2M0VGMEIxOEMiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6NUI0RTA2RDdFNTYzMTFFMkJDOTdGRTQ2M0VGMEIxOEMiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDo1QjRFMDZENEU1NjMxMUUyQkM5N0ZFNDYzRUYwQjE4QyIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDo1QjRFMDZENUU1NjMxMUUyQkM5N0ZFNDYzRUYwQjE4QyIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/PjyBbi0AAAvnSURBVHja7JwLUFTnFcdZ2EVYEQNxMkgEI9MoaoVQpdakom0hE6t2nFocFRrHlqSatlOLio+pjDOZjCYkdmKiE9vRacahoyMdH4wYsE2iIdIWEIurRV4LldfyXJ7Lm/7Pci69ud1d7t59Ycs3c+Yu997vfOf+7vnO97yoxsbGvCwllUrlJSdZy28hqSHfgKyGREEWQhZAAiAz+Z4elmpIBaQUchtSAhlxxE57bVa5GIwG8n3INsg6SKD44tDQUBekd3BwsI/K02g0WshMSKBETyfkOiQTkiuG9KSBIS9IgaRCwhhCZ319/b1Hjx7pbt++/ejGjRsNJSUlHbg0TJepSPYqdUxMTND69etDV69eHYm0bO7cudEiWDWQE5CzkD5XgTHfZEnsKUQkasgbkBbI2Ojo6FB1dfVnp0+f/k1wcHACbo+GhLPnqG2UTYBm870vzJ49O+HkyZOH9Xr959A5PDaeGiA7ISolYCYTZ4L5OqSILB4ZGRkqLS29smXLlmSOJ3ME71Qi7E1PE9ikpKQdOp3uGpXBgO5AlkxVMLsh/WRlXV3d33fu3LkDlyIh/kph2LDLH7KYymhsbCxiOH2Qn0wZMLjPB/IBWTY8PNyfnZ39Prc8WmcDsWAfBerY3NzcU/CeAQb0rpyq5VIwuMcXcoms6e3tbdyzZw8F23muBmLBzvC0tLRdfX19zQwnk2zzCBjyFATBLLLCaDRWbty4cRO1RO6GIrJz1q5du5Ko6ecYl2nLc1wJ5jRD0a9cufJlnJrhCSiCnThqAeXPZJMAB+mYW8FwoB3r6empT0xM/IGtZtdNooX35pFNCMbFW7du3Y5q1cJwktwCBueXwYgBCrT79+9/1ZOeYgnK0qVLv02t1pEjR1JQnQZxrRuXnncpGJzzhpveJSNycnJ+y73bqQbFh80NzMvL+5Bby3xpvHEqGBTwGhtRRK2PPYW4GYo5+fn5zTcYDPe4Su1wCRj8PQuu2UrueejQoR/ZW4i7oQjp6NGjW2kIAbsNuN3f6WBQhQ6TIQ8ePLgsmiLwBBjZUITBbFlZ2XW6HyP4N5wKBr81qEYGIr9v377vKglkHoJiTunp6euQbxRg9BQnnQYGUDaRMVVVVZ9S1fUQGItQZA5dtLW1tfncx/me08Cgu3+FlGIc9HOlfQJXQZE7prt+/Xoq973OOwUMza8gcPUMDAx0xsTEhHoAjE0ocsHExcWFwVt64P0dVJ0cBoN6uZKMqqmpuclzIu4EMykUO6ZHvOvq6r7kIBwtp3xvW9rgevF0bG5uLiAGXu5LNG1xRaVSJTQ1Nd2Nj4//FVrEAhofKtQ3imf4K/3AcCFBFslJBovL6Yg39rcnGIo5QVcBNyYxDoPx9fWNoGNlZWXpkwyFX+5987KFRrPQoWk+jjFtFHh5ctrLxTFGVkxROgVLA14a/JpMpnqHgy8UmdBc1zs6G+YqKHaC8QKUZlrLcggMjUjJ0K6urkoXg1EMxV4waExqaUnHKWC6u7srXAjGISj2goH31/Cyi+NVCc2bq6qSw1CUVCXEzS6HwSDwtkFRhwvAOAWKvWDgLRQzGxwG09bWpuOJngAngnEaFDsXBkOozJaWlmKHe76oRv/i4+Kp3k+ZLOElLxHijMMdvPb29gd07O/vf/FJhsK7N16io9FofOgwGPR4vzBvPVCrv/MkQ+FnWENHnU73hcM9X9T/YFrA4uG6RmGMcWpMUbjG7odnME+fBAcHBzpjokpVXV2dx8sQGxSAcSkUuWBgeyLZUF5enu20GbyrV6/u4oX7q3aCcTkUuWBgey7ZcfHixR1OA4MHCkGrZOCdTAtkgnELFJm7MhZSLMNwoC40NHSOM5dPVPn5+eZFfLROH8kA4zYocsAgrnxMtty8efMdYRbSaetK69atW4ICOngAFmkDjFuhyNiV8QLsGaFF/tjY2AhXLNH65ObmnuAliE+tgHE7lEl2Zahgq3me9/Lly2+KuyZOXbsOCQl5Dr3HRzxE+KmkEI9AmQSMecmkubn5vlarDXXlNhDVwYMHt6HpGwAE2gwYJWza8RQUG9tVVtDiIy2Z7N69e5M7Ng4FZGdnv8t7eOto74knoVjZrjIfo+h6bp7f5F2ebtlq9uy9e/eyGE6XJ6FY2JXxDGyqJJuKi4svUARw6x48X1/fyKqqqr9wMO5LS0v7oSegSDYfPAco5dzD/WTGjBmLPLKdNTw8fDkt9LPnPMYh2lNgOKY0ClCCgoKiPLkB2luj0USLqhUF5J/xXLG7wFBZe2nllWwoLCz8I7x5mbXlZLdumUdadOnSpbfRWgnbSD+DLHUDlBjILWELa2Zm5luw5fkp9S0BUmhKSsqrra2tDxkO9ZB/B/maC4AsgpzlMsYMBkNpcnJykrVA6/GvT3hv/7eysrIyTCZTGwMagfwJQpuPHNn66gfZDLnKOseom3/hwoVjKPOblprkqfRZzoT3hIWFvZyTk/MBRrQNY/9JNNlFm5B+DXkREmTDMLr2EsePa5BOQQmNkuljDoyUaSfGXCWzeR4Bw3lpXBIWEBCw5r333jtQVlb2Ca/nSBNtUK6GlELu8+8e6U3Ia6RNhhkZGfv9/PzW8HZab3uXT+wB49JvIlXjSoLozc6cOXNuamrqkri4uMXwqPloUkMB7hm0IgE+Pj5aUkXrPoDQi2qCYVlbXW1tbRU8r/TUqVMVtEGSNi1AyPPG7LVTrs0Teh0FY89Evdf4J39P8a5yLccGtWg3xTBLP028QboJBB+dlhwC8/+evKcRTIOZBjMNZhrMNJhpMNNgpsH8b4Kh7xzbIRE0FBALUqLX+HcEiZLzNAY6ztcEoY8xXpdRbqIkn1iOT5K3iu8Tl7Pchj6xBFnSY+GZx8H09/fT53w01M+SWtHQ0PCU+MhjjQiaiEe+1efOnfsllL1Cotfry3D5zGQPJ+i6devWW0JeEtKFQeQGflGWEk01RGCQWYH7kkXjugqxnocPH56j82LbWHps6fmvAZXJZPonRq/dPMo/IL5eX19v/nqWjsK50dHRu52dnWT8ChoYiqYbFhQWFr7Pel63NqQX65RMVwSeOHFiM2yhKYrj0nyw8+OBgYEGnU53nMuIsKTfYDC8TRcxOo+zdN2SHimTiRhjNBqLiSBOHqKJIhsjU3K9mJKSEnor9G9KukTX9LGxsRnQVYKH+4WCUW9XampqTktLyy3k3y697uvru6m9vb2opqbmGv2Nt71dSfyQo2cCjEajGTxz5swheIM35PfWlPb29sbRV29r1669aOXh6jo6Or5Uq9U0Wx+hAI4J+iuQP0ySP9Hb2zuQHmbDhg0lBN/Hx+c1BVxk6flKq0Rvq7Ky8gIy0vxqohXD55Ab4mebtZIBlmKNV2tra4iSN4oyWqX5UeaP8WYbV61adZngEXw8UDgHXtnJmh7h2yxrzbUpMjLyGFUpPFyGpSpFHoU0aqtwf3//QTpCj1oJGHjLiCR/EDx6TVNTEy3NmF/I+fPnz5LnogFItkO1bD2W+jH6O3fufIiHnw8I70gvUmCE8mdtla7VaufTEQHaqAQM9M8W50eZu8n9w8PDtwtNb3p6OlWBAEDcLFevPXosdvASEhIy0aTmQElKYGBglKSpvQNFs0A83poBfn5+a8nroqKiKpSAgcdFk7sL+VHWNtInaXpfKSoqOsmxKFFmFbWp5yvhQ2iu8XbyxEr27t27imIJ3KxT0lyHIACXDw0NfS7kl0g83c9NoV3NNUsElVleXv4R/72cP4g/ZWE1Yh51M1ANrslori3q4TShZ2JO2BoY8mhUqXRhCUPcj6G+Bt4o7Y+5yQUKBR2ge6urq6nFmqcATCL3kYqpT0Tn8IbTyWjhb6k0NjZm88sLsgXGmh4hSfXYAmP2jubm5ttSMF7js/txqFZ/EK//QE8+dfBwbaGtNRsBjDQBivHx48f0Nf0K4V48TC0ZbU1XQUFBCq9fH7YFxpoeIUn1mFcJUM9WUSMA+YcFOPTfDkP4WpPkmvCPRIXUxvfUTVLdQ1ivNA1x3nLRuTjW+8CKrqe5B0559HxuAdtGnxR32auHOqrTyydW0r8FGADOGvuNcLn3BwAAAABJRU5ErkJggg=="
};

var Piechart_images_back = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAC8AAAA1CAYAAADRarJRAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAgFJREFUeNrUmc8rBGEYx9/dUbTkoIhCcXSQLUV74szRH6C9uConJy9HZwdylisnjsuNxE2ituS0tChx8eP1fXmnpm1mza/X7vepT00708znfd/Z533fZ4RIP1YEaWhxxSyumMUVs7hiFlfM4opZXDGLK2ZxxSyumMUVs/i/yWdCiMuY99aNeDbHL+AePIAKuAHX4BJcga9m6PE46AYegCUwzCTuxymYB21s4l7uQBFk2cS9HIMhRnGXKigwiru8gglGcRedbvtd8WyIXN9M0Q22an+URL2vmdbSjpEvmRGYIhmBHrDDOgLv+hVyauRZRkD/Vy8cnxMsDSg7AScYGlBx6pxM0oAn8AFaLcpXW/64QMYsnnZ5jjvBABgEo2DS0JtQ3gl7YdQsFCbyYN1sUOJknFKUlkphZxvYZjYijxHl96MOlRT29rB94DCC/Each0hhbwPumLVLGPnFuA+Rwl71QGe43RDyidK4tFj6yJnqQtD9dRruSPoQabFuM1tH/iStyUJaks+Ymo6f/Fqas520VDFbDpAfT3u6lhbkCz7iZVvrDZmyfM5HftXmak+mfD/vzPsZpobTVOt2j/yeIIvbtCamRoT72pyxibd7en2OTT5vxM/JimM/UTTyM4IwtsGRIA397WqMUXwEbLL2+kJNFSJ++aAB8SZ+v0sFxrcAAwAU8YKsEeepXgAAAABJRU5ErkJggg==";
// Generated by CoffeeScript 1.8.0
var Base_Random;

Base_Random = (function() {
  function Base_Random(seed) {
    this.seed = seed;
    this.A = 48271;
    this.M = 2147483647;
    this.Q = this.M / this.A;
    this.R = this.M % this.A;
    this.oneOverM = 1.0 / this.M;
  }

  Base_Random.prototype.get = function() {
    var hi, lo, test;
    hi = this.seed / this.Q;
    lo = this.seed % this.Q;
    test = this.A * lo - this.R * hi;
    if (test > 0) {
      this.seed = test;
    } else {
      this.seed = test + this.M;
    }
    return this.seed * this.oneOverM;
  };

  Base_Random.prototype.getArrayIndex = function(array) {
    return array[Math.floor(array.length * this.get())];
  };

  return Base_Random;

})();
// Generated by CoffeeScript 1.8.0
var RadialLayout;

RadialLayout = (function() {
  function RadialLayout() {}

  RadialLayout.prototype.setParams = function(cx, xy, spacing, startAngle, endAngle) {
    this.cx = cx;
    this.xy = xy;
    this.spacing = spacing;
    this.startAngle = startAngle;
    this.endAngle = endAngle;
    return 1;
  };

  RadialLayout.prototype.getMainLinks = function(centerNode) {
    var level, link, node, nodes, result, subnodes, _i, _j, _len, _len1, _ref;
    this.visitedNodes = {};
    this.visitedNodes[centerNode.id] = true;
    result = {};
    level = 1;
    nodes = [centerNode];
    while (nodes.length > 0) {
      subnodes = [];
      for (_i = 0, _len = nodes.length; _i < _len; _i++) {
        node = nodes[_i];
        _ref = this.getSublinks(node);
        for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
          link = _ref[_j];
          result[link.id] = true;
          subnodes.push(link.otherEnd(node));
        }
      }
      nodes = subnodes;
      level += 1;
    }
    return result;
  };

  RadialLayout.prototype.layoutGraph = function(centerNode) {
    this.visitedNodes = {};
    this.visitedNodes[centerNode.id] = true;
    this.subnodes = {};
    this.radiuses = [];
    this.minAngle = {};
    this.computeMaxRadius(centerNode);
    return this.placeNodeRec(centerNode, 0, this.startAngle, this.endAngle - this.startAngle);
  };

  RadialLayout.prototype.getSubnodes = function(node) {
    var id, link, otherNode, result, _i, _len, _ref;
    id = node.id;
    if (this.subnodes[id]) {
      return this.subnodes[id];
    }
    result = [];
    _ref = node.links;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      link = _ref[_i];
      otherNode = link.otherEnd(node);
      if (!this.visitedNodes.hasOwnProperty(otherNode.id)) {
        result.push(otherNode);
        this.visitedNodes[otherNode.id] = true;
      }
    }
    this.subnodes[id] = result;
    return result;
  };

  RadialLayout.prototype.getSublinks = function(node) {
    var link, otherNode, result, _i, _len, _ref;
    result = [];
    _ref = node.links;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      link = _ref[_i];
      if (link.removed) {
        continue;
      }
      otherNode = link.otherEnd(node);
      if (!this.visitedNodes.hasOwnProperty(otherNode.id)) {
        result.push(link);
        this.visitedNodes[otherNode.id] = true;
      }
    }
    return result;
  };

  RadialLayout.prototype.getNodeSize = function(node) {
    return Math.max(node.bRight - node.bLeft, node.bBottom - node.bTop) * node.visibility;
  };

  RadialLayout.prototype.computeMaxRadius = function(node) {
    var level, maxDistance, maxLength, nodeSize, nodes, prevRadius, radius, spacing, subSize, subnode, subnodes, _i, _j, _len, _len1, _ref, _results;
    spacing = this.spacing;
    prevRadius = 0;
    this.radiuses[0] = prevRadius;
    level = 1;
    nodes = [node];
    _results = [];
    while (nodes.length > 0) {
      maxDistance = 0;
      maxLength = 0;
      subnodes = [];
      for (_i = 0, _len = nodes.length; _i < _len; _i++) {
        node = nodes[_i];
        nodeSize = this.getNodeSize(node);
        _ref = this.getSubnodes(node);
        for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
          subnode = _ref[_j];
          subSize = this.getNodeSize(subnode);
          maxDistance = Math.max(maxDistance, subSize + nodeSize);
          maxLength += spacing + subSize;
          subnodes.push(subnode);
        }
      }
      radius = Math.max(prevRadius + maxDistance * 0.5 + spacing, maxLength / (Math.PI * 2));
      this.radiuses[level] = radius;
      prevRadius = radius;
      nodes = subnodes;
      _results.push(level += 1);
    }
    return _results;
  };

  RadialLayout.prototype.computeMinAngle = function(node, level) {
    var id, minAngle, radius, size, spacing, subAngle, subnode, _i, _len, _ref;
    id = node.id;
    if (this.minAngle.hasOwnProperty(id)) {
      return this.minAngle[id];
    }
    spacing = this.spacing;
    radius = this.radiuses[level];
    size = this.getNodeSize(node);
    minAngle = (size + spacing) / radius;
    subAngle = 0;
    _ref = this.getSubnodes(node);
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      subnode = _ref[_i];
      subAngle += this.computeMinAngle(subnode, level + 1);
    }
    minAngle = Math.max(minAngle, subAngle);
    this.minAngle[id] = minAngle;
    return minAngle;
  };

  RadialLayout.prototype.placeNodeRec = function(node, level, startAngle, availableAngle) {
    var angle, avail, nodeAngle, radius, scale, subnode, subnodes, subnodesAngle, _i, _j, _len, _len1, _results;
    nodeAngle = startAngle + availableAngle * 0.5;
    radius = this.radiuses[level];
    node.x = this.cx + radius * Math.cos(nodeAngle);
    node.y = this.cx + radius * Math.sin(nodeAngle);
    subnodes = this.getSubnodes(node);
    if (subnodes.length > 0) {
      subnodesAngle = 0;
      for (_i = 0, _len = subnodes.length; _i < _len; _i++) {
        subnode = subnodes[_i];
        subnodesAngle += this.computeMinAngle(subnode, level + 1);
      }
      scale = availableAngle / subnodesAngle;
      angle = startAngle;
      _results = [];
      for (_j = 0, _len1 = subnodes.length; _j < _len1; _j++) {
        subnode = subnodes[_j];
        avail = this.computeMinAngle(subnode, level + 1) * scale;
        this.placeNodeRec(subnode, level + 1, angle, avail);
        _results.push(angle += avail);
      }
      return _results;
    }
  };

  return RadialLayout;

})();
// Generated by CoffeeScript 1.8.0

/*
  retrieving and caching raw data
 */
var Base_Data,
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

Base_Data = (function() {
  Base_Data.settings = {
    _doc: {
      doc_file: "base/settings/data.markdown",
      type: "section"
    },
    id: "default",
    id_doc: {
      doc: "Data id used for series to reference specific data source.",
      type: "string"
    },
    url: null,
    url_doc: {
      doc: "URL to load more data. URL parameters: from, to, unit",
      type: "url"
    },
    urlParameters: [],
    urlParameters_doc: {
      doc: "List of extra parameters to pass with data URL.",
      type: "array",
      baseObject: {
        name: null,
        name_doc: {
          doc: "Parameter name.",
          type: "string"
        },
        value: null,
        value_doc: {
          doc: "Parameter value.",
          type: "string"
        },
        _doc: {
          doc: "Url parameter.",
          type: "object"
        }
      }
    },
    postprocessorFunction: null,
    postprocessorFunction_doc: {
      doc: "Function to postprocess data response.",
      type: "function",
      parameters: {
        "data": "Recieved data"
      },
      returns: "Processed data"
    },
    preloaded: null,
    preloaded_doc: {
      doc: "Preloaded data as JSON, same format as data response. Data can be represented by an object or string.",
      type: "string"
    },
    format: "JSON",
    format_doc: {
      doc: "Data loading format. Currently only JSON supported.",
      type: "enum",
      values: ["JSON"]
    },
    requestTimeout: 40000,
    requestTimeout_doc: {
      doc: "Timeout in milliseconds for data requests. New request will be issued if success or error function is not called in this period.",
      type: "integer"
    },
    numberOfParallelRequests: 3,
    numberOfParallelRequests_doc: {
      doc: "Max number of parallel data requests to issue. More requests will result in faster loading, but might put heavy load on server.",
      type: "integer"
    }
  };

  function Base_Data(chart, dataSettings) {
    this.chart = chart;
    this.dataSettings = dataSettings;
    this._runRequests = __bind(this._runRequests, this);
    this.settings = chart.settings;
    this.removed = false;
    this.requestScheduled = false;
    this.cleanupScheduled = false;
    this.requestsRunning = false;
    this.requests = [];
    this.CS = String.fromCharCode(0xf8ff);
  }

  Base_Data.prototype.buildRequest = function() {
    return 1;
  };

  Base_Data.prototype.dataFunc = function(request, success, fail) {
    return 1;
  };

  Base_Data.prototype.verifyData = function(request, data) {
    return 1;
  };

  Base_Data.prototype.addVerifiedData = function(request, data) {
    return {};
  };

  Base_Data.prototype.requestTimeout = function(request) {
    return 1;
  };

  Base_Data.prototype.requestFailedPermanently = function(request) {
    return 1;
  };

  Base_Data.prototype.removeData = function(data) {
    return 1;
  };

  Base_Data.prototype.exportData = function() {
    return 1;
  };

  Base_Data.prototype.remove = function() {
    return this.removed = true;
  };

  Base_Data.prototype.hasPendingRequests = function() {
    return this.requests.length > 0;
  };

  Base_Data.prototype.addData = function(data) {
    return this._dataArrived(null, data);
  };

  Base_Data.prototype.hasDataFunc = function() {
    return this.dataSettings.dataFunction || this.dataSettings.url;
  };

  Base_Data.prototype.applyPreloadedData = function() {
    if (this.dataSettings.preloaded) {
      return this._dataArrived(null, this.dataSettings.preloaded);
    }
  };

  Base_Data.prototype.scheduleRequests = function() {
    if (!this.requestScheduled) {
      this.requestScheduled = true;
      return setTimeout(this._runRequests, 0);
    }
  };

  Base_Data.prototype._runRequests = function() {
    var r, remainingRequests, time, timeout, _i, _len, _ref;
    if (this.removed || this.requestsRunning) {
      return;
    }
    this.requestScheduled = false;
    time = new Date().getTime();
    timeout = this.dataSettings.requestTimeout;
    if (this.cleanupScheduled) {
      this.cleanupScheduled = false;
      remainingRequests = [];
      _ref = this.requests;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        r = _ref[_i];
        if (r.time + timeout > time) {
          remainingRequests.push(r);
        } else {
          this.requestTimeout(r);
          if (r.time !== 0) {
            this.chart.error("Data request timed out, timeout " + timeout + " ms");
          }
        }
      }
      this.requests = remainingRequests;
    }
    this.requestsRunning = true;
    while (this.requests.length < this.dataSettings.numberOfParallelRequests) {
      r = this.buildRequest();
      if (!r) {
        break;
      }
      (function(_this) {
        return (function() {
          var e, failFunc, okFunc, request, result;
          request = r;
          request.time = time;
          okFunc = function(data) {
            return _this._dataArrived(request, data);
          };
          failFunc = function() {
            return _this._dataError(request);
          };
          _this.requests.push(request);
          _this.chart.log("Requesting data for", request);
          try {
            result = _this.dataFunc(request, okFunc, failFunc);
          } catch (_error) {
            e = _error;
            _this.requestsRunning = false;
            throw e;
          }
          if (!result) {
            return Base_Helpers.removeFromArray(_this.requests, request);
          } else if (result !== true) {
            return _this._dataArrived(request, result);
          }
        });
      })(this)();
    }
    this.requestsRunning = false;
    if (this.requests.length > 0 && !this.cleanupScheduled) {
      this.cleanupScheduled = true;
      return setTimeout(this._runRequests, timeout);
    }
  };

  Base_Data.prototype._dataError = function(request) {
    if (this.removed) {
      return;
    }
    this.chart.error("Data request failed for nodes: " + request.nodes);
    request.time = 0;
    this.cleanupScheduled = true;
    return this._runRequests();
  };

  Base_Data.prototype._dataArrived = function(request, rawData) {
    var allOk, changes, data;
    if (this.removed) {
      return;
    }
    this.chart.log("Data arrived for request", request);
    if (request) {
      Base_Helpers.removeFromArray(this.requests, request);
    }
    if (rawData) {
      data = Base_Helpers.parseData(rawData, this.dataSettings.format, this.chart);
      if (data.error != null) {
        this.chart.error(data.error);
      }
      allOk = this.verifyData(request, data);
    } else {
      allOk = false;
      this.chart.error("Got empty response");
    }
    if (allOk) {
      changes = this.addVerifiedData(request, data);
      changes.dataArrived = {};
      changes.dataArrived[this.dataSettings.id] = true;
      this.chart.events.notifySceneChanges(changes);
    } else {
      this.requestFailedPermanently(request);
    }
    return this._runRequests();
  };

  Base_Data.doRequest = function(url, config, params, success, fail) {
    var p, resultFunc, _i, _len, _ref;
    _ref = config.urlParameters;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      p = _ref[_i];
      params.push([p.name, p.value]);
    }
    if (config.postprocessorFunction) {
      resultFunc = function(data) {
        return success(config.postprocessorFunction(data));
      };
    } else {
      resultFunc = success;
    }
    return Base_Helpers.doRequest(url, params, resultFunc, fail);
  };

  return Base_Data;

})();
//! moment.js
//! version : 2.9.0
//! authors : Tim Wood, Iskren Chernev, Moment.js contributors
//! license : MIT
//! momentjs.com

var moment =

(function (undefined) {
    /************************************
     Constants
     ************************************/

    var moment,
        VERSION = '2.9.0',
    // the global-scope this is NOT the global object in Node.js
        globalScope = (typeof global !== 'undefined' && (typeof window === 'undefined' || window === global.window)) ? global : this,
        oldGlobalMoment,
        round = Math.round,
        hasOwnProperty = Object.prototype.hasOwnProperty,
        i,

        YEAR = 0,
        MONTH = 1,
        DATE = 2,
        HOUR = 3,
        MINUTE = 4,
        SECOND = 5,
        MILLISECOND = 6,

    // internal storage for locale config files
        locales = {},

    // extra moment internal properties (plugins register props here)
        momentProperties = [],

    // check for nodeJS
        hasModule = (typeof module !== 'undefined' && module && module.exports),

    // ASP.NET json date format regex
        aspNetJsonRegex = /^\/?Date\((\-?\d+)/i,
        aspNetTimeSpanJsonRegex = /(\-)?(?:(\d*)\.)?(\d+)\:(\d+)(?:\:(\d+)\.?(\d{3})?)?/,

    // from http://docs.closure-library.googlecode.com/git/closure_goog_date_date.js.source.html
    // somewhat more in line with 4.4.3.2 2004 spec, but allows decimal anywhere
        isoDurationRegex = /^(-)?P(?:(?:([0-9,.]*)Y)?(?:([0-9,.]*)M)?(?:([0-9,.]*)D)?(?:T(?:([0-9,.]*)H)?(?:([0-9,.]*)M)?(?:([0-9,.]*)S)?)?|([0-9,.]*)W)$/,

    // format tokens
        formattingTokens = /(\[[^\[]*\])|(\\)?(Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Q|YYYYYY|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|mm?|ss?|S{1,4}|x|X|zz?|ZZ?|.)/g,
        localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g,

    // parsing token regexes
        parseTokenOneOrTwoDigits = /\d\d?/, // 0 - 99
        parseTokenOneToThreeDigits = /\d{1,3}/, // 0 - 999
        parseTokenOneToFourDigits = /\d{1,4}/, // 0 - 9999
        parseTokenOneToSixDigits = /[+\-]?\d{1,6}/, // -999,999 - 999,999
        parseTokenDigits = /\d+/, // nonzero number of digits
        parseTokenWord = /[0-9]*['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+|[\u0600-\u06FF\/]+(\s*?[\u0600-\u06FF]+){1,2}/i, // any word (or two) characters or numbers including two/three word month in arabic.
        parseTokenTimezone = /Z|[\+\-]\d\d:?\d\d/gi, // +00:00 -00:00 +0000 -0000 or Z
        parseTokenT = /T/i, // T (ISO separator)
        parseTokenOffsetMs = /[\+\-]?\d+/, // 1234567890123
        parseTokenTimestampMs = /[\+\-]?\d+(\.\d{1,3})?/, // 123456789 123456789.123

    //strict parsing regexes
        parseTokenOneDigit = /\d/, // 0 - 9
        parseTokenTwoDigits = /\d\d/, // 00 - 99
        parseTokenThreeDigits = /\d{3}/, // 000 - 999
        parseTokenFourDigits = /\d{4}/, // 0000 - 9999
        parseTokenSixDigits = /[+-]?\d{6}/, // -999,999 - 999,999
        parseTokenSignedNumber = /[+-]?\d+/, // -inf - inf

    // iso 8601 regex
    // 0000-00-00 0000-W00 or 0000-W00-0 + T + 00 or 00:00 or 00:00:00 or 00:00:00.000 + +00:00 or +0000 or +00)
        isoRegex = /^\s*(?:[+-]\d{6}|\d{4})-(?:(\d\d-\d\d)|(W\d\d$)|(W\d\d-\d)|(\d\d\d))((T| )(\d\d(:\d\d(:\d\d(\.\d+)?)?)?)?([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/,

        isoFormat = 'YYYY-MM-DDTHH:mm:ssZ',

        isoDates = [
            ['YYYYYY-MM-DD', /[+-]\d{6}-\d{2}-\d{2}/],
            ['YYYY-MM-DD', /\d{4}-\d{2}-\d{2}/],
            ['GGGG-[W]WW-E', /\d{4}-W\d{2}-\d/],
            ['GGGG-[W]WW', /\d{4}-W\d{2}/],
            ['YYYY-DDD', /\d{4}-\d{3}/]
        ],

    // iso time formats and regexes
        isoTimes = [
            ['HH:mm:ss.SSSS', /(T| )\d\d:\d\d:\d\d\.\d+/],
            ['HH:mm:ss', /(T| )\d\d:\d\d:\d\d/],
            ['HH:mm', /(T| )\d\d:\d\d/],
            ['HH', /(T| )\d\d/]
        ],

    // timezone chunker '+10:00' > ['10', '00'] or '-1530' > ['-', '15', '30']
        parseTimezoneChunker = /([\+\-]|\d\d)/gi,

    // getter and setter names
        proxyGettersAndSetters = 'Date|Hours|Minutes|Seconds|Milliseconds'.split('|'),
        unitMillisecondFactors = {
            'Milliseconds' : 1,
            'Seconds' : 1e3,
            'Minutes' : 6e4,
            'Hours' : 36e5,
            'Days' : 864e5,
            'Months' : 2592e6,
            'Years' : 31536e6
        },

        unitAliases = {
            ms : 'millisecond',
            s : 'second',
            m : 'minute',
            h : 'hour',
            d : 'day',
            D : 'date',
            w : 'week',
            W : 'isoWeek',
            M : 'month',
            Q : 'quarter',
            y : 'year',
            DDD : 'dayOfYear',
            e : 'weekday',
            E : 'isoWeekday',
            gg: 'weekYear',
            GG: 'isoWeekYear'
        },

        camelFunctions = {
            dayofyear : 'dayOfYear',
            isoweekday : 'isoWeekday',
            isoweek : 'isoWeek',
            weekyear : 'weekYear',
            isoweekyear : 'isoWeekYear'
        },

    // format function strings
        formatFunctions = {},

    // default relative time thresholds
        relativeTimeThresholds = {
            s: 45,  // seconds to minute
            m: 45,  // minutes to hour
            h: 22,  // hours to day
            d: 26,  // days to month
            M: 11   // months to year
        },

    // tokens to ordinalize and pad
        ordinalizeTokens = 'DDD w W M D d'.split(' '),
        paddedTokens = 'M D H h m s w W'.split(' '),

        formatTokenFunctions = {
            M    : function () {
                return this.month() + 1;
            },
            MMM  : function (format) {
                return this.localeData().monthsShort(this, format);
            },
            MMMM : function (format) {
                return this.localeData().months(this, format);
            },
            D    : function () {
                return this.date();
            },
            DDD  : function () {
                return this.dayOfYear();
            },
            d    : function () {
                return this.day();
            },
            dd   : function (format) {
                return this.localeData().weekdaysMin(this, format);
            },
            ddd  : function (format) {
                return this.localeData().weekdaysShort(this, format);
            },
            dddd : function (format) {
                return this.localeData().weekdays(this, format);
            },
            w    : function () {
                return this.week();
            },
            W    : function () {
                return this.isoWeek();
            },
            YY   : function () {
                return leftZeroFill(this.year() % 100, 2);
            },
            YYYY : function () {
                return leftZeroFill(this.year(), 4);
            },
            YYYYY : function () {
                return leftZeroFill(this.year(), 5);
            },
            YYYYYY : function () {
                var y = this.year(), sign = y >= 0 ? '+' : '-';
                return sign + leftZeroFill(Math.abs(y), 6);
            },
            gg   : function () {
                return leftZeroFill(this.weekYear() % 100, 2);
            },
            gggg : function () {
                return leftZeroFill(this.weekYear(), 4);
            },
            ggggg : function () {
                return leftZeroFill(this.weekYear(), 5);
            },
            GG   : function () {
                return leftZeroFill(this.isoWeekYear() % 100, 2);
            },
            GGGG : function () {
                return leftZeroFill(this.isoWeekYear(), 4);
            },
            GGGGG : function () {
                return leftZeroFill(this.isoWeekYear(), 5);
            },
            e : function () {
                return this.weekday();
            },
            E : function () {
                return this.isoWeekday();
            },
            a    : function () {
                return this.localeData().meridiem(this.hours(), this.minutes(), true);
            },
            A    : function () {
                return this.localeData().meridiem(this.hours(), this.minutes(), false);
            },
            H    : function () {
                return this.hours();
            },
            h    : function () {
                return this.hours() % 12 || 12;
            },
            m    : function () {
                return this.minutes();
            },
            s    : function () {
                return this.seconds();
            },
            S    : function () {
                return toInt(this.milliseconds() / 100);
            },
            SS   : function () {
                return leftZeroFill(toInt(this.milliseconds() / 10), 2);
            },
            SSS  : function () {
                return leftZeroFill(this.milliseconds(), 3);
            },
            SSSS : function () {
                return leftZeroFill(this.milliseconds(), 3);
            },
            Z    : function () {
                var a = this.utcOffset(),
                    b = '+';
                if (a < 0) {
                    a = -a;
                    b = '-';
                }
                return b + leftZeroFill(toInt(a / 60), 2) + ':' + leftZeroFill(toInt(a) % 60, 2);
            },
            ZZ   : function () {
                var a = this.utcOffset(),
                    b = '+';
                if (a < 0) {
                    a = -a;
                    b = '-';
                }
                return b + leftZeroFill(toInt(a / 60), 2) + leftZeroFill(toInt(a) % 60, 2);
            },
            z : function () {
                return this.zoneAbbr();
            },
            zz : function () {
                return this.zoneName();
            },
            x    : function () {
                return this.valueOf();
            },
            X    : function () {
                return this.unix();
            },
            Q : function () {
                return this.quarter();
            }
        },

        deprecations = {},

        lists = ['months', 'monthsShort', 'weekdays', 'weekdaysShort', 'weekdaysMin'],

        updateInProgress = false;

    // Pick the first defined of two or three arguments. dfl comes from
    // default.
    function dfl(a, b, c) {
        switch (arguments.length) {
            case 2: return a != null ? a : b;
            case 3: return a != null ? a : b != null ? b : c;
            default: throw new Error('Implement me');
        }
    }

    function hasOwnProp(a, b) {
        return hasOwnProperty.call(a, b);
    }

    function defaultParsingFlags() {
        // We need to deep clone this object, and es5 standard is not very
        // helpful.
        return {
            empty : false,
            unusedTokens : [],
            unusedInput : [],
            overflow : -2,
            charsLeftOver : 0,
            nullInput : false,
            invalidMonth : null,
            invalidFormat : false,
            userInvalidated : false,
            iso: false
        };
    }

    function printMsg(msg) {
        if (moment.suppressDeprecationWarnings === false &&
            typeof console !== 'undefined' && console.warn) {
            console.warn('Deprecation warning: ' + msg);
        }
    }

    function deprecate(msg, fn) {
        var firstTime = true;
        return extend(function () {
            if (firstTime) {
                printMsg(msg);
                firstTime = false;
            }
            return fn.apply(this, arguments);
        }, fn);
    }

    function deprecateSimple(name, msg) {
        if (!deprecations[name]) {
            printMsg(msg);
            deprecations[name] = true;
        }
    }

    function padToken(func, count) {
        return function (a) {
            return leftZeroFill(func.call(this, a), count);
        };
    }
    function ordinalizeToken(func, period) {
        return function (a) {
            return this.localeData().ordinal(func.call(this, a), period);
        };
    }

    function monthDiff(a, b) {
        // difference in months
        var wholeMonthDiff = ((b.year() - a.year()) * 12) + (b.month() - a.month()),
        // b is in (anchor - 1 month, anchor + 1 month)
            anchor = a.clone().add(wholeMonthDiff, 'months'),
            anchor2, adjust;

        if (b - anchor < 0) {
            anchor2 = a.clone().add(wholeMonthDiff - 1, 'months');
            // linear across the month
            adjust = (b - anchor) / (anchor - anchor2);
        } else {
            anchor2 = a.clone().add(wholeMonthDiff + 1, 'months');
            // linear across the month
            adjust = (b - anchor) / (anchor2 - anchor);
        }

        return -(wholeMonthDiff + adjust);
    }

    while (ordinalizeTokens.length) {
        i = ordinalizeTokens.pop();
        formatTokenFunctions[i + 'o'] = ordinalizeToken(formatTokenFunctions[i], i);
    }
    while (paddedTokens.length) {
        i = paddedTokens.pop();
        formatTokenFunctions[i + i] = padToken(formatTokenFunctions[i], 2);
    }
    formatTokenFunctions.DDDD = padToken(formatTokenFunctions.DDD, 3);


    function meridiemFixWrap(locale, hour, meridiem) {
        var isPm;

        if (meridiem == null) {
            // nothing to do
            return hour;
        }
        if (locale.meridiemHour != null) {
            return locale.meridiemHour(hour, meridiem);
        } else if (locale.isPM != null) {
            // Fallback
            isPm = locale.isPM(meridiem);
            if (isPm && hour < 12) {
                hour += 12;
            }
            if (!isPm && hour === 12) {
                hour = 0;
            }
            return hour;
        } else {
            // thie is not supposed to happen
            return hour;
        }
    }

    /************************************
     Constructors
     ************************************/

    function Locale() {
    }

    // Moment prototype object
    function Moment(config, skipOverflow) {
        if (skipOverflow !== false) {
            checkOverflow(config);
        }
        copyConfig(this, config);
        this._d = new Date(+config._d);
        // Prevent infinite loop in case updateOffset creates new moment
        // objects.
        if (updateInProgress === false) {
            updateInProgress = true;
            moment.updateOffset(this);
            updateInProgress = false;
        }
    }

    // Duration Constructor
    function Duration(duration) {
        var normalizedInput = normalizeObjectUnits(duration),
            years = normalizedInput.year || 0,
            quarters = normalizedInput.quarter || 0,
            months = normalizedInput.month || 0,
            weeks = normalizedInput.week || 0,
            days = normalizedInput.day || 0,
            hours = normalizedInput.hour || 0,
            minutes = normalizedInput.minute || 0,
            seconds = normalizedInput.second || 0,
            milliseconds = normalizedInput.millisecond || 0;

        // representation for dateAddRemove
        this._milliseconds = +milliseconds +
        seconds * 1e3 + // 1000
        minutes * 6e4 + // 1000 * 60
        hours * 36e5; // 1000 * 60 * 60
        // Because of dateAddRemove treats 24 hours as different from a
        // day when working around DST, we need to store them separately
        this._days = +days +
        weeks * 7;
        // It is impossible translate months into days without knowing
        // which months you are are talking about, so we have to store
        // it separately.
        this._months = +months +
        quarters * 3 +
        years * 12;

        this._data = {};

        this._locale = moment.localeData();

        this._bubble();
    }

    /************************************
     Helpers
     ************************************/


    function extend(a, b) {
        for (var i in b) {
            if (hasOwnProp(b, i)) {
                a[i] = b[i];
            }
        }

        if (hasOwnProp(b, 'toString')) {
            a.toString = b.toString;
        }

        if (hasOwnProp(b, 'valueOf')) {
            a.valueOf = b.valueOf;
        }

        return a;
    }

    function copyConfig(to, from) {
        var i, prop, val;

        if (typeof from._isAMomentObject !== 'undefined') {
            to._isAMomentObject = from._isAMomentObject;
        }
        if (typeof from._i !== 'undefined') {
            to._i = from._i;
        }
        if (typeof from._f !== 'undefined') {
            to._f = from._f;
        }
        if (typeof from._l !== 'undefined') {
            to._l = from._l;
        }
        if (typeof from._strict !== 'undefined') {
            to._strict = from._strict;
        }
        if (typeof from._tzm !== 'undefined') {
            to._tzm = from._tzm;
        }
        if (typeof from._isUTC !== 'undefined') {
            to._isUTC = from._isUTC;
        }
        if (typeof from._offset !== 'undefined') {
            to._offset = from._offset;
        }
        if (typeof from._pf !== 'undefined') {
            to._pf = from._pf;
        }
        if (typeof from._locale !== 'undefined') {
            to._locale = from._locale;
        }

        if (momentProperties.length > 0) {
            for (i in momentProperties) {
                prop = momentProperties[i];
                val = from[prop];
                if (typeof val !== 'undefined') {
                    to[prop] = val;
                }
            }
        }

        return to;
    }

    function absRound(number) {
        if (number < 0) {
            return Math.ceil(number);
        } else {
            return Math.floor(number);
        }
    }

    // left zero fill a number
    // see http://jsperf.com/left-zero-filling for performance comparison
    function leftZeroFill(number, targetLength, forceSign) {
        var output = '' + Math.abs(number),
            sign = number >= 0;

        while (output.length < targetLength) {
            output = '0' + output;
        }
        return (sign ? (forceSign ? '+' : '') : '-') + output;
    }

    function positiveMomentsDifference(base, other) {
        var res = {milliseconds: 0, months: 0};

        res.months = other.month() - base.month() +
        (other.year() - base.year()) * 12;
        if (base.clone().add(res.months, 'M').isAfter(other)) {
            --res.months;
        }

        res.milliseconds = +other - +(base.clone().add(res.months, 'M'));

        return res;
    }

    function momentsDifference(base, other) {
        var res;
        other = makeAs(other, base);
        if (base.isBefore(other)) {
            res = positiveMomentsDifference(base, other);
        } else {
            res = positiveMomentsDifference(other, base);
            res.milliseconds = -res.milliseconds;
            res.months = -res.months;
        }

        return res;
    }

    // TODO: remove 'name' arg after deprecation is removed
    function createAdder(direction, name) {
        return function (val, period) {
            var dur, tmp;
            //invert the arguments, but complain about it
            if (period !== null && !isNaN(+period)) {
                deprecateSimple(name, 'moment().' + name  + '(period, number) is deprecated. Please use moment().' + name + '(number, period).');
                tmp = val; val = period; period = tmp;
            }

            val = typeof val === 'string' ? +val : val;
            dur = moment.duration(val, period);
            addOrSubtractDurationFromMoment(this, dur, direction);
            return this;
        };
    }

    function addOrSubtractDurationFromMoment(mom, duration, isAdding, updateOffset) {
        var milliseconds = duration._milliseconds,
            days = duration._days,
            months = duration._months;
        updateOffset = updateOffset == null ? true : updateOffset;

        if (milliseconds) {
            mom._d.setTime(+mom._d + milliseconds * isAdding);
        }
        if (days) {
            rawSetter(mom, 'Date', rawGetter(mom, 'Date') + days * isAdding);
        }
        if (months) {
            rawMonthSetter(mom, rawGetter(mom, 'Month') + months * isAdding);
        }
        if (updateOffset) {
            moment.updateOffset(mom, days || months);
        }
    }

    // check if is an array
    function isArray(input) {
        return Object.prototype.toString.call(input) === '[object Array]';
    }

    function isDate(input) {
        return Object.prototype.toString.call(input) === '[object Date]' ||
            input instanceof Date;
    }

    // compare two arrays, return the number of differences
    function compareArrays(array1, array2, dontConvert) {
        var len = Math.min(array1.length, array2.length),
            lengthDiff = Math.abs(array1.length - array2.length),
            diffs = 0,
            i;
        for (i = 0; i < len; i++) {
            if ((dontConvert && array1[i] !== array2[i]) ||
                (!dontConvert && toInt(array1[i]) !== toInt(array2[i]))) {
                diffs++;
            }
        }
        return diffs + lengthDiff;
    }

    function normalizeUnits(units) {
        if (units) {
            var lowered = units.toLowerCase().replace(/(.)s$/, '$1');
            units = unitAliases[units] || camelFunctions[lowered] || lowered;
        }
        return units;
    }

    function normalizeObjectUnits(inputObject) {
        var normalizedInput = {},
            normalizedProp,
            prop;

        for (prop in inputObject) {
            if (hasOwnProp(inputObject, prop)) {
                normalizedProp = normalizeUnits(prop);
                if (normalizedProp) {
                    normalizedInput[normalizedProp] = inputObject[prop];
                }
            }
        }

        return normalizedInput;
    }

    function makeList(field) {
        var count, setter;

        if (field.indexOf('week') === 0) {
            count = 7;
            setter = 'day';
        }
        else if (field.indexOf('month') === 0) {
            count = 12;
            setter = 'month';
        }
        else {
            return;
        }

        moment[field] = function (format, index) {
            var i, getter,
                method = moment._locale[field],
                results = [];

            if (typeof format === 'number') {
                index = format;
                format = undefined;
            }

            getter = function (i) {
                var m = moment().utc().set(setter, i);
                return method.call(moment._locale, m, format || '');
            };

            if (index != null) {
                return getter(index);
            }
            else {
                for (i = 0; i < count; i++) {
                    results.push(getter(i));
                }
                return results;
            }
        };
    }

    function toInt(argumentForCoercion) {
        var coercedNumber = +argumentForCoercion,
            value = 0;

        if (coercedNumber !== 0 && isFinite(coercedNumber)) {
            if (coercedNumber >= 0) {
                value = Math.floor(coercedNumber);
            } else {
                value = Math.ceil(coercedNumber);
            }
        }

        return value;
    }

    function daysInMonth(year, month) {
        return new Date(Date.UTC(year, month + 1, 0)).getUTCDate();
    }

    function weeksInYear(year, dow, doy) {
        return weekOfYear(moment([year, 11, 31 + dow - doy]), dow, doy).week;
    }

    function daysInYear(year) {
        return isLeapYear(year) ? 366 : 365;
    }

    function isLeapYear(year) {
        return (year % 4 === 0 && year % 100 !== 0) || year % 400 === 0;
    }

    function checkOverflow(m) {
        var overflow;
        if (m._a && m._pf.overflow === -2) {
            overflow =
                m._a[MONTH] < 0 || m._a[MONTH] > 11 ? MONTH :
                    m._a[DATE] < 1 || m._a[DATE] > daysInMonth(m._a[YEAR], m._a[MONTH]) ? DATE :
                        m._a[HOUR] < 0 || m._a[HOUR] > 24 ||
                        (m._a[HOUR] === 24 && (m._a[MINUTE] !== 0 ||
                        m._a[SECOND] !== 0 ||
                        m._a[MILLISECOND] !== 0)) ? HOUR :
                            m._a[MINUTE] < 0 || m._a[MINUTE] > 59 ? MINUTE :
                                m._a[SECOND] < 0 || m._a[SECOND] > 59 ? SECOND :
                                    m._a[MILLISECOND] < 0 || m._a[MILLISECOND] > 999 ? MILLISECOND :
                                        -1;

            if (m._pf._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) {
                overflow = DATE;
            }

            m._pf.overflow = overflow;
        }
    }

    function isValid(m) {
        if (m._isValid == null) {
            m._isValid = !isNaN(m._d.getTime()) &&
            m._pf.overflow < 0 &&
            !m._pf.empty &&
            !m._pf.invalidMonth &&
            !m._pf.nullInput &&
            !m._pf.invalidFormat &&
            !m._pf.userInvalidated;

            if (m._strict) {
                m._isValid = m._isValid &&
                m._pf.charsLeftOver === 0 &&
                m._pf.unusedTokens.length === 0 &&
                m._pf.bigHour === undefined;
            }
        }
        return m._isValid;
    }

    function normalizeLocale(key) {
        return key ? key.toLowerCase().replace('_', '-') : key;
    }

    // pick the locale from the array
    // try ['en-au', 'en-gb'] as 'en-au', 'en-gb', 'en', as in move through the list trying each
    // substring from most specific to least, but move to the next array item if it's a more specific variant than the current root
    function chooseLocale(names) {
        var i = 0, j, next, locale, split;

        while (i < names.length) {
            split = normalizeLocale(names[i]).split('-');
            j = split.length;
            next = normalizeLocale(names[i + 1]);
            next = next ? next.split('-') : null;
            while (j > 0) {
                locale = loadLocale(split.slice(0, j).join('-'));
                if (locale) {
                    return locale;
                }
                if (next && next.length >= j && compareArrays(split, next, true) >= j - 1) {
                    //the next array item is better than a shallower substring of this one
                    break;
                }
                j--;
            }
            i++;
        }
        return null;
    }

    function loadLocale(name) {
        var oldLocale = null;
        if (!locales[name] && hasModule) {
            try {
                oldLocale = moment.locale();
                require('./locale/' + name);
                // because defineLocale currently also sets the global locale, we want to undo that for lazy loaded locales
                moment.locale(oldLocale);
            } catch (e) { }
        }
        return locales[name];
    }

    // Return a moment from input, that is local/utc/utcOffset equivalent to
    // model.
    function makeAs(input, model) {
        var res, diff;
        if (model._isUTC) {
            res = model.clone();
            diff = (moment.isMoment(input) || isDate(input) ?
                +input : +moment(input)) - (+res);
            // Use low-level api, because this fn is low-level api.
            res._d.setTime(+res._d + diff);
            moment.updateOffset(res, false);
            return res;
        } else {
            return moment(input).local();
        }
    }

    /************************************
     Locale
     ************************************/


    extend(Locale.prototype, {

        set : function (config) {
            var prop, i;
            for (i in config) {
                prop = config[i];
                if (typeof prop === 'function') {
                    this[i] = prop;
                } else {
                    this['_' + i] = prop;
                }
            }
            // Lenient ordinal parsing accepts just a number in addition to
            // number + (possibly) stuff coming from _ordinalParseLenient.
            this._ordinalParseLenient = new RegExp(this._ordinalParse.source + '|' + /\d{1,2}/.source);
        },

        _months : 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_'),
        months : function (m) {
            return this._months[m.month()];
        },

        _monthsShort : 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),
        monthsShort : function (m) {
            return this._monthsShort[m.month()];
        },

        monthsParse : function (monthName, format, strict) {
            var i, mom, regex;

            if (!this._monthsParse) {
                this._monthsParse = [];
                this._longMonthsParse = [];
                this._shortMonthsParse = [];
            }

            for (i = 0; i < 12; i++) {
                // make the regex if we don't have it already
                mom = moment.utc([2000, i]);
                if (strict && !this._longMonthsParse[i]) {
                    this._longMonthsParse[i] = new RegExp('^' + this.months(mom, '').replace('.', '') + '$', 'i');
                    this._shortMonthsParse[i] = new RegExp('^' + this.monthsShort(mom, '').replace('.', '') + '$', 'i');
                }
                if (!strict && !this._monthsParse[i]) {
                    regex = '^' + this.months(mom, '') + '|^' + this.monthsShort(mom, '');
                    this._monthsParse[i] = new RegExp(regex.replace('.', ''), 'i');
                }
                // test the regex
                if (strict && format === 'MMMM' && this._longMonthsParse[i].test(monthName)) {
                    return i;
                } else if (strict && format === 'MMM' && this._shortMonthsParse[i].test(monthName)) {
                    return i;
                } else if (!strict && this._monthsParse[i].test(monthName)) {
                    return i;
                }
            }
        },

        _weekdays : 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'),
        weekdays : function (m) {
            return this._weekdays[m.day()];
        },

        _weekdaysShort : 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
        weekdaysShort : function (m) {
            return this._weekdaysShort[m.day()];
        },

        _weekdaysMin : 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),
        weekdaysMin : function (m) {
            return this._weekdaysMin[m.day()];
        },

        weekdaysParse : function (weekdayName) {
            var i, mom, regex;

            if (!this._weekdaysParse) {
                this._weekdaysParse = [];
            }

            for (i = 0; i < 7; i++) {
                // make the regex if we don't have it already
                if (!this._weekdaysParse[i]) {
                    mom = moment([2000, 1]).day(i);
                    regex = '^' + this.weekdays(mom, '') + '|^' + this.weekdaysShort(mom, '') + '|^' + this.weekdaysMin(mom, '');
                    this._weekdaysParse[i] = new RegExp(regex.replace('.', ''), 'i');
                }
                // test the regex
                if (this._weekdaysParse[i].test(weekdayName)) {
                    return i;
                }
            }
        },

        _longDateFormat : {
            LTS : 'h:mm:ss A',
            LT : 'h:mm A',
            L : 'MM/DD/YYYY',
            LL : 'MMMM D, YYYY',
            LLL : 'MMMM D, YYYY LT',
            LLLL : 'dddd, MMMM D, YYYY LT'
        },
        longDateFormat : function (key) {
            var output = this._longDateFormat[key];
            if (!output && this._longDateFormat[key.toUpperCase()]) {
                output = this._longDateFormat[key.toUpperCase()].replace(/MMMM|MM|DD|dddd/g, function (val) {
                    return val.slice(1);
                });
                this._longDateFormat[key] = output;
            }
            return output;
        },

        isPM : function (input) {
            // IE8 Quirks Mode & IE7 Standards Mode do not allow accessing strings like arrays
            // Using charAt should be more compatible.
            return ((input + '').toLowerCase().charAt(0) === 'p');
        },

        _meridiemParse : /[ap]\.?m?\.?/i,
        meridiem : function (hours, minutes, isLower) {
            if (hours > 11) {
                return isLower ? 'pm' : 'PM';
            } else {
                return isLower ? 'am' : 'AM';
            }
        },


        _calendar : {
            sameDay : '[Today at] LT',
            nextDay : '[Tomorrow at] LT',
            nextWeek : 'dddd [at] LT',
            lastDay : '[Yesterday at] LT',
            lastWeek : '[Last] dddd [at] LT',
            sameElse : 'L'
        },
        calendar : function (key, mom, now) {
            var output = this._calendar[key];
            return typeof output === 'function' ? output.apply(mom, [now]) : output;
        },

        _relativeTime : {
            future : 'in %s',
            past : '%s ago',
            s : 'a few seconds',
            m : 'a minute',
            mm : '%d minutes',
            h : 'an hour',
            hh : '%d hours',
            d : 'a day',
            dd : '%d days',
            M : 'a month',
            MM : '%d months',
            y : 'a year',
            yy : '%d years'
        },

        relativeTime : function (number, withoutSuffix, string, isFuture) {
            var output = this._relativeTime[string];
            return (typeof output === 'function') ?
                output(number, withoutSuffix, string, isFuture) :
                output.replace(/%d/i, number);
        },

        pastFuture : function (diff, output) {
            var format = this._relativeTime[diff > 0 ? 'future' : 'past'];
            return typeof format === 'function' ? format(output) : format.replace(/%s/i, output);
        },

        ordinal : function (number) {
            return this._ordinal.replace('%d', number);
        },
        _ordinal : '%d',
        _ordinalParse : /\d{1,2}/,

        preparse : function (string) {
            return string;
        },

        postformat : function (string) {
            return string;
        },

        week : function (mom) {
            return weekOfYear(mom, this._week.dow, this._week.doy).week;
        },

        _week : {
            dow : 0, // Sunday is the first day of the week.
            doy : 6  // The week that contains Jan 1st is the first week of the year.
        },

        firstDayOfWeek : function () {
            return this._week.dow;
        },

        firstDayOfYear : function () {
            return this._week.doy;
        },

        _invalidDate: 'Invalid date',
        invalidDate: function () {
            return this._invalidDate;
        }
    });

    /************************************
     Formatting
     ************************************/


    function removeFormattingTokens(input) {
        if (input.match(/\[[\s\S]/)) {
            return input.replace(/^\[|\]$/g, '');
        }
        return input.replace(/\\/g, '');
    }

    function makeFormatFunction(format) {
        var array = format.match(formattingTokens), i, length;

        for (i = 0, length = array.length; i < length; i++) {
            if (formatTokenFunctions[array[i]]) {
                array[i] = formatTokenFunctions[array[i]];
            } else {
                array[i] = removeFormattingTokens(array[i]);
            }
        }

        return function (mom) {
            var output = '';
            for (i = 0; i < length; i++) {
                output += array[i] instanceof Function ? array[i].call(mom, format) : array[i];
            }
            return output;
        };
    }

    // format date using native date object
    function formatMoment(m, format) {
        if (!m.isValid()) {
            return m.localeData().invalidDate();
        }

        format = expandFormat(format, m.localeData());

        if (!formatFunctions[format]) {
            formatFunctions[format] = makeFormatFunction(format);
        }

        return formatFunctions[format](m);
    }

    function expandFormat(format, locale) {
        var i = 5;

        function replaceLongDateFormatTokens(input) {
            return locale.longDateFormat(input) || input;
        }

        localFormattingTokens.lastIndex = 0;
        while (i >= 0 && localFormattingTokens.test(format)) {
            format = format.replace(localFormattingTokens, replaceLongDateFormatTokens);
            localFormattingTokens.lastIndex = 0;
            i -= 1;
        }

        return format;
    }


    /************************************
     Parsing
     ************************************/


    // get the regex to find the next token
    function getParseRegexForToken(token, config) {
        var a, strict = config._strict;
        switch (token) {
            case 'Q':
                return parseTokenOneDigit;
            case 'DDDD':
                return parseTokenThreeDigits;
            case 'YYYY':
            case 'GGGG':
            case 'gggg':
                return strict ? parseTokenFourDigits : parseTokenOneToFourDigits;
            case 'Y':
            case 'G':
            case 'g':
                return parseTokenSignedNumber;
            case 'YYYYYY':
            case 'YYYYY':
            case 'GGGGG':
            case 'ggggg':
                return strict ? parseTokenSixDigits : parseTokenOneToSixDigits;
            case 'S':
                if (strict) {
                    return parseTokenOneDigit;
                }
            /* falls through */
            case 'SS':
                if (strict) {
                    return parseTokenTwoDigits;
                }
            /* falls through */
            case 'SSS':
                if (strict) {
                    return parseTokenThreeDigits;
                }
            /* falls through */
            case 'DDD':
                return parseTokenOneToThreeDigits;
            case 'MMM':
            case 'MMMM':
            case 'dd':
            case 'ddd':
            case 'dddd':
                return parseTokenWord;
            case 'a':
            case 'A':
                return config._locale._meridiemParse;
            case 'x':
                return parseTokenOffsetMs;
            case 'X':
                return parseTokenTimestampMs;
            case 'Z':
            case 'ZZ':
                return parseTokenTimezone;
            case 'T':
                return parseTokenT;
            case 'SSSS':
                return parseTokenDigits;
            case 'MM':
            case 'DD':
            case 'YY':
            case 'GG':
            case 'gg':
            case 'HH':
            case 'hh':
            case 'mm':
            case 'ss':
            case 'ww':
            case 'WW':
                return strict ? parseTokenTwoDigits : parseTokenOneOrTwoDigits;
            case 'M':
            case 'D':
            case 'd':
            case 'H':
            case 'h':
            case 'm':
            case 's':
            case 'w':
            case 'W':
            case 'e':
            case 'E':
                return parseTokenOneOrTwoDigits;
            case 'Do':
                return strict ? config._locale._ordinalParse : config._locale._ordinalParseLenient;
            default :
                a = new RegExp(regexpEscape(unescapeFormat(token.replace('\\', '')), 'i'));
                return a;
        }
    }

    function utcOffsetFromString(string) {
        string = string || '';
        var possibleTzMatches = (string.match(parseTokenTimezone) || []),
            tzChunk = possibleTzMatches[possibleTzMatches.length - 1] || [],
            parts = (tzChunk + '').match(parseTimezoneChunker) || ['-', 0, 0],
            minutes = +(parts[1] * 60) + toInt(parts[2]);

        return parts[0] === '+' ? minutes : -minutes;
    }

    // function to convert string input to date
    function addTimeToArrayFromToken(token, input, config) {
        var a, datePartArray = config._a;

        switch (token) {
            // QUARTER
            case 'Q':
                if (input != null) {
                    datePartArray[MONTH] = (toInt(input) - 1) * 3;
                }
                break;
            // MONTH
            case 'M' : // fall through to MM
            case 'MM' :
                if (input != null) {
                    datePartArray[MONTH] = toInt(input) - 1;
                }
                break;
            case 'MMM' : // fall through to MMMM
            case 'MMMM' :
                a = config._locale.monthsParse(input, token, config._strict);
                // if we didn't find a month name, mark the date as invalid.
                if (a != null) {
                    datePartArray[MONTH] = a;
                } else {
                    config._pf.invalidMonth = input;
                }
                break;
            // DAY OF MONTH
            case 'D' : // fall through to DD
            case 'DD' :
                if (input != null) {
                    datePartArray[DATE] = toInt(input);
                }
                break;
            case 'Do' :
                if (input != null) {
                    datePartArray[DATE] = toInt(parseInt(
                        input.match(/\d{1,2}/)[0], 10));
                }
                break;
            // DAY OF YEAR
            case 'DDD' : // fall through to DDDD
            case 'DDDD' :
                if (input != null) {
                    config._dayOfYear = toInt(input);
                }

                break;
            // YEAR
            case 'YY' :
                datePartArray[YEAR] = moment.parseTwoDigitYear(input);
                break;
            case 'YYYY' :
            case 'YYYYY' :
            case 'YYYYYY' :
                datePartArray[YEAR] = toInt(input);
                break;
            // AM / PM
            case 'a' : // fall through to A
            case 'A' :
                config._meridiem = input;
                // config._isPm = config._locale.isPM(input);
                break;
            // HOUR
            case 'h' : // fall through to hh
            case 'hh' :
                config._pf.bigHour = true;
            /* falls through */
            case 'H' : // fall through to HH
            case 'HH' :
                datePartArray[HOUR] = toInt(input);
                break;
            // MINUTE
            case 'm' : // fall through to mm
            case 'mm' :
                datePartArray[MINUTE] = toInt(input);
                break;
            // SECOND
            case 's' : // fall through to ss
            case 'ss' :
                datePartArray[SECOND] = toInt(input);
                break;
            // MILLISECOND
            case 'S' :
            case 'SS' :
            case 'SSS' :
            case 'SSSS' :
                datePartArray[MILLISECOND] = toInt(('0.' + input) * 1000);
                break;
            // UNIX OFFSET (MILLISECONDS)
            case 'x':
                config._d = new Date(toInt(input));
                break;
            // UNIX TIMESTAMP WITH MS
            case 'X':
                config._d = new Date(parseFloat(input) * 1000);
                break;
            // TIMEZONE
            case 'Z' : // fall through to ZZ
            case 'ZZ' :
                config._useUTC = true;
                config._tzm = utcOffsetFromString(input);
                break;
            // WEEKDAY - human
            case 'dd':
            case 'ddd':
            case 'dddd':
                a = config._locale.weekdaysParse(input);
                // if we didn't get a weekday name, mark the date as invalid
                if (a != null) {
                    config._w = config._w || {};
                    config._w['d'] = a;
                } else {
                    config._pf.invalidWeekday = input;
                }
                break;
            // WEEK, WEEK DAY - numeric
            case 'w':
            case 'ww':
            case 'W':
            case 'WW':
            case 'd':
            case 'e':
            case 'E':
                token = token.substr(0, 1);
            /* falls through */
            case 'gggg':
            case 'GGGG':
            case 'GGGGG':
                token = token.substr(0, 2);
                if (input) {
                    config._w = config._w || {};
                    config._w[token] = toInt(input);
                }
                break;
            case 'gg':
            case 'GG':
                config._w = config._w || {};
                config._w[token] = moment.parseTwoDigitYear(input);
        }
    }

    function dayOfYearFromWeekInfo(config) {
        var w, weekYear, week, weekday, dow, doy, temp;

        w = config._w;
        if (w.GG != null || w.W != null || w.E != null) {
            dow = 1;
            doy = 4;

            // TODO: We need to take the current isoWeekYear, but that depends on
            // how we interpret now (local, utc, fixed offset). So create
            // a now version of current config (take local/utc/offset flags, and
            // create now).
            weekYear = dfl(w.GG, config._a[YEAR], weekOfYear(moment(), 1, 4).year);
            week = dfl(w.W, 1);
            weekday = dfl(w.E, 1);
        } else {
            dow = config._locale._week.dow;
            doy = config._locale._week.doy;

            weekYear = dfl(w.gg, config._a[YEAR], weekOfYear(moment(), dow, doy).year);
            week = dfl(w.w, 1);

            if (w.d != null) {
                // weekday -- low day numbers are considered next week
                weekday = w.d;
                if (weekday < dow) {
                    ++week;
                }
            } else if (w.e != null) {
                // local weekday -- counting starts from begining of week
                weekday = w.e + dow;
            } else {
                // default to begining of week
                weekday = dow;
            }
        }
        temp = dayOfYearFromWeeks(weekYear, week, weekday, doy, dow);

        config._a[YEAR] = temp.year;
        config._dayOfYear = temp.dayOfYear;
    }

    // convert an array to a date.
    // the array should mirror the parameters below
    // note: all values past the year are optional and will default to the lowest possible value.
    // [year, month, day , hour, minute, second, millisecond]
    function dateFromConfig(config) {
        var i, date, input = [], currentDate, yearToUse;

        if (config._d) {
            return;
        }

        currentDate = currentDateArray(config);

        //compute day of the year from weeks and weekdays
        if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {
            dayOfYearFromWeekInfo(config);
        }

        //if the day of the year is set, figure out what it is
        if (config._dayOfYear) {
            yearToUse = dfl(config._a[YEAR], currentDate[YEAR]);

            if (config._dayOfYear > daysInYear(yearToUse)) {
                config._pf._overflowDayOfYear = true;
            }

            date = makeUTCDate(yearToUse, 0, config._dayOfYear);
            config._a[MONTH] = date.getUTCMonth();
            config._a[DATE] = date.getUTCDate();
        }

        // Default to current date.
        // * if no year, month, day of month are given, default to today
        // * if day of month is given, default month and year
        // * if month is given, default only year
        // * if year is given, don't default anything
        for (i = 0; i < 3 && config._a[i] == null; ++i) {
            config._a[i] = input[i] = currentDate[i];
        }

        // Zero out whatever was not defaulted, including time
        for (; i < 7; i++) {
            config._a[i] = input[i] = (config._a[i] == null) ? (i === 2 ? 1 : 0) : config._a[i];
        }

        // Check for 24:00:00.000
        if (config._a[HOUR] === 24 &&
            config._a[MINUTE] === 0 &&
            config._a[SECOND] === 0 &&
            config._a[MILLISECOND] === 0) {
            config._nextDay = true;
            config._a[HOUR] = 0;
        }

        config._d = (config._useUTC ? makeUTCDate : makeDate).apply(null, input);
        // Apply timezone offset from input. The actual utcOffset can be changed
        // with parseZone.
        if (config._tzm != null) {
            config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
        }

        if (config._nextDay) {
            config._a[HOUR] = 24;
        }
    }

    function dateFromObject(config) {
        var normalizedInput;

        if (config._d) {
            return;
        }

        normalizedInput = normalizeObjectUnits(config._i);
        config._a = [
            normalizedInput.year,
            normalizedInput.month,
            normalizedInput.day || normalizedInput.date,
            normalizedInput.hour,
            normalizedInput.minute,
            normalizedInput.second,
            normalizedInput.millisecond
        ];

        dateFromConfig(config);
    }

    function currentDateArray(config) {
        var now = new Date();
        if (config._useUTC) {
            return [
                now.getUTCFullYear(),
                now.getUTCMonth(),
                now.getUTCDate()
            ];
        } else {
            return [now.getFullYear(), now.getMonth(), now.getDate()];
        }
    }

    // date from string and format string
    function makeDateFromStringAndFormat(config) {
        if (config._f === moment.ISO_8601) {
            parseISO(config);
            return;
        }

        config._a = [];
        config._pf.empty = true;

        // This array is used to make a Date, either with `new Date` or `Date.UTC`
        var string = '' + config._i,
            i, parsedInput, tokens, token, skipped,
            stringLength = string.length,
            totalParsedInputLength = 0;

        tokens = expandFormat(config._f, config._locale).match(formattingTokens) || [];

        for (i = 0; i < tokens.length; i++) {
            token = tokens[i];
            parsedInput = (string.match(getParseRegexForToken(token, config)) || [])[0];
            if (parsedInput) {
                skipped = string.substr(0, string.indexOf(parsedInput));
                if (skipped.length > 0) {
                    config._pf.unusedInput.push(skipped);
                }
                string = string.slice(string.indexOf(parsedInput) + parsedInput.length);
                totalParsedInputLength += parsedInput.length;
            }
            // don't parse if it's not a known token
            if (formatTokenFunctions[token]) {
                if (parsedInput) {
                    config._pf.empty = false;
                }
                else {
                    config._pf.unusedTokens.push(token);
                }
                addTimeToArrayFromToken(token, parsedInput, config);
            }
            else if (config._strict && !parsedInput) {
                config._pf.unusedTokens.push(token);
            }
        }

        // add remaining unparsed input length to the string
        config._pf.charsLeftOver = stringLength - totalParsedInputLength;
        if (string.length > 0) {
            config._pf.unusedInput.push(string);
        }

        // clear _12h flag if hour is <= 12
        if (config._pf.bigHour === true && config._a[HOUR] <= 12) {
            config._pf.bigHour = undefined;
        }
        // handle meridiem
        config._a[HOUR] = meridiemFixWrap(config._locale, config._a[HOUR],
            config._meridiem);
        dateFromConfig(config);
        checkOverflow(config);
    }

    function unescapeFormat(s) {
        return s.replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g, function (matched, p1, p2, p3, p4) {
            return p1 || p2 || p3 || p4;
        });
    }

    // Code from http://stackoverflow.com/questions/3561493/is-there-a-regexp-escape-function-in-javascript
    function regexpEscape(s) {
        return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
    }

    // date from string and array of format strings
    function makeDateFromStringAndArray(config) {
        var tempConfig,
            bestMoment,

            scoreToBeat,
            i,
            currentScore;

        if (config._f.length === 0) {
            config._pf.invalidFormat = true;
            config._d = new Date(NaN);
            return;
        }

        for (i = 0; i < config._f.length; i++) {
            currentScore = 0;
            tempConfig = copyConfig({}, config);
            if (config._useUTC != null) {
                tempConfig._useUTC = config._useUTC;
            }
            tempConfig._pf = defaultParsingFlags();
            tempConfig._f = config._f[i];
            makeDateFromStringAndFormat(tempConfig);

            if (!isValid(tempConfig)) {
                continue;
            }

            // if there is any input that was not parsed add a penalty for that format
            currentScore += tempConfig._pf.charsLeftOver;

            //or tokens
            currentScore += tempConfig._pf.unusedTokens.length * 10;

            tempConfig._pf.score = currentScore;

            if (scoreToBeat == null || currentScore < scoreToBeat) {
                scoreToBeat = currentScore;
                bestMoment = tempConfig;
            }
        }

        extend(config, bestMoment || tempConfig);
    }

    // date from iso format
    function parseISO(config) {
        var i, l,
            string = config._i,
            match = isoRegex.exec(string);

        if (match) {
            config._pf.iso = true;
            for (i = 0, l = isoDates.length; i < l; i++) {
                if (isoDates[i][1].exec(string)) {
                    // match[5] should be 'T' or undefined
                    config._f = isoDates[i][0] + (match[6] || ' ');
                    break;
                }
            }
            for (i = 0, l = isoTimes.length; i < l; i++) {
                if (isoTimes[i][1].exec(string)) {
                    config._f += isoTimes[i][0];
                    break;
                }
            }
            if (string.match(parseTokenTimezone)) {
                config._f += 'Z';
            }
            makeDateFromStringAndFormat(config);
        } else {
            config._isValid = false;
        }
    }

    // date from iso format or fallback
    function makeDateFromString(config) {
        parseISO(config);
        if (config._isValid === false) {
            delete config._isValid;
            moment.createFromInputFallback(config);
        }
    }

    function map(arr, fn) {
        var res = [], i;
        for (i = 0; i < arr.length; ++i) {
            res.push(fn(arr[i], i));
        }
        return res;
    }

    function makeDateFromInput(config) {
        var input = config._i, matched;
        if (input === undefined) {
            config._d = new Date();
        } else if (isDate(input)) {
            config._d = new Date(+input);
        } else if ((matched = aspNetJsonRegex.exec(input)) !== null) {
            config._d = new Date(+matched[1]);
        } else if (typeof input === 'string') {
            makeDateFromString(config);
        } else if (isArray(input)) {
            config._a = map(input.slice(0), function (obj) {
                return parseInt(obj, 10);
            });
            dateFromConfig(config);
        } else if (typeof(input) === 'object') {
            dateFromObject(config);
        } else if (typeof(input) === 'number') {
            // from milliseconds
            config._d = new Date(input);
        } else {
            moment.createFromInputFallback(config);
        }
    }

    function makeDate(y, m, d, h, M, s, ms) {
        //can't just apply() to create a date:
        //http://stackoverflow.com/questions/181348/instantiating-a-javascript-object-by-calling-prototype-constructor-apply
        var date = new Date(y, m, d, h, M, s, ms);

        //the date constructor doesn't accept years < 1970
        if (y < 1970) {
            date.setFullYear(y);
        }
        return date;
    }

    function makeUTCDate(y) {
        var date = new Date(Date.UTC.apply(null, arguments));
        if (y < 1970) {
            date.setUTCFullYear(y);
        }
        return date;
    }

    function parseWeekday(input, locale) {
        if (typeof input === 'string') {
            if (!isNaN(input)) {
                input = parseInt(input, 10);
            }
            else {
                input = locale.weekdaysParse(input);
                if (typeof input !== 'number') {
                    return null;
                }
            }
        }
        return input;
    }

    /************************************
     Relative Time
     ************************************/


    // helper function for moment.fn.from, moment.fn.fromNow, and moment.duration.fn.humanize
    function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale) {
        return locale.relativeTime(number || 1, !!withoutSuffix, string, isFuture);
    }

    function relativeTime(posNegDuration, withoutSuffix, locale) {
        var duration = moment.duration(posNegDuration).abs(),
            seconds = round(duration.as('s')),
            minutes = round(duration.as('m')),
            hours = round(duration.as('h')),
            days = round(duration.as('d')),
            months = round(duration.as('M')),
            years = round(duration.as('y')),

            args = seconds < relativeTimeThresholds.s && ['s', seconds] ||
                minutes === 1 && ['m'] ||
                minutes < relativeTimeThresholds.m && ['mm', minutes] ||
                hours === 1 && ['h'] ||
                hours < relativeTimeThresholds.h && ['hh', hours] ||
                days === 1 && ['d'] ||
                days < relativeTimeThresholds.d && ['dd', days] ||
                months === 1 && ['M'] ||
                months < relativeTimeThresholds.M && ['MM', months] ||
                years === 1 && ['y'] || ['yy', years];

        args[2] = withoutSuffix;
        args[3] = +posNegDuration > 0;
        args[4] = locale;
        return substituteTimeAgo.apply({}, args);
    }


    /************************************
     Week of Year
     ************************************/


    // firstDayOfWeek       0 = sun, 6 = sat
    //                      the day of the week that starts the week
    //                      (usually sunday or monday)
    // firstDayOfWeekOfYear 0 = sun, 6 = sat
    //                      the first week is the week that contains the first
    //                      of this day of the week
    //                      (eg. ISO weeks use thursday (4))
    function weekOfYear(mom, firstDayOfWeek, firstDayOfWeekOfYear) {
        var end = firstDayOfWeekOfYear - firstDayOfWeek,
            daysToDayOfWeek = firstDayOfWeekOfYear - mom.day(),
            adjustedMoment;


        if (daysToDayOfWeek > end) {
            daysToDayOfWeek -= 7;
        }

        if (daysToDayOfWeek < end - 7) {
            daysToDayOfWeek += 7;
        }

        adjustedMoment = moment(mom).add(daysToDayOfWeek, 'd');
        return {
            week: Math.ceil(adjustedMoment.dayOfYear() / 7),
            year: adjustedMoment.year()
        };
    }

    //http://en.wikipedia.org/wiki/ISO_week_date#Calculating_a_date_given_the_year.2C_week_number_and_weekday
    function dayOfYearFromWeeks(year, week, weekday, firstDayOfWeekOfYear, firstDayOfWeek) {
        var d = makeUTCDate(year, 0, 1).getUTCDay(), daysToAdd, dayOfYear;

        d = d === 0 ? 7 : d;
        weekday = weekday != null ? weekday : firstDayOfWeek;
        daysToAdd = firstDayOfWeek - d + (d > firstDayOfWeekOfYear ? 7 : 0) - (d < firstDayOfWeek ? 7 : 0);
        dayOfYear = 7 * (week - 1) + (weekday - firstDayOfWeek) + daysToAdd + 1;

        return {
            year: dayOfYear > 0 ? year : year - 1,
            dayOfYear: dayOfYear > 0 ?  dayOfYear : daysInYear(year - 1) + dayOfYear
        };
    }

    /************************************
     Top Level Functions
     ************************************/

    function makeMoment(config) {
        var input = config._i,
            format = config._f,
            res;

        config._locale = config._locale || moment.localeData(config._l);

        if (input === null || (format === undefined && input === '')) {
            return moment.invalid({nullInput: true});
        }

        if (typeof input === 'string') {
            config._i = input = config._locale.preparse(input);
        }

        if (moment.isMoment(input)) {
            return new Moment(input, true);
        } else if (format) {
            if (isArray(format)) {
                makeDateFromStringAndArray(config);
            } else {
                makeDateFromStringAndFormat(config);
            }
        } else {
            makeDateFromInput(config);
        }

        res = new Moment(config);
        if (res._nextDay) {
            // Adding is smart enough around DST
            res.add(1, 'd');
            res._nextDay = undefined;
        }

        return res;
    }

    moment = function (input, format, locale, strict) {
        var c;

        if (typeof(locale) === 'boolean') {
            strict = locale;
            locale = undefined;
        }
        // object construction must be done this way.
        // https://github.com/moment/moment/issues/1423
        c = {};
        c._isAMomentObject = true;
        c._i = input;
        c._f = format;
        c._l = locale;
        c._strict = strict;
        c._isUTC = false;
        c._pf = defaultParsingFlags();

        return makeMoment(c);
    };

    moment.suppressDeprecationWarnings = false;

    moment.createFromInputFallback = deprecate(
        'moment construction falls back to js Date. This is ' +
        'discouraged and will be removed in upcoming major ' +
        'release. Please refer to ' +
        'https://github.com/moment/moment/issues/1407 for more info.',
        function (config) {
            config._d = new Date(config._i + (config._useUTC ? ' UTC' : ''));
        }
    );

    // Pick a moment m from moments so that m[fn](other) is true for all
    // other. This relies on the function fn to be transitive.
    //
    // moments should either be an array of moment objects or an array, whose
    // first element is an array of moment objects.
    function pickBy(fn, moments) {
        var res, i;
        if (moments.length === 1 && isArray(moments[0])) {
            moments = moments[0];
        }
        if (!moments.length) {
            return moment();
        }
        res = moments[0];
        for (i = 1; i < moments.length; ++i) {
            if (moments[i][fn](res)) {
                res = moments[i];
            }
        }
        return res;
    }

    moment.min = function () {
        var args = [].slice.call(arguments, 0);

        return pickBy('isBefore', args);
    };

    moment.max = function () {
        var args = [].slice.call(arguments, 0);

        return pickBy('isAfter', args);
    };

    // creating with utc
    moment.utc = function (input, format, locale, strict) {
        var c;

        if (typeof(locale) === 'boolean') {
            strict = locale;
            locale = undefined;
        }
        // object construction must be done this way.
        // https://github.com/moment/moment/issues/1423
        c = {};
        c._isAMomentObject = true;
        c._useUTC = true;
        c._isUTC = true;
        c._l = locale;
        c._i = input;
        c._f = format;
        c._strict = strict;
        c._pf = defaultParsingFlags();

        return makeMoment(c).utc();
    };

    // creating with unix timestamp (in seconds)
    moment.unix = function (input) {
        return moment(input * 1000);
    };

    // duration
    moment.duration = function (input, key) {
        var duration = input,
        // matching against regexp is expensive, do it on demand
            match = null,
            sign,
            ret,
            parseIso,
            diffRes;

        if (moment.isDuration(input)) {
            duration = {
                ms: input._milliseconds,
                d: input._days,
                M: input._months
            };
        } else if (typeof input === 'number') {
            duration = {};
            if (key) {
                duration[key] = input;
            } else {
                duration.milliseconds = input;
            }
        } else if (!!(match = aspNetTimeSpanJsonRegex.exec(input))) {
            sign = (match[1] === '-') ? -1 : 1;
            duration = {
                y: 0,
                d: toInt(match[DATE]) * sign,
                h: toInt(match[HOUR]) * sign,
                m: toInt(match[MINUTE]) * sign,
                s: toInt(match[SECOND]) * sign,
                ms: toInt(match[MILLISECOND]) * sign
            };
        } else if (!!(match = isoDurationRegex.exec(input))) {
            sign = (match[1] === '-') ? -1 : 1;
            parseIso = function (inp) {
                // We'd normally use ~~inp for this, but unfortunately it also
                // converts floats to ints.
                // inp may be undefined, so careful calling replace on it.
                var res = inp && parseFloat(inp.replace(',', '.'));
                // apply sign while we're at it
                return (isNaN(res) ? 0 : res) * sign;
            };
            duration = {
                y: parseIso(match[2]),
                M: parseIso(match[3]),
                d: parseIso(match[4]),
                h: parseIso(match[5]),
                m: parseIso(match[6]),
                s: parseIso(match[7]),
                w: parseIso(match[8])
            };
        } else if (duration == null) {// checks for null or undefined
            duration = {};
        } else if (typeof duration === 'object' &&
            ('from' in duration || 'to' in duration)) {
            diffRes = momentsDifference(moment(duration.from), moment(duration.to));

            duration = {};
            duration.ms = diffRes.milliseconds;
            duration.M = diffRes.months;
        }

        ret = new Duration(duration);

        if (moment.isDuration(input) && hasOwnProp(input, '_locale')) {
            ret._locale = input._locale;
        }

        return ret;
    };

    // version number
    moment.version = VERSION;

    // default format
    moment.defaultFormat = isoFormat;

    // constant that refers to the ISO standard
    moment.ISO_8601 = function () {};

    // Plugins that add properties should also add the key here (null value),
    // so we can properly clone ourselves.
    moment.momentProperties = momentProperties;

    // This function will be called whenever a moment is mutated.
    // It is intended to keep the offset in sync with the timezone.
    moment.updateOffset = function () {};

    // This function allows you to set a threshold for relative time strings
    moment.relativeTimeThreshold = function (threshold, limit) {
        if (relativeTimeThresholds[threshold] === undefined) {
            return false;
        }
        if (limit === undefined) {
            return relativeTimeThresholds[threshold];
        }
        relativeTimeThresholds[threshold] = limit;
        return true;
    };

    moment.lang = deprecate(
        'moment.lang is deprecated. Use moment.locale instead.',
        function (key, value) {
            return moment.locale(key, value);
        }
    );

    // This function will load locale and then set the global locale.  If
    // no arguments are passed in, it will simply return the current global
    // locale key.
    moment.locale = function (key, values) {
        var data;
        if (key) {
            if (typeof(values) !== 'undefined') {
                data = moment.defineLocale(key, values);
            }
            else {
                data = moment.localeData(key);
            }

            if (data) {
                moment.duration._locale = moment._locale = data;
            }
        }

        return moment._locale._abbr;
    };

    moment.defineLocale = function (name, values) {
        if (values !== null) {
            values.abbr = name;
            if (!locales[name]) {
                locales[name] = new Locale();
            }
            locales[name].set(values);

            // backwards compat for now: also set the locale
            moment.locale(name);

            return locales[name];
        } else {
            // useful for testing
            delete locales[name];
            return null;
        }
    };

    moment.langData = deprecate(
        'moment.langData is deprecated. Use moment.localeData instead.',
        function (key) {
            return moment.localeData(key);
        }
    );

    // returns locale data
    moment.localeData = function (key) {
        var locale;

        if (key && key._locale && key._locale._abbr) {
            key = key._locale._abbr;
        }

        if (!key) {
            return moment._locale;
        }

        if (!isArray(key)) {
            //short-circuit everything else
            locale = loadLocale(key);
            if (locale) {
                return locale;
            }
            key = [key];
        }

        return chooseLocale(key);
    };

    // compare moment object
    moment.isMoment = function (obj) {
        return obj instanceof Moment ||
            (obj != null && hasOwnProp(obj, '_isAMomentObject'));
    };

    // for typechecking Duration objects
    moment.isDuration = function (obj) {
        return obj instanceof Duration;
    };

    for (i = lists.length - 1; i >= 0; --i) {
        makeList(lists[i]);
    }

    moment.normalizeUnits = function (units) {
        return normalizeUnits(units);
    };

    moment.invalid = function (flags) {
        var m = moment.utc(NaN);
        if (flags != null) {
            extend(m._pf, flags);
        }
        else {
            m._pf.userInvalidated = true;
        }

        return m;
    };

    moment.parseZone = function () {
        return moment.apply(null, arguments).parseZone();
    };

    moment.parseTwoDigitYear = function (input) {
        return toInt(input) + (toInt(input) > 68 ? 1900 : 2000);
    };

    moment.isDate = isDate;

    /************************************
     Moment Prototype
     ************************************/


    extend(moment.fn = Moment.prototype, {

        clone : function () {
            return moment(this);
        },

        valueOf : function () {
            return +this._d - ((this._offset || 0) * 60000);
        },

        unix : function () {
            return Math.floor(+this / 1000);
        },

        toString : function () {
            return this.clone().locale('en').format('ddd MMM DD YYYY HH:mm:ss [GMT]ZZ');
        },

        toDate : function () {
            return this._offset ? new Date(+this) : this._d;
        },

        toISOString : function () {
            var m = moment(this).utc();
            if (0 < m.year() && m.year() <= 9999) {
                if ('function' === typeof Date.prototype.toISOString) {
                    // native implementation is ~50x faster, use it when we can
                    return this.toDate().toISOString();
                } else {
                    return formatMoment(m, 'YYYY-MM-DD[T]HH:mm:ss.SSS[Z]');
                }
            } else {
                return formatMoment(m, 'YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]');
            }
        },

        toArray : function () {
            var m = this;
            return [
                m.year(),
                m.month(),
                m.date(),
                m.hours(),
                m.minutes(),
                m.seconds(),
                m.milliseconds()
            ];
        },

        isValid : function () {
            return isValid(this);
        },

        isDSTShifted : function () {
            if (this._a) {
                return this.isValid() && compareArrays(this._a, (this._isUTC ? moment.utc(this._a) : moment(this._a)).toArray()) > 0;
            }

            return false;
        },

        parsingFlags : function () {
            return extend({}, this._pf);
        },

        invalidAt: function () {
            return this._pf.overflow;
        },

        utc : function (keepLocalTime) {
            return this.utcOffset(0, keepLocalTime);
        },

        local : function (keepLocalTime) {
            if (this._isUTC) {
                this.utcOffset(0, keepLocalTime);
                this._isUTC = false;

                if (keepLocalTime) {
                    this.subtract(this._dateUtcOffset(), 'm');
                }
            }
            return this;
        },

        format : function (inputString) {
            var output = formatMoment(this, inputString || moment.defaultFormat);
            return this.localeData().postformat(output);
        },

        add : createAdder(1, 'add'),

        subtract : createAdder(-1, 'subtract'),

        diff : function (input, units, asFloat) {
            var that = makeAs(input, this),
                zoneDiff = (that.utcOffset() - this.utcOffset()) * 6e4,
                anchor, diff, output, daysAdjust;

            units = normalizeUnits(units);

            if (units === 'year' || units === 'month' || units === 'quarter') {
                output = monthDiff(this, that);
                if (units === 'quarter') {
                    output = output / 3;
                } else if (units === 'year') {
                    output = output / 12;
                }
            } else {
                diff = this - that;
                output = units === 'second' ? diff / 1e3 : // 1000
                    units === 'minute' ? diff / 6e4 : // 1000 * 60
                        units === 'hour' ? diff / 36e5 : // 1000 * 60 * 60
                            units === 'day' ? (diff - zoneDiff) / 864e5 : // 1000 * 60 * 60 * 24, negate dst
                                units === 'week' ? (diff - zoneDiff) / 6048e5 : // 1000 * 60 * 60 * 24 * 7, negate dst
                                    diff;
            }
            return asFloat ? output : absRound(output);
        },

        from : function (time, withoutSuffix) {
            return moment.duration({to: this, from: time}).locale(this.locale()).humanize(!withoutSuffix);
        },

        fromNow : function (withoutSuffix) {
            return this.from(moment(), withoutSuffix);
        },

        calendar : function (time) {
            // We want to compare the start of today, vs this.
            // Getting start-of-today depends on whether we're locat/utc/offset
            // or not.
            var now = time || moment(),
                sod = makeAs(now, this).startOf('day'),
                diff = this.diff(sod, 'days', true),
                format = diff < -6 ? 'sameElse' :
                    diff < -1 ? 'lastWeek' :
                        diff < 0 ? 'lastDay' :
                            diff < 1 ? 'sameDay' :
                                diff < 2 ? 'nextDay' :
                                    diff < 7 ? 'nextWeek' : 'sameElse';
            return this.format(this.localeData().calendar(format, this, moment(now)));
        },

        isLeapYear : function () {
            return isLeapYear(this.year());
        },

        isDST : function () {
            return (this.utcOffset() > this.clone().month(0).utcOffset() ||
            this.utcOffset() > this.clone().month(5).utcOffset());
        },

        day : function (input) {
            var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
            if (input != null) {
                input = parseWeekday(input, this.localeData());
                return this.add(input - day, 'd');
            } else {
                return day;
            }
        },

        month : makeAccessor('Month', true),

        startOf : function (units) {
            units = normalizeUnits(units);
            // the following switch intentionally omits break keywords
            // to utilize falling through the cases.
            switch (units) {
                case 'year':
                    this.month(0);
                /* falls through */
                case 'quarter':
                case 'month':
                    this.date(1);
                /* falls through */
                case 'week':
                case 'isoWeek':
                case 'day':
                    this.hours(0);
                /* falls through */
                case 'hour':
                    this.minutes(0);
                /* falls through */
                case 'minute':
                    this.seconds(0);
                /* falls through */
                case 'second':
                    this.milliseconds(0);
                /* falls through */
            }

            // weeks are a special case
            if (units === 'week') {
                this.weekday(0);
            } else if (units === 'isoWeek') {
                this.isoWeekday(1);
            }

            // quarters are also special
            if (units === 'quarter') {
                this.month(Math.floor(this.month() / 3) * 3);
            }

            return this;
        },

        endOf: function (units) {
            units = normalizeUnits(units);
            if (units === undefined || units === 'millisecond') {
                return this;
            }
            return this.startOf(units).add(1, (units === 'isoWeek' ? 'week' : units)).subtract(1, 'ms');
        },

        isAfter: function (input, units) {
            var inputMs;
            units = normalizeUnits(typeof units !== 'undefined' ? units : 'millisecond');
            if (units === 'millisecond') {
                input = moment.isMoment(input) ? input : moment(input);
                return +this > +input;
            } else {
                inputMs = moment.isMoment(input) ? +input : +moment(input);
                return inputMs < +this.clone().startOf(units);
            }
        },

        isBefore: function (input, units) {
            var inputMs;
            units = normalizeUnits(typeof units !== 'undefined' ? units : 'millisecond');
            if (units === 'millisecond') {
                input = moment.isMoment(input) ? input : moment(input);
                return +this < +input;
            } else {
                inputMs = moment.isMoment(input) ? +input : +moment(input);
                return +this.clone().endOf(units) < inputMs;
            }
        },

        isBetween: function (from, to, units) {
            return this.isAfter(from, units) && this.isBefore(to, units);
        },

        isSame: function (input, units) {
            var inputMs;
            units = normalizeUnits(units || 'millisecond');
            if (units === 'millisecond') {
                input = moment.isMoment(input) ? input : moment(input);
                return +this === +input;
            } else {
                inputMs = +moment(input);
                return +(this.clone().startOf(units)) <= inputMs && inputMs <= +(this.clone().endOf(units));
            }
        },

        min: deprecate(
            'moment().min is deprecated, use moment.min instead. https://github.com/moment/moment/issues/1548',
            function (other) {
                other = moment.apply(null, arguments);
                return other < this ? this : other;
            }
        ),

        max: deprecate(
            'moment().max is deprecated, use moment.max instead. https://github.com/moment/moment/issues/1548',
            function (other) {
                other = moment.apply(null, arguments);
                return other > this ? this : other;
            }
        ),

        zone : deprecate(
            'moment().zone is deprecated, use moment().utcOffset instead. ' +
            'https://github.com/moment/moment/issues/1779',
            function (input, keepLocalTime) {
                if (input != null) {
                    if (typeof input !== 'string') {
                        input = -input;
                    }

                    this.utcOffset(input, keepLocalTime);

                    return this;
                } else {
                    return -this.utcOffset();
                }
            }
        ),

        // keepLocalTime = true means only change the timezone, without
        // affecting the local hour. So 5:31:26 +0300 --[utcOffset(2, true)]-->
        // 5:31:26 +0200 It is possible that 5:31:26 doesn't exist with offset
        // +0200, so we adjust the time as needed, to be valid.
        //
        // Keeping the time actually adds/subtracts (one hour)
        // from the actual represented time. That is why we call updateOffset
        // a second time. In case it wants us to change the offset again
        // _changeInProgress == true case, then we have to adjust, because
        // there is no such time in the given timezone.
        utcOffset : function (input, keepLocalTime) {
            var offset = this._offset || 0,
                localAdjust;
            if (input != null) {
                if (typeof input === 'string') {
                    input = utcOffsetFromString(input);
                }
                if (Math.abs(input) < 16) {
                    input = input * 60;
                }
                if (!this._isUTC && keepLocalTime) {
                    localAdjust = this._dateUtcOffset();
                }
                this._offset = input;
                this._isUTC = true;
                if (localAdjust != null) {
                    this.add(localAdjust, 'm');
                }
                if (offset !== input) {
                    if (!keepLocalTime || this._changeInProgress) {
                        addOrSubtractDurationFromMoment(this,
                            moment.duration(input - offset, 'm'), 1, false);
                    } else if (!this._changeInProgress) {
                        this._changeInProgress = true;
                        moment.updateOffset(this, true);
                        this._changeInProgress = null;
                    }
                }

                return this;
            } else {
                return this._isUTC ? offset : this._dateUtcOffset();
            }
        },

        isLocal : function () {
            return !this._isUTC;
        },

        isUtcOffset : function () {
            return this._isUTC;
        },

        isUtc : function () {
            return this._isUTC && this._offset === 0;
        },

        zoneAbbr : function () {
            return this._isUTC ? 'UTC' : '';
        },

        zoneName : function () {
            return this._isUTC ? 'Coordinated Universal Time' : '';
        },

        parseZone : function () {
            if (this._tzm) {
                this.utcOffset(this._tzm);
            } else if (typeof this._i === 'string') {
                this.utcOffset(utcOffsetFromString(this._i));
            }
            return this;
        },

        hasAlignedHourOffset : function (input) {
            if (!input) {
                input = 0;
            }
            else {
                input = moment(input).utcOffset();
            }

            return (this.utcOffset() - input) % 60 === 0;
        },

        daysInMonth : function () {
            return daysInMonth(this.year(), this.month());
        },

        dayOfYear : function (input) {
            var dayOfYear = round((moment(this).startOf('day') - moment(this).startOf('year')) / 864e5) + 1;
            return input == null ? dayOfYear : this.add((input - dayOfYear), 'd');
        },

        quarter : function (input) {
            return input == null ? Math.ceil((this.month() + 1) / 3) : this.month((input - 1) * 3 + this.month() % 3);
        },

        weekYear : function (input) {
            var year = weekOfYear(this, this.localeData()._week.dow, this.localeData()._week.doy).year;
            return input == null ? year : this.add((input - year), 'y');
        },

        isoWeekYear : function (input) {
            var year = weekOfYear(this, 1, 4).year;
            return input == null ? year : this.add((input - year), 'y');
        },

        week : function (input) {
            var week = this.localeData().week(this);
            return input == null ? week : this.add((input - week) * 7, 'd');
        },

        isoWeek : function (input) {
            var week = weekOfYear(this, 1, 4).week;
            return input == null ? week : this.add((input - week) * 7, 'd');
        },

        weekday : function (input) {
            var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;
            return input == null ? weekday : this.add(input - weekday, 'd');
        },

        isoWeekday : function (input) {
            // behaves the same as moment#day except
            // as a getter, returns 7 instead of 0 (1-7 range instead of 0-6)
            // as a setter, sunday should belong to the previous week.
            return input == null ? this.day() || 7 : this.day(this.day() % 7 ? input : input - 7);
        },

        isoWeeksInYear : function () {
            return weeksInYear(this.year(), 1, 4);
        },

        weeksInYear : function () {
            var weekInfo = this.localeData()._week;
            return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
        },

        get : function (units) {
            units = normalizeUnits(units);
            return this[units]();
        },

        set : function (units, value) {
            var unit;
            if (typeof units === 'object') {
                for (unit in units) {
                    this.set(unit, units[unit]);
                }
            }
            else {
                units = normalizeUnits(units);
                if (typeof this[units] === 'function') {
                    this[units](value);
                }
            }
            return this;
        },

        // If passed a locale key, it will set the locale for this
        // instance.  Otherwise, it will return the locale configuration
        // variables for this instance.
        locale : function (key) {
            var newLocaleData;

            if (key === undefined) {
                return this._locale._abbr;
            } else {
                newLocaleData = moment.localeData(key);
                if (newLocaleData != null) {
                    this._locale = newLocaleData;
                }
                return this;
            }
        },

        lang : deprecate(
            'moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.',
            function (key) {
                if (key === undefined) {
                    return this.localeData();
                } else {
                    return this.locale(key);
                }
            }
        ),

        localeData : function () {
            return this._locale;
        },

        _dateUtcOffset : function () {
            // On Firefox.24 Date#getTimezoneOffset returns a floating point.
            // https://github.com/moment/moment/pull/1871
            return -Math.round(this._d.getTimezoneOffset() / 15) * 15;
        }

    });

    function rawMonthSetter(mom, value) {
        var dayOfMonth;

        // TODO: Move this out of here!
        if (typeof value === 'string') {
            value = mom.localeData().monthsParse(value);
            // TODO: Another silent failure?
            if (typeof value !== 'number') {
                return mom;
            }
        }

        dayOfMonth = Math.min(mom.date(),
            daysInMonth(mom.year(), value));
        mom._d['set' + (mom._isUTC ? 'UTC' : '') + 'Month'](value, dayOfMonth);
        return mom;
    }

    function rawGetter(mom, unit) {
        return mom._d['get' + (mom._isUTC ? 'UTC' : '') + unit]();
    }

    function rawSetter(mom, unit, value) {
        if (unit === 'Month') {
            return rawMonthSetter(mom, value);
        } else {
            return mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value);
        }
    }

    function makeAccessor(unit, keepTime) {
        return function (value) {
            if (value != null) {
                rawSetter(this, unit, value);
                moment.updateOffset(this, keepTime);
                return this;
            } else {
                return rawGetter(this, unit);
            }
        };
    }

    moment.fn.millisecond = moment.fn.milliseconds = makeAccessor('Milliseconds', false);
    moment.fn.second = moment.fn.seconds = makeAccessor('Seconds', false);
    moment.fn.minute = moment.fn.minutes = makeAccessor('Minutes', false);
    // Setting the hour should keep the time, because the user explicitly
    // specified which hour he wants. So trying to maintain the same hour (in
    // a new timezone) makes sense. Adding/subtracting hours does not follow
    // this rule.
    moment.fn.hour = moment.fn.hours = makeAccessor('Hours', true);
    // moment.fn.month is defined separately
    moment.fn.date = makeAccessor('Date', true);
    moment.fn.dates = deprecate('dates accessor is deprecated. Use date instead.', makeAccessor('Date', true));
    moment.fn.year = makeAccessor('FullYear', true);
    moment.fn.years = deprecate('years accessor is deprecated. Use year instead.', makeAccessor('FullYear', true));

    // add plural methods
    moment.fn.days = moment.fn.day;
    moment.fn.months = moment.fn.month;
    moment.fn.weeks = moment.fn.week;
    moment.fn.isoWeeks = moment.fn.isoWeek;
    moment.fn.quarters = moment.fn.quarter;

    // add aliased format methods
    moment.fn.toJSON = moment.fn.toISOString;

    // alias isUtc for dev-friendliness
    moment.fn.isUTC = moment.fn.isUtc;

    /************************************
     Duration Prototype
     ************************************/


    function daysToYears (days) {
        // 400 years have 146097 days (taking into account leap year rules)
        return days * 400 / 146097;
    }

    function yearsToDays (years) {
        // years * 365 + absRound(years / 4) -
        //     absRound(years / 100) + absRound(years / 400);
        return years * 146097 / 400;
    }

    extend(moment.duration.fn = Duration.prototype, {

        _bubble : function () {
            var milliseconds = this._milliseconds,
                days = this._days,
                months = this._months,
                data = this._data,
                seconds, minutes, hours, years = 0;

            // The following code bubbles up values, see the tests for
            // examples of what that means.
            data.milliseconds = milliseconds % 1000;

            seconds = absRound(milliseconds / 1000);
            data.seconds = seconds % 60;

            minutes = absRound(seconds / 60);
            data.minutes = minutes % 60;

            hours = absRound(minutes / 60);
            data.hours = hours % 24;

            days += absRound(hours / 24);

            // Accurately convert days to years, assume start from year 0.
            years = absRound(daysToYears(days));
            days -= absRound(yearsToDays(years));

            // 30 days to a month
            // TODO (iskren): Use anchor date (like 1st Jan) to compute this.
            months += absRound(days / 30);
            days %= 30;

            // 12 months -> 1 year
            years += absRound(months / 12);
            months %= 12;

            data.days = days;
            data.months = months;
            data.years = years;
        },

        abs : function () {
            this._milliseconds = Math.abs(this._milliseconds);
            this._days = Math.abs(this._days);
            this._months = Math.abs(this._months);

            this._data.milliseconds = Math.abs(this._data.milliseconds);
            this._data.seconds = Math.abs(this._data.seconds);
            this._data.minutes = Math.abs(this._data.minutes);
            this._data.hours = Math.abs(this._data.hours);
            this._data.months = Math.abs(this._data.months);
            this._data.years = Math.abs(this._data.years);

            return this;
        },

        weeks : function () {
            return absRound(this.days() / 7);
        },

        valueOf : function () {
            return this._milliseconds +
                this._days * 864e5 +
                (this._months % 12) * 2592e6 +
                toInt(this._months / 12) * 31536e6;
        },

        humanize : function (withSuffix) {
            var output = relativeTime(this, !withSuffix, this.localeData());

            if (withSuffix) {
                output = this.localeData().pastFuture(+this, output);
            }

            return this.localeData().postformat(output);
        },

        add : function (input, val) {
            // supports only 2.0-style add(1, 's') or add(moment)
            var dur = moment.duration(input, val);

            this._milliseconds += dur._milliseconds;
            this._days += dur._days;
            this._months += dur._months;

            this._bubble();

            return this;
        },

        subtract : function (input, val) {
            var dur = moment.duration(input, val);

            this._milliseconds -= dur._milliseconds;
            this._days -= dur._days;
            this._months -= dur._months;

            this._bubble();

            return this;
        },

        get : function (units) {
            units = normalizeUnits(units);
            return this[units.toLowerCase() + 's']();
        },

        as : function (units) {
            var days, months;
            units = normalizeUnits(units);

            if (units === 'month' || units === 'year') {
                days = this._days + this._milliseconds / 864e5;
                months = this._months + daysToYears(days) * 12;
                return units === 'month' ? months : months / 12;
            } else {
                // handle milliseconds separately because of floating point math errors (issue #1867)
                days = this._days + Math.round(yearsToDays(this._months / 12));
                switch (units) {
                    case 'week': return days / 7 + this._milliseconds / 6048e5;
                    case 'day': return days + this._milliseconds / 864e5;
                    case 'hour': return days * 24 + this._milliseconds / 36e5;
                    case 'minute': return days * 24 * 60 + this._milliseconds / 6e4;
                    case 'second': return days * 24 * 60 * 60 + this._milliseconds / 1000;
                    // Math.floor prevents floating point math errors here
                    case 'millisecond': return Math.floor(days * 24 * 60 * 60 * 1000) + this._milliseconds;
                    default: throw new Error('Unknown unit ' + units);
                }
            }
        },

        lang : moment.fn.lang,
        locale : moment.fn.locale,

        toIsoString : deprecate(
            'toIsoString() is deprecated. Please use toISOString() instead ' +
            '(notice the capitals)',
            function () {
                return this.toISOString();
            }
        ),

        toISOString : function () {
            // inspired by https://github.com/dordille/moment-isoduration/blob/master/moment.isoduration.js
            var years = Math.abs(this.years()),
                months = Math.abs(this.months()),
                days = Math.abs(this.days()),
                hours = Math.abs(this.hours()),
                minutes = Math.abs(this.minutes()),
                seconds = Math.abs(this.seconds() + this.milliseconds() / 1000);

            if (!this.asSeconds()) {
                // this is the same as C#'s (Noda) and python (isodate)...
                // but not other JS (goog.date)
                return 'P0D';
            }

            return (this.asSeconds() < 0 ? '-' : '') +
                'P' +
                (years ? years + 'Y' : '') +
                (months ? months + 'M' : '') +
                (days ? days + 'D' : '') +
                ((hours || minutes || seconds) ? 'T' : '') +
                (hours ? hours + 'H' : '') +
                (minutes ? minutes + 'M' : '') +
                (seconds ? seconds + 'S' : '');
        },

        localeData : function () {
            return this._locale;
        },

        toJSON : function () {
            return this.toISOString();
        }
    });

    moment.duration.fn.toString = moment.duration.fn.toISOString;

    function makeDurationGetter(name) {
        moment.duration.fn[name] = function () {
            return this._data[name];
        };
    }

    for (i in unitMillisecondFactors) {
        if (hasOwnProp(unitMillisecondFactors, i)) {
            makeDurationGetter(i.toLowerCase());
        }
    }

    moment.duration.fn.asMilliseconds = function () {
        return this.as('ms');
    };
    moment.duration.fn.asSeconds = function () {
        return this.as('s');
    };
    moment.duration.fn.asMinutes = function () {
        return this.as('m');
    };
    moment.duration.fn.asHours = function () {
        return this.as('h');
    };
    moment.duration.fn.asDays = function () {
        return this.as('d');
    };
    moment.duration.fn.asWeeks = function () {
        return this.as('weeks');
    };
    moment.duration.fn.asMonths = function () {
        return this.as('M');
    };
    moment.duration.fn.asYears = function () {
        return this.as('y');
    };

    /************************************
     Default Locale
     ************************************/


        // Set default locale, other locale will inherit from English.
    moment.locale('en', {
        ordinalParse: /\d{1,2}(th|st|nd|rd)/,
        ordinal : function (number) {
            var b = number % 10,
                output = (toInt(number % 100 / 10) === 1) ? 'th' :
                    (b === 1) ? 'st' :
                        (b === 2) ? 'nd' :
                            (b === 3) ? 'rd' : 'th';
            return number + output;
        }
    });

    /* EMBED_LOCALES */

    /************************************
     Exposing Moment
     ************************************/

    //Replaced default make global code.
    return moment;

}).call();// Generated by CoffeeScript 1.8.0
var Linearchart_DataLimitRenderer;

Linearchart_DataLimitRenderer = (function() {
  "use strict";
  function Linearchart_DataLimitRenderer(r) {
    this.r = r;
    this.scene = r.scene;
  }

  Linearchart_DataLimitRenderer.prototype.paint = function(g, dataExistsFrom, dataExistsTo) {
    var dataLimitFrom, dataLimitTo, df, dt, from, height, to, width, x, x0, x1, y0, _ref;
    return;
    df = null;
    dt = null;
    if (this.bars != null) {
      df = this.bars.dataExistsFrom;
      dt = this.bars.dataExistsTo;
    }
    from = this.scene.timeStart;
    to = this.scene.timeEnd;
    _ref = this.scene.getDataLimits(), dataLimitFrom = _ref[0], dataLimitTo = _ref[1];
    x0 = this.scene.x0;
    y0 = this.scene.y0;
    height = this.scene.height;
    x1 = x0 + this.scene.width;
    if (this.scene.settings.area.noData) {
      if (dataLimitFrom !== null && dataLimitFrom > from) {
        x = this.scene.timeToX(dataLimitFrom);
        this.paintFancyRect(g, x0, x1, -Infinity, x, y0, height, this.scene.settings.area.style.noData);
        x0 = x;
        from = dataLimitFrom;
      }
      if (dataLimitTo !== null && dataLimitTo < to && x0 < x1) {
        x = this.scene.timeToX(dataLimitTo);
        this.paintFancyRect(g, x0, x1, x, Infinity, y0, height, this.scene.settings.area.style.noData);
        x1 = x;
        to = dataLimitTo;
      }
    }
    width = x1 - x0;
    if (width <= 0) {
      return;
    }
    if (dataExistsFrom === null || dataExistsTo === null) {
      this.paintFancyRect(g, x0, x1, x0, x1, y0, height, this.scene.settings.area.style.loadingData);
    } else {
      this.paintFancyRect(g, x0, x1, x0, this.scene.timeToX(dataExistsFrom), y0, height, this.scene.settings.area.style.loadingData);
      this.paintFancyRect(g, x0, x1, this.scene.timeToX(dataExistsTo), x1, y0, height, this.scene.settings.area.style.loadingData);
    }
  };

  Linearchart_DataLimitRenderer.prototype.paintFancyRect = function(g, clipX0, clipX1, x0, x1, y0, height, style) {
    var ih, image, iw, iww, ix, w, x, xx0, xx1, y;
    if (x0 >= clipX1 || x1 <= clipX0) {
      return;
    }
    xx0 = Math.max(x0, clipX0);
    xx1 = Math.min(x1, clipX1);
    g.beginPath();
    g.rect(xx0, y0, xx1 - xx0, height);
    Base_Graphics.paint(g, style);
    if (style.image != null) {
      image = this.r.getImage(style.image);
      if (image != null) {
        iw = image.width;
        ih = image.height;
        x = (xx0 + xx1) / 2;
        y = y0 + (height - ih) / 2;
        w = iw / 2 + 2;
        if (x + w - 2 > x1) {
          x = x1 - iw - 2;
          ix = xx0 - x;
          if (((iw - ix) | 0) > 0 && (ix | 0) < (iw | 0)) {
            return g.drawImage(image, ix | 0, 0, (iw - ix) | 0, ih, (x + ix) | 0, y | 0, (iw - ix) | 0, ih | 0);
          }
        } else if (x - w < x0) {
          x = x0 + 2;
          iww = Math.min(xx1 - x, iw);
          if ((iww | 0) > 0) {
            return g.drawImage(image, 0, 0, iww | 0, ih, x | 0, y | 0, iww | 0, ih | 0);
          }
        } else {
          return g.drawImage(image, (x - iw / 2) | 0, y | 0);
        }
      }
    }
  };

  return Linearchart_DataLimitRenderer;

})();
var Base_images_logo = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAWgAAAAkCAYAAACkCKB2AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAFbxJREFUeNrsXQt4FFWWPp2k0yEPHgKB8BaQlzwEwgwP37LKMrwcHUQcmRnHDYzuuLPKqviBozI64Koz6qoQ0XHcHWARR8URGQmgO6IYExCIMPIOCEh4JyGvTrrn/tXndm5XV3VXd7qTdq3/+87X1VW3bt261fXfc/977m2H1+slGzZsRI7cfIddCTbihqI8LyXZ1WDDRpPwz8KOCfPaZlsM7Bj/pjTYBG3DRtPwirAcuxpsxAg5/JvSkGLXh40WlQlyc1u2G1lUhDL8iLffiPKFsmEj1iRtTNCO/OLvbrUkOynt1GEa9OZCSmpwk9cRcQfjamGv8/ZqYfd+l6oPZNcCyBOW38Q8FvHnGzY32EgkJJIHfRkcKmGXCksXdljYNmGFwk59S+ozQ1h33u6c4GVFOSfyNnSvd7+Fv98HmFzbCVtsv842bIKOPX4gbJ6wsXDgDY4fF7ZC2CPCKhK8Pj3Kdn2Cl3WosCW8/XkLEvRI/oym69bbfoVt2AQdP4B050NcCJEmh6UCEPgdwnbbjy0mUBuQqhYsRx5/zo7i3MW2NGHDJuj4AF7zr5Xvu4S9Qz5JA55yJ2FXCZvK26PZy7tc2Df2o/t/A8gTZ6M890CUxG7DxrcCLRVmN1nYE8p3bEN/fkjY28I2CFvOL18uEzfQR9h/h/G4EwWJPgOo0sSbbm6MtF9DGzase9AIkv6eRYKBZrxO2Gdh0rXi/Gr4+wLl2OPkkznM8LUwhEGtFTaebZKwreTTrzGo2ENYlrAGTl/IBH9eWJqwa4R9X1hfYdl83zi2m/P92AKJYEBtEHt8uM5JYXuFbebz6w3qBufdIKy/sI68/xjX159CSAud+LyhfG+t+ZroOewgX4TI0TBlRmM2TthAYd2EXcR1gm0X14WadgE1jgHgWkspcHAWvZkJfC8Z3Mv5SthGblAjRm5u7nje7K1IHQXsGRM/d2wX87ZMn8/7evM+9RwJ+Vtpp3jb+U3w1mOO7LR+NGvw/dQ5qxtV1pZT4dGPaG3pC9qx2UOepqU77zM8z+zYoLbX0sS+M7X8vqn4mtbuW067zm3U9g/LHkcr9iwMm8+4TjNocPYow+uqadWy41qvlzxJZTV7Qt7vrf0W0PayzVqZQu3H99auttp2ee052nD4f03zRtr+HYZQpqt1wD2rx63kZVZH2H9F9x/4vyMPfRqjdEZ1Fg0c+qnejvziV8XHzyLIAyPpT+r29WSiBzFeIqwN+QbQTpNv0G8Ke+87mDhrLFwH5LiFibhMmFN5+Yywh8lzLJOKGTxMRg9RsvOcLsyuEzcgs/h6ZnhG2H18z2vlsyRfNIqZjIQIlblMcPq6+0RYlxDXQ+PwNNe7V1dHN3I5LmMiVYFBwTkWn+sQYSWcx9NhpIS/gECLiopqIiDnPK73IP6hxrC5/Uy+xZz2AD/zf+J9Mg/1HPmbXMRkfFZpBA5wj8xP0hwHvZ+3+0TUwPimekfVU8IL/czEFXSy8hs6UXHc1ypn5dDta4Zpx16fvoFmrbouiMzMjk3seTc9eM1i2nV8O1XWVVBmapYgrKP0yCfTNSK+cciPacLyTv70c3OX0bAuo7TrqcD+8f0ma9vpqRlUVXfBf2zWn6/QyE1fdpS7Y2ZnunftrUHlVbFu5gl6a+f/BJGWfj++y7wH5wzXyrFo0wP+xsv/Y75hM/Vq35dKjm/z11/Pi/oEpEVeKszyemTsKrq230S6eeWIAAJH3d02cjYVln6s1Smud6GukhYU/EvAvcp0an2pdRYNN2OqtxF5NESYkUfnKWNA7z+YlPXoq/v+hEVyBnax1zmHvWCjcqiSTT82o/tzsxfp4HN+Qb6wuB+SV8641IgJcstoA2nAw/fqVDxQPVqHuZ/hwtYIG0WBA58ZCjnXM9HL8rbl/R2ZgOAN/1JXn1NNrufmsiO/TL53h8lzdCs9gsd05OzhfJI4H+KGODWCZwkyzBfECPJdzyS8WPF0VbTje32Q01jRrAu4zG8oaSVp51EChOTNu/J3GrHM3TShyXmBMEHOfypeasljQ/opg2doRKXHU0V3CgtNqAvHvxxUdhAc7klP+NHi44MF/uvCC8b9Fa1c7yc7kDOgNjqyB7D5xMqAfeo9gEj1eWneSJeRGrle1+OWIA8Z+9V7RSOGBkpPvkinL088NOgXhU3nLqXephp4fLv4M4dfjN8YkHM5vyi1OhL4PMLyfqTTTZ/lco0RNoK98dvZM1e14H38ck5kz3Ioyw/zlDLdSElJNzlrKyi5rg7e8zMKOXvZ+xzLXuoAzmeasJXcM9CjhuvqLvb4ULaryTcwWqGQ8Yu654DyvCTsZr5Gf7YBLFm8pqT9VyZHI5LdxeR6M5cbb85/km+QFY3D3UraYt43gg0S10FuKFRyfp6PD+R6GMPEWUjGIZLhSFol4wMG5CylimKFVK1IFMUGcob8Pr6lyRmEA0/vyU/viUl+0wfNodIz+y13p+8Yfr/mEeq9SCuAp94xsxO9ui2w0/zi1vnaPeF4rAHCBPndeMlsfxkG5Qyj5z5bEJRWT85GkoOal5RrcE+HTu/T5JJwQCMGLxoST0to0NvYjHADe3wSz3GXHp7cB/ziSnzBZLKZ9dI6Ye2FDRY2g1+UCxGWt0zZvsDadaUuDcjiQ76HDvI3KexvJvfaoEg0eeTxvCn4+GKx/RPF4wbpr9Cde5waI0+MvOV3+D6NGpkPuDHLYNIeyvUlu/V3GZwHzfwEyx/p3IgSy1GblIZE4lFhq0LU4UW6BnSHQdoxikyC+9EzyhGWnZ6m+A2KtqOmzxQkRe5o8djpkV3HaQQZZdc3CKN7XaV5iVagacw5wzU5IipvveNwOll5IkjKwL2gkcDxtaWxrzOQZ5bL5/dd23uyJuWEklPC5ZWT1d3/HV4zSHvbsS10ff9plvL49NAmGtNL+EZxnjwbSRRHTybcLNlYsZyBQbhXdeT8W/ba4OEWMZmdZl34z0wukyny6IFMVaNRyqLH16yLynS9QuT5nl/WcTj6pNRWiRM817KkoD0LA3Imgx6CkQdthi1MtH45M8J6+LVSd+NNGohwkS4uC7+DDjrP3gz1UUhjkSBW6w8kxAAhCHLvqS9jkhfkig6Z2fS3I+9ZSj/n+/OoYM+7UZMbBgUPnt5reAyaMY7HAxmuzID623c6+ukQHbM60/GKI/7v8Joh2aAO4UnDow6Ho+WllJGaGfffilWCdjJJyenLZ4TdyS9lHnfhpQeHbjfC5aoDcsC6FtraFv6e8GYTaSAUIhG49inbbUOkq2bvHmVLS6kWDrnHM1w5vj5Odav+ys1+1Q4+BlnhCrZR3DBVKCTa2eTcpmK72pMm3xjACGreMEcz6aMliT5h0M6VbTkt9Nd0QSrookcLDMSZAVEUF7e/JC73iUFIkKJERe35qBs0kPCR8safFPRnNJhotKQOHfbFKNusNYzIT5+/NCtEH43EYYSF3N2VQJf/79z9/ZWyHxploLCVLC6RlEzwTDVXy+nSFiXSuBx0Xi+40euxUoa2FFl0iUoiobrfjUTmcJCzpjyZvN4eam8mTu+W6pGm6d8DrldISn0Negp1yrND+VPj6LlCkrmKv89k2aaE96+IY/3EAhifGEmN0T4tHnMdqccb1hvPHkWnKsssecRWu+/hiBIDeEYAacbaqwTJ3TXiN5rmCy1a1p8eajhdSdnnAVo0pBEZPog6gDwi9XepP8vnAU9a06GjUJ9QLkTYSOC5NHXQMMXij3yujoRlKBkGrS7m7XMsbTQitRV1OXucbv/ifRp9ZBfVJyfTedFVOdS2MxV1HUAeQS3bOvWlk1nthdcatoc8X7lWvCCI3OHUSQblzfDeqg3IlcL+GEaWSQ1xfizh5kZxGaQ/pWcwlO1ulpLm6noELQ3ozKuYkNVQuxaXOE7VfK15aZF4viG1tdpzltIhvGzLoY80bzFUjLUVSC04nkBYIAzlhraNsDa1/vSYOOBmrfFA+sLSSwMIGmGDMBxbU7IyoAch9WfEMMs4ZtRRVM9WELKq7aOs8fag4Um+qHij8JrUJztJ2cYkiMYp2CkuGn1oGz2+Pp96lJdRTYqPU5KEt3z54R10244PqE7sm3LrE/CwHYKgQ5HML3XXbU7CbE70ZK9UhtmVcWOIaJeD7HVnsOyxiMKH8sUCuO549p6ncKPcVSFr7MPAL6JDjicIOUtZSh9qt5RaOIoDg2kgBHhz4SIOLGlQWlf7Mc2zDOVF45qIiUaIGLzIaAkaHqaZzoyBN8QvxwLQyTHpBFDvS9afHjK876lr1gUdk2F2CM3Tlx3eMogbjYHamMGzDjWIa9bARqvtmyGUToo4X8xYkwNFZ9ibcitd68uV9O805ppMbarO0uMFL1NO5RnhNWdQbbJTs2pB3JXCs65KTaNk4TVP2vMJtGl08R8mX3gXCMjJkgaCD9Gfeo5zria9th1biHvyurk34O/VNeP7e49Czp+xB/gzbiTfJ1/YHtYjeamZPHu1wYL+DHEOMzevD3jePlJ8IEG85zwuD8L/9KF27RKhgOiux8oLlR5lrzYDLaXHjD906eFFxxqYzScn3TQVkEtAdkaEF239rfn7cvpez8sDtOE+HfprXjWkCGlWdOhIpKV4ETRm0I1SXtAfszclAVKVteQJ9J6dNL1kI3U7X0ZVTpdCfuob76C65BTKK3qXcku3V1NKKmbAIboBw9sYnNrNpHQdn4LmbBo3FHGiIS+507IayOFQA4XGNaPHrg6CPkW+aBTDd0FXn83576Xn2UOdRo0L3RMlQHyxIskdIOMV7hJi3Y+dx4q1WXyx8sgR9obwNqvpQUjR6tEYTEMUhREwQIiBwngDIW7R1B90Z8glMn4ZRI3Y7V0nA6OKrcRDo7eAdPGGGUFjcsO/Kd9/x2Rp4HH6CaZRRBaece7Rr6g+KWCwH4scYf2MIu6yF3ocSYXp7trl4458icHEM5wfuvlwB2RkAjzFPzJRb6DgAbVY8qTDndEGHn2hsnNCM767KtHWhkmbpjzDhiZeyxNleRcqDWZCeKffBqzatSSmkzo++OptbWag1agB6UVHc/239i7VJAD9uRiEQ57I2wz6+GNJksgPA3uWiXbf8qjrDwOccip7bidf8FnRicBALYTwhdKhISdhWvhHB9e1CEHjKb+qHENX1kiwgtRwkrfBxOrEB2pwBEVioUkazl5MLnvnozwOR/dT6ZBSvVJKgZeOiRdv8nXhVf6Uvcn4jk40NFBt646uhhRXgcPrlRNgLqPgCRp6dIgRMX+l7JsZIv1NSn0fCeFph0K1hfJjjCLU+hR4numy55ngvDiSEmSBf3SLMVHlnnEPB4Rp6QkWOqcatmUG6Kvwoh+76g8BeZgRtvSibx2WF5XHjrLjXFkmXAfx1eEm30BiALGpxIoIDZQ9Ej0e9Yfyo/4iJWl1yjd6HfCo9WX+9EhBUDy0fAZoiDClHZEgZosmWXlmVmE0SIhuqxrWBT14mQmZqwv6YCqzb7aeIOdTwhNNDgyfC/IIMWBY7sp4e3P3wZlUXy+JANrhqjBSQHzgqafai7qmVnfoXpZxYv/z3pTUeXwEE27Q3EL7LWWPExo5Ii4mcZf6JzEoARrGPG7wZnAv4gUmbjcTKXo3cxRSxz8AR/NPM3uZpDHWMJivs4yfExpQiGtYeQ9vDibdYILRZu7RQLdCTPZ8xZP/vybcdyzlkWJqXMXurE76SJiV7LC2Awa0lkxb4x/0grZ60+rG9vDZqYHzo17+9BnT8DxEOYA4Vs/Y6s8PURsYGDTzolcP3qoRXKRTvlF2DLjJssMDBmGFW1cE1xlUMlxbC+Oeuof9+6OZ1eiLxFgWlJeM1AgFDEBC4qkS9b39WLDnjsaiqu5Zvw6ths/hftEQGd2rPswOMFrwKiLPzWA1OyydGY3uCkFmqPbSp7aiH217nx7fsIzK0/wLqhVS4DRxyqyrPrvx4hG9754yd6bX0/ACeb0ggkvJfGJCOyaW9kwUWJ/CbFQCT+1R3kYUyH+ZpINXVcJEdYxcrQZkF79X0evD15wNqa1WsLeqop4bCnV1O/QyIOqpq9lB0pkVor6w1se/K43iPINy+317bhT0K+rtJF/4m1wWFL2OH/L2beSLrAmFZw16B26+Dtba2M313Vd3PEUnkWDC0diioqKIo0dzc3PXs3c7mxonksjnv58/zbx4o9XsQM7I8w1u7CU553H+I9X8Wmo1O9XLxboQmDiBrrb05oy8L/mih4rYkPG++lhgo6iEcJEK4Y6bXcvqPZst/xnuuvq0IFLEQKMce89vDTjXLC/pHZtdRz1PfRYYlDU7J9Qzi4abzVazi/ZfVvqyF7mE6mtp7YBxdMuXm2jgyVKqdrqCEqc21HsrU1v99KVRU73epORHqUGbufwxhZ415lC61OkUenDMabJtlGcrf57uOseZfqOp8/a/ul0Vp2/zJCXvZ4kl26R+KpjgpdQj4QpTX6km24+xXDBHIcZkXd6QX+BK3UuBazanRfgcEb+MAUe4Chm6upLdH3jOdygyiNPAY0UDGO3CEg8yocpeUz417V9SCjjPRUzMxJ7zdOV7wgAvu1HIW6gXO9QxEKURWRqRSjgSDHfc7FrR3rPV6+rTGkkN4fKK5N6tkmw8IjqMXmIMcXa06BngJZ7MLzCAyI9PyOPZcSEtk+Zfdye99tYiSnfXIGIjxc+w7prTF5xpv7r/+l+s2dlt4Gqqq5Ev/+/DXK+SXzQXe3KhIjrgPcoFiL4Ike4b9n5TNO/f01BVn9meKroOoLSSD2spNRnhY4hJupp8YYXtuG6gvyPqBOFwhzmvz1mCIJZCQgFEtMlAeya+3hKWja5nqUP+ycAXTGiHDPJcyDKJ7LGEA+rw5+RbpvQW7pHUcrlk/g+wt4/ZhGOYqL3cc3mfZQ93EyWJXEXmUKMvci3UodFi/Yt5/0glz7NkPtU7l2zYSEAYSRyR5gFPFsKLXJqzjLv2fyVXOk0q2Ui/LcintPq6dR5HUqv6pKT3tnS79JXfj72lemdOv+XkrpHrFz9P4QfjmgfONOq1IZ+yd2yghtQ0+1diEZALvkuIhcRhw0akEkekqGJpA15XF5YCMJniFaqt+sNfBl5ZfKR1x4YrSndOKE9Lp90derUp7tJvusfpuk+Qs/ynE8xQfCihqsdrv3c2bNhoWcTqX70h2GAxfMw2wyAfdMo5mtXXbd/edeDu7T2GXBCk1528ntFiX2ty+4M6MKg2k4LXdbZhw4YNm6BjBMz+Q9gZ/uYAC87Lga9hgpCHaavWBQIj/4hWwDTmBvtR2LBhw0b8CBrAoB1CxxCbi8FDxJ1gBbo2TMIgZQyI4R9FIIMctR+BDRs2bBgjaJDQhg0b1sCDhJjMk2PXho0YApFlORgkTLLrwoaNJuFOUhcKs2GjaYCq8HP5JcWuDxs2moS1tgdtI174hwADAIWSg7lTzeQwAAAAAElFTkSuQmCC";
var Base_images_error = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAAYdEVYdFNvZnR3YXJlAHBhaW50Lm5ldCA0LjAuNWWFMmUAAAANSURBVBhXY/j//z8DAAj8Av6IXwbgAAAAAElFTkSuQmCC";


// Generated by CoffeeScript 1.8.0
var Base_AssetsLoader,
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

Base_AssetsLoader = (function() {
  function Base_AssetsLoader(chart) {
    this.chart = chart;
    this.loadNextAsset = __bind(this.loadNextAsset, this);
    this.load = __bind(this.load, this);
    this.loadedAssets = {};
    this.queuedAssets = {};
    this.imgAssets = {};
    this.callbacks = [];
  }

  Base_AssetsLoader.prototype.load = function(assetsList, callback) {
    var asset, needCallback, needLoading, url, _i, _len;
    needCallback = false;
    needLoading = true;
    for (_i = 0, _len = assetsList.length; _i < _len; _i++) {
      asset = assetsList[_i];
      url = this.chart.settings.getAssetUrl(asset);
      if (!this.loadedAssets.hasOwnProperty(url)) {
        needCallback = true;
        if (!this.queuedAssets.hasOwnProperty(url)) {
          this.queuedAssets[url] = true;
          needLoading = true;
        }
      }
    }
    if (!needLoading) {
      return false;
    }
    this.callbacks.push(callback);
    if (this.callbacks.length === 1) {
      this.chart.log("Loading assets");
      this.loadNextAsset(true);
    }
    return true;
  };

  Base_AssetsLoader.prototype.loadNextAsset = function(immediate) {
    var asset, assetToLoad, c, loaded, v, _i, _len, _ref, _ref1;
    if (immediate == null) {
      immediate = false;
    }
    assetToLoad = null;
    _ref = this.queuedAssets;
    for (asset in _ref) {
      v = _ref[asset];
      if (!this.loadedAssets.hasOwnProperty(asset)) {
        assetToLoad = asset;
        break;
      } else {
        delete this.queuedAssets[asset];
      }
    }
    if (assetToLoad) {
      loaded = (function(_this) {
        return function(asset) {
          if (_this.chart.removed) {
            return;
          }
          _this.loadedAssets[asset] = true;
          return _this.loadNextAsset();
        };
      })(this);
      return this.loadAsset(assetToLoad, loaded);
    } else {
      if (immediate) {
        return setTimeout(this.loadNextAsset, 0);
      } else {
        if (this.callbacks.length > 0) {
          this.chart.log("Chart assets loaded");
          _ref1 = this.callbacks;
          for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
            c = _ref1[_i];
            c();
          }
          return this.callbacks = [];
        }
      }
    }
  };

  Base_AssetsLoader.prototype.loadAsset = function(url, callback) {
    var elem, ext;
    ext = Base_Helpers.getExtension(url);
    if (ext === "css") {
      elem = document.createElement("link");
      elem.setAttribute("rel", "stylesheet");
      elem.setAttribute("href", url);
      elem.setAttribute("type", "text/css");
      Base_Helpers.listen(elem, "load", function() {
        return callback(url);
      });
      Base_Helpers.listen(elem, "error", (function(_this) {
        return function() {
          _this.chart.error("Assets: Failed to load asset", url);
          return callback(url);
        };
      })(this));
      document.getElementsByTagName("head")[0].appendChild(elem);
      return setTimeout((function(_this) {
        return function() {
          var img;
          if (!_this.loadedAssets.hasOwnProperty(url) && !_this.imgAssets.hasOwnProperty(url)) {
            _this.imgAssets[url] = true;
            img = document.createElement('img');
            img.onerror = function() {
              return callback(url);
            };
            return img.src = url;
          }
        };
      })(this), 200);
    } else if (ext === "js") {
      elem = document.createElement("script");
      elem.setAttribute("src", url);
      elem.setAttribute("type", "text/javascript");
      Base_Helpers.listen(elem, "load", function() {
        return callback(url);
      });
      Base_Helpers.listen(elem, "error", (function(_this) {
        return function() {
          _this.chart.error("Assets: Failed to load asset", url);
          return callback(url);
        };
      })(this));
      return document.getElementsByTagName("head")[0].appendChild(elem);
    } else {
      this.chart.error("Assets: Do not know how to load", url);
      return callback(url);
    }
  };

  return Base_AssetsLoader;

})();
// Generated by CoffeeScript 1.8.0
var Base_Rect;

Base_Rect = (function() {
  Base_Rect.prototype.x0 = 0;

  Base_Rect.prototype.x1 = 0;

  Base_Rect.prototype.y0 = 0;

  Base_Rect.prototype.y1 = 0;

  function Base_Rect(x0, y0, x1, y1) {
    this.x0 = x0;
    this.y0 = y0;
    this.x1 = x1;
    this.y1 = y1;
    1;
  }

  Base_Rect.prototype.isEmpty = function() {
    return this.x0 >= this.x1 || this.y0 >= this.y1;
  };

  Base_Rect.prototype.clone = function() {
    return new Base_Rect(this.x0, this.y0, this.x1, this.y1);
  };

  Base_Rect.prototype.empty = function() {
    this.x0 = Infinity;
    this.y0 = Infinity;
    this.x1 = -Infinity;
    this.y1 = -Infinity;
    return this;
  };

  Base_Rect.prototype.w = function() {
    return this.x1 - this.x0;
  };

  Base_Rect.prototype.h = function() {
    return this.y1 - this.y0;
  };

  Base_Rect.prototype.inflate = function(scale) {
    var cx, cy;
    cx = (this.x0 + this.x1) / 2;
    cy = (this.y0 + this.y1) / 2;
    this.x0 = (this.x0 - cx) * scale + cx;
    this.x1 = (this.x1 - cx) * scale + cx;
    this.y0 = (this.y0 - cy) * scale + cy;
    this.y1 = (this.y1 - cy) * scale + cy;
    return this;
  };

  Base_Rect.prototype.clip = function(rect) {
    this.x0 = Math.max(this.x0, rect.x0);
    this.x1 = Math.min(this.x1, rect.x1);
    this.y0 = Math.max(this.y0, rect.y0);
    this.y1 = Math.min(this.y1, rect.y1);
    return this;
  };

  Base_Rect.prototype.isInside = function(rect) {
    return this.x0 >= rect.x0 && this.x1 <= rect.x1 && this.y0 >= rect.y0 && this.y1 <= rect.y1;
  };

  Base_Rect.prototype.isOutside = function(rect) {
    return this.x0 > rect.x1 || this.x1 < rect.x0 || this.y0 > rect.y1 || this.y1 < rect.y0;
  };

  Base_Rect.prototype.overlapsRect = function(x0, y0, x1, y1) {
    return x0 < this.x1 && x1 > this.x0 && y0 < this.y1 && y1 > this.y0;
  };

  Base_Rect.prototype.area = function() {
    return (this.x1 - this.x0) * (this.y1 - this.y0);
  };

  Base_Rect.prototype.toString = function() {
    return "" + this.x0 + "," + this.y0 + ", " + this.x1 + ", " + this.y1;
  };

  Base_Rect.prototype.addPoint = function(x, y) {
    this.x0 = Math.min(this.x0, x);
    this.x1 = Math.max(this.x1, x);
    this.y0 = Math.min(this.y0, y);
    this.y1 = Math.max(this.y1, y);
    return this;
  };

  Base_Rect.prototype.containsPoint = function(x, y) {
    return x >= this.x0 && x < this.x1 && y >= this.y0 && y < this.y1;
  };

  Base_Rect.prototype.addLine = function(lineArray) {
    var i, _i, _ref;
    for (i = _i = 0, _ref = lineArray.length - 2; _i <= _ref; i = _i += 2) {
      this.addPoint(lineArray[i], lineArray[i + 1]);
    }
    return this;
  };

  Base_Rect.prototype.overlaps = function(bounds) {
    return this.x0 < bounds.x1 && this.x1 > bounds.x0 && this.y0 < bounds.y1 && this.y1 > bounds.y0;
  };

  return Base_Rect;

})();
// Generated by CoffeeScript 1.8.0
var Netchart_Layout_BHTree;

Netchart_Layout_BHTree = (function() {
  var RepulsiveTreeNode, swap;

  RepulsiveTreeNode = (function() {
    function RepulsiveTreeNode() {}

    RepulsiveTreeNode.prototype.forceLinkList = null;

    RepulsiveTreeNode.prototype.x = 0;

    RepulsiveTreeNode.prototype.y = 0;

    RepulsiveTreeNode.prototype.r = 0;

    RepulsiveTreeNode.prototype.fx = 0;

    RepulsiveTreeNode.prototype.fy = 0;

    RepulsiveTreeNode.prototype.sizeEstimate = 0;

    RepulsiveTreeNode.prototype.left = null;

    RepulsiveTreeNode.prototype.right = null;

    RepulsiveTreeNode.prototype.nodes = null;

    return RepulsiveTreeNode;

  })();

  Netchart_Layout_BHTree.prototype.maxLeafCount = 5;

  Netchart_Layout_BHTree.test = function() {
    var base, nodes, t;
    t = new Netchart_Layout_BHTree();
    t.maxLeafCount = 2;
    t.temperature = 1;
    nodes = [];
    base = {
      z: 0,
      dx: 0,
      dy: 0,
      dz: 0,
      repulsiveForceX: 0,
      repulsiveForceY: 0,
      repulsiveForceZ: 0,
      fsum: 0
    };
    nodes.push(Base_Helpers.extend({
      r: 5,
      x: 10,
      y: 10
    }, base));
    nodes.push(Base_Helpers.extend({
      r: 5,
      x: 0,
      y: 0
    }, base));
    nodes.push(Base_Helpers.extend({
      r: 5,
      x: 0,
      y: 10
    }, base));
    nodes.push(Base_Helpers.extend({
      r: 5,
      x: 10,
      y: 0
    }, base));
    nodes.push(Base_Helpers.extend({
      r: 5,
      x: 10,
      y: 10
    }, base));
    nodes.push(Base_Helpers.extend({
      r: 5,
      x: 20,
      y: 0
    }, base));
    nodes.push(Base_Helpers.extend({
      r: 5,
      x: 25,
      y: 0
    }, base));
    return t.buildTree(nodes, nodes.length);
  };

  function Netchart_Layout_BHTree() {
    this.root = null;
    this.freeNodeRoot = null;
    this.temperature = 0;
    this.nodeCount = 0;
  }

  Netchart_Layout_BHTree.prototype.buildTree = function(nodeArray) {
    var count, i, _i, _ref;
    this.iters = 0;
    count = nodeArray.length;
    if (this.root != null) {
      this.freeNode(this.root);
    }
    this.root = this.newNode();
    if (count > 0) {
      this.buildTreeRecursive(nodeArray, 0, count, this.root);
    }
    for (i = _i = 0, _ref = count - 1; _i <= _ref; i = _i += 1) {
      nodeArray[i].repulsiveForceX = 0;
      nodeArray[i].repulsiveForceY = 0;
      nodeArray[i].repulsiveForceZ = 0;
    }
    return this.calculateForces();
  };

  Netchart_Layout_BHTree.prototype.freeNode = function(node) {
    if (node.left != null) {
      this.freeNode(node.left);
    }
    if (node.right != null) {
      this.freeNode(node.right);
    }
    node.left = this.freeNodeRoot;
    return this.freeNodeRoot = node;
  };

  Netchart_Layout_BHTree.prototype.newNode = function() {
    var node;
    if (this.freeNodeRoot != null) {
      node = this.freeNodeRoot;
      this.freeNodeRoot = node.left;
      node.left = null;
      node.right = null;
      node.leafCount = 0;
      node.sizeEstimate = 0;
      node.forceLinkList.length = 0;
    } else {
      node = new RepulsiveTreeNode();
      node.forceLinkList = [];
      node.leaves = new Array(this.maxLeafCount);
    }
    node.repulsiveForceX = 0;
    node.repulsiveForceY = 0;
    node.repulsiveForceZ = 0;
    return node;
  };

  swap = function(arr, a, b) {
    var p;
    p = arr[a];
    arr[a] = arr[b];
    return arr[b] = p;
  };

  Netchart_Layout_BHTree.prototype.addForceLink = function(source, target) {
    return source.forceLinkList.push(target);
  };

  Netchart_Layout_BHTree.prototype.getMedianX = function(arr, low, high) {
    var hh, ll, median, middle, tmp;
    high -= 1;
    median = ((low + high) / 2) | 0;
    while (true) {
      if (high <= low) {
        return median;
      }
      if (high === low + 1) {
        if (arr[low].x > arr[high].x) {
          swap(arr, low, high);
          return median;
        }
      }
      middle = ((low + high) / 2) | 0;
      if (arr[middle].x > arr[high].x) {
        swap(arr, middle, high);
      }
      if (arr[low].x > arr[high].x) {
        swap(arr, low, high);
      }
      if (arr[middle].x > arr[low].x) {
        swap(arr, middle, low);
      }
      swap(arr, middle, low + 1);
      ll = low + 1;
      hh = high;
      while (true) {
        while (true) {
          ll += 1;
          if (!(arr[low].x > arr[ll].x)) {
            break;
          }
        }
        while (true) {
          hh -= 1;
          if (!(arr[hh].x > arr[low].x)) {
            break;
          }
        }
        if (hh < ll) {
          break;
        }
        tmp = arr[ll];
        arr[ll] = arr[hh];
        arr[hh] = tmp;
      }
      swap(arr, low, hh);
      if (hh <= median) {
        low = ll;
      }
      if (hh >= median) {
        high = hh - 1;
      }
    }
  };

  Netchart_Layout_BHTree.prototype.getMedianY = function(arr, low, high) {
    var hh, ll, median, middle, tmp;
    high -= 1;
    median = ((low + high) / 2) | 0;
    while (true) {
      if (high <= low) {
        return median;
      }
      if (high === low + 1) {
        if (arr[low].y > arr[high].y) {
          swap(arr, low, high);
        }
        return median;
      }
      middle = ((low + high) / 2) | 0;
      if (arr[middle].y > arr[high].y) {
        swap(arr, middle, high);
      }
      if (arr[low].y > arr[high].y) {
        swap(arr, low, high);
      }
      if (arr[middle].y > arr[low].y) {
        swap(arr, middle, low);
      }
      swap(arr, middle, low + 1);
      ll = low + 1;
      hh = high;
      while (true) {
        while (true) {
          ll += 1;
          if (!(arr[low].y > arr[ll].y)) {
            break;
          }
        }
        while (true) {
          hh -= 1;
          if (!(arr[hh].y > arr[low].y)) {
            break;
          }
        }
        if (hh < ll) {
          break;
        }
        tmp = arr[ll];
        arr[ll] = arr[hh];
        arr[hh] = tmp;
      }
      swap(arr, low, hh);
      if (hh <= median) {
        low = ll;
      }
      if (hh >= median) {
        high = hh - 1;
      }
    }
  };

  Netchart_Layout_BHTree.prototype.buildTreeRecursive = function(nodeArray, start, end, subtree) {
    var child, count, i, invcnt, median, node, p, r, x, x1, x2, y, y1, y2, z, _i, _j, _ref, _ref1, _ref2;
    x1 = x2 = nodeArray[start].x;
    y1 = y2 = nodeArray[start].y;
    for (i = _i = _ref = start + 1, _ref1 = end - 1; _i <= _ref1; i = _i += 1) {
      p = nodeArray[i];
      x = p.x;
      y = p.y;
      if (x < x1) {
        x1 = x;
      }
      if (x > x2) {
        x2 = x;
      }
      if (y < y1) {
        y1 = y;
      }
      if (y > y2) {
        y2 = y;
      }
    }
    subtree.sizeEstimate = Math.max(x2 - x1, y2 - y1);
    subtree.sizeEstimate = subtree.sizeEstimate * subtree.sizeEstimate + 0.1;
    subtree.sizeEstimate *= 2;
    count = end - start;
    if (count <= this.maxLeafCount) {
      subtree.leafCount = count;
      x = 0;
      y = 0;
      z = 0;
      r = 0;
      for (i = _j = 0, _ref2 = count - 1; _j <= _ref2; i = _j += 1) {
        node = nodeArray[i + start];
        x += node.x;
        y += node.y;
        z += node.z;
        r += node.r;
        subtree.leaves[i] = node;
      }
      invcnt = 1.0 / count;
      subtree.r = r;
      subtree.x = x * invcnt;
      subtree.y = y * invcnt;
      subtree.z = z * invcnt;
      return;
    }
    if (x2 - x1 > y2 - y1) {
      median = this.getMedianX(nodeArray, start, end);
    } else {
      median = this.getMedianY(nodeArray, start, end);
    }
    median++;
    child = this.newNode();
    subtree.left = child;
    this.buildTreeRecursive(nodeArray, start, median, child);
    child = this.newNode();
    subtree.right = child;
    this.buildTreeRecursive(nodeArray, median, end, child);
    invcnt = 1.0 / count;
    subtree.r = subtree.right.r + subtree.left.r;
    subtree.x = (subtree.left.x * (median - start) + subtree.right.x * (end - median)) * invcnt;
    subtree.y = (subtree.left.y * (median - start) + subtree.right.y * (end - median)) * invcnt;
    return subtree.z = (subtree.left.z * (median - start) + subtree.right.z * (end - median)) * invcnt;
  };

  Netchart_Layout_BHTree.prototype.calculateForces = function() {
    var factor, forceX, forceY, i, invr, k, node, node1, node2, queue, queueEnd, queueStart, _i, _j, _ref, _ref1, _ref2, _results;
    queue = new Array(this.nodeCount);
    queueStart = 0;
    queueEnd = 0;
    if (this.root.left !== null) {
      queue[queueEnd] = this.root.left;
      queueEnd++;
      queue[queueEnd] = this.root.right;
      queueEnd++;
      this.addForceLink(this.root.left, this.root.right);
    } else {
      queue[queueEnd] = this.root;
      queueEnd++;
    }
    _results = [];
    while (queueStart < queueEnd) {
      node = queue[queueStart];
      queueStart++;
      invr = 1.0 / node.r;
      if (node.left !== null) {
        this.processTreeNode(node, node.left);
        this.processTreeNode(node, node.right);
        queue[queueEnd] = node.left;
        queueEnd++;
        queue[queueEnd] = node.right;
        queueEnd++;
        factor = node.left.r * invr;
        forceX = node.repulsiveForceX * factor;
        forceY = node.repulsiveForceY * factor;
        node.left.repulsiveForceX += forceX;
        node.left.repulsiveForceY += forceY;
        node.right.repulsiveForceX += node.repulsiveForceX - forceX;
        node.right.repulsiveForceY += node.repulsiveForceY - forceY;
        this.addForceLink(node.left, node.right);
      } else {
        for (i = _i = 0, _ref = node.leafCount - 1; _i <= _ref; i = _i += 1) {
          node1 = node.leaves[i];
          this.processLeafNode(node, node1);
          factor = node1.r * invr;
          node1.repulsiveForceX += node.repulsiveForceX * factor;
          node1.repulsiveForceY += node.repulsiveForceY * factor;
          for (k = _j = _ref1 = i + 1, _ref2 = node.leafCount - 1; _j <= _ref2; k = _j += 1) {
            node2 = node.leaves[k];
            this.forceBetweenParticles(node1, node2);
          }
        }
      }
      _results.push(node.forceLinkList.length = 0);
    }
    return _results;
  };

  Netchart_Layout_BHTree.prototype.processTreeNode = function(node, subtree) {
    var fx, fy, i, len, length, otherNode, threshold, vx, vy, w, _i, _ref, _results;
    length = node.forceLinkList.length;
    _results = [];
    for (i = _i = 0, _ref = length - 1; _i <= _ref; i = _i += 1) {
      otherNode = node.forceLinkList[i];
      vx = subtree.x - otherNode.x;
      vy = subtree.y - otherNode.y;
      len = vx * vx + vy * vy;
      threshold = subtree.sizeEstimate;
      if (otherNode instanceof RepulsiveTreeNode) {
        threshold += otherNode.sizeEstimate;
      }
      if (threshold < len) {
        w = subtree.r * otherNode.r / (len * Math.sqrt(len));
        fx = vx * w;
        subtree.repulsiveForceX += fx;
        otherNode.repulsiveForceX -= fx;
        fy = vy * w;
        subtree.repulsiveForceY += fy;
        _results.push(otherNode.repulsiveForceY -= fy);
      } else {
        if (otherNode instanceof RepulsiveTreeNode) {
          _results.push(this.addForceLink(otherNode, subtree));
        } else {
          _results.push(this.addForceLink(subtree, otherNode));
        }
      }
    }
    return _results;
  };

  Netchart_Layout_BHTree.prototype.processLeafNode = function(node, subtree) {
    var fx, fy, len, otherNode, threshold, vx, vy, w, _i, _len, _ref, _results;
    _ref = node.forceLinkList;
    _results = [];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      otherNode = _ref[_i];
      if (!(otherNode instanceof RepulsiveTreeNode)) {
        _results.push(this.forceBetweenParticles(subtree, otherNode));
      } else {
        vx = subtree.x - otherNode.x;
        vy = subtree.y - otherNode.y;
        len = vx * vx + vy * vy;
        threshold = otherNode.sizeEstimate;
        if (threshold < len) {
          w = subtree.r * otherNode.r / (len * Math.sqrt(len));
          fx = vx * w;
          subtree.repulsiveForceX += fx;
          otherNode.repulsiveForceX -= fx;
          fy = vy * w;
          subtree.repulsiveForceY += fy;
          _results.push(otherNode.repulsiveForceY -= fy);
        } else {
          _results.push(this.addForceLink(otherNode, subtree));
        }
      }
    }
    return _results;
  };

  Netchart_Layout_BHTree.prototype.forceBetweenParticles = function(node1, node2) {
    var len1, r, vx1, vy1, vz1, w;
    vx1 = node1.x - node2.x;
    vy1 = node1.y - node2.y;
    vz1 = node1.z - node2.z;
    len1 = vx1 * vx1 + vy1 * vy1 + vz1 * vz1;
    r = node1.r + node2.r;
    if (len1 * this.temperature < r) {
      w = 0.25 * this.temperature * Math.sqrt(this.temperature * r);
    } else {
      w = 0.25 * r * r / (len1 * Math.sqrt(len1));
    }
    node1.repulsiveForceX += vx1 * w;
    node2.repulsiveForceX -= vx1 * w;
    node1.repulsiveForceY += vy1 * w;
    node2.repulsiveForceY -= vy1 * w;
    node1.repulsiveForceZ += vz1 * w;
    return node2.repulsiveForceZ -= vz1 * w;
  };

  return Netchart_Layout_BHTree;

})();
// Generated by CoffeeScript 1.8.0
var Netchart_Layout_GraphAdjacency;

Netchart_Layout_GraphAdjacency = (function() {
  function Netchart_Layout_GraphAdjacency(nodes, edges) {
    var i, _i, _ref;
    this.edgecnt = 0;
    this.nodecnt = nodes;
    this.maxedges = edges;
    this.increment = edges + 1;
    this.nodestart = new Array(nodes);
    this.enodes = new Array(edges);
    this.next = new Array(edges);
    for (i = _i = 0, _ref = this.nodecnt - 1; _i <= _ref; i = _i += 1) {
      this.nodestart[i] = -1;
    }
  }

  Netchart_Layout_GraphAdjacency.prototype.addEdge = function(snode, enode) {
    if (this.edgecnt >= this.maxedges) {
      this.maxedges += this.increment;
      this.increment *= 2;
      this.next.length = this.maxedges;
      this.enodes.length = this.maxedges;
    }
    this.enodes[this.edgecnt] = enode;
    this.next[this.edgecnt] = this.nodestart[snode];
    this.nodestart[snode] = this.edgecnt;
    return this.edgecnt++;
  };

  Netchart_Layout_GraphAdjacency.prototype.addUndirectEdge = function(snode, enode) {
    this.addEdge(snode, enode);
    return this.addEdge(enode, snode);
  };

  return Netchart_Layout_GraphAdjacency;

})();
// Generated by CoffeeScript 1.8.0
var Base_Geometry;

Base_Geometry = (function() {
  function Base_Geometry() {}

  Base_Geometry.distanceToLineSq = function(x0, y0, x1, y1, x, y) {
    var cx, cy, _ref;
    _ref = this.closestPointToLine(x0, y0, x1, y1, x, y), cx = _ref[0], cy = _ref[1];
    return (x - cx) * (x - cx) + (y - cy) * (y - cy);
  };

  Base_Geometry.closestPointToLine = function(x0, y0, x1, y1, x, y) {
    var dx, dy, lengthSqr, t;
    dx = x1 - x0;
    dy = y1 - y0;
    lengthSqr = dx * dx + dy * dy;
    if (lengthSqr > 0) {
      t = (((x - x0) * dx) + (y - y0) * dy) / lengthSqr;
      t = Math.min(Math.max(t, 0), 1);
    } else {
      t = 0;
    }
    return [x0 + dx * t, y0 + dy * t];
  };

  Base_Geometry.rayIntersectsLine = function(rx, ry, rdx, rdy, lx, ly, lx1, ly1) {
    var coef, div, ldx, ldy, tl, tr;
    coef = Infinity;
    ldx = lx1 - lx;
    ldy = ly1 - ly;
    div = rdx * ldy - rdy * ldx;
    if (div !== 0) {
      tr = (ry * ldx - rx * ldy + lx * ldy - ly * ldx) / div;
      if (Math.abs(ldx) > Math.abs(ldy)) {
        tl = (rx + rdx * tr - lx) / ldx;
      } else {
        tl = (ry + rdy * tr - ly) / ldy;
      }
      if (tl >= 0 && tl <= 1 && tr >= 0) {
        coef = tr;
      }
    }
    return coef;
  };

  Base_Geometry.rayIntersectsLineBidir = function(rx, ry, rdx, rdy, lx, ly, lx1, ly1) {
    var coef, div, ldx, ldy, tl, tr;
    coef = Infinity;
    ldx = lx1 - lx;
    ldy = ly1 - ly;
    div = rdx * ldy - rdy * ldx;
    if (div !== 0) {
      tr = (ry * ldx - rx * ldy + lx * ldy - ly * ldx) / div;
      if (Math.abs(ldx) > Math.abs(ldy)) {
        tl = (rx + rdx * tr - lx) / ldx;
      } else {
        tl = (ry + rdy * tr - ly) / ldy;
      }
      if (tl >= 0 && tl <= 1) {
        coef = tr;
      }
    }
    return coef;
  };

  Base_Geometry.rayIntersectsCircle = function(rx, ry, rdx, rdy, r) {
    var a, b, c, coef, d, t0, t1;
    a = rdx * rdx + rdy * rdy;
    b = rx * rdx + ry * rdy;
    c = rx * rx + ry * ry - r * r;
    d = b * b - a * c;
    coef = Infinity;
    if (d > 0) {
      d = Math.sqrt(d);
      t0 = (-b - d) / a;
      t1 = (-b + d) / a;
      if (t0 >= 0) {
        coef = t0;
      }
      if (t1 >= 0) {
        coef = Math.min(coef, t1);
      }
    }
    return coef;
  };

  Base_Geometry.rayIntersectsCircleOuter = function(rx, ry, rdx, rdy, r) {
    var a, b, c, d;
    a = rdx * rdx + rdy * rdy;
    b = rx * rdx + ry * rdy;
    c = rx * rx + ry * ry - r * r;
    d = b * b - a * c;
    d = Math.sqrt(d);
    return Math.max((-b + d) / a, (-b - d) / a);
  };

  Base_Geometry.lineTouchingCircle = function(rx, ry, xt, yt, r) {
    var a, angle, b, dx, dy, h, xx;
    a = Math.sqrt(rx * rx + ry * ry);
    if (!(a > r)) {
      return null;
    }
    b = Math.sqrt(a * a - r * r);
    h = r * b / a;
    xx = r * r / a;
    dx = rx / a;
    dy = ry / a;
    angle = rx * yt - ry * xt;
    if (angle < 0) {
      h = -h;
    }
    return [dx * xx - dy * h, dy * xx + dx * h];
  };

  Base_Geometry.distanceToPolygonSq = function(x, y, polygonLines) {
    var dist, i, len, line, x0, x1, y0, y1, _i, _j, _len, _ref;
    if (Base_Geometry.isInsidePolygon(x, y, polygonLines)) {
      return 0;
    }
    dist = Infinity;
    for (_i = 0, _len = polygonLines.length; _i < _len; _i++) {
      line = polygonLines[_i];
      len = line.length;
      x0 = line[len - 2];
      y0 = line[len - 1];
      for (i = _j = 0, _ref = len - 2; _j <= _ref; i = _j += 2) {
        x1 = line[i];
        y1 = line[i + 1];
        dist = Math.min(dist, Base_Geometry.distanceToLineSq(x0, y0, x1, y1, x, y));
        x0 = x1;
        y0 = y1;
      }
    }
    return dist;
  };

  Base_Geometry.distanceToLinesSq = function(x, y, polygonLines) {
    var dist, i, len, line, x0, x1, y0, y1, _i, _j, _len, _ref;
    dist = Infinity;
    for (_i = 0, _len = polygonLines.length; _i < _len; _i++) {
      line = polygonLines[_i];
      len = line.length;
      if (len === 2) {
        dist = Math.min(dist, (x - line[0]) * (x - line[0]) + (y - line[1]) * (y - line[1]));
      } else if (len > 2) {
        x0 = line[0];
        y0 = line[1];
        for (i = _j = 2, _ref = len - 2; _j <= _ref; i = _j += 2) {
          x1 = line[i];
          y1 = line[i + 1];
          dist = Math.min(dist, Base_Geometry.distanceToLineSq(x0, y0, x1, y1, x, y));
          x0 = x1;
          y0 = y1;
        }
      }
    }
    return dist;
  };

  Base_Geometry.isInsidePolygon = function(x, y, polygonLines) {
    var i, inside, len, line, x0, x1, y0, y1, _i, _j, _len, _ref;
    inside = false;
    for (_i = 0, _len = polygonLines.length; _i < _len; _i++) {
      line = polygonLines[_i];
      len = line.length;
      x0 = line[len - 2];
      y0 = line[len - 1];
      for (i = _j = 0, _ref = len - 2; _j <= _ref; i = _j += 2) {
        x1 = line[i];
        y1 = line[i + 1];
        if ((y1 > y) !== (y0 > y) && (x < (x1 - x0) * (y - y0) / (y1 - y0) + x0)) {
          inside = !inside;
        }
        x0 = x1;
        y0 = y1;
      }
    }
    return inside;
  };

  Base_Geometry.distanceToBalloon = function(r, w, ddx, ddy) {
    var t0, ysign;
    if (r >= w) {
      t0 = r;
    } else if (ddy === 0) {
      t0 = w;
    } else {
      ysign = Base_Helpers.sign(ddy);
      t0 = r / ddy * ysign;
      if (Math.abs(ddx * t0) > w - r) {
        t0 = Base_Geometry.rayIntersectsCircleOuter(-(w - r), 0, Math.abs(ddx), ddy, r);
      }
    }
    return t0;
  };

  Base_Geometry.distanceToRect = function(x, y, x0, y0, x1, y1) {
    var dx, dy;
    if (x < x0) {
      dx = x0 - x;
    } else if (x > x1) {
      dx = x - x1;
    } else {
      dx = 0;
    }
    if (y < y0) {
      dy = y0 - y;
    } else if (y > y1) {
      dy = y - y1;
    } else {
      dy = 0;
    }
    return Math.sqrt(dx * dx + dy * dy);
  };

  Base_Geometry.simplify = function(points, tolerance) {
    var sqTolerance;
    if (!tolerance || !points.length) {
      return points;
    }
    sqTolerance = tolerance * tolerance;
    points = Base_Geometry.reducePoints(points, sqTolerance);
    points = Base_Geometry.simplifyDP(points, sqTolerance);
    return points;
  };

  Base_Geometry.simplifyDP = function(points, sqTolerance) {
    var ArrayConstructor, i, len, markers, newPoints, _i;
    len = points.length;
    ArrayConstructor = typeof Uint8Array !== void 0 ? Uint8Array : Array;
    markers = new ArrayConstructor(len);
    markers[0] = markers[len - 2] = 1;
    Base_Geometry.simplifyDPStep(points, markers, sqTolerance, 0, len - 2);
    newPoints = [];
    for (i = _i = 0; _i < len; i = _i += 2) {
      if (markers[i]) {
        newPoints.push(points[i]);
        newPoints.push(points[i + 1]);
      }
    }
    return newPoints;
  };

  Base_Geometry.simplifyDPStep = function(points, markers, sqTolerance, first, last) {
    var i, index, maxSqDist, sqDist, x0, x1, y0, y1, _i, _ref, _ref1;
    maxSqDist = 0;
    index = 0;
    x0 = points[first];
    y0 = points[first + 1];
    x1 = points[last];
    y1 = points[last + 1];
    for (i = _i = _ref = first + 2, _ref1 = last - 2; _i <= _ref1; i = _i += 2) {
      sqDist = Base_Geometry.distanceToLineSq(x0, y0, x1, y1, points[i], points[i + 1]);
      if (sqDist > maxSqDist) {
        index = i;
        maxSqDist = sqDist;
      }
    }
    if (maxSqDist > sqTolerance) {
      markers[index] = 1;
      Base_Geometry.simplifyDPStep(points, markers, sqTolerance, first, index);
      return Base_Geometry.simplifyDPStep(points, markers, sqTolerance, index, last);
    }
  };

  Base_Geometry.reducePoints = function(points, sqTolerance) {
    var i, len, reducedPoints, x, xx, y, yy, _i;
    x = points[0];
    y = points[1];
    reducedPoints = [x, y];
    len = points.length;
    for (i = _i = 2; _i < len; i = _i += 2) {
      xx = points[i];
      yy = points[i + 1];
      if ((x - xx) * (x - xx) + (y - yy) * (y - yy) > sqTolerance) {
        reducedPoints.push(xx);
        reducedPoints.push(yy);
        x = xx;
        y = yy;
      }
    }
    if (x !== xx && y !== yy) {
      reducedPoints.push(xx, yy);
    }
    return reducedPoints;
  };

  return Base_Geometry;

})();
// Generated by CoffeeScript 1.8.0
var Base_CssColorParser;

Base_CssColorParser = (function() {
  function Base_CssColorParser() {}

  Base_CssColorParser.clamp_css_byte = function(i) {
    i = Math.round(i);
    if (i < 0) {
      return 0;
    } else {
      if (i > 255) {
        return 255;
      } else {
        return i;
      }
    }
  };

  Base_CssColorParser.clamp_css_float = function(f) {
    if (f < 0) {
      return 0;
    } else {
      if (f > 1) {
        return 1;
      } else {
        return f;
      }
    }
  };

  Base_CssColorParser.parse_css_int = function(str) {
    if (str[str.length - 1] === "%") {
      return Base_CssColorParser.clamp_css_byte(parseFloat(str) / 100 * 255);
    }
    return Base_CssColorParser.clamp_css_byte(parseInt(str));
  };

  Base_CssColorParser.parse_css_float = function(str) {
    if (str[str.length - 1] === "%") {
      return Base_CssColorParser.clamp_css_float(parseFloat(str) / 100);
    }
    return Base_CssColorParser.clamp_css_float(parseFloat(str));
  };

  Base_CssColorParser.css_hue_to_rgb = function(m1, m2, h) {
    if (h < 0) {
      h += 1;
    } else {
      if (h > 1) {
        h -= 1;
      }
    }
    if (h * 6 < 1) {
      return m1 + (m2 - m1) * h * 6;
    }
    if (h * 2 < 1) {
      return m2;
    }
    if (h * 3 < 2) {
      return m1 + (m2 - m1) * (2 / 3 - h) * 6;
    }
    return m1;
  };

  Base_CssColorParser.parseCSSColor = function(css_str) {
    var alpha, ep, fname, h, iv, l, m1, m2, op, params, s, str;
    str = css_str.replace(RegExp(" ", "g"), "").toLowerCase();
    if (str in Base_CssColorParser.kCSSColorTable) {
      return Base_CssColorParser.kCSSColorTable[str].slice();
    }
    if (str[0] === "#") {
      if (str.length === 4) {
        iv = parseInt(str.substr(1), 16);
        if (!(iv >= 0 && iv <= 0xfff)) {
          return null;
        }
        return [((iv & 0xf00) >> 4) | ((iv & 0xf00) >> 8), (iv & 0xf0) | ((iv & 0xf0) >> 4), (iv & 0xf) | ((iv & 0xf) << 4), 1];
      } else if (str.length === 7) {
        iv = parseInt(str.substr(1), 16);
        if (!(iv >= 0 && iv < 0xffffff)) {
          return null;
        }
        return [(iv & 0xff0000) >> 16, (iv & 0xff00) >> 8, iv & 0xff, 1];
      }
      return null;
    }
    op = str.indexOf("(");
    ep = str.indexOf(")");
    if (op !== -1 && ep + 1 === str.length) {
      fname = str.substr(0, op);
      params = str.substr(op + 1, ep - (op + 1)).split(",");
      alpha = 1;
      if (fname === "rgba") {
        if (params.length !== 4) {
          return null;
        }
        alpha = Base_CssColorParser.parse_css_float(params.pop());
      }
      if (fname === "rgba" || fname === "rgb") {
        if (params.length !== 3) {
          return null;
        }
        return [Base_CssColorParser.parse_css_int(params[0]), Base_CssColorParser.parse_css_int(params[1]), Base_CssColorParser.parse_css_int(params[2]), alpha];
      }
      if (fname === "hsla") {
        if (params.length !== 4) {
          return null;
        }
        alpha = Base_CssColorParser.parse_css_float(params.pop());
      }
      if (fname === "hsla" || fname === "hsl") {
        if (params.length !== 3) {
          return null;
        }
        h = (((parseFloat(params[0]) % 360) + 360) % 360) / 360;
        s = parse_css_float(params[1]);
        l = parse_css_float(params[2]);
        m2 = (l <= 0.5 ? l * (s + 1) : l + s - l * s);
        m1 = l * 2 - m2;
        return [Base_CssColorParser.clamp_css_byte(Base_CssColorParser.css_hue_to_rgb(m1, m2, h + 1 / 3) * 255), Base_CssColorParser.clamp_css_byte(Base_CssColorParser.css_hue_to_rgb(m1, m2, h) * 255), Base_CssColorParser.clamp_css_byte(Base_CssColorParser.css_hue_to_rgb(m1, m2, h - 1 / 3) * 255), alpha];
      }
    }
    return null;
  };

  Base_CssColorParser.kCSSColorTable = {
    transparent: [0, 0, 0, 0],
    aliceblue: [240, 248, 255, 1],
    antiquewhite: [250, 235, 215, 1],
    aqua: [0, 255, 255, 1],
    aquamarine: [127, 255, 212, 1],
    azure: [240, 255, 255, 1],
    beige: [245, 245, 220, 1],
    bisque: [255, 228, 196, 1],
    black: [0, 0, 0, 1],
    blanchedalmond: [255, 235, 205, 1],
    blue: [0, 0, 255, 1],
    blueviolet: [138, 43, 226, 1],
    brown: [165, 42, 42, 1],
    burlywood: [222, 184, 135, 1],
    cadetblue: [95, 158, 160, 1],
    chartreuse: [127, 255, 0, 1],
    chocolate: [210, 105, 30, 1],
    coral: [255, 127, 80, 1],
    cornflowerblue: [100, 149, 237, 1],
    cornsilk: [255, 248, 220, 1],
    crimson: [220, 20, 60, 1],
    cyan: [0, 255, 255, 1],
    darkblue: [0, 0, 139, 1],
    darkcyan: [0, 139, 139, 1],
    darkgoldenrod: [184, 134, 11, 1],
    darkgray: [169, 169, 169, 1],
    darkgreen: [0, 100, 0, 1],
    darkgrey: [169, 169, 169, 1],
    darkkhaki: [189, 183, 107, 1],
    darkmagenta: [139, 0, 139, 1],
    darkolivegreen: [85, 107, 47, 1],
    darkorange: [255, 140, 0, 1],
    darkorchid: [153, 50, 204, 1],
    darkred: [139, 0, 0, 1],
    darksalmon: [233, 150, 122, 1],
    darkseagreen: [143, 188, 143, 1],
    darkslateblue: [72, 61, 139, 1],
    darkslategray: [47, 79, 79, 1],
    darkslategrey: [47, 79, 79, 1],
    darkturquoise: [0, 206, 209, 1],
    darkviolet: [148, 0, 211, 1],
    deeppink: [255, 20, 147, 1],
    deepskyblue: [0, 191, 255, 1],
    dimgray: [105, 105, 105, 1],
    dimgrey: [105, 105, 105, 1],
    dodgerblue: [30, 144, 255, 1],
    firebrick: [178, 34, 34, 1],
    floralwhite: [255, 250, 240, 1],
    forestgreen: [34, 139, 34, 1],
    fuchsia: [255, 0, 255, 1],
    gainsboro: [220, 220, 220, 1],
    ghostwhite: [248, 248, 255, 1],
    gold: [255, 215, 0, 1],
    goldenrod: [218, 165, 32, 1],
    gray: [128, 128, 128, 1],
    green: [0, 128, 0, 1],
    greenyellow: [173, 255, 47, 1],
    grey: [128, 128, 128, 1],
    honeydew: [240, 255, 240, 1],
    hotpink: [255, 105, 180, 1],
    indianred: [205, 92, 92, 1],
    indigo: [75, 0, 130, 1],
    ivory: [255, 255, 240, 1],
    khaki: [240, 230, 140, 1],
    lavender: [230, 230, 250, 1],
    lavenderblush: [255, 240, 245, 1],
    lawngreen: [124, 252, 0, 1],
    lemonchiffon: [255, 250, 205, 1],
    lightblue: [173, 216, 230, 1],
    lightcoral: [240, 128, 128, 1],
    lightcyan: [224, 255, 255, 1],
    lightgoldenrodyellow: [250, 250, 210, 1],
    lightgray: [211, 211, 211, 1],
    lightgreen: [144, 238, 144, 1],
    lightgrey: [211, 211, 211, 1],
    lightpink: [255, 182, 193, 1],
    lightsalmon: [255, 160, 122, 1],
    lightseagreen: [32, 178, 170, 1],
    lightskyblue: [135, 206, 250, 1],
    lightslategray: [119, 136, 153, 1],
    lightslategrey: [119, 136, 153, 1],
    lightsteelblue: [176, 196, 222, 1],
    lightyellow: [255, 255, 224, 1],
    lime: [0, 255, 0, 1],
    limegreen: [50, 205, 50, 1],
    linen: [250, 240, 230, 1],
    magenta: [255, 0, 255, 1],
    maroon: [128, 0, 0, 1],
    mediumaquamarine: [102, 205, 170, 1],
    mediumblue: [0, 0, 205, 1],
    mediumorchid: [186, 85, 211, 1],
    mediumpurple: [147, 112, 219, 1],
    mediumseagreen: [60, 179, 113, 1],
    mediumslateblue: [123, 104, 238, 1],
    mediumspringgreen: [0, 250, 154, 1],
    mediumturquoise: [72, 209, 204, 1],
    mediumvioletred: [199, 21, 133, 1],
    midnightblue: [25, 25, 112, 1],
    mintcream: [245, 255, 250, 1],
    mistyrose: [255, 228, 225, 1],
    moccasin: [255, 228, 181, 1],
    navajowhite: [255, 222, 173, 1],
    navy: [0, 0, 128, 1],
    oldlace: [253, 245, 230, 1],
    olive: [128, 128, 0, 1],
    olivedrab: [107, 142, 35, 1],
    orange: [255, 165, 0, 1],
    orangered: [255, 69, 0, 1],
    orchid: [218, 112, 214, 1],
    palegoldenrod: [238, 232, 170, 1],
    palegreen: [152, 251, 152, 1],
    paleturquoise: [175, 238, 238, 1],
    palevioletred: [219, 112, 147, 1],
    papayawhip: [255, 239, 213, 1],
    peachpuff: [255, 218, 185, 1],
    peru: [205, 133, 63, 1],
    pink: [255, 192, 203, 1],
    plum: [221, 160, 221, 1],
    powderblue: [176, 224, 230, 1],
    purple: [128, 0, 128, 1],
    red: [255, 0, 0, 1],
    rosybrown: [188, 143, 143, 1],
    royalblue: [65, 105, 225, 1],
    saddlebrown: [139, 69, 19, 1],
    salmon: [250, 128, 114, 1],
    sandybrown: [244, 164, 96, 1],
    seagreen: [46, 139, 87, 1],
    seashell: [255, 245, 238, 1],
    sienna: [160, 82, 45, 1],
    silver: [192, 192, 192, 1],
    skyblue: [135, 206, 235, 1],
    slateblue: [106, 90, 205, 1],
    slategray: [112, 128, 144, 1],
    slategrey: [112, 128, 144, 1],
    snow: [255, 250, 250, 1],
    springgreen: [0, 255, 127, 1],
    steelblue: [70, 130, 180, 1],
    tan: [210, 180, 140, 1],
    teal: [0, 128, 128, 1],
    thistle: [216, 191, 216, 1],
    tomato: [255, 99, 71, 1],
    turquoise: [64, 224, 208, 1],
    violet: [238, 130, 238, 1],
    wheat: [245, 222, 179, 1],
    white: [255, 255, 255, 1],
    whitesmoke: [245, 245, 245, 1],
    yellow: [255, 255, 0, 1],
    yellowgreen: [154, 205, 50, 1]
  };

  return Base_CssColorParser;

})();
// Generated by CoffeeScript 1.8.0
var Base_Layer;

Base_Layer = (function() {
  function Base_Layer(scene) {
    this.scene = scene;
    this.bounds = null;
  }

  Base_Layer.prototype.setBounds = function(left, top, right, bottom) {
    return this.bounds = new Base_Rect(left, top, right, bottom);
  };

  Base_Layer.prototype.doAnimations = function(event) {
    return 0;
  };

  Base_Layer.prototype.paint = function(event) {
    return 0;
  };

  Base_Layer.prototype.findObjectAt = function(displayX, displayY, tolerance) {
    return null;
  };

  return Base_Layer;

})();
// Generated by CoffeeScript 1.8.0
var PieChart_Renderer_Base;

PieChart_Renderer_Base = (function() {
  function PieChart_Renderer_Base(renderer) {
    this.renderer = renderer;
    this.settings = this.renderer.settings;
  }

  PieChart_Renderer_Base.prototype.paintPie = function(context, x, y, r0, r1, a0, a1, pie) {
    if (pie.fillColor) {
      context.beginPath();
      context.arc(x, y, r1, a0, a1, false);
      context.arc(x, y, r0, a1, a0, true);
      context.closePath();
      return Base_Graphics.fill(context, pie);
    }
  };

  PieChart_Renderer_Base.prototype.paintSlices = function(context, x, y, radius, innerRadius, slices) {
    throw "paintSlices not implemented";
  };

  PieChart_Renderer_Base.prototype.paintExpandableHilights = function(context, piex, piey, slices) {
    var distance, oa0, oa1, params, r, r0, r1, slice, x, y, _i, _len, _results;
    distance = this.settings.slice.expandableMarkStyle.distance;
    _results = [];
    for (_i = 0, _len = slices.length; _i < _len; _i++) {
      slice = slices[_i];
      if (!slice.expandable) {
        continue;
      }
      params = slice.renderParams;
      x = piex + slice.x;
      y = piey + slice.y;
      r0 = params[0];
      r1 = params[1];
      r = Math.max((r0 + r1) / 2, r1 - distance);
      oa0 = params[2];
      oa1 = params[3];
      context.beginPath();
      context.arc(x, y, r, oa0, oa1);
      _results.push(Base_Graphics.paint(context, this.settings.slice.expandableMarkStyle));
    }
    return _results;
  };

  PieChart_Renderer_Base.prototype.strokeSlice = function(context, x, y, slice) {

    /*
     * each slice has .renderParams field with:
     * 0 -> innerRadius (r0)
     * 1 -> outerRadius (r1)
     * 2 -> outerLeft - angle in radians
     * 3 -> outerRight - angle in radians
     * 4 -> innerLeft - angle in radians
     * 5 -> innerRight - angle in radians
     */
    var ia0, ia1, oa0, oa1, offset, params, perimeter, r0, r1, width;
    params = slice.renderParams;
    x = x + slice.x;
    y = y + slice.y;
    r0 = params[0], r1 = params[1], oa0 = params[2], oa1 = params[3], ia0 = params[4], ia1 = params[5];
    perimeter = r1 * Math.abs(oa1 - oa0);
    width = r1 - r0;
    offset = Math.min(0.1 * Math.min(perimeter, width), 3);
    if (r0 + r1 === -2) {
      r0 = 0;
      r1 = 0;
    }
    context.beginPath();
    if (slice.lineDecoration === "zigzag") {
      this.strokeZigZag(context, x, y, r1, offset, oa0, oa1);
    } else {
      context.arc(x, y, r1, oa0, oa1, false, true);
    }
    if (ia0 === ia1) {
      context.lineTo(x + Math.cos(ia1) * r0, y + Math.sin(ia0) * r0);
    } else {
      context.arc(x, y, r0, ia1, ia0, true);
    }
    return context.closePath();
  };

  PieChart_Renderer_Base.prototype.strokeZigZag = function(context, x, y, r, offset, a0, a1) {
    var a, da;
    da = 5 / r;
    a = a0;
    context.moveTo(x + r * Math.cos(a0), y + r * Math.sin(a0));
    while (a + da < a1) {
      a += da;
      context.lineTo(x + (r + offset) * Math.cos(a), y + (r + offset) * Math.sin(a));
      offset = -offset;
    }
    return context.lineTo(x + r * Math.cos(a1), y + r * Math.sin(a1));
  };

  PieChart_Renderer_Base.prototype.strokeAndPaint = function(g, x, y, slice) {
    var gr;
    gr = Base_Graphics.beginStrokeAndFill(g, slice);
    this.strokeSlice(gr, x, y, slice);
    return Base_Graphics.endStrokeAndFill(g, gr, slice);
  };

  return PieChart_Renderer_Base;

})();
// Generated by CoffeeScript 1.8.0
var Base_MonotoneCurve;

Base_MonotoneCurve = (function() {
  function Base_MonotoneCurve(x, y, n0, n1) {
    var deltai, deltai0, disti, i, m, mi, mi0, taui, _i, _ref, _ref1;
    if (n0 == null) {
      n0 = 0;
    }
    if (n1 == null) {
      n1 = x.length;
    }
    this.n0 = n0;
    m = [];
    m.length = n1 - n0;
    mi0 = 0;
    m[n1 - n0 - 1] = (y[n1 - 1] - y[n1 - 2]) / (x[n1 - 1] - x[n1 - 2]);
    deltai0 = (y[n0 + 1] - y[n0]) / (x[n0 + 1] - x[n0]);
    for (i = _i = _ref = n0 + 1, _ref1 = n1 - 1; _ref <= _ref1 ? _i < _ref1 : _i > _ref1; i = _ref <= _ref1 ? ++_i : --_i) {
      deltai = (y[i + 1] - y[i]) / (x[i + 1] - x[i]);
      if (deltai0 === 0) {
        mi0 = mi = 0;
      } else {
        mi = (deltai0 + deltai) / 2;
        disti = (mi0 * mi0 + mi * mi) / (deltai0 * deltai0);
        if (disti > 9) {
          taui = 3 / Math.sqrt(disti);
          mi0 = taui * mi0;
          mi = taui * mi;
        }
      }
      m[i - n0 - 1] = mi0;
      mi0 = mi;
      deltai0 = deltai;
    }
    m[i - n0 - 1] = mi0;
    this.x = x;
    this.y = y;
    this.m = m;
  }

  Base_MonotoneCurve.prototype.interpolate = function(i, x) {
    var h, h00, h01, h10, h11, t, t2, t3, y;
    h = this.x[i + 1] - this.x[i];
    t = (x - this.x[i]) / h;
    t2 = t * t;
    t3 = t2 * t;
    h00 = 2 * t3 - 3 * t2 + 1;
    h10 = t3 - 2 * t2 + t;
    h01 = -2 * t3 + 3 * t2;
    h11 = t3 - t2;
    y = h00 * this.y[i] + h10 * h * this.m[i - this.n0] + h01 * this.y[i + 1] + h11 * h * this.m[i - this.n0 + 1];
    return y;
  };

  Base_MonotoneCurve.prototype.interpolateArray = function(i, xarray, xfrom, xto, resultArray) {
    var h, h00, h01, h10, h11, invh, j, mi, mi1, t, t2, t3, xi, y, yi, yi1, _i;
    xi = this.x[i];
    yi = this.y[i];
    mi = this.m[i - this.n0];
    yi1 = this.y[i + 1];
    mi1 = this.m[i - this.n0 + 1];
    h = this.x[i + 1] - xi;
    invh = 1 / h;
    for (j = _i = xfrom; xfrom <= xto ? _i < xto : _i > xto; j = xfrom <= xto ? ++_i : --_i) {
      t = (xarray[j] - xi) * invh;
      t2 = t * t;
      t3 = t2 * t;
      h00 = 2 * t3 - 3 * t2 + 1;
      h10 = t3 - 2 * t2 + t;
      h01 = -2 * t3 + 3 * t2;
      h11 = t3 - t2;
      y = h00 * yi + h10 * h * mi + h01 * yi1 + h11 * h * mi1;
      resultArray.push(y);
    }
  };

  Base_MonotoneCurve.prototype.clear = function() {
    return this.m.length = 0;
  };

  return Base_MonotoneCurve;

})();
// Generated by CoffeeScript 1.8.0

/*
  retrieving and caching raw data
 */
var Netchart_Data,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

Netchart_Data = (function(_super) {
  __extends(Netchart_Data, _super);

  Netchart_Data.prototype.nextLinkId = 0;

  Netchart_Data.settings = {
    dataFunction: null,
    dataFunction_doc: {
      doc: "Load more chart data.",
      parameters: {
        "nodes": "loading nodes",
        "successFunc": "callback function to execute when data arrived correctly",
        "errorFunc": "callback function to execute when error occure while loading data."
      },
      returns: "Node data",
      type: "function"
    }
  };

  function Netchart_Data(chart, dataSettings) {
    this.chart = chart;
    this.dataSettings = dataSettings;
    Netchart_Data.__super__.constructor.call(this, chart, this.dataSettings);
    this.nodes = {};
    this.links = {};
    this.nodeToLinks = {};
    this.pendingNodes = {};
    this.requestedNodes = {};
    this.hasAllData = !this.hasDataFunc();
    this.pendingAllData = false;
    this.requestedAllData = false;
  }

  Netchart_Data.prototype.buildRequest = function() {
    var id, nodes, _, _ref;
    if (this.pendingAllData && !this.requestedAllData) {
      this.pendingNodes = {};
      this.requestedAllData = true;
      return {
        nodes: []
      };
    }
    if (!Base_Helpers.hasProperties(this.pendingNodes)) {
      return null;
    }
    nodes = [];
    _ref = this.pendingNodes;
    for (id in _ref) {
      _ = _ref[id];
      nodes.push(id);
      delete this.pendingNodes[id];
      this.requestedNodes[id] = true;
      if (nodes.length > this.dataSettings.requestMaxUnits) {
        break;
      }
    }
    return {
      nodes: nodes
    };
  };

  Netchart_Data.prototype.dataFunc = function(request, success, fail) {
    var config, params, r;
    config = this.dataSettings;
    if (config.dataFunction) {
      r = config.dataFunction(request.nodes || null, success, fail);
      if (r) {
        return r;
      } else {
        return true;
      }
    } else if (config.url) {
      params = [];
      if (request.nodes) {
        params.push(["nodes", request.nodes]);
      }
      Base_Data.doRequest(config.url, config, params, success, fail);
      return true;
    } else {
      return null;
    }
  };

  Netchart_Data.prototype.verifyData = function(request, data) {
    var allOk, hasLoadedRequestedNodes, hasResultsOnRequestedNodes, ids, key, n, obj, required, value, _i, _j, _k, _l, _len, _len1, _len2, _len3, _ref, _ref1, _ref2, _ref3;
    _ref = ["links", "nodes"];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      required = _ref[_i];
      if (!data.hasOwnProperty(required)) {
        data[required] = [];
      }
    }
    allOk = true;
    if (!Base_Helpers.isArray(data.nodes)) {
      obj = data.nodes;
      data.nodes = [];
      for (key in obj) {
        value = obj[key];
        value.id = key;
        data.nodes.push(value);
      }
    }
    if (!Base_Helpers.isArray(data.links)) {
      obj = data.links;
      data.links = [];
      for (key in obj) {
        value = obj[key];
        value.id = key;
        data.links.push(value);
      }
    }
    if (request) {
      this.chart.log("Got " + data.nodes.length + " data on  " + request.nodes);
    } else {
      this.chart.log("Got " + data.nodes.length + " data on all nodes");
    }
    hasResultsOnRequestedNodes = !(request && request.nodes.length > 0);
    hasLoadedRequestedNodes = !(request && request.nodes.length > 0 && data.nodes.length > 0);
    ids = {};
    _ref1 = data.nodes;
    for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
      n = _ref1[_j];
      if (ids.hasOwnProperty(n.id)) {
        this.chart.error("Data response: Multiple nodes with the same ID: " + n.id);
      }
      ids[n.id] = true;
      if (request && Base_Helpers.arrayContains(request.nodes, n.id)) {
        hasResultsOnRequestedNodes = true;
        hasLoadedRequestedNodes || (hasLoadedRequestedNodes = n.loaded);
      }
    }
    ids = {};
    _ref2 = data.links;
    for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
      n = _ref2[_k];
      if (n.hasOwnProperty("id") && ids.hasOwnProperty(n.id)) {
        this.chart.error("Data response: Multiple links with the same ID: " + n.id);
      }
      ids[n.id] = true;
    }
    if (!hasResultsOnRequestedNodes) {
      this.chart.error("Data response: Results set did not contain any of requested nodes: ", request.nodes);
      allOk = false;
    } else if (!hasLoadedRequestedNodes) {
      this.chart.error("Data response: loaded field was not set on any of the requested nodes, adding manually");
      _ref3 = data.nodes;
      for (_l = 0, _len3 = _ref3.length; _l < _len3; _l++) {
        n = _ref3[_l];
        if (Base_Helpers.arrayContains(request.nodes, n.id)) {
          n.loaded = true;
        }
      }
    }
    return allOk;
  };

  Netchart_Data.prototype.addVerifiedData = function(request, data) {
    var loaded, markLoaded, n, updatedLinks, updatedNodes, _i, _j, _k, _l, _len, _len1, _len2, _len3, _ref, _ref1, _ref2, _ref3;
    markLoaded = !this.hasDataFunc();
    loaded = {};
    this.updateGraph(data, markLoaded);
    _ref = data.nodes;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      n = _ref[_i];
      if (n.loaded) {
        loaded[n.id] = true;
        delete this.requestedNodes[n.id];
      }
      if (n.error) {
        delete this.requestedNodes[n.id];
        loaded[n.id] = true;
      }
    }
    if (request) {
      if (request.nodes.length === 0) {
        this.pendingNodes = {};
        this.hasAllData = true;
      } else {
        _ref1 = request.nodes;
        for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
          n = _ref1[_j];
          if (this.requestedNodes[n]) {
            this.pendingNodes[n] = true;
            delete this.requestedNodes[n];
          }
        }
      }
    }
    updatedNodes = {};
    updatedLinks = {};
    _ref2 = data.nodes;
    for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
      n = _ref2[_k];
      if (!this.isFilteredNode(n.id)) {
        updatedNodes[n.id] = n;
      }
    }
    _ref3 = data.links;
    for (_l = 0, _len3 = _ref3.length; _l < _len3; _l++) {
      n = _ref3[_l];
      updatedLinks[n.id] = true;
    }
    return {
      dataLoadedNodesIds: loaded,
      dataNodesIds: updatedNodes,
      dataLinksIds: updatedLinks
    };
  };

  Netchart_Data.prototype.requestTimeout = function(request) {
    return true;
  };

  Netchart_Data.prototype.requestFailedPermanently = function(request) {
    var id, nodes, _i, _len, _ref;
    if (request.nodes) {
      nodes = [];
      _ref = request.nodes;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        id = _ref[_i];
        nodes.push({
          id: id,
          error: "Bad response",
          loaded: true
        });
      }
      this.addVerifiedData(request, {
        nodes: nodes,
        links: []
      });
    }
    return this.chart.error("Failed data request, giving up on nodes: ", request.nodes);
  };

  Netchart_Data.prototype.removeData = function(data) {
    var l, link, linksToRemove, node, _i, _j, _k, _len, _len1, _len2, _ref, _ref1, _results;
    linksToRemove = [];
    if (data.nodes) {
      _ref = data.nodes;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        node = _ref[_i];
        this.removeNode(node.id, linksToRemove);
      }
    }
    if (data.links) {
      _ref1 = data.links;
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        link = _ref1[_j];
        l = this.links[link.id];
        if (l) {
          this.removeLink(l);
        }
      }
    }
    _results = [];
    for (_k = 0, _len2 = linksToRemove.length; _k < _len2; _k++) {
      link = linksToRemove[_k];
      _results.push(this.removeLink(link));
    }
    return _results;
  };

  Netchart_Data.prototype.exportData = function() {
    var id, l, links, n, nodes, _ref, _ref1;
    nodes = [];
    links = [];
    _ref = this.nodes;
    for (id in _ref) {
      n = _ref[id];
      nodes.push(n);
    }
    _ref1 = this.links;
    for (id in _ref1) {
      l = _ref1[id];
      links.push(l);
    }
    return {
      "nodes": nodes,
      "links": links
    };
  };

  Netchart_Data.prototype.applyPreloadedData = function() {
    if (this.dataSettings.randomNodes > 0) {
      return this.addData(this.genRandomGraph(this.dataSettings));
    } else {
      return Netchart_Data.__super__.applyPreloadedData.call(this);
    }
  };

  Netchart_Data.otherEnd = function(linkData, nodeId) {
    if (nodeId === linkData.from) {
      return linkData.to;
    }
    if (nodeId === linkData.to) {
      return linkData.from;
    }
    return null;
  };

  Netchart_Data.multiLinkId = function(linkData) {
    if (linkData.from < linkData.to) {
      return linkData.from + "#" + linkData.to;
    } else {
      return linkData.to + "#" + linkData.from;
    }
  };

  Netchart_Data.prototype.getNodeData = function(id) {
    if (this.nodes.hasOwnProperty(id)) {
      return this.nodes[id];
    } else {
      this.requestNodeData(id);
    }
    return null;
  };

  Netchart_Data.prototype.nodeRemoved = function(id) {
    delete this.pendingNodes[id];
    return delete this.requestedNodes[id];
  };

  Netchart_Data.prototype.getLinkData = function(id) {
    return this.links[id];
  };

  Netchart_Data.prototype.getNodeLinks = function(id) {
    if (this.nodes.hasOwnProperty(id) && this.nodes[id].loaded) {
      return this.applyLinkFilter(id);
    } else {
      this.requestNodeData(id);
    }
    return null;
  };

  Netchart_Data.prototype.getNodeCollectedLinks = function(id) {
    return this.applyLinkFilter(id);
  };

  Netchart_Data.prototype.getNodeLinksRaw = function(id) {
    return this.nodeToLinks[id];
  };

  Netchart_Data.prototype.isLoaded = function(id) {
    return this.nodes.hasOwnProperty(id) && this.nodes[id].loaded;
  };

  Netchart_Data.prototype.isFilteredNode = function(id) {
    var nodeData, nodeFilter;
    nodeFilter = this.settings.filters.nodeFilter;
    nodeData = this.nodes[id];
    if (!nodeFilter || !nodeData) {
      return false;
    }
    return !nodeFilter(nodeData, this.isLoaded(id) ? this.nodeToLinks[id] : null);
  };

  Netchart_Data.prototype.getNodes = function() {
    var id, nodeData, nodeFilter, result, _ref;
    nodeFilter = this.settings.filters.nodeFilter;
    if (!nodeFilter) {
      return this.nodes;
    }
    result = {};
    _ref = this.nodes;
    for (id in _ref) {
      nodeData = _ref[id];
      if (nodeFilter(nodeData, this.isLoaded(id) ? this.nodeToLinks[id] : null)) {
        result[id] = nodeData;
      }
    }
    return result;
  };

  Netchart_Data.prototype.applyLinkFilter = function(nodeId) {
    var d1, d2, filtered, id, l, link, linkFilter, links, multiId, multiIds, multiLinkProcessor, multiLists, nodeData, nodeFilter, nodeLinksProcessor, otherNodeData, otherNodeId, otherNodes, processedLinks, _i, _j, _k, _l, _len, _len1, _len2, _len3;
    nodeData = this.nodes[nodeId];
    links = this.nodeToLinks[nodeId];
    if (!(links && links.length > 0)) {
      return [];
    }
    linkFilter = this.settings.filters.linkFilter;
    nodeFilter = this.settings.filters.nodeFilter;
    nodeLinksProcessor = this.settings.filters.nodeLinksProcessor;
    multiLinkProcessor = this.settings.filters.multilinkProcessor;
    if (nodeFilter && !nodeFilter(nodeData, nodeData.loaded ? links : null)) {
      return [];
    }
    if (nodeFilter || linkFilter) {
      filtered = [];
      for (_i = 0, _len = links.length; _i < _len; _i++) {
        link = links[_i];
        otherNodeId = Netchart_Data.otherEnd(link, nodeId);
        otherNodeData = this.nodes[otherNodeId];
        if (linkFilter) {
          if (link.from === nodeId) {
            d1 = nodeData;
            d2 = otherNodeData;
          } else {
            d1 = otherNodeData;
            d2 = nodeData;
          }
          if (!linkFilter(link, d1, d2)) {
            continue;
          }
        }
        if (nodeFilter && !nodeFilter(otherNodeData, otherNodeData.loaded ? this.nodeToLinks[otherNodeId] : null)) {
          continue;
        }
        filtered.push(link);
      }
      links = filtered;
    }
    if (nodeLinksProcessor) {
      links = nodeLinksProcessor(nodeData, links);
    }
    if (multiLinkProcessor) {
      otherNodes = {};
      for (_j = 0, _len1 = links.length; _j < _len1; _j++) {
        link = links[_j];
        otherNodes[Netchart_Data.otherEnd(link, nodeId)] = true;
      }
      if (Base_Helpers.countProperties(otherNodes) < links.length) {
        filtered = [];
        multiIds = {};
        multiLists = {};
        for (_k = 0, _len2 = links.length; _k < _len2; _k++) {
          l = links[_k];
          multiId = Netchart_Data.multiLinkId(l);
          if (multiIds.hasOwnProperty(multiId)) {
            if (!multiLists.hasOwnProperty(multiId)) {
              multiLists[multiId] = [multiIds[multiId], l];
            } else {
              multiLists[multiId].push(l);
            }
          } else {
            multiIds[multiId] = l;
          }
        }
        for (_l = 0, _len3 = links.length; _l < _len3; _l++) {
          l = links[_l];
          multiId = Netchart_Data.multiLinkId(l);
          if (!multiLists.hasOwnProperty(multiId)) {
            filtered.push(l);
          }
        }
        for (id in multiLists) {
          links = multiLists[id];
          l = links[0];
          processedLinks = multiLinkProcessor(links, this.nodes[l.from], this.nodes[l.to]);
          if (Base_Helpers.isArray(processedLinks)) {
            filtered.concat(processedLinks);
          } else if (processedLinks) {
            filtered.push(processedLinks);
          }
        }
        links = filtered;
      }
    }
    return links;
  };

  Netchart_Data.prototype.requestAllNodes = function() {
    if (this.hasAllData) {
      return false;
    } else {
      if (!this.pendingAllData) {
        this.pendingAllData = true;
        this.scheduleRequests();
      }
      return true;
    }
  };

  Netchart_Data.prototype.requestNodeData = function(nodeId) {
    if (!this.hasDataFunc() || this.pendingNodes.hasOwnProperty(nodeId) || this.requestedNodes.hasOwnProperty(nodeId)) {
      return;
    }
    this.pendingNodes[nodeId] = true;
    return this.scheduleRequests();
  };

  Netchart_Data.prototype.updateGraph = function(data, markLoaded) {
    var n, orig, _i, _j, _len, _len1, _ref, _ref1;
    _ref = data.nodes;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      n = _ref[_i];
      n.id = n.id.toString();
      if (markLoaded) {
        n.loaded = true;
      }
      if (this.nodes.hasOwnProperty(n.id)) {
        if (!n.error && n.loaded) {
          delete this.nodes[n.id]["_noData"];
          Base_Helpers.extendDataItem(this.nodes[n.id], n);
        }
      } else {
        this.nodes[n.id] = n;
        this.nodeToLinks[n.id] = [];
      }
    }
    _ref1 = data.links;
    for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
      n = _ref1[_j];
      if (n.hasOwnProperty("id")) {
        n.id = n.id.toString();
      } else {
        n.id = "°" + this.nextLinkId;
        this.nextLinkId += 1;
      }
      if (this.links.hasOwnProperty(n.id)) {
        orig = this.links[n.id];
        if (n.hasOwnProperty("from")) {
          n.from = n.from.toString();
        }
        if (n.hasOwnProperty("to")) {
          n.to = n.to.toString();
        }
        if ((n.from && orig.from !== n.from) || (n.to && orig.to !== n.to)) {
          this.chart.error("Changing link from,to not supported");
        } else {
          Base_Helpers.extendDataItem(orig, n);
        }
      } else {
        if (!n.hasOwnProperty("from")) {
          this.chart.error("Link.from missing for link " + n.id);
          continue;
        } else {
          n.from = n.from.toString();
        }
        if (!n.hasOwnProperty("to")) {
          this.chart.error("Link.to missing for link " + n.id);
          continue;
        } else {
          n.to = n.to.toString();
        }
        if (!this.nodes.hasOwnProperty(n.from)) {
          this.nodes[n.from] = {
            id: n.from,
            _noData: true
          };
          this.nodeToLinks[n.from] = [];
          if (markLoaded) {
            this.nodes[n.from].loaded = true;
          }
        }
        if (!this.nodes.hasOwnProperty(n.to)) {
          this.nodes[n.to] = {
            id: n.to,
            _noData: true
          };
          this.nodeToLinks[n.to] = [];
          if (markLoaded) {
            this.nodes[n.to].loaded = true;
          }
        }
        this.links[n.id] = n;
        this.nodeToLinks[n.from].push(n);
        this.nodeToLinks[n.to].push(n);
      }
    }
  };

  Netchart_Data.prototype.removeNode = function(nodeId, linksToRemove) {
    var link, links, n, _i, _len, _results;
    this.chart.graph.removeNode(nodeId);
    delete this.pendingNodes[nodeId];
    delete this.requestedNodes[nodeId];
    n = this.nodes[nodeId];
    if (!n) {
      return;
    }
    delete this.nodes[nodeId];
    links = this.nodeToLinks[nodeId];
    if (links) {
      delete this.nodeToLinks[nodeId];
      _results = [];
      for (_i = 0, _len = links.length; _i < _len; _i++) {
        link = links[_i];
        _results.push(linksToRemove.push(link));
      }
      return _results;
    }
  };

  Netchart_Data.prototype.removeLink = function(link) {
    this.chart.graph.removeLink(link.id);
    delete this.links[link.id];
    if (this.nodeToLinks[link.from]) {
      Base_Helpers.removeFromArray(this.nodeToLinks[link.from], link);
    }
    if (this.nodeToLinks[link.to]) {
      return Base_Helpers.removeFromArray(this.nodeToLinks[link.to], link);
    }
  };

  Netchart_Data.prototype.genRandomGraph = function(settings) {
    var data, link, node, numLinks, numNodes, random, _i, _j, _len, _len1, _ref, _ref1;
    random = new Base_Random(32131);
    numNodes = settings.randomNodes;
    numLinks = settings.randomLinks;
    if (settings.random === "grid") {
      data = this.genRandomGrid(numNodes, settings.randomGridLinkProbability);
    } else if (settings.random === "tree") {
      data = this.genRandomTree(numNodes, settings.randomTreeDensity);
    } else {
      data = this.genRandomUniform(numNodes, numLinks);
    }
    _ref = data.nodes;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      node = _ref[_i];
      node.style = {
        label: "Node " + node.id
      };
      node.value = 10 + random.get() * 40;
    }
    _ref1 = data.links;
    for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
      link = _ref1[_j];
      link.style = {
        label: "Link " + link.id
      };
      link.value = 1 + random.get() * 5;
    }
    return data;
  };

  Netchart_Data.prototype.genRandomGrid = function(numNodes, linkProbability) {
    var gridSize, i, ind, l, links, n, nodes, random, x, y, _i, _j, _k, _l, _len, _ref, _ref1, _ref2;
    nodes = [];
    links = [];
    for (i = _i = 0, _ref = numNodes - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
      n = {
        id: "n" + i,
        loaded: true
      };
      nodes.push(n);
    }
    gridSize = Math.ceil(Math.sqrt(numNodes));
    random = new Base_Random(32131);
    for (y = _j = 0, _ref1 = gridSize - 1; _j <= _ref1; y = _j += 1) {
      for (x = _k = 0, _ref2 = gridSize - 1; _k <= _ref2; x = _k += 1) {
        ind = x + y * gridSize;
        if (ind >= numNodes) {
          continue;
        }
        if (x > 0 && random.get() <= linkProbability) {
          links.push({
            from: "n" + ind,
            to: "n" + (ind - 1)
          });
        }
        if (y > 0 && random.get() <= linkProbability) {
          links.push({
            from: "n" + ind,
            to: "n" + (ind - gridSize)
          });
        }
      }
    }
    for (ind = _l = 0, _len = links.length; _l < _len; ind = ++_l) {
      l = links[ind];
      l.id = "" + ind;
    }
    return {
      nodes: nodes,
      links: links
    };
  };

  Netchart_Data.prototype.genRandomUniform = function(numNodes, numLinks) {
    var i, l, links, n, nodes, random, _i, _j, _ref, _ref1;
    random = new Base_Random(32131);
    nodes = [];
    links = [];
    for (i = _i = 0; 0 <= numNodes ? _i < numNodes : _i > numNodes; i = 0 <= numNodes ? ++_i : --_i) {
      n = {
        id: "n" + i,
        loaded: true
      };
      if (nodes.length > 0) {
        l = {
          id: "l" + i,
          from: n.id,
          to: nodes[random.get() * nodes.length | 0].id
        };
        links.push(l);
      }
      nodes.push(n);
    }
    for (i = _j = _ref = links.length, _ref1 = numLinks - 1; _j <= _ref1; i = _j += 1) {
      l = {
        id: "l" + (i + 1),
        from: nodes[random.get() * nodes.length | 0].id,
        to: nodes[random.get() * nodes.length | 0].id
      };
      links.push(l);
    }
    return {
      nodes: nodes,
      links: links
    };
  };

  Netchart_Data.prototype.genRandomTree = function(numNodes, maxBranches) {
    var freeNodes, i, l, linkCount, links, nn, node, nodes, random, root, _i;
    random = new Base_Random(31927832);
    root = {
      id: "n0",
      loaded: true
    };
    freeNodes = [root];
    nodes = [root];
    links = [];
    while (nodes.length < numNodes) {
      node = random.getArrayIndex(freeNodes);
      Base_Helpers.removeFromArray(freeNodes, node);
      linkCount = Math.max(1, Math.ceil(random.get() * maxBranches));
      for (i = _i = 0; 0 <= linkCount ? _i < linkCount : _i > linkCount; i = 0 <= linkCount ? ++_i : --_i) {
        nn = {
          id: "n" + nodes.length,
          loaded: true
        };
        l = {
          id: "l" + nodes.length,
          from: node.id,
          to: nn.id
        };
        links.push(l);
        nodes.push(nn);
        freeNodes.push(nn);
      }
    }
    return {
      nodes: nodes,
      links: links
    };
  };

  return Netchart_Data;

})(Base_Data);
// Generated by CoffeeScript 1.8.0
var Base_TimeStep;

Base_TimeStep = (function() {
  "use strict";
  Base_TimeStep.parsingMap = {
    milliseconds: 'ms',
    millisecond: 'ms',
    second: 's',
    seconds: 's',
    minute: 'm',
    minutes: 'm',
    hour: 'h',
    hours: 'h',
    day: 'd',
    days: 'd',
    week: 'w',
    weeks: 'w',
    month: 'M',
    months: 'M',
    year: 'y',
    years: 'y',
    'ms': 'ms',
    's': 's',
    'm': 'm',
    'h': 'h',
    'd': 'd',
    'w': 'w',
    'M': 'M',
    'y': 'y'
  };

  Base_TimeStep.knownUnits = ['ms', 's', 'm', 'h', 'd', 'w', 'M', 'y'];

  Base_TimeStep.isGoodUnit = function(unit) {
    return Base_TimeStep.parsingMap[unit] != null;
  };

  Base_TimeStep.prototype.unit = "s";

  Base_TimeStep.prototype.count = 1;

  Base_TimeStep.prototype.name = null;

  function Base_TimeStep(unit, count) {
    this.unit = unit;
    this.count = count;
    this.name = "" + this.count + " " + this.unit;
  }

  Base_TimeStep.parse = function(input) {
    var count, l, name, s, unit, unitText;
    if (input == null) {
      return null;
    }
    if (input.unit != null) {
      name = input.name;
      unitText = input.unit;
    } else {
      unitText = input;
      name = input;
    }
    if (input.count != null) {
      count = input.count;
      unit = input.unit;
    } else {
      l = unitText.split(" ");
      if (l.length === 2) {
        count = parseInt(l[0], 10);
        unit = l[1];
      } else if (l.length === 1) {
        count = 1;
        unit = l[0];
      } else {
        return null;
      }
    }
    unit = Base_TimeStep.parsingMap[unit];
    if (typeof count !== "number" || !Base_TimeStep.isGoodUnit(unit)) {
      return null;
    }
    s = new Base_TimeStep(unit, count);
    s.name = name;
    return s;
  };

  Base_TimeStep.prototype.clone = function() {
    return new Base_TimeStep(this.unit, this.count);
  };

  Base_TimeStep.prototype.add = function(time, times) {
    if (times == null) {
      times = 1;
    }
    return moment(time).utc().add(this.count * times, this.unit).valueOf();
  };

  Base_TimeStep.prototype.sub = function(time, times) {
    if (times == null) {
      times = 1;
    }
    return moment(time).utc().subtract(this.count * times, this.unit).valueOf();
  };

  Base_TimeStep.prototype.numberOfUnits = function(from, to) {
    return Math.round(moment(to).utc().diff(from, Base_TimeStep.unitsTranslation[this.unit], true) / this.count);
  };

  Base_TimeStep.prototype.toString = function() {
    return "" + this.count + " " + this.unit;
  };

  Base_TimeStep.timeUnitDiffs = {
    "ms": 1,
    "s": 1000,
    "m": 60 * 1000,
    "h": 60 * 60 * 1000,
    "d": 24 * 60 * 60 * 1000,
    "w": 7 * 24 * 60 * 60 * 1000,
    "M": 30 * 24 * 60 * 60 * 1000,
    "y": 365 * 24 * 60 * 60 * 1000
  };

  Base_TimeStep.unitsTranslation = {
    s: "second",
    m: "minute",
    h: "hour",
    d: "day",
    w: "week",
    M: "month",
    y: "year"
  };

  Base_TimeStep.toBiggerUnit = {
    ms: "s",
    s: "m",
    m: "h",
    h: "d",
    d: "w",
    w: "M",
    M: "y",
    y: null
  };

  Base_TimeStep.toSmallerUnit = {
    ms: null,
    s: "ms",
    m: "s",
    h: "m",
    d: "h",
    w: "d",
    M: "d",
    y: "M"
  };

  Base_TimeStep.prototype.approxTime = function() {
    return Base_TimeStep.timeUnitDiffs[this.unit] * this.count;
  };

  Base_TimeStep.prototype.isSmallerOrEqual = function(bigger) {
    return this.approxTime() <= bigger.approxTime();
  };

  Base_TimeStep.prototype.isSmaller = function(bigger) {
    return this.approxTime() < bigger.approxTime();
  };

  Base_TimeStep.prototype.isBigger = function(smaller) {
    return this.approxTime() > smaller.approxTime();
  };

  Base_TimeStep.prototype.isEqual = function(step) {
    return this.approxTime() === step.approxTime();
  };

  Base_TimeStep.prototype.getBigger = function() {
    if (this.unit === "y") {
      return new Base_TimeStep(this.unit, this.count * 10);
    } else {
      return new Base_TimeStep(Base_TimeStep.toBiggerUnit[this.unit], 1);
    }
  };

  Base_TimeStep.prototype.roundTimeDown = function(t) {
    var times;
    t = Math.round(t);
    times = this.count;
    if (this.unit === "ms") {
      Math.floor(t / times) * times;
    }
    if (this.unit !== "ms") {
      t = moment(t).utc().startOf(Base_TimeStep.unitsTranslation[this.unit]);
    }
    if (this.unit === "y") {
      t.year(Math.floor(t.year() / times) * times);
    } else if (this.unit === "M") {
      t.month(Math.floor(t.month() / times) * times);
    } else if (this.unit === "w") {
      t.week(Math.floor(t.week() / times) * times);
    } else if (this.unit === "d") {
      t.date(Math.floor(t.date() / times) * times);
    } else if (this.unit === "h") {
      t.hours(Math.floor(t.hours() / times) * times);
    } else if (this.unit === "m") {
      t.minutes(Math.floor(t.minutes() / times) * times);
    } else if (this.unit === "s") {
      t.seconds(Math.floor(t.seconds() / times) * times);
    }
    return t.valueOf();
  };

  Base_TimeStep.prototype.roundTimeUp = function(time) {
    return this.roundTimeDown(moment(Math.round(time)).utc().add(this.count, this.unit).valueOf() - 1);
  };

  Base_TimeStep.prototype.roundTimeRound = function(time) {
    var t;
    t = moment(Math.round(time)).utc().add(this.count, this.unit);
    return this.roundTimeDown((t.valueOf() + time - 1) / 2);
  };

  return Base_TimeStep;

})();
// Generated by CoffeeScript 1.8.0

/*
  retrieving and caching raw data
 */
var Piechart_Data, Piechart_PieData,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

Piechart_PieData = (function() {
  function Piechart_PieData(id) {
    this.values = [];
    this.offset = 0;
    this.totalCount = null;
    this.total = 0;
    this.valuesSum = 0;
    this.beforeSum = 0;
    this.afterSum = 0;
    this.done = false;
  }

  Piechart_PieData.prototype.addData = function(values, offset, limit, before, after, sum, chart) {
    var len, v;
    len = values.length;
    if (this.values.length === 0) {
      this.offset = offset;
    }
    if (offset < this.offset) {
      if (offset + len < this.offset) {
        chart.error("Data cannot be merged");
        return;
      }
      while (offset < this.offset) {
        this.offset--;
        v = values[this.offset - offset];
        this.values.unshift(v);
        this.valuesSum += v.value;
        this.beforeSum -= v.value;
      }
    }
    if (offset + len > this.offset + this.values.length) {
      if (this.offset + this.values.length < offset) {
        chart.error("Data cannot be merged");
        return;
      }
      while (this.offset + this.values.length < offset + len) {
        v = values[this.offset + this.values.length - offset];
        this.values.push(v);
        this.valuesSum += v.value;
        this.afterSum -= v.value;
      }
    }
    if (!limit || values.length < limit) {
      this.done = true;
    }
    if (offset = 0) {
      this.beforeSum = 0;
    } else if (before) {
      this.beforeSum = parseFloat(before);
    } else {
      this.beforeSum = Math.max(0, this.beforeSum);
    }
    if (this.done) {
      this.afterSum = 0;
      this.totalCount = this.values.length + this.offset;
    } else if (after) {
      this.afterSum = parseFloat(after);
    } else {
      this.afterSum = Math.max(0, this.afterSum);
    }
    if (sum) {
      this.total = parseFloat(sum);
      if (!after && (this.beforeSum || this.offset === 0)) {
        this.afterSum = this.total - this.valuesSum - this.beforeSum;
      }
      if (!before && (this.afterSum || this.done)) {
        return this.beforeSum = this.total - this.valuesSum - this.afterSum;
      }
    } else {
      return this.total = this.beforeSum + this.valuesSum + this.afterSum;
    }
  };

  Piechart_PieData.prototype.markDone = function(id) {
    if (this.done) {
      return;
    }
    this.done = true;
    this.afterSum = 0;
    return this.totalCount = this.offset + this.values.length;
  };

  return Piechart_PieData;

})();

Piechart_Data = (function(_super) {
  __extends(Piechart_Data, _super);

  Piechart_Data.settings = {
    itemsToLoad: 50,
    itemsToLoad_doc: {
      doc: "Number of slices to request from server.",
      type: "integer"
    },
    partialLoad: true,
    partialLoad_doc: {
      doc: "Enables/Disables partial load. Items will be loaded on demand but is not compatible with sortField or autoCategories.",
      type: "bool"
    },
    autoCategories: null,
    autoCategories_doc: {
      doc: "An array of fields for auto-categorization. For each field a new drilldown sub-level will be created, separated by the values of that field.",
      type: "array",
      baseObject: "string"
    },
    sortField: null,
    sortField_doc: {
      doc: "If set, items will be sorted in descending order using values from this field.",
      type: "string"
    },
    dataFunction: null,
    dataFunction_doc: {
      doc: "Load more chart data.",
      parameters: {
        "id": "pie id",
        "limit": "max number of slices to load on pie",
        "offset": "number of slices to skip from start",
        "successFunc": "callback function to execute when data arrived correctly",
        "errorFunc": "callback function to execute when error occure while loading data"
      },
      returns: "Pie data.",
      type: "function"
    }
  };

  function Piechart_Data(chart, dataSettings) {
    var id, value, _ref;
    this.chart = chart;
    this.dataSettings = dataSettings;
    Piechart_Data.__super__.constructor.call(this, chart, dataSettings);
    this.pies = {};
    this.pendingPies = {};
    this.requestedPies = {};
    this.nextId = 0;
    this.applyPreloadedData();
    if (!this.hasDataFunc()) {
      _ref = this.pies;
      for (id in _ref) {
        value = _ref[id];
        value.markDone();
      }
      this.chart.scene.loading = false;
    }
  }

  Piechart_Data.prototype.getRootId = function() {
    if (Base_Helpers.isArray(this.settings.navigation.initialDrilldown)) {
      return this.settings.navigation.initialDrilldown[0];
    } else {
      return this.settings.navigation.initialDrilldown;
    }
  };

  Piechart_Data.prototype.canExpand = function(id) {
    return this.pies.hasOwnProperty(id) || (Base_Helpers.isString(id) && id[0] !== this.CS);
  };

  Piechart_Data.prototype.getPieData = function(id) {
    var data;
    if (!this.pies.hasOwnProperty(id)) {
      return null;
    }
    data = this.pies[id];
    if (this.needPostprocessing()) {
      data = this.filterAndSortData(data);
    }
    return data;
  };

  Piechart_Data.prototype.requestMorePieData = function(id, count) {
    if (count == null) {
      count = this.dataSettings.itemsToLoad;
    }
    if (!(this.pies.hasOwnProperty(id) && !this.pies[id].done)) {
      return false;
    }
    this.requestPieData(id, this.pies[id].offset + this.pies[id].values.length, count);
    return true;
  };

  Piechart_Data.prototype.requestLessPieData = function(id, count) {
    if (count == null) {
      count = this.dataSettings.itemsToLoad;
    }
    if (!(this.pies.hasOwnProperty(id) && !this.pies[id].done && this.pies[id].offset > 0)) {
      return false;
    }
    this.requestPieData(id, Math.max(this.pies[id].offset - this.dataSettings.itemsToLoad, 0), count);
    return true;
  };

  Piechart_Data.prototype.pieRemoved = function(id) {
    delete this.pendingPies[id];
    return delete this.requestedPies[id];
  };

  Piechart_Data.prototype.requestPieData = function(pieId, offset, count) {
    var data, end, newMax, newOffset, request, start;
    if (count == null) {
      count = this.dataSettings.itemsToLoad;
    }
    if (pieId[0] === this.CS) {
      throw "Invalid Id: " + pieId;
    }
    if (this.pies.hasOwnProperty(pieId)) {
      data = this.pies[pieId];
      start = data.offset;
      end = start + data.values.length;
      if (offset < start) {
        count = start - offset;
      } else if (offset + count > end) {
        count = offset + count - end;
        offset = end;
      } else {
        return;
      }
    } else if (this.needPostprocessing() || !this.dataSettings.partialLoad || this.settings.autoCategories) {
      count = 2147483647;
      offset = 0;
    }
    if (this.requestedPies.hasOwnProperty(pieId)) {
      return;
    }
    if (this.pendingPies.hasOwnProperty(pieId)) {
      request = this.pendingPies[pieId];
      newOffset = Math.min(request.offset, offset);
      newMax = Math.max(request.offset + request.count, offset + count);
      request.offset = newOffset;
      request.count = newMax - newOffset;
    } else if (this.dataFunc != null) {
      this.pendingPies[pieId] = {
        id: pieId,
        offset: offset,
        count: count
      };
      return this.scheduleRequests();
    }
  };

  Piechart_Data.prototype.autoCategorize = function(data, categoriesFields) {
    var baseCategory, catField, categories, categoriesList, category, collectedCategories, newCollectedCategories, prop, v, _i, _j, _k, _len, _len1, _len2, _ref;
    if (data.offset || data.afterSum > 0 || data.total > data.values.length) {
      this.chart.error("Cannot auto categorize partial data");
      return data;
    }
    if (!(categoriesFields.length > 0)) {
      return data;
    }
    data.subvalues = data.values;
    collectedCategories = [data];
    for (_i = 0, _len = categoriesFields.length; _i < _len; _i++) {
      catField = categoriesFields[_i];
      newCollectedCategories = [];
      for (_j = 0, _len1 = collectedCategories.length; _j < _len1; _j++) {
        baseCategory = collectedCategories[_j];
        categoriesList = [];
        categories = {};
        _ref = baseCategory.subvalues;
        for (_k = 0, _len2 = _ref.length; _k < _len2; _k++) {
          v = _ref[_k];
          if (Base_Helpers.isFunction(catField)) {
            prop = catField(v);
          } else {
            prop = v[catField];
          }
          if (prop === void 0 || prop === null) {
            prop = "None";
          } else {
            prop = prop.toString();
          }
          if (categories.hasOwnProperty(prop)) {
            category = categories[prop];
          } else {
            category = Base_Helpers.clone(v);
            delete category.id;
            category.subvalues = [];
            category.name = prop;
            category.__category = catField;
            category.value = 0;
            categories[prop] = category;
            categoriesList.push(category);
            newCollectedCategories.push(category);
          }
          category.subvalues.push(v);
          if (Base_Helpers.isNumber(v.value)) {
            category.value += parseFloat(v.value);
          }
        }
        baseCategory.subvalues = categoriesList;
      }
      collectedCategories = newCollectedCategories;
    }
    data.values = data.subvalues;
    delete data.subvalues;
    return data;
  };

  Piechart_Data.prototype.addDataInt = function(id, values, offset, limit, afterValue, beforeValue, sum, dataObj, newIds) {
    var builinKeys, key, pie, seenIds, v, val, _i, _len, _results;
    seenIds = {};
    for (_i = 0, _len = values.length; _i < _len; _i++) {
      v = values[_i];
      v.value = parseFloat(v.value);
      if (!v.id) {
        v.__id = this.CS + this.nextId;
        this.nextId++;
      } else {
        v.__id = "" + v.id;
        if (seenIds.hasOwnProperty(v.__id)) {
          this.chart.error("Data response: Multiple slices with the same ID: " + v.__id);
        }
        seenIds[v.__id] = true;
      }
      if (v.subvalues) {
        newIds[v.__id] = true;
        this.addDataInt(v.__id, v.subvalues, 0, Infinity, 0, 0, 0, null, newIds);
        this.markDone(v.__id);
      }
    }
    if (this.pies.hasOwnProperty(id)) {
      pie = this.pies[id];
    } else {
      pie = this.pies[id] = new Piechart_PieData(id);
    }
    pie.addData(values, offset, limit, afterValue, beforeValue, sum, this.chart);
    if (dataObj) {
      builinKeys = {
        "values": true,
        "id": true,
        "offset": true,
        "limit": true,
        "afterSum": true,
        "beforeSum": true,
        "subvalues": true,
        "sum": true
      };
      _results = [];
      for (key in dataObj) {
        val = dataObj[key];
        if (!builinKeys[key]) {
          _results.push(pie[key] = val);
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    }
  };

  Piechart_Data.prototype.markDone = function(id) {
    if (this.pies.hasOwnProperty(id)) {
      return this.pies[id].markDone();
    }
  };

  Piechart_Data.prototype.needPostprocessing = function() {
    return (this.chart.settings.filters.sliceFilter != null) || this.dataSettings.sortField;
  };

  Piechart_Data.prototype.filterAndSortData = function(pieData) {
    var f, filter, newData, slice, total, totalCount, values, _i, _len, _ref;
    filter = this.chart.settings.filters.sliceFilter;
    if (filter) {
      total = pieData.total || 0;
      totalCount = pieData.totalCount || 0;
      values = [];
      _ref = pieData.values;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        slice = _ref[_i];
        if (filter(slice)) {
          values.push(slice);
        } else {
          total -= slice.value;
          totalCount -= 1;
        }
      }
      newData = {
        values: values,
        done: pieData.done,
        beforeSum: pieData.beforeSum,
        afterSum: pieData.afterSum
      };
      if (pieData.total) {
        newData.total = total;
      }
      if (pieData.totalCount) {
        newData.totalCount = totalCount;
      }
      pieData = newData;
    }
    if (this.dataSettings.sortField) {
      f = this.dataSettings.sortField;
      pieData.values.sort(function(x, y) {
        return y[f] - x[f];
      });
    }
    return pieData;
  };


  /*  Base override methods
   */

  Piechart_Data.prototype.buildRequest = function() {
    var id, request, _ref;
    if (!Base_Helpers.hasProperties(this.pendingPies)) {
      return null;
    }
    _ref = Base_Helpers.removePropertyValue(this.pendingPies), id = _ref[0], request = _ref[1];
    this.requestedPies[id] = request;
    return request;
  };

  Piechart_Data.prototype.dataFunc = function(request, success, fail) {
    var config, params, r;
    config = this.dataSettings;
    if (config.dataFunction) {
      r = config.dataFunction(request.id, request.limit, request.offset, success, fail);
      if (r) {
        return r;
      } else {
        return true;
      }
    } else if (config.url) {
      params = [];
      if (request.id) {
        params.push(["id", request.id]);
      }
      params.push(["limit", request.limit]);
      params.push(["offset", request.offset]);
      Base_Data.doRequest(config.url, config, params, success, fail);
      return true;
    } else {
      return null;
    }
  };

  Piechart_Data.prototype.verifyData = function(request, data) {
    var allOk, id, required, _i, _len, _ref;
    id = data.id = data.hasOwnProperty("id") ? data.id : request ? request.id : this.getRootId();
    delete this.requestedPies[id];
    allOk = true;
    _ref = ["values"];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      required = _ref[_i];
      if (!data.hasOwnProperty(required)) {
        allOk = false;
        this.chart.error("Field " + required + " not set in data");
      }
    }
    if (data.hasOwnProperty("offset") && parseInt(data.offset) >= 0) {
      data.offset = parseInt(data.offset);
      if (request && request.offset !== data.offset) {
        allOk = false;
        this.chart.error("Response Offset " + data.offset + " does not match request offset: " + request.offset);
        this.markDone(id);
      }
    } else if (request) {
      data.offset = request.offset;
    } else {
      data.offset = 0;
    }
    data.limit = parseInt(data.limit) ? parseInt(data.limit) : null;
    return allOk;
  };

  Piechart_Data.prototype.addVerifiedData = function(request, data) {
    var id, newIds;
    this.chart.scene.loading = this.requests.length > 0;
    id = data.id;
    newIds = {};
    newIds[id] = true;
    if (request) {
      this.chart.log("Data arrived, id=" + id + ", offset=" + request.offset + ", len=" + data.values.length + " of " + (request.limit || 'unset'));
    } else {
      this.chart.log("Data arrived, id=" + id + ", offset=" + data.offset + ", len=" + data.values.length + " of " + (data.limit || 'unset'));
    }
    if (this.dataSettings.autoCategories) {
      data = this.autoCategorize(data, this.dataSettings.autoCategories);
    }
    this.addDataInt(id, data.values, data.offset, data.limit, data.afterSum, data.beforeSum, data.sum, data, newIds);
    return {
      dataArrived: true,
      dataArrivedIds: newIds
    };
  };

  Piechart_Data.prototype.requestTimeout = function(request) {
    this.chart.scene.loading = this.requests.length > 0;
    return delete this.requestedPies[request.id];
  };

  Piechart_Data.prototype.requestFailedPermanently = function(request) {
    var p;
    this.chart.scene.loading = this.requests.length > 0;
    if (request) {
      p = new Piechart_PieData(request.id);
      p.done = true;
      this.pies[request.id] = p;
      this.chart.error("Data request failed for pie: " + request.id);
      return delete this.requestedPies[request.id];
    } else {
      return this.chart.error("Data request failed");
    }
  };

  Piechart_Data.prototype.removeData = function(data) {
    return 1;
  };

  Piechart_Data.prototype.exportData = function() {
    return 1;
  };

  return Piechart_Data;

})(Base_Data);
// Generated by CoffeeScript 1.8.0
var Netchart_Layout_TimedSpringEmbedder;

Netchart_Layout_TimedSpringEmbedder = (function() {
  var SpringEdge, SpringNode;

  SpringEdge = (function() {
    function SpringEdge() {}

    SpringEdge.prototype.to = null;

    SpringEdge.prototype.K = 0;

    SpringEdge.prototype.len = 0;

    SpringEdge.prototype.strength = 0;

    return SpringEdge;

  })();

  SpringNode = (function() {
    function SpringNode() {}

    SpringNode.prototype.x = 0;

    SpringNode.prototype.y = 0;

    SpringNode.prototype.z = 0;

    SpringNode.prototype.r = 1;

    SpringNode.prototype.zattr = 1;

    SpringNode.prototype.repulsiveForceX = 0;

    SpringNode.prototype.repulsiveForceY = 0;

    SpringNode.prototype.repulsiveForceZ = 0;

    SpringNode.prototype.fsum = 0;

    SpringNode.prototype.edges = [];

    return SpringNode;

  })();

  Netchart_Layout_TimedSpringEmbedder.prototype.temperature = 0;

  Netchart_Layout_TimedSpringEmbedder.prototype.unitTemperature = 0;

  Netchart_Layout_TimedSpringEmbedder.prototype.randomLayoutRadius = 0;

  Netchart_Layout_TimedSpringEmbedder.prototype.repulsiveForceTree = null;

  Netchart_Layout_TimedSpringEmbedder.prototype.randomGenerator = null;

  Netchart_Layout_TimedSpringEmbedder.prototype.nodePermutation = null;

  Netchart_Layout_TimedSpringEmbedder.prototype.nodeRepulsionFactor = 15;

  Netchart_Layout_TimedSpringEmbedder.prototype.componentCenterFactor = 0.005;

  Netchart_Layout_TimedSpringEmbedder.prototype.linkForceFactor = 0.2;

  Netchart_Layout_TimedSpringEmbedder.prototype.zAxisAttraction = 1;

  Netchart_Layout_TimedSpringEmbedder.prototype.nodeDegreeModifier = 1.2;

  Netchart_Layout_TimedSpringEmbedder.prototype.forceReductionFactor = 1;

  Netchart_Layout_TimedSpringEmbedder.prototype.stability = 1;

  Netchart_Layout_TimedSpringEmbedder.prototype.globalForceX = 0;

  Netchart_Layout_TimedSpringEmbedder.prototype.globalForceY = 0;

  Netchart_Layout_TimedSpringEmbedder.prototype.centerX = 0;

  Netchart_Layout_TimedSpringEmbedder.prototype.centerY = 0;

  Netchart_Layout_TimedSpringEmbedder.prototype.aspectRatio = null;

  function Netchart_Layout_TimedSpringEmbedder(random) {
    this.random = random;
    this.nodeCount = 0;
    this.nodes = [];
    this.forceX = [];
    this.forceY = [];
    this.forceZ = [];
    this.forceSum = [];
    this.oldForceX = [];
    this.oldForceY = [];
    this.oldForceZ = [];
    this.componentX = [];
    this.componentY = [];
    this.componentSum = [];
    this.componentNodeCount = [];
    this.nodePermutation = [];
    this.nodesAspect = 1;
    this.idToIndex = {};
    this.repulsiveForceTree = new Netchart_Layout_BHTree();
  }

  Netchart_Layout_TimedSpringEmbedder.prototype.updateParams = function(spacing, nodeDegreeModifier, aspectRatio) {
    this.spacing = spacing;
    this.nodeDegreeModifier = nodeDegreeModifier;
    this.aspectRatio = aspectRatio;
  };

  Netchart_Layout_TimedSpringEmbedder.prototype.updateGraph = function(nodes, links, topologyChanges) {
    var desiredLen, desiredStrength, directionReverse, e, from, fsum, height, id, idx, lenSum, length, lengthProp, link, n, nn, node, nodesAspect, nodesAspectCount, oldIdToIndex, oldIdx, oldNode, oldNodes, oldOldForceX, oldOldForceY, oldOldForceZ, radSum, relevantEdgeCount, spacing, strength, sum, to, ton, vis, w, width, _i, _j, _k, _l, _len, _len1, _len2, _len3, _len4, _len5, _len6, _m, _n, _o, _ref, _ref1, _ref2, _ref3;
    topologyChanges |= nodes.length !== this.nodeCount;
    if (topologyChanges) {
      oldNodes = this.nodes;
      oldOldForceX = this.oldForceX;
      oldOldForceY = this.oldForceY;
      oldOldForceZ = this.oldForceZ;
      oldIdToIndex = this.idToIndex;
      this.nodeCount = nodes.length;
      this.oldForceX = new Array(this.nodeCount);
      this.oldForceY = new Array(this.nodeCount);
      this.oldForceZ = new Array(this.nodeCount);
      this.forceX = new Array(this.nodeCount);
      this.forceY = new Array(this.nodeCount);
      this.forceZ = new Array(this.nodeCount);
      this.forceSum = new Array(this.nodeCount);
      this.nodes = new Array(this.nodeCount);
      this.idToIndex = {};
      nodesAspect = 0;
      nodesAspectCount = 0;
      for (idx = _i = 0, _len = nodes.length; _i < _len; idx = ++_i) {
        n = nodes[idx];
        id = n.id;
        node = new SpringNode();
        node.edges = [];
        width = n.bRight - n.bLeft;
        height = n.bBottom - n.bTop;
        if (height > 0) {
          nodesAspect += height / width;
          nodesAspectCount += 1;
        }
        this.idToIndex[id] = idx;
        this.nodes[idx] = node;
        if (oldIdToIndex.hasOwnProperty(id)) {
          oldIdx = oldIdToIndex[id];
          oldNode = oldNodes[oldIdx];
          node.z = oldNode.z;
          this.oldForceX[idx] = oldOldForceX[oldIdx];
          this.oldForceY[idx] = oldOldForceY[oldIdx];
          this.oldForceZ[idx] = oldOldForceZ[oldIdx];
        } else {
          this.oldForceX[idx] = 0;
          this.oldForceY[idx] = 0;
          this.oldForceZ[idx] = 0;
        }
      }
      this.nodePermutation = this.nodes.slice(0);
      if (nodesAspectCount > 0) {
        this.nodesAspect = Math.max(0.3, nodesAspect / nodesAspectCount);
      } else {
        this.nodesAspect = 1;
      }
    }
    for (idx = _j = 0, _len1 = nodes.length; _j < _len1; idx = ++_j) {
      n = nodes[idx];
      width = n.bRight - n.bLeft;
      height = n.bBottom - n.bTop;
      nn = this.nodes[idx];
      nn.offsetX = n.bRight + n.bLeft;
      nn.offsetY = n.bTop + n.bBottom;
      nn.x = n.x + nn.offsetX;
      nn.y = n.y + nn.offsetY;
      nn.r = Math.max(1, width) * 0.5;
      nn.minr = Math.max(1, (height + width * 0.5) / 3);
      nn.zattr = n.visibility;
      nn.edges.length = 0;
      nn.locked = n.locked;
      this.forceX[idx] = 0;
      this.forceY[idx] = 0;
      this.forceZ[idx] = 0;
      this.forceSum[idx] = 0;
    }
    directionReverse = {
      "U": "D",
      "null": null,
      "D": "U",
      "L": "R",
      "R": "L"
    };
    for (_k = 0, _len2 = links.length; _k < _len2; _k++) {
      link = links[_k];
      strength = link.strength;
      length = link.length;
      vis = link.visibility;
      from = this.nodes[this.idToIndex[link.from.id]];
      to = this.nodes[this.idToIndex[link.to.id]];
      if (!from || !to) {
        console.log("Layout: missing node for link: " + link.from.id + " " + link.to.id + ", topology = " + topologyChanges);
        continue;
      }
      if (from === to) {
        continue;
      }
      from.edges.push({
        to: to,
        strength: strength,
        len: length,
        vis: vis,
        direction: link.direction
      });
      to.edges.push({
        to: from,
        strength: strength,
        len: length,
        vis: vis,
        direction: directionReverse[link.direction]
      });
    }
    if (topologyChanges) {
      this.computeComponents();
    }
    spacing = this.spacing / 2;
    _ref = this.nodes;
    for (_l = 0, _len3 = _ref.length; _l < _len3; _l++) {
      n = _ref[_l];
      sum = 0;
      _ref1 = n.edges;
      for (_m = 0, _len4 = _ref1.length; _m < _len4; _m++) {
        e = _ref1[_m];
        sum += e.to.edges.length * e.vis;
      }
      w = Math.sqrt(sum);
      n.r += spacing;
      n.minr += spacing;
      if (w > 4) {
        n.r += (w - 4) * n.r / 4 * this.nodeDegreeModifier;
        n.minr += (w - 4) * n.minr / 4 * this.nodeDegreeModifier;
      }
    }
    lenSum = 0;
    radSum = 0;
    relevantEdgeCount = 0;
    _ref2 = this.nodes;
    for (_n = 0, _len5 = _ref2.length; _n < _len5; _n++) {
      n = _ref2[_n];
      fsum = 0;
      _ref3 = n.edges;
      for (_o = 0, _len6 = _ref3.length; _o < _len6; _o++) {
        e = _ref3[_o];
        ton = e.to;
        if (n.locked && ton.locked || (n === ton)) {
          continue;
        }
        relevantEdgeCount++;
        desiredLen = n.minr + ton.minr;
        lengthProp = e.len;
        desiredStrength = Math.min(20, e.strength);
        e.len = Math.max(1, desiredLen * lengthProp);
        e.K = desiredStrength * 30 / e.len;
        fsum += e.K;
        lenSum += e.len;
      }
      n.fsum = fsum;
      radSum += n.r * n.r;
    }
    if (relevantEdgeCount > 0) {
      this.randomLayoutRadius = Math.max(1, lenSum / 10);
      return this.unitTemperature = lenSum / relevantEdgeCount / 50;
    } else {
      this.randomLayoutRadius = Math.max(1, Math.sqrt(radSum));
      return this.unitTemperature = 1;
    }
  };

  Netchart_Layout_TimedSpringEmbedder.prototype.computeComponents = function() {
    var component, componentNodes, e, end, n2, node, queue, start, _i, _j, _k, _len, _len1, _len2, _ref, _ref1, _ref2;
    this.componentX = [];
    this.componentY = [];
    this.componentSum = [];
    this.componentNodeCount = [];
    queue = new Array(this.nodeCount);
    _ref = this.nodes;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      node = _ref[_i];
      node.component = -1;
    }
    component = 0;
    _ref1 = this.nodes;
    for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
      node = _ref1[_j];
      if (node.component >= 0) {
        continue;
      }
      node.component = component;
      componentNodes = 0;
      start = 0;
      end = 0;
      queue[end] = node;
      end += 1;
      while (start < end) {
        node = queue[start];
        start += 1;
        componentNodes += 1;
        _ref2 = node.edges;
        for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
          e = _ref2[_k];
          n2 = e.to;
          if (n2.component === -1) {
            n2.component = component;
            queue[end] = n2;
            end += 1;
          }
        }
      }
      this.componentNodeCount.push(componentNodes);
      this.componentX.push(0);
      this.componentY.push(0);
      this.componentSum.push(0);
      component += 1;
    }
  };

  Netchart_Layout_TimedSpringEmbedder.prototype.updateComponents = function() {
    var i, node, _i, _j, _k, _len, _ref, _ref1, _ref2, _results;
    for (i = _i = 0, _ref = this.componentNodeCount.length - 1; _i <= _ref; i = _i += 1) {
      this.componentX[i] = 0;
      this.componentY[i] = 0;
      this.componentSum[i] = 0;
    }
    _ref1 = this.nodes;
    for (_j = 0, _len = _ref1.length; _j < _len; _j++) {
      node = _ref1[_j];
      i = node.component;
      this.componentX[i] += node.x * node.r;
      this.componentY[i] += node.y * node.r;
      this.componentSum[i] += node.r;
    }
    _results = [];
    for (i = _k = 0, _ref2 = this.componentNodeCount.length - 1; _k <= _ref2; i = _k += 1) {
      this.componentX[i] /= this.componentSum[i];
      _results.push(this.componentY[i] /= this.componentSum[i]);
    }
    return _results;
  };

  Netchart_Layout_TimedSpringEmbedder.prototype.globalLayout = function(nodes, timeout, resetPositions) {
    var i1, iter, node, numberOfMovingNodes, step, t0, _i, _len, _ref;
    if (this.nodeCount <= 0) {
      return;
    }
    if (resetPositions) {
      if (this.nodeCount === 1) {
        nodes[0].x = nodes[0].y = 0;
        return;
      } else {
        this.initialRandomLayout();
      }
    }
    numberOfMovingNodes = 0;
    _ref = this.nodes;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      node = _ref[_i];
      if (!node.locked) {
        numberOfMovingNodes++;
      }
    }
    step = Math.floor(Math.sqrt(numberOfMovingNodes) + 10);
    iter = step * 2;
    this.forceReductionFactor = 1;
    this.temperature = (Math.sqrt(numberOfMovingNodes) * 2 + 20) * this.unitTemperature;
    this.zAxisAttraction = 0.02;
    t0 = new Date().getTime();
    i1 = 3;
    while (this.temperature > this.unitTemperature) {
      if ((iter--) <= 0) {
        iter = step * 3 / (i1++);
        this.temperature = this.temperature / 1.5 - 0.5;
        if (this.temperature < 20 * this.unitTemperature) {
          this.zAxisAttraction = this.zAxisAttraction * 1.5 + 0.02;
        }
      }
      this.randomNodePermutation();
      this.repulsiveForceTree.temperature = this.zAxisAttraction * 1.75;
      this.repulsiveForceTree.buildTree(this.nodePermutation);
      this.moveNodesGlobal();
      if (new Date().getTime() > t0 + timeout) {
        break;
      }
    }
    if (resetPositions) {
      this.centerNodes();
    }
    return this.storeNodes(nodes);
  };

  Netchart_Layout_TimedSpringEmbedder.prototype.initialRandomLayout = function() {
    var R, coef, i, i1, n, perm, r, tmp, _i, _j, _k, _len, _ref, _ref1, _results;
    n = this.nodeCount;
    perm = new Array(n);
    for (i = _i = 0, _ref = n - 1; _i <= _ref; i = _i += 1) {
      perm[i] = i;
    }
    for (i = _j = 0; _j <= n; i = _j += 1) {
      i1 = Math.floor(this.random.get() * (n - i)) + i;
      tmp = perm[i];
      perm[i] = perm[i1];
      perm[i1] = tmp;
    }
    R = this.randomLayoutRadius;
    coef = 2 * Math.PI / this.nodeCount;
    _ref1 = this.nodes;
    _results = [];
    for (i = _k = 0, _len = _ref1.length; _k < _len; i = ++_k) {
      n = _ref1[i];
      this.oldForceX[i] = 0;
      this.oldForceY[i] = 0;
      this.oldForceZ[i] = 0;
      n.z = this.random.get() - 0.5;
      if (!n.locked) {
        r = R + n.r;
        n.x = r * Math.cos(perm[i] * coef);
        _results.push(n.y = r * Math.sin(perm[i] * coef));
      } else {
        _results.push(void 0);
      }
    }
    return _results;
  };

  Netchart_Layout_TimedSpringEmbedder.prototype.timedLayout = function(nodes, time) {
    var iter, x, _i, _ref;
    if (this.nodeCount <= 1 || !(time > 0)) {
      return;
    }
    iter = 0;
    if (time < 0.1) {
      iter = 2;
      this.forceReductionFactor = Math.max(0.002, Math.min(this.forceReductionFactor, time * 10));
    } else {
      iter = Math.min(6, Math.round(2 + time * 10));
    }
    this.zAxisAttraction = this.nodeRepulsionFactor / 28;
    this.temperature = this.unitTemperature;
    for (x = _i = 0, _ref = iter - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; x = 0 <= _ref ? ++_i : --_i) {
      this.randomNodePermutation();
      this.applyAspect(1 / this.nodesAspect);
      this.repulsiveForceTree.temperature = this.zAxisAttraction * 1.75;
      this.repulsiveForceTree.buildTree(this.nodePermutation);
      this.applyAspect(this.nodesAspect);
      this.moveNodesIncremental();
    }
    return this.storeNodes(nodes);
  };

  Netchart_Layout_TimedSpringEmbedder.prototype.prepareAspectRatio = function(fraction) {
    var cx, cy, i, incX, incY, invForce, n, ratio, scaleX, scaleY, side, sx, sy, x0, x1, y0, y1, _i, _ref;
    n = this.nodes;
    x0 = n[0].x;
    y0 = n[0].y;
    x1 = x0;
    y1 = y0;
    for (i = _i = 1, _ref = this.nodeCount - 1; _i <= _ref; i = _i += 1) {
      x0 = Math.min(x0, n[i].x);
      x1 = Math.max(x1, n[i].x);
      y0 = Math.min(y0, n[i].y);
      y1 = Math.max(y1, n[i].y);
    }
    cx = (x0 + x1) / 2;
    cy = (y0 + y1) / 2;
    sx = x1 - x0;
    sy = y1 - y0;
    ratio = Math.sqrt(this.aspectRatio);
    side = Math.sqrt(sx * sy);
    scaleX = side * ratio / sx;
    scaleY = side / ratio / sy;
    scaleX = fraction * scaleX + (1 - fraction);
    scaleY = fraction * scaleY + (1 - fraction);
    incX = cx - cx * scaleX;
    incY = cy - cy * scaleY;
    invForce = 1 / this.forceReductionFactor;
    return [scaleX, incX, scaleY, incY, invForce];
  };

  Netchart_Layout_TimedSpringEmbedder.prototype.updateAspectRatioNode = function(params, node, i) {
    this.forceX[i] += (node.x * (params[0] - 1) + params[1]) * params[4];
    return this.forceY[i] += (node.y * (params[2] - 1) + params[3]) * params[4];
  };

  Netchart_Layout_TimedSpringEmbedder.prototype.updateAspectRatio = function(fraction) {
    var i, n, node, params, _i, _ref, _results;
    params = this.prepareAspectRatio(fraction);
    n = this.nodes;
    _results = [];
    for (i = _i = 0, _ref = this.nodeCount - 1; _i <= _ref; i = _i += 1) {
      node = n[i];
      _results.push(this.updateAspectRatioNode(params, node, i));
    }
    return _results;
  };

  Netchart_Layout_TimedSpringEmbedder.prototype.moveNodesGlobal = function() {
    var aspectParams, forceFactor, fsum, fx, fy, fz, i, len, n1, randomness, _i, _ref, _results;
    this.initIteration();
    randomness = this.temperature * 0.5;
    forceFactor = this.forceReductionFactor;
    if (this.aspectRatio) {
      aspectParams = this.prepareAspectRatio(0.005);
    }
    _results = [];
    for (i = _i = 0, _ref = this.nodeCount - 1; _i <= _ref; i = _i += 1) {
      n1 = this.nodes[i];
      if (n1.locked) {
        continue;
      }
      this.calculateForce(i, 0.5);
      if (this.aspectRatio) {
        this.updateAspectRatioNode(aspectParams, n1, i);
      }
      this.oldForceX[i] = fx = this.forceX[i];
      this.oldForceY[i] = fy = this.forceY[i];
      this.oldForceZ[i] = fz = this.forceZ[i];
      fsum = this.forceSum[i];
      fx *= fsum;
      fy *= fsum;
      fz *= fsum;
      len = fx * fx + fy * fy + fz * fz;
      if (len < this.temperature * this.temperature && len > 0.001) {
        len = this.temperature / Math.sqrt(len);
        fx *= len;
        fy *= len;
        fz *= len;
      }
      n1.x += fx * forceFactor + (this.random.get() - 0.5) * randomness;
      n1.y += fy * forceFactor + (this.random.get() - 0.5) * randomness;
      _results.push(n1.z += fz * forceFactor + (this.random.get() - 0.5) * randomness);
    }
    return _results;
  };

  Netchart_Layout_TimedSpringEmbedder.prototype.moveNodesIncremental = function() {
    var cfx, cfy, curLen, dx, dy, dz, fraction, freezedNodes, fsum, i, len, movement, n1, oscilations, scal, ss, _i, _j, _k, _l, _ref, _ref1, _ref2, _ref3;
    this.initIteration();
    for (i = _i = 0, _ref = this.nodeCount - 1; _i <= _ref; i = _i += 1) {
      if (!this.nodes[i].locked) {
        this.calculateForce(i, 0);
      }
    }
    if (this.aspectRatio) {
      fraction = Math.min(0.4, 0.5 / Math.pow(this.nodeCount, 0.5));
      this.updateAspectRatio(fraction);
    }
    oscilations = 0;
    movement = 0;
    scal = 0;
    len = 0;
    freezedNodes = new Array(this.nodeCount);
    for (i = _j = 0, _ref1 = this.nodeCount - 1; _j <= _ref1; i = _j += 1) {
      if (this.nodes[i].locked) {
        continue;
      }
      dx = this.forceX[i];
      dy = this.forceY[i];
      dz = this.forceZ[i];
      fsum = this.forceSum[i];
      curLen = dx * dx + dy * dy + dz * dz;
      if (curLen * fsum * fsum > this.unitTemperature * this.unitTemperature * 0.05 * 0.05) {
        len += curLen;
        ss = this.oldForceX[i] * dx + this.oldForceY[i] * dy + this.oldForceZ[i] * dz;
        scal += ss;
        if (ss > 0) {
          movement += ss;
        } else {
          oscilations -= ss;
        }
      } else {
        freezedNodes[i] = true;
      }
    }
    this.stability = (movement - oscilations * 5) / this.nodeCount;
    if (scal > 1e-7) {
      this.forceReductionFactor *= 1 + 0.4 / 1.618033989;
    } else if (scal < -1e-7) {
      this.forceReductionFactor /= 1.4;
    }
    cfx = this.globalForceX / this.nodeCount;
    cfy = this.globalForceY / this.nodeCount;
    for (i = _k = 0, _ref2 = this.nodeCount - 1; _k <= _ref2; i = _k += 1) {
      this.forceX[i] += cfx;
      this.forceY[i] += cfy;
    }
    this.forceReductionFactor = Math.min(1, this.forceReductionFactor);
    this.forceReductionFactor = Math.max(0.002, this.forceReductionFactor);
    for (i = _l = 0, _ref3 = this.nodeCount - 1; _l <= _ref3; i = _l += 1) {
      n1 = this.nodes[i];
      if (!n1.locked && !freezedNodes[i]) {
        fsum = this.forceSum[i] * this.forceReductionFactor;
        n1.x += this.forceX[i] * fsum;
        n1.y += this.forceY[i] * fsum;
        n1.z += this.forceZ[i] * fsum;
      }
      this.oldForceX[i] = this.forceX[i];
      this.oldForceY[i] = this.forceY[i];
      this.oldForceZ[i] = this.forceZ[i];
    }
  };

  Netchart_Layout_TimedSpringEmbedder.prototype.initIteration = function() {
    var cx, cy, node, sum, _i, _len, _ref;
    cx = 0;
    cy = 0;
    sum = 0;
    _ref = this.nodes;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      node = _ref[_i];
      sum += node.r;
      cx += node.x * node.r;
      cy += node.y * node.r;
    }
    this.centerX = cx / sum;
    this.centerY = cy / sum;
    this.updateComponents();
    this.globalForceX = 0;
    return this.globalForceY = 0;
  };

  Netchart_Layout_TimedSpringEmbedder.prototype.applyAspect = function(aspect) {
    var node, _i, _len, _ref, _results;
    _ref = this.nodes;
    _results = [];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      node = _ref[_i];
      _results.push(node.y *= aspect);
    }
    return _results;
  };

  Netchart_Layout_TimedSpringEmbedder.prototype.calculateForce = function(nnum, fractionOfOld) {
    var cdx, cdy, cfx, cfy, component, csize, dx, dy, dz, e, edgeLen, f, kz, len, n1, n2, vx, vy, vz, _i, _len, _ref;
    n1 = this.nodes[nnum];
    dx = this.oldForceX[nnum] * fractionOfOld;
    dy = this.oldForceY[nnum] * fractionOfOld;
    dz = this.oldForceZ[nnum] * fractionOfOld;
    _ref = n1.edges;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      e = _ref[_i];
      n2 = e.to;
      edgeLen = e.len;
      vx = n1.x - n2.x;
      vy = n1.y - n2.y;
      vz = n1.z - n2.z;
      if (e.direction) {
        if (e.direction === "U") {
          vy -= edgeLen;
          edgeLen = 0;
        } else if (e.direction === "D") {
          vy += edgeLen;
          edgeLen = 0;
        } else if (e.direction === "L") {
          vx -= edgeLen;
          edgeLen = 0;
        } else if (e.direction === "R") {
          vx += edgeLen;
          edgeLen = 0;
        }
      }
      len = Math.sqrt(vx * vx + vy * vy + vz * vz);
      if (len < 0.01) {
        len = 0.01;
      }
      f = (edgeLen - len) * e.K / len * this.linkForceFactor;
      dx += f * vx;
      dy += f * vy;
      dz += f * vz;
    }
    dx += n1.repulsiveForceX * this.nodeRepulsionFactor;
    dy += n1.repulsiveForceY * this.nodeRepulsionFactor;
    dz += n1.repulsiveForceZ * this.nodeRepulsionFactor;
    kz = n1.zattr * this.zAxisAttraction;
    dz -= n1.z * kz;
    component = n1.component;
    cdx = this.componentX[component] - this.centerX;
    cdy = this.componentY[component] - this.centerY;
    csize = Math.min(10, Math.sqrt(this.componentNodeCount[component]));
    cfx = cdx * csize * this.componentCenterFactor;
    cfy = cdy * csize * this.componentCenterFactor;
    dx -= cfx;
    dy -= cfy;
    this.globalForceX += cfx;
    this.globalForceY += cfy;
    if (isNaN(dx)) {
      throw "Internal error: Nan in layout";
    }
    this.forceX[nnum] = dx;
    this.forceY[nnum] = dy;
    this.forceZ[nnum] = dz;
    return this.forceSum[nnum] = 1.0 / (n1.fsum + kz);
  };

  Netchart_Layout_TimedSpringEmbedder.prototype.storeNodes = function(nodes) {
    var i, ni, _i, _ref;
    for (i = _i = 0, _ref = this.nodeCount - 1; _i <= _ref; i = _i += 1) {
      ni = this.nodes[i];
      if (!ni.locked) {
        nodes[i].x = ni.x - ni.offsetX;
        nodes[i].y = ni.y - ni.offsetY;
      }
    }
  };

  Netchart_Layout_TimedSpringEmbedder.prototype.centerNodes = function() {
    var cx, cy, i, n, node, random, rr, x0, x1, y0, y1, _i, _j, _ref, _ref1, _results;
    random = new Base_Random(243178931);
    n = this.nodes;
    x0 = x1 = n[0].x;
    y0 = y1 = n[0].y;
    for (i = _i = 1, _ref = this.nodeCount - 1; _i <= _ref; i = _i += 1) {
      x0 = Math.min(x0, n[i].x);
      x1 = Math.max(x1, n[i].x);
      y0 = Math.min(y0, n[i].y);
      y1 = Math.max(y1, n[i].y);
    }
    cx = (x0 + x1) / 2;
    cy = (y0 + y1) / 2;
    _results = [];
    for (i = _j = 0, _ref1 = this.nodeCount - 1; _j <= _ref1; i = _j += 1) {
      node = n[i];
      node.x -= cx;
      node.y -= cy;
      if (!node.locked) {
        rr = node.r * 0.3;
        node.x += random.get() * rr;
        _results.push(node.y += random.get() * rr);
      } else {
        _results.push(void 0);
      }
    }
    return _results;
  };

  Netchart_Layout_TimedSpringEmbedder.prototype.randomNodePermutation = function() {
    var i, i1, tmp, _i, _ref;
    for (i = _i = 0, _ref = this.nodeCount - 1; _i <= _ref; i = _i += 1) {
      i1 = Math.floor(this.random.get() * (this.nodeCount - i)) + i;
      tmp = this.nodePermutation[i];
      this.nodePermutation[i] = this.nodePermutation[i1];
      this.nodePermutation[i1] = tmp;
    }
  };

  return Netchart_Layout_TimedSpringEmbedder;

})();
// Generated by CoffeeScript 1.8.0
var Base_Animator;

Base_Animator = (function() {
  "use strict";
  Base_Animator.prototype.formula = null;

  Base_Animator.prototype.startTime = null;

  Base_Animator.prototype.from = 0;

  Base_Animator.prototype.to = 0;

  Base_Animator.prototype.fromColor = null;

  Base_Animator.prototype.toColor = null;

  Base_Animator.prototype.t = 0;

  Base_Animator.prototype.startSpeed = 0;

  Base_Animator.prototype.easing_formulas = {
    "=": function(t) {
      return t;
    },
    "<>": function(t) {
      if (t < 0.5) {
        return 2 * t * t;
      } else {
        return -0.5 * ((t * 2 - 1) * (t * 2 - 3) - 1);
      }
    },
    "scroll": function(t) {
      return 1 - (1 - t) * (1 - t);
    }
  };

  function Base_Animator(from, to, duration, easing, startTime) {
    this.from = from;
    this.to = to;
    this.duration = duration;
    if (easing == null) {
      easing = "<>";
    }
    if (this.from === void 0 || this.from === null) {
      this.from = this.to;
    }
    this.startTime = startTime;
    this.x = this.from;
    this.t = this.startTime;
    if (!this.easing_formulas[easing]) {
      throw "Easing formula not defined: " + easing;
    } else {
      this.formula = this.easing_formulas[easing];
    }
  }

  Base_Animator.prototype.jump = function(to) {
    this.to = to;
    this.from = to;
    this.x = to;
    return this.t = this.startTime = 0;
  };

  Base_Animator.prototype.retarget = function(newTo, startTime) {
    if (this.finished(this.t)) {
      this.startSpeed = 0;
    } else {
      this.startSpeed = this._getSpeed();
    }
    if (startTime) {
      this.from = this.get(startTime);
      this.startTime = startTime;
    } else {
      this.startTime = this.t;
      this.from = this.x;
    }
    this.to = newTo;
    return this;
  };

  Base_Animator.prototype.retargetColor = function(newTo, startTime) {
    this.startSpeed = 0;
    this.from = this.x;
    this.to = newTo;
    this.fromColor = null;
    this.toColor = null;
    this.startTime = startTime;
    return this;
  };

  Base_Animator.prototype.switchCoordinates = function(trAdd, trMul) {
    this.from = this.from * trMul + trAdd;
    this.x = this.x * trMul + trAdd;
    this.to = this.to * trMul + trAdd;
    return this.startSpeed = this.startSpeed * trMul;
  };

  Base_Animator.prototype.updateAndGet = function(targetValue, time) {
    var changes;
    changes = this.x !== targetValue;
    if (targetValue !== this.to) {
      this.retarget(targetValue, time);
    }
    return [this.get(time), changes];
  };

  Base_Animator.prototype.updateAndGetFixed = function(targetValue, time) {
    var changes;
    changes = this.x !== targetValue;
    if (targetValue !== this.to) {
      this.startSpeed = 0;
      this.startTime = time;
      this.from = this.x;
      this.to = targetValue;
      this.fromColor = null;
      this.toColor = null;
    }
    return [this.get(time), changes];
  };

  Base_Animator.prototype.updateColorAndGet = function(targetValue, time) {
    var changes;
    changes = this.x !== targetValue;
    if (targetValue !== this.to) {
      this.retargetColor(targetValue, time);
    }
    return [this.getColor(time), changes];
  };

  Base_Animator.prototype.get = function(time) {
    var easingPerc, percentage, spx, xx;
    if (this.duration <= 0) {
      this.t = time;
      this.x = this.to;
      return this.to;
    }
    if (!this.startTime) {
      this.startTime = time;
    }
    percentage = Math.min(1, Math.max(time - this.startTime, 0) / this.duration);
    if (percentage >= 1) {
      this.t = 0;
      this.x = this.to;
      return this.to;
    }
    easingPerc = this.formula(percentage);
    xx = easingPerc * (this.to - this.from);
    if (this.startSpeed && percentage < 1) {
      spx = this.startSpeed * percentage * this.duration;
      xx = xx * easingPerc + spx * (1 - easingPerc);
    }
    xx = this.from + xx;
    this.t = time;
    this.x = xx;
    return xx;
  };

  Base_Animator.prototype.getColor = function(time) {
    var fa, fb, fg, fr, p0, p1, percentage, ta, tb, tg, tr, xx, _ref, _ref1;
    this.t = time;
    if (this.duration <= 0 || this.from === this.to) {
      return this.to;
    }
    if (!this.startTime) {
      this.startTime = time;
    }
    if (this.fromColor == null) {
      this.fromColor = Base_CssColorParser.parseCSSColor(this.from);
    }
    if (this.toColor == null) {
      this.toColor = Base_CssColorParser.parseCSSColor(this.to);
    }
    percentage = Math.min(1, Math.max(time - this.startTime, 0) / this.duration);
    p1 = this.formula(percentage);
    p0 = 1 - p1;
    _ref = this.fromColor, fr = _ref[0], fg = _ref[1], fb = _ref[2], fa = _ref[3];
    _ref1 = this.toColor, tr = _ref1[0], tg = _ref1[1], tb = _ref1[2], ta = _ref1[3];
    xx = "rgba(" + (Math.round(fr * p0 + tr * p1)) + "," + (Math.round(fg * p0 + tg * p1)) + "," + (Math.round(fb * p0 + tb * p1)) + "," + ((fa * p0 + ta * p1).toFixed(3)) + ")";
    this.t = time;
    this.x = xx;
    return xx;
  };

  Base_Animator.prototype.finished = function(time) {
    if (!this.startTime) {
      this.startTime = time;
    }
    return time >= this.startTime + this.duration;
  };

  Base_Animator.prototype._getSpeed = function() {
    var d, p0, p1, time;
    time = this.t;
    d = this.duration / 1000;
    p0 = this.get(time - d / 2);
    p1 = this.get(time + d / 2);
    this.t = time;
    return (p1 - p0) / d;
  };

  return Base_Animator;

})();
// Generated by CoffeeScript 1.8.0
var Base_Graphics, Base_Graphics_DashedLineContext;

Base_Graphics_DashedLineContext = (function() {
  function Base_Graphics_DashedLineContext(g, lineDash, fill) {
    this.g = g;
    this.lineDash = lineDash;
    this.fill = fill;
    this.beginPath();
  }

  Base_Graphics_DashedLineContext.prototype.beginPath = function() {
    this.remaining = this.lineDash[0];
    this.dashes = [];
    this.pos = 0;
    this.x0 = 0;
    this.y0 = 0;
    this.x = 0;
    this.y = 0;
    return this.hasPos = false;
  };

  Base_Graphics_DashedLineContext.prototype.moveTo = function(x, y) {
    this.x = x;
    this.y = y;
    if (this.fill) {
      this.dashes.push(0, x, y);
    }
    this.g.moveTo(x, y);
    this.x0 = x;
    this.y0 = y;
    return this.hasPos = true;
  };

  Base_Graphics_DashedLineContext.prototype.lineTo = function(xx, yy) {
    var dashLen, dashPos, dashRemaining, dlen, dx, dy, invLen, len, x, y;
    if (this.fill) {
      this.g.lineTo(xx, yy);
    }
    dx = xx - this.x;
    dy = yy - this.y;
    x = this.x;
    y = this.y;
    this.x = xx;
    this.y = yy;
    len = Math.sqrt(dx * dx + dy * dy);
    invLen = 1 / len;
    dx *= invLen;
    dy *= invLen;
    dashLen = this.lineDash.length;
    dashPos = this.pos;
    dashRemaining = this.remaining;
    while (true) {
      dlen = Math.min(len, dashRemaining);
      x += dx * dlen;
      y += dy * dlen;
      if (dashPos % 2 === 0) {
        if (this.fill) {
          this.dashes.push(1, x, y);
        } else {
          this.g.lineTo(x, y);
        }
      } else {
        if (this.fill) {
          this.dashes.push(0, x, y);
        } else {
          this.g.moveTo(x, y);
        }
      }
      if (len > dlen) {
        dashPos = (dashPos + 1) % dashLen;
        dashRemaining = this.lineDash[dashPos];
        len -= dlen;
      } else {
        dashRemaining -= dlen;
        break;
      }
    }
    this.pos = dashPos;
    this.remaining = dashRemaining;
    return this.hasPos = true;
  };

  Base_Graphics_DashedLineContext.prototype.arc = function(centerX, centerY, radius, angleFrom, angleTo, counterClockwise) {
    var PI2, c, d, da, i, s, x, xp, xt, y, yp, yt, _i, _j, _results, _results1;
    PI2 = Math.PI * 2;
    da = Math.min(0.6, 2 / radius);
    c = Math.cos(da);
    s = Math.sin(da);
    y = Math.sin(angleFrom) * radius;
    x = Math.cos(angleFrom) * radius;
    yt = Math.sin(angleTo) * radius;
    xt = Math.cos(angleTo) * radius;
    if (!this.hasPos) {
      this.moveTo(centerX + x, centerY + y);
      this.hasPos = true;
    }
    if (counterClockwise) {
      if (angleFrom < angleTo) {
        angleFrom += PI2;
      }
      d = (angleFrom - angleTo) / da;
      _results = [];
      for (i = _i = d; _i >= 0; i = _i += -1) {
        if (i - 1 <= 0) {
          this.lineTo(centerX + xt, centerY + yt);
          break;
        }
        this.lineTo(centerX + x, centerY + y);
        xp = x * c + y * s;
        yp = -x * s + y * c;
        x = xp;
        _results.push(y = yp);
      }
      return _results;
    } else {
      if (angleFrom > angleTo) {
        angleFrom -= 2 * Math.PI;
      }
      d = (angleTo - angleFrom) / da;
      _results1 = [];
      for (i = _j = d; _j >= 0; i = _j += -1) {
        if (i - 1 <= 0) {
          this.lineTo(centerX + xt, centerY + yt);
          break;
        }
        this.lineTo(centerX + x, centerY + y);
        xp = x * c - y * s;
        yp = x * s + y * c;
        x = xp;
        _results1.push(y = yp);
      }
      return _results1;
    }
  };

  Base_Graphics_DashedLineContext.prototype.closePath = function() {
    return this.lineTo(this.x0, this.y0);
  };

  Base_Graphics_DashedLineContext.prototype.strokeDashes = function() {
    var d, i, m, x, y, _i, _ref, _results;
    d = this.dashes;
    _results = [];
    for (i = _i = 0, _ref = d.length; _i < _ref; i = _i += 3) {
      m = d[i];
      x = d[i + 1];
      y = d[i + 2];
      if (m === 0) {
        _results.push(this.g.moveTo(x, y));
      } else {
        _results.push(this.g.lineTo(x, y));
      }
    }
    return _results;
  };

  return Base_Graphics_DashedLineContext;

})();

Base_Graphics = (function() {
  function Base_Graphics() {}

  Base_Graphics.setLineDash = 1;

  Base_Graphics.SQRT3D6 = Math.sqrt(3) / 6;

  "use strict";

  Base_Graphics.stroke = function(g, st) {
    if (st.lineWidth) {
      g.lineWidth = st.lineWidth;
    }
    g.strokeStyle = st.lineColor;
    if (st.lineDash && typeof g.setLineDash !== 'undefined') {
      g.setLineDash(st.lineDash);
      g.stroke();
      g.setLineDash([]);
    } else {
      g.stroke();
    }
    if (st.lineWidth) {
      return g.lineWidth = 1;
    }
  };

  Base_Graphics.strokeWithShadow = function(g, st) {
    if (st.shadowColor) {
      g.shadowOffsetX = st.shadowOffsetX;
      g.shadowOffsetY = st.shadowOffsetY;
      g.shadowBlur = st.shadowBlur;
      g.shadowColor = st.shadowColor;
    }
    if (st.lineWidth) {
      g.lineWidth = st.lineWidth;
    }
    g.strokeStyle = st.lineColor;
    g.stroke();
    if (st.lineWidth) {
      g.lineWidth = 1;
    }
    if (st.shadowColor) {
      g.shadowBlur = 0;
      return g.shadowColor = "transparent";
    }
  };

  Base_Graphics.beginStroke = function(g, style, fill) {
    if (fill == null) {
      fill = false;
    }
    g.beginPath();
    if (style.lineColor && style.lineDash && style.lineDash.length > 1 && typeof g.setLineDash === 'undefined') {
      if (fill && !style.fillColor) {
        fill = false;
      }
      return new Base_Graphics_DashedLineContext(g, style.lineDash, fill);
    } else {
      return g;
    }
  };

  Base_Graphics.endStroke = function(g, strokeContext, style, fill) {
    if (fill == null) {
      fill = false;
    }
    if (g === strokeContext) {
      if (fill) {
        return Base_Graphics.paint(g, style);
      } else {
        return Base_Graphics.stroke(g, style);
      }
    } else {
      if (strokeContext.fill) {
        Base_Graphics.fill(g, style);
        g.beginPath();
        strokeContext.strokeDashes();
      }
      return Base_Graphics.strokeWithShadow(g, style);
    }
  };

  Base_Graphics.beginStrokeAndFill = function(g, style) {
    return this.beginStroke(g, style, true);
  };

  Base_Graphics.endStrokeAndFill = function(g, strokeContext, style) {
    return this.endStroke(g, strokeContext, style, true);
  };

  Base_Graphics.fill = function(g, st) {
    if (!st.fillColor) {
      return;
    }
    g.fillStyle = st.fillColor;
    if (st.shadowColor) {
      g.shadowOffsetX = st.shadowOffsetX;
      g.shadowOffsetY = st.shadowOffsetY;
      g.shadowBlur = st.shadowBlur;
      g.shadowColor = st.shadowColor;
    }
    g.fill();
    if (st.shadowColor) {
      g.shadowBlur = 0;
      return g.shadowColor = "transparent";
    }
  };

  Base_Graphics.fillGradient = function(g, st, x0, y0, x1, y1) {
    var grad, s, step, _i, _len, _ref;
    if (st.fillGradient) {
      grad = g.createLinearGradient(x0, y0, x1, y1);
      _ref = st.fillGradient;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        step = _ref[_i];
        grad.addColorStop(step[0], step[1]);
      }
      s = st.fillColor;
      st.fillColor = grad;
      this.fill(g, st);
      return st.fillColor = s;
    } else {
      return this.fill(g, st);
    }
  };

  Base_Graphics.paint = function(g, st) {
    if (st.shadowColor) {
      g.shadowOffsetX = st.shadowOffsetX;
      g.shadowOffsetY = st.shadowOffsetY;
      g.shadowBlur = st.shadowBlur;
      g.shadowColor = st.shadowColor;
    }
    if (st.fillColor) {
      g.fillStyle = st.fillColor;
      g.fill();
    }
    if (st.lineColor) {
      g.lineWidth = st.lineWidth ? st.lineWidth : 1;
      g.strokeStyle = st.lineColor;
      if (st.lineDash) {
        g.setLineDash(st.lineDash);
        g.stroke();
        g.setLineDash([]);
      } else {
        g.stroke();
      }
    }
    if (st.shadowColor) {
      g.shadowBlur = 0;
      return g.shadowColor = "transparent";
    }
  };

  Base_Graphics.textStyle = function(g, st) {
    if (st.fillColor) {
      g.fillStyle = st.fillColor;
    }
    if (st.font) {
      g.font = st.font;
    }
    if (st["shadowColor"]) {
      g.shadowOffsetX = st.shadowOffsetX;
      g.shadowOffsetY = st.shadowOffsetY;
      g.shadowBlur = st.shadowBlur;
      return g.shadowColor = st.shadowColor;
    }
  };

  Base_Graphics.textStyleNoShadow = function(g, st) {
    if (st.fillColor) {
      g.fillStyle = st.fillColor;
    }
    if (st.font) {
      return g.font = st.font;
    }
  };

  Base_Graphics.rectStyle = function(g, st) {
    if (st.hasOwnProperty("lineColor")) {
      g.strokeStyle = st.lineColor;
    }
    if (st.hasOwnProperty("fillColor")) {
      g.fillStyle = st.fillColor;
    }
    if (st.hasOwnProperty("lineWidth")) {
      return g.lineWidth = st.lineWidth;
    }
  };

  Base_Graphics.pushClip = function(g, x, y, w, h) {
    g.save();
    g.beginPath();
    g.rect(x, y, w, h);
    return g.clip();
  };

  Base_Graphics.popClip = function(g) {
    return g.restore();
  };

  Base_Graphics.arcBetweenTwoPoints = function(g, x, y, r, x0, y0, x1, y1) {
    var a1, a2, counterclockwise, d, d1, d2, len, lenSq, mx, my, px, py, xa, xb, ya, yb;
    mx = (x0 + x1) / 2;
    my = (y0 + y1) / 2;
    px = y1 - y0;
    py = x0 - x1;
    lenSq = px * px + py * py;
    if (lenSq === 0) {
      return;
    }
    len = Math.sqrt(lenSq);
    r = Math.min(Math.max(r, len / 2), len * 3);
    d = Math.sqrt(r * r / lenSq - 0.25);
    xa = mx + px * d;
    ya = my + py * d;
    xb = mx - px * d;
    yb = my - py * d;
    d1 = (xa - x) * (xa - x) + (ya - y) * (ya - y);
    d2 = (xb - x) * (xb - x) + (yb - y) * (yb - y);
    if (d1 > d2) {
      x = xb;
      y = yb;
    } else {
      x = xa;
      y = ya;
    }
    a1 = Math.atan2(y0 - y, x0 - x);
    a2 = Math.atan2(y1 - y, x1 - x);
    if (a2 < a1) {
      a2 += Math.PI * 2;
    }
    counterclockwise = Math.abs(a1 - a2) > Math.PI;
    return g.arc(x, y, r, a1, a2, counterclockwise);
  };

  Base_Graphics.strokeMarker = function(g, shape, x, y, r) {
    var addFromCenter, d2;
    d2 = r * 1.41421356237;
    addFromCenter = this.SQRT3D6 * (r * 3);
    if (shape === "rect") {
      g.moveTo(x - r, y - r);
      g.lineTo(x + r, y - r);
      g.lineTo(x + r, y + r);
      g.lineTo(x - r, y + r);
      return g.closePath();
    } else if (shape === "romb") {
      d2 = d2 * .9;
      g.moveTo(x - d2, y);
      g.lineTo(x, y - d2);
      g.lineTo(x + d2, y);
      g.lineTo(x, y + d2);
      g.closePath();
      return g.fill();
    } else if (shape === "triangle") {
      g.beginPath();
      g.moveTo(x - r, y + addFromCenter);
      g.lineTo(x + r, y + addFromCenter);
      g.lineTo(x, y - addFromCenter);
      g.closePath();
      return g.fill();
    } else if (shape === "triangle2") {
      g.beginPath();
      g.moveTo(x - d2, y - d2);
      g.lineTo(x + d2, y - d2);
      g.lineTo(x, y + d2);
      g.closePath();
      return g.fill();
    } else if (shape === "circle") {
      g.beginPath();
      g.arc(x, y, r, 0, Math.PI * 2, true);
      return g.closePath();
    } else {
      throw "unknown marker shape " + shape;
    }
  };

  Base_Graphics.strokeBalloon = function(g, x0, y0, w, h) {
    var m, r, s, x, y;
    w = Math.max(w, h * 2);
    m = 5;
    s = 4;
    r = (h + s * 2) / 2;
    x = x0;
    y = y0;
    g.moveTo(x, y);
    x += m;
    y += m;
    g.lineTo(x, y);
    x += w / 2 - s - m;
    g.lineTo(x, y);
    g.arc(x, y + r, r, -Math.PI / 2, Math.PI / 2);
    y += r * 2;
    x -= w - 2 * s;
    g.lineTo(x, y);
    g.arc(x, y - r, r, Math.PI * 0.5, Math.PI * 1.5);
    y -= r * 2;
    x += w / 2 - s - m;
    g.lineTo(x, y);
    x += m;
    y -= m;
    g.closePath();
    return y0 + m + r;
  };

  Base_Graphics.strokeBalloon2 = function(g, x0, y0, w, h) {
    var r, s, x, y;
    s = 4;
    r = (h + s * 2) / 2;
    w = Math.max(w, h * 2) / 2 - s;
    x = x0 + w;
    y = y0 - r;
    g.moveTo(x, y);
    g.arc(x, y + r, r, -Math.PI / 2, Math.PI / 2, false);
    y += r * 2;
    x -= w * 2;
    g.lineTo(x, y);
    g.arc(x, y - r, r, Math.PI * 0.5, Math.PI * 1.5, false);
    return g.closePath();
  };

  Base_Graphics.applyColorToImage = function(image, color, ignoreTransparent) {
    var a, b, c, cData, data, g, gr, h, i, r, w, _i, _j, _ref, _ref1, _ref2;
    if (ignoreTransparent == null) {
      ignoreTransparent = true;
    }
    _ref = Base_Graphics.parseColor(color), r = _ref[0], g = _ref[1], b = _ref[2], a = _ref[3];
    c = document.createElement("canvas");
    w = c.width = image.width;
    h = c.height = image.height;
    gr = c.getContext("2d");
    gr.drawImage(image, 0, 0);
    cData = gr.getImageData(0, 0, w, h);
    data = cData.data;
    if (ignoreTransparent) {
      for (i = _i = 0, _ref1 = data.length; _i <= _ref1; i = _i += 4) {
        if (data[i + 3] !== 255) {
          continue;
        }
        data[i] = (data[i] * r) >> 8;
        data[i + 1] = (data[i + 1] * g) >> 8;
        data[i + 2] = (data[i + 2] * b) >> 8;
      }
    } else {
      for (i = _j = 0, _ref2 = data.length; _j <= _ref2; i = _j += 4) {
        data[i] = (data[i] * r) >> 8;
        data[i + 1] = (data[i + 1] * g) >> 8;
        data[i + 2] = (data[i + 2] * b) >> 8;
      }
    }
    gr.putImageData(cData, 0, 0);
    return c;
  };

  Base_Graphics.cropImageToCircle = function(image, mode) {
    var canvas, g, h, maxSize, minSize, old, r, scale, size, w;
    minSize = Math.min(image.width, image.height);
    maxSize = Math.max(image.width, image.height);
    size = Math.min(maxSize, minSize * 2);
    canvas = document.createElement("canvas");
    canvas.width = size;
    canvas.height = size;
    g = canvas.getContext("2d");
    w = image.width;
    h = image.height;
    g.fillStyle = 'rgba(0,0,0,1)';
    g.beginPath();
    g.arc(size / 2, size / 2, size / 2, 0, -Math.PI * 2, false);
    g.fill();
    old = g.globalCompositeOperation;
    g.globalCompositeOperation = 'source-in';
    if (mode === "crop") {
      r = Math.min(w, h) / 2;
      g.drawImage(image, w / 2 - r, h / 2 - r, r * 2, r * 2, 0, 0, size, size);
    } else if (mode === "letterbox") {
      g.fillColor = "black";
      g.fillRect(0, 0, size, size);
      scale = size / Math.max(w, h);
      g.drawImage(image, 0, 0, w, h, size / 2 - w / 2 * scale, size / 2 - h / 2 * scale, w * scale, h * scale);
    } else if (mode === "fit") {
      g.fillColor = "black";
      g.fillRect(0, 0, size, size);
      scale = size / Math.sqrt(w * w + h * h);
      g.drawImage(image, 0, 0, w, h, size / 2 - w / 2 * scale, size / 2 - h / 2 * scale, w * scale, h * scale);
    } else {
      g.drawImage(image, 0, 0, w, h, 0, 0, size, size);
    }
    g.globalCompositeOperation = old;
    return canvas;
  };

  Base_Graphics.parseColor = function(color) {
    return Base_CssColorParser.parseCSSColor(color);
  };

  Base_Graphics.normalizeColor = function(color) {
    var a, b, g, r, _ref;
    _ref = Base_CssColorParser.parseCSSColor(color), r = _ref[0], g = _ref[1], b = _ref[2], a = _ref[3];
    return "rgba(" + r + "," + g + "," + b + "," + (a.toFixed(3)) + ")";
  };

  Base_Graphics.deriveColor = function(color, lighten, opacity) {
    var a, b, g, r, _ref;
    _ref = Base_Graphics.parseColor(color), r = _ref[0], g = _ref[1], b = _ref[2], a = _ref[3];
    return this.deriveColorRGBA(r, g, b, a, lighten, opacity);
  };

  Base_Graphics.deriveColorRGBA = function(r, g, b, a, lighten, opacity) {
    var light;
    light = (lighten - 1) * 255;
    r = Math.round(Math.min(255, Math.max(0, r + light)));
    g = Math.round(Math.min(255, Math.max(0, g + light)));
    b = Math.round(Math.min(255, Math.max(0, b + light)));
    a = Math.min(1, a * opacity);
    return "rgba(" + r + "," + g + "," + b + "," + (a.toFixed(3)) + ")";
  };

  Base_Graphics.blendColors = function(c0, c1, proportion) {
    var a, a0, a1, b, b0, b1, g, g0, g1, r, r0, r1, _ref, _ref1;
    _ref = Base_Graphics.parseColor(c0), r0 = _ref[0], g0 = _ref[1], b0 = _ref[2], a0 = _ref[3];
    _ref1 = Base_Graphics.parseColor(c1), r1 = _ref1[0], g1 = _ref1[1], b1 = _ref1[2], a1 = _ref1[3];
    r = Math.round(r1 * proportion + r0 * (1 - proportion));
    g = Math.round(g1 * proportion + g0 * (1 - proportion));
    b = Math.round(b1 * proportion + b0 * (1 - proportion));
    a = a1 * proportion + a0 * (1 - proportion);
    return "rgba(" + r + "," + g + "," + b + "," + (a.toFixed(3)) + ")";
  };

  Base_Graphics.copyHue = function(hue, brightness) {
    var a, a0, a1, b, b0, b1, br0, br1, g, g0, g1, r, r0, r1, _ref, _ref1;
    _ref = Base_Graphics.parseColor(hue), r0 = _ref[0], g0 = _ref[1], b0 = _ref[2], a0 = _ref[3];
    _ref1 = Base_Graphics.parseColor(brightness), r1 = _ref1[0], g1 = _ref1[1], b1 = _ref1[2], a1 = _ref1[3];
    br0 = (r0 + g0 + b0) / 765;
    br1 = (r1 + g1 + b1) / 765;
    r = Math.round(r0 / br0 * br1);
    g = Math.round(g0 / br0 * br1);
    b = Math.round(b0 / br0 * br1);
    a = a1;
    return "rgba(" + r + "," + g + "," + b + "," + (a.toFixed(3)) + ")";
  };

  Base_Graphics.inverseColor = function(c0) {
    var a, b, g, r, _ref;
    _ref = Base_Graphics.parseColor(c0), r = _ref[0], g = _ref[1], b = _ref[2], a = _ref[3];
    r = 255 - r;
    g = 255 - g;
    b = 255 - b;
    return "rgba(" + r + "," + g + "," + b + "," + (a.toFixed(3)) + ")";
  };

  Base_Graphics.applyShadow = function(g, style) {
    if (style.shadowColor) {
      g.shadowOffsetX = style.shadowOffsetX;
      g.shadowOffsetY = style.shadowOffsetY;
      g.shadowBlur = style.shadowBlur;
      return g.shadowColor = style.shadowColor;
    }
  };

  Base_Graphics.clearShadow = function(g) {
    g.shadowBlur = 0;
    return g.shadowColor = "transparent";
  };

  Base_Graphics.drawImageInSquare = function(g, im, ix0, iy0, iw, ih, cx, cy, radius) {
    var ihh, iww, scale;
    scale = radius / Math.max(iw, ih);
    iww = iw * scale;
    ihh = ih * scale;
    return g.drawImage(im, ix0, iy0, iw, ih, cx - iww, cy - ihh, iww * 2, ihh * 2);
  };

  Base_Graphics.heightElem = null;

  Base_Graphics.heightCache = {};

  Base_Graphics.getTextHeight = function(g, textStyle) {
    var body, cache, container, dummy, dummyText, result;
    cache = Base_Graphics.heightCache;
    if (cache.hasOwnProperty(textStyle)) {
      return cache[textStyle];
    }
    dummy = Base_Graphics.heightElem;
    if (!dummy) {
      body = document.getElementsByTagName("body")[0];
      container = document.createElement("div");
      container.setAttribute("style", "position:absolute; visibility:hidden; top: -9999px; left: -9999px");
      Base_Graphics.heightElem = dummy = document.createElement("div");
      dummyText = document.createTextNode("Mg");
      dummy.appendChild(dummyText);
      container.appendChild(dummy);
      body.appendChild(container);
    }
    dummy.setAttribute("style", "font:" + textStyle + "; line-height:1em");
    cache[textStyle] = result = dummy.offsetHeight;
    return result;
  };

  return Base_Graphics;

})();
// Generated by CoffeeScript 1.8.0
var Timechart_TimeSetup;

Timechart_TimeSetup = (function() {
  "use strict";
  Timechart_TimeSetup.prototype.settigns = null;

  function Timechart_TimeSetup(settings) {
    this.settings = settings;
    true;
  }

  Timechart_TimeSetup.isSmallerOrEqualUnit = function(smaller, bigger) {
    return Base_TimeStep.timeUnitDiffs[smaller] <= Base_TimeStep.timeUnitDiffs[bigger];
  };

  Timechart_TimeSetup.isSmallerUnit = function(smaller, bigger) {
    return Base_TimeStep.timeUnitDiffs[smaller] < Base_TimeStep.timeUnitDiffs[bigger];
  };

  Timechart_TimeSetup.prototype.toBiggerDisplayPeriod = function(unit) {
    var best, p, _i, _len, _ref;
    best = null;
    _ref = this.settings.area._displayPeriodsParsed;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      p = _ref[_i];
      if ((p.displayPeriod != null) && p.displayPeriod.approxTime() > unit.approxTime() && (best === null || p.displayPeriod.approxTime() < best.approxTime())) {
        best = p.displayPeriod;
      }
    }
    return best;
  };

  Timechart_TimeSetup.prototype.getMinUnitForTime = function(approxTime) {
    var best, bestTime, p, pt, _i, _len, _ref;
    best = null;
    bestTime = Infinity;
    _ref = this.settings.area._displayUnitsParsed;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      p = _ref[_i];
      pt = p.approxTime();
      if (pt < bestTime && pt > approxTime) {
        best = p;
        bestTime = pt;
      }
    }
    return best;
  };

  Timechart_TimeSetup.prototype.getBiggerDisplayPeriod = function(from, to) {
    var best, bestD, dt, p, proportion, unitdt, _i, _len, _ref;
    dt = Math.abs(to - from);
    bestD = 0;
    best = null;
    _ref = this.settings.area._displayPeriodsParsed;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      p = _ref[_i];
      if (!((p.displayPeriod != null) && (p.displayPeriod.unit != null))) {
        continue;
      }
      unitdt = p.displayPeriod.approxTime();
      proportion = dt / unitdt;
      if (proportion < 0.9 && proportion > bestD) {
        bestD = proportion;
        best = p;
      }
    }
    return best;
  };

  Timechart_TimeSetup.prototype.getClosestDisplayPeriod = function(dt, unitHint, allowMultiples) {
    var above, aboveT, below, belowT, p, pt, _i, _len, _ref;
    below = null;
    belowT = 0;
    above = null;
    aboveT = Infinity;
    _ref = this.settings.area._displayPeriodsParsed;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      p = _ref[_i];
      if (!((p.displayPeriod != null) && (p.displayPeriod.unit != null))) {
        continue;
      }
      pt = p.displayPeriod.approxTime();
      if (pt <= dt && ((below == null) || belowT < pt)) {
        below = p;
        belowT = pt;
      }
      if (pt >= dt && ((above == null) || aboveT > pt)) {
        above = p;
        aboveT = pt;
      }
    }
    if (allowMultiples) {
      if ((unitHint != null) && unitHint.approxTime() < dt * 0.8) {
        return {
          displayPeriod: unitHint
        };
      }
      if (((above != null) && aboveT < dt * 1.2) || (below == null)) {
        return above;
      } else {
        return below;
      }
    } else {
      if ((below != null) && (belowT > dt * 0.8 || aboveT > dt * 1.2)) {
        return below;
      } else {
        return above;
      }
    }
  };

  Timechart_TimeSetup.prototype.isAllowedDisplayUnit = function(unit) {
    var u, _i, _len, _ref;
    _ref = this.settings.area._displayUnitsParsed;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      u = _ref[_i];
      if (u.step === unit.step && (u.count = unit.count)) {
        return true;
      }
    }
    return false;
  };

  Timechart_TimeSetup.prototype.computeDisplayUnit = function(oldFrom, oldTo, oldUnit, from, to, scene) {
    var bestUnit, bestUnitTime, isBetter, maxUnitTime, maxUnitWidth, minUnitTime, oldUnitTime, policy, step, time, width, zoom, _i, _len, _ref;
    width = Math.max(scene.width, 10);
    maxUnitWidth = Math.min(width / 3, this.settings.timeAxis.maxUnitWidth);
    minUnitTime = (to - from) / width * this.settings.timeAxis.minUnitWidth;
    maxUnitTime = (to - from) / width * maxUnitWidth;
    if ((oldFrom != null) && (oldTo != null) && (oldUnit != null)) {
      zoom = (oldTo - oldFrom) / (to - from);
      oldUnitTime = oldUnit.approxTime();
      if (zoom === 1) {
        return oldUnit;
      } else if (zoom > 1) {
        if (oldUnitTime <= maxUnitTime) {
          return oldUnit;
        }
      } else {
        if (oldUnitTime >= minUnitTime) {
          return oldUnit;
        }
      }
    }
    policy = this.settings.timeAxis.unitSizePolicy;
    bestUnit = null;
    bestUnitTime = 0;
    _ref = this.settings.area._displayUnitsParsed;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      step = _ref[_i];
      if (step.approxTime() < this.settings.area._minUnit.approxTime()) {
        continue;
      }
      time = step.approxTime();
      if (bestUnit === null) {
        isBetter = true;
      } else if (policy === "min") {
        isBetter = (time >= minUnitTime && time < bestUnitTime) || (bestUnitTime < minUnitTime && time > bestUnitTime);
      } else {
        isBetter = (time <= maxUnitTime && time > bestUnitTime) || (bestUnitTime > maxUnitTime && time < bestUnitTime);
      }
      if (isBetter) {
        bestUnit = step;
        bestUnitTime = time;
      }
    }
    if (!bestUnit) {
      console.error(oldFrom, oldTo, oldUnit, from, to, width);
      throw "Could not calculate displayUnit";
    }
    return bestUnit;
  };


  /*
    Compute the period.
    Snapping to bars will be done later.
   */

  Timechart_TimeSetup.prototype.tryComputeDisplayPeriod = function(periodStr, anchorStr, unitStr, dataFrom, dataTo, scene, curTime) {
    var anchor, from, fromS, maxTimeScale, maxUnit, minTimeScale, minUnit, period, to, toS, unit, _ref, _ref1;
    from = null;
    to = null;
    if ((periodStr != null) && Base_Helpers.arrayContains(periodStr, ">")) {
      _ref = periodStr.split(">"), fromS = _ref[0], toS = _ref[1];
      from = parseInt(fromS);
      to = parseInt(toS);
    } else {
      if (periodStr === "max" && (dataFrom != null) && (dataTo != null)) {
        from = dataFrom;
        to = anchorStr === "now" ? curTime : dataTo;
      } else if (periodStr !== "max") {
        period = Base_TimeStep.parse(periodStr);
        if (anchorStr === "now") {
          anchor = curTime;
        } else if (anchorStr === "newestData" && (dataTo != null)) {
          anchor = dataTo;
        } else if (Base_Helpers.isNumber(anchorStr)) {
          anchor = parseFloat(anchorStr);
        }
        if ((period != null) && (anchor != null)) {
          from = period.sub(anchor);
          to = anchor;
        }
      }
    }
    if (from === null || to === null) {
      return [null, null, null];
    }
    _ref1 = this.computeTimeScaleRange(scene), minTimeScale = _ref1[0], maxTimeScale = _ref1[1], minUnit = _ref1[2], maxUnit = _ref1[3];
    unit = unitStr === "auto" ? null : Base_TimeStep.parse(unitStr);
    if (to - from > maxTimeScale) {
      unit = maxUnit;
      from = to - maxTimeScale;
    }
    if (to - from < minTimeScale) {
      unit = minUnit;
      from = to - minTimeScale;
    }
    return [from, to, unit];
  };


  /*
    Resolves from to values that are strings
   */

  Timechart_TimeSetup.prototype.resolveFromTo = function(from, to, unit, dataFrom, dataTo, curTime) {
    if (from === "oldestData" && (dataFrom != null)) {
      from = unit.roundTimeDown(dataFrom);
    }
    if (to === "newestData" && (dataTo != null)) {
      to = unit.roundTimeUp(dataTo);
    }
    if (to === "now") {
      to = unit.roundTimeUp(curTime);
    }
    return [from, to];
  };

  Timechart_TimeSetup.prototype.computeTimeScaleRange = function(scene, unitSteps) {
    var diff, maxDiff, maxTime, maxUnit, minDiff, minTime, minUnit, step, width, _i, _len;
    if (unitSteps == null) {
      unitSteps = this.settings.area._displayUnitsParsed;
    }
    minUnit = null;
    minDiff = 0;
    maxUnit = null;
    maxDiff = Infinity;
    for (_i = 0, _len = unitSteps.length; _i < _len; _i++) {
      step = unitSteps[_i];
      diff = step.approxTime();
      if (minUnit === null || minDiff > diff) {
        minUnit = step;
        minDiff = diff;
      }
      if (maxUnit === null || maxDiff < diff) {
        maxUnit = step;
        maxDiff = diff;
      }
    }
    width = Math.max(10, scene.width);
    maxTime = width / this.settings.timeAxis.minUnitWidth * maxDiff;
    minTime = width / this.settings.timeAxis.maxUnitWidth * minDiff;
    return [minTime, maxTime, minUnit, maxUnit];
  };

  Timechart_TimeSetup.prototype.getLimits = function(dataFrom, dataTo, unit, curTime, isFinal) {
    var applyLimit, limitFrom, limitMode, limitTo, settings, _ref, _ref1;
    settings = this.settings.interaction.scrolling;
    limitMode = settings.limitMode;
    applyLimit = !isFinal ? limitMode === "block" : limitMode != null;
    limitFrom = null;
    limitTo = null;
    if (applyLimit) {
      limitFrom = settings.limitFrom;
      limitTo = settings.limitTo;
      _ref = this.resolveFromTo(limitFrom, limitTo, unit, dataFrom, dataTo, curTime), limitFrom = _ref[0], limitTo = _ref[1];
      _ref1 = this.resolveFromTo(limitFrom, limitTo, unit, dataFrom, dataTo, curTime), limitFrom = _ref1[0], limitTo = _ref1[1];
      if (!Base_Helpers.isNumber(limitFrom)) {
        limitFrom = null;
      }
      if (!Base_Helpers.isNumber(limitTo)) {
        limitTo = null;
      }
    }
    return [limitFrom, limitTo];
  };

  Timechart_TimeSetup.prototype.preventOverscale = function(scene, units, origin, from, to, unit, dataFrom, dataTo, curTime, isFinal) {
    var center, downscale, limitFrom, limitTo, maxTime, minTime, offset, time, _ref, _ref1;
    _ref = this.getLimits(dataFrom, dataTo, unit, curTime, isFinal), limitFrom = _ref[0], limitTo = _ref[1];
    _ref1 = this.computeTimeScaleRange(scene, units), minTime = _ref1[0], maxTime = _ref1[1];
    if ((limitFrom != null) && (limitTo != null) && to - from > limitTo - limitFrom) {
      center = (limitFrom + limitTo) / 2;
      offset = (limitTo - limitFrom) / 2;
      offset = Math.max(offset, minTime / 2);
      return [center - offset, center + offset];
    } else {
      maxTime *= 0.99;
      minTime *= 1.01;
      time = to - from;
      if (time > maxTime) {
        time = Math.min(time, maxTime);
      }
      time = Math.max(time, minTime);
      downscale = time / (to - from);
      if (origin == null) {
        origin = (from + to) / 2;
      }
      if (from === to) {
        console.error("From = To, trouble", from, to);
      }
      return [origin + (from - origin) * downscale, origin + (to - origin) * downscale];
    }
  };

  Timechart_TimeSetup.prototype.preventOverscroll = function(unit, from, to, dataFrom, dataTo, curTime, isFinal) {
    var diff, limitFrom, limitTo, settings, _ref;
    _ref = this.getLimits(dataFrom, dataTo, unit, curTime, isFinal), limitFrom = _ref[0], limitTo = _ref[1];
    settings = this.settings.interaction.scrolling;
    diff = to - from;
    if ((limitFrom != null) && (limitTo != null)) {
      diff = Math.min(diff, limitTo - limitFrom);
    }
    diff *= settings.overscrollProportion;
    if (limitFrom != null) {
      limitFrom -= diff;
    }
    if (limitTo != null) {
      limitTo += diff;
    }
    if ((limitFrom != null) && (limitTo != null) && limitTo - limitFrom < to - from) {
      if (limitFrom < from) {
        diff = from - limitFrom;
        from -= diff;
        to -= diff;
      } else if (limitTo > to) {
        diff = to - limitTo;
        from -= diff;
        to -= diff;
      }
    } else {
      if ((limitTo != null) && limitTo < to) {
        diff = to - limitTo;
        from -= diff;
        to -= diff;
      } else if ((limitFrom != null) && limitFrom > from) {
        diff = limitFrom - from;
        from = limitFrom;
        to += diff;
      }
    }
    return [from, to];
  };

  Timechart_TimeSetup.prototype.scroll = function(from, to, displayUnit, direction, count, unit) {
    var step;
    if (unit === "displayUnit") {
      step = displayUnit.clone();
    } else if (unit === "page") {
      step = this.getTimeRangeStep(from, to);
    } else if (Base_TimeStep.isGoodUnit(unit)) {
      step = Base_TimeStep.parse(unit);
    } else {
      Base_Helpers.error("Incorrect scroll unit: " + unit);
      return;
    }
    step.count *= count;
    if (direction === "<") {
      return [step.sub(from), step.sub(to)];
    } else {
      return [step.add(from), step.add(to)];
    }
  };

  Timechart_TimeSetup.prototype.getTimeRangeStep = function(from, to) {
    var biggestStep, ff, step, tt, unit, _i, _len, _ref;
    from = Math.round(from);
    to = Math.round(to);
    biggestStep = null;
    _ref = Base_TimeStep.knownUnits;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      unit = _ref[_i];
      step = new Base_TimeStep(unit, 1);
      ff = step.roundTimeRound(from);
      tt = step.roundTimeRound(to);
      if (from === ff && to === tt && (biggestStep === null || biggestStep.approxTime() < step.approxTime())) {
        biggestStep = step;
      }
    }
    biggestStep.count = Math.max(1, biggestStep.numberOfUnits(from, to));
    return biggestStep;
  };

  return Timechart_TimeSetup;

})();
// Generated by CoffeeScript 1.8.0
var ItemsChart_ItemsLayer, Itemschart_Link, Itemschart_Node,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

Itemschart_Node = (function() {
  Itemschart_Node.styleSettings = {
    _doc: {
      doc: "Node style settings",
      type: "object"
    },
    fillColor: null,
    lineColor: null,
    lineWidth: 1,
    lineDash: null,
    shadowColor: null,
    radius: 1,
    label: null,
    display: "image",
    coordinates: null
  };

  Itemschart_Node.prototype.zindex = 0;

  Itemschart_Node.prototype.isNode = true;

  Itemschart_Node.prototype.isLink = false;

  Itemschart_Node.prototype.removed = false;

  Itemschart_Node.prototype.added = false;

  Itemschart_Node.prototype.loading = false;

  Itemschart_Node.prototype.userLock = false;

  Itemschart_Node.prototype.expanded = false;

  Itemschart_Node.prototype.focused = false;

  Itemschart_Node.prototype.background = false;

  Itemschart_Node.prototype.cursor = null;

  Itemschart_Node.prototype.relevance = 1;

  Itemschart_Node.prototype.opacity = 1;

  Itemschart_Node.prototype.selectable = true;

  Itemschart_Node.prototype.movable = true;

  Itemschart_Node.prototype.display = "image";

  Itemschart_Node.prototype.coordinates = null;

  Itemschart_Node.prototype.fillColor = null;

  Itemschart_Node.prototype.lineColor = null;

  Itemschart_Node.prototype.lineWidth = 1;

  Itemschart_Node.prototype.image = null;

  Itemschart_Node.prototype.imageCropping = false;

  Itemschart_Node.prototype.imageSlicing = null;

  Itemschart_Node.prototype.tintImage = false;

  Itemschart_Node.prototype.items = [];

  Itemschart_Node.prototype.label = null;

  Itemschart_Node.prototype.labelStyle = null;

  Itemschart_Node.prototype.locks = 0;

  function Itemschart_Node(id, layer) {
    this.id = id;
    this.layer = layer;
    this.data = null;
    this.x = null;
    this.y = null;
    this.targetHHeight = null;
    this.targetHWidth = null;
    this.hHeight = 0;
    this.hWidth = 0;
    this.bLeft = 0;
    this.bRight = 0;
    this.bTop = 0;
    this.bBottom = 0;
    this.currentLabel = null;
    this.currentItems = [];
    this.coordinatesCache = null;
    this.coordinatesCacheZoom = Infinity;
    this.renderHheight = 0;
    this.renderHwidth = 0;
    this.links = [];
    this.dataLinks = [];
    this.dataLinksFiltered = [];
  }

  return Itemschart_Node;

})();

Itemschart_Link = (function() {
  Itemschart_Link.styleSettings = {
    _doc: {
      doc: "Link style settings",
      type: "object"
    },
    fillColor: "#333",
    shadowColor: null,
    label: null,
    radius: 1,
    length: 1,
    strength: 1,
    lineDash: null,
    toPieValue: 0,
    toPieColor: null,
    direction: null,
    fromDecoration: null,
    toDecoration: null
  };

  Itemschart_Link.prototype.from = null;

  Itemschart_Link.prototype.to = null;

  Itemschart_Link.prototype.removed = false;

  Itemschart_Link.prototype.background = false;

  Itemschart_Link.prototype.isNode = false;

  Itemschart_Link.prototype.isLink = true;

  Itemschart_Link.prototype.data = null;

  Itemschart_Link.prototype.multiId = null;

  Itemschart_Link.prototype.radius = 1;

  Itemschart_Link.prototype.length = 1;

  Itemschart_Link.prototype.cursor = null;

  Itemschart_Link.prototype.strength = 1;

  Itemschart_Link.prototype.label = null;

  Itemschart_Link.prototype.labelStyle = null;

  Itemschart_Link.prototype.dashed = false;

  Itemschart_Link.prototype.currentRadius = 0;

  Itemschart_Link.prototype.direction = null;

  Itemschart_Link.prototype.fromDecoration = null;

  Itemschart_Link.prototype.toDecoration = null;

  Itemschart_Link.prototype.relevance = 1;

  Itemschart_Link.prototype.items = [];

  Itemschart_Link.prototype.toPieValue = 0;

  Itemschart_Link.prototype.toPieColor = null;

  Itemschart_Link.prototype.toPie0 = null;

  Itemschart_Link.prototype.toPie1 = null;

  Itemschart_Link.prototype.currentItems = null;

  Itemschart_Link.prototype.currentCenterOffset = 0;

  function Itemschart_Link(id, layer) {
    this.id = id;
    this.layer = layer;
    1;
  }

  Itemschart_Link.prototype.otherEnd = function(node) {
    if (node === this.from) {
      return this.to;
    }
    if (node === this.to) {
      return this.from;
    }
    return null;
  };

  Itemschart_Link.prototype.commonNode = function(link) {
    if (this.from === link.from || this.from === link.to) {
      return this.from;
    }
    if (this.to === link.from || this.to === link.to) {
      return this.to;
    }
    return null;
  };

  return Itemschart_Link;

})();

ItemsChart_ItemsLayer = (function(_super) {
  __extends(ItemsChart_ItemsLayer, _super);

  function ItemsChart_ItemsLayer(scene, layerSettings) {
    this.scene = scene;
    this.layerSettings = layerSettings;
    ItemsChart_ItemsLayer.__super__.constructor.call(this, this.scene);
    this.parentId = null;
    this.scaleObjectsWithZoom = true;
    this._nodes = [];
    this._links = [];
    this._nodesDel = null;
    this._linksDel = null;
    this.idToNode = {};
    this.idToLink = {};
    this.clearModified();
    this.styleUpdater = this.createStyleUpdater(this.layerSettings.style);
  }

  ItemsChart_ItemsLayer.prototype.onSettingsChanged = function(settingsChanges) {
    var link, node, _i, _j, _len, _len1, _ref, _ref1, _results;
    if (settingsChanges.style) {
      this.styleUpdater = this.createStyleUpdater(this.layerSettings.style);
      _ref = this.nodes();
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        node = _ref[_i];
        this.touchNode(node);
      }
      _ref1 = this.links();
      _results = [];
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        link = _ref1[_j];
        _results.push(this.touchLink(link));
      }
      return _results;
    }
  };

  ItemsChart_ItemsLayer.prototype.doAnimations = function(event) {
    return this.styleUpdater.updateItems(event, this, true);
  };

  ItemsChart_ItemsLayer.prototype.createStyleUpdater = function(style) {
    return null;
  };

  ItemsChart_ItemsLayer.prototype.paintPrepare = function(event) {
    return 0;
  };

  ItemsChart_ItemsLayer.prototype.paintSelection = function(event, selectedNodes, selectedLinks) {
    return 0;
  };

  ItemsChart_ItemsLayer.prototype.paintLinks = function(event, links) {
    return 0;
  };

  ItemsChart_ItemsLayer.prototype.paintNodes = function(event, nodes) {
    return 0;
  };

  ItemsChart_ItemsLayer.prototype.findObjectAt = function(displayX, displayY, tolerance) {
    return null;
  };

  ItemsChart_ItemsLayer.prototype.getLegendItems = function() {
    return [];
  };

  ItemsChart_ItemsLayer.prototype.paint = function(event) {
    var hoverLinkPos, hoverNodePos, item, links, nodes, sel, _i, _len;
    this.paintPrepare(event);
    this.clearModified();
    sel = this.scene.selection;
    if (sel.length > 0) {
      nodes = [];
      links = [];
      for (_i = 0, _len = sel.length; _i < _len; _i++) {
        item = sel[_i];
        if (item.layer === this && item.isNode) {
          nodes.push(item);
        }
        if (item.layer === this && item.isLink) {
          links.push(item);
        }
      }
      if (nodes.length > 0 || links.length > 0) {
        this.paintSelection(event, nodes, links);
      }
    }
    links = this.links();
    hoverLinkPos = this._makeHoveredLast(links, this.scene.hoverLink);
    this.paintLinks(event, links);
    this._restoreHovered(links, hoverLinkPos);
    nodes = this.nodes();
    hoverNodePos = this._makeHoveredLast(nodes, this.scene.hoverNode);
    this.paintNodes(event, nodes);
    return this._restoreHovered(nodes, hoverNodePos);
  };

  ItemsChart_ItemsLayer.prototype.clearObjects = function() {
    var link, node, _i, _j, _len, _len1, _ref, _ref1, _results;
    _ref = this.nodes();
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      node = _ref[_i];
      this.removeNode(node);
    }
    _ref1 = this.links();
    _results = [];
    for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
      link = _ref1[_j];
      _results.push(this.removeLink(link));
    }
    return _results;
  };

  ItemsChart_ItemsLayer.prototype.nodes = function() {
    var n, node, _i, _len, _ref;
    if (this._nodesDel === null) {
      return this._nodes;
    }
    n = [];
    _ref = this._nodes;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      node = _ref[_i];
      if (!this._nodesDel[node.id]) {
        n.push(node);
      }
    }
    this._nodes = n;
    this._nodesDel = null;
    return n;
  };

  ItemsChart_ItemsLayer.prototype.links = function() {
    var n, node, _i, _len, _ref;
    if (this._linksDel === null) {
      return this._links;
    }
    n = [];
    _ref = this._links;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      node = _ref[_i];
      if (!this._linksDel[node.id]) {
        n.push(node);
      }
    }
    this._links = n;
    this._linksDel = null;
    return n;
  };

  ItemsChart_ItemsLayer.prototype.addNode = function(nodeId) {
    var node;
    this.nodes();
    if (this.idToNode.hasOwnProperty(nodeId)) {
      node = this.idToNode[nodeId];
      node.removed = false;
      if (!node.added) {
        node.added = true;
      }
    } else if (this.deletedNodes.hasOwnProperty(nodeId)) {
      node = this.deletedNodes[nodeId];
      node.removed = false;
      if (!node.added) {
        node.added = true;
      }
      this.idToNode[nodeId] = node;
      this._nodes.push(node);
      delete this.deletedNodes[nodeId];
    } else {
      node = new Itemschart_Node(nodeId, this);
      node.added = true;
      this.idToNode[nodeId] = node;
      this._nodes.push(node);
      this.newNodes[nodeId] = node;
    }
    this.modifiedNodes[nodeId] = node;
    return node;
  };

  ItemsChart_ItemsLayer.prototype.touchNodeOrLink = function(obj) {
    if (obj.isNode) {
      return this.modifiedNodes[obj.id] = obj;
    } else {
      return this.modifiedLinks[obj.id] = obj;
    }
  };

  ItemsChart_ItemsLayer.prototype.touchNode = function(node) {
    return this.modifiedNodes[node.id] = node;
  };

  ItemsChart_ItemsLayer.prototype.removeNode = function(node) {
    var nodeId;
    nodeId = node.id;
    if (!this.idToNode.hasOwnProperty(nodeId)) {
      return;
    }
    if (node === this.lastClickedNode) {
      this.lastClickedNode = null;
    }
    this.scene.objectRemoved(node);
    if (this.newNodes.hasOwnProperty(node.id)) {
      return this.deleteNode(node);
    } else {
      if (!node.removed) {
        node.removed = true;
      }
      node.added = false;
      return this.modifiedNodes[nodeId] = node;
    }
  };

  ItemsChart_ItemsLayer.prototype.deleteNode = function(node) {
    if (this._nodesDel === null) {
      this._nodesDel = {};
    }
    this._nodesDel[node.id] = true;
    this.scene.objectRemoved(node);
    delete this.newNodes[node.id];
    delete this.modifiedNodes[node.id];
    delete this.idToNode[node.id];
    return this.deletedNodes[node.id] = node;
  };

  ItemsChart_ItemsLayer.prototype.addLink = function(linkId, from, to) {
    var link;
    if (!(this.idToNode.hasOwnProperty(from) && this.idToNode.hasOwnProperty(to))) {
      throw "Cannot add link - missing nodes";
    }
    this.links();
    if (this.idToLink.hasOwnProperty(linkId)) {
      link = this.idToLink[linkId];
      link.removed = false;
      if (!link.added) {
        link.added = true;
      }
    } else if (this.deletedLinks.hasOwnProperty(linkId)) {
      link = this.deletedLinks[linkId];
      delete this.deletedLinks[linkId];
      this.idToLink[linkId] = link;
      this._links.push(link);
      link.removed = false;
      if (!link.added) {
        link.added = true;
      }
    } else {
      link = new Itemschart_Link(linkId, this);
      link.added = true;
      this._links.push(link);
      this.idToLink[linkId] = link;
      this.newLinks[linkId] = link;
    }
    link.from = null;
    link.to = null;
    link.multiId = from < to ? from + "#" + to : to + "#" + from;
    this.modifiedLinks[linkId] = link;
    return link;
  };

  ItemsChart_ItemsLayer.prototype.removeLink = function(link) {
    var linkId;
    linkId = link.id;
    if (!this.idToLink.hasOwnProperty(linkId)) {
      return;
    }
    this.scene.objectRemoved(link);
    if (this.newLinks.hasOwnProperty(linkId)) {
      return this.deleteLink(link);
    } else {
      link.added = false;
      if (!link.removed) {
        link.removed = true;
      }
      return this.modifiedLinks[linkId] = link;
    }
  };

  ItemsChart_ItemsLayer.prototype.deleteLink = function(link) {
    if (this._linksDel === null) {
      this._linksDel = {};
    }
    this._linksDel[link.id] = true;
    this.scene.objectRemoved(link);
    if (this.newLinks.hasOwnProperty(link.id)) {
      delete this.newLinks[link.id];
    } else {
      this.deletedLinks[link.id] = link;
    }
    delete this.modifiedLinks[link.id];
    return delete this.idToLink[link.id];
  };

  ItemsChart_ItemsLayer.prototype.touchLink = function(link) {
    return this.modifiedLinks[link.id] = link;
  };

  ItemsChart_ItemsLayer.prototype.getModified = function() {
    return [this.newNodes, this.newLinks, this.modifiedNodes, this.modifiedLinks, this.deletedNodes, this.deletedLinks];
  };

  ItemsChart_ItemsLayer.prototype.hasTopologyChanges = function() {
    return Base_Helpers.hasProperties(this.newNodes) || Base_Helpers.hasProperties(this.newLinks) || Base_Helpers.hasProperties(this.deletedNodes) || Base_Helpers.hasProperties(this.deletedLinks);
  };

  ItemsChart_ItemsLayer.prototype.hasStyleChanges = function() {
    return this.hasTopologyChanges() || Base_Helpers.hasProperties(this.modifiedLinks) || Base_Helpers.hasProperties(this.modifiedNodes);
  };

  ItemsChart_ItemsLayer.prototype.clearModified = function() {
    this.newNodes = {};
    this.newLinks = {};
    this.modifiedNodes = {};
    this.modifiedLinks = {};
    this.deletedNodes = {};
    return this.deletedLinks = {};
  };

  ItemsChart_ItemsLayer.prototype.paintNodeDetails = function(node, x, y, w, r, zoom, nodeLabelScaleBase, event, paintLabel) {
    var fx, fy, g, item, ix, iy, label, labelRenderer, scale, sizeScale, xx, yy, _i, _len, _ref, _results;
    labelRenderer = event.labelRenderer;
    g = event.context;
    sizeScale = r / nodeLabelScaleBase;
    if (paintLabel && node.currentLabel) {
      label = node.currentLabel;
      if (label.scaleWithSize) {
        scale = sizeScale;
      } else if (label.scaleWithZoom) {
        scale = zoom;
      } else {
        scale = 1;
      }
      labelRenderer.measure(g, label);
      if (label.hheight > 1.5) {
        labelRenderer.paint(g, x, y + r + label.hheight * scale * 0.8, scale, label);
      }
    }
    if (node.currentItems) {
      _ref = node.currentItems;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        item = _ref[_i];
        fx = item.x || 0;
        fy = item.y || 0;
        ix = item.px || 0;
        iy = item.py || 0;
        xx = x + w * ix + fx;
        yy = y + r * iy + fy;
        if (item.scaleWithSize) {
          scale = sizeScale;
        } else if (item.scaleWithZoom) {
          scale = zoom;
        } else {
          scale = 1;
        }
        if (item.hheight > 1.5) {
          _results.push(labelRenderer.paint(g, xx, yy, scale, item));
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    }
  };

  ItemsChart_ItemsLayer.prototype.getGeometry = function() {
    var txa, txm, tya, tym, x0s, x0w, x1s, x1w, y0s, y0w, y1s, y1w, zoom, _ref;
    _ref = this.scene.toDisplayTransform(), txm = _ref[0], txa = _ref[1], tym = _ref[2], tya = _ref[3];
    x0s = this.bounds.x0;
    x1s = this.bounds.x1;
    y0s = this.bounds.y0;
    y1s = this.bounds.y1;
    x0w = (x0s - txa) / txm;
    x1w = (x1s - txa) / txm;
    y0w = (y0s - tya) / tym;
    y1w = (y1s - tya) / tym;
    zoom = this.scaleObjectsWithZoom ? this.scene.zoom : 1;
    return [txm, txa, tym, tya, zoom, x0s, x1s, y0s, y1s, x0w, y0w, x1w, y1w];
  };

  ItemsChart_ItemsLayer.prototype._makeHoveredLast = function(list, hobj) {
    var i, len, n1, obj, _i, _len;
    len = list.length;
    if (len < 2 || !hobj || hobj === list[len - 1]) {
      return len - 1;
    }
    for (i = _i = 0, _len = list.length; _i < _len; i = ++_i) {
      obj = list[i];
      if (obj === hobj) {
        n1 = list[len - 1];
        list[len - 1] = hobj;
        list[i] = n1;
        return i;
      }
    }
    return len - 1;
  };

  ItemsChart_ItemsLayer.prototype._restoreHovered = function(list, pos) {
    var len, n1;
    len = list.length;
    if (pos !== len - 1) {
      n1 = list[pos];
      list[pos] = list[len - 1];
      return list[len - 1] = n1;
    }
  };

  return ItemsChart_ItemsLayer;

})(Base_Layer);
// Generated by CoffeeScript 1.8.0
var PieChart_Renderer_Flat,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

PieChart_Renderer_Flat = (function(_super) {
  __extends(PieChart_Renderer_Flat, _super);

  function PieChart_Renderer_Flat() {
    return PieChart_Renderer_Flat.__super__.constructor.apply(this, arguments);
  }

  PieChart_Renderer_Flat.prototype.paintSlices = function(g, x, y, slices) {
    var slice, _i, _len, _results;
    _results = [];
    for (_i = 0, _len = slices.length; _i < _len; _i++) {
      slice = slices[_i];
      _results.push(this.strokeAndPaint(g, x, y, slice));
    }
    return _results;
  };

  return PieChart_Renderer_Flat;

})(PieChart_Renderer_Base);
// Generated by CoffeeScript 1.8.0
var PieChart_Renderer_Can,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

PieChart_Renderer_Can = (function(_super) {
  __extends(PieChart_Renderer_Can, _super);

  function PieChart_Renderer_Can() {
    return PieChart_Renderer_Can.__super__.constructor.apply(this, arguments);
  }

  PieChart_Renderer_Can.prototype.paintPie = function(context, x, y, r0, r1, a0, a1, pie) {
    var depth, offset, _i, _len, _ref, _results;
    PieChart_Renderer_Can.__super__.paintPie.call(this, context, x, y, r0, r1, a0, a1, pie);
    depth = this.settings.pie.depth;
    if (depth > 0 && pie.allSlices.length > 0) {
      context.fillStyle = "rgba(0,0,0,0.05)";
      _ref = [5, 10, 18];
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        offset = _ref[_i];
        context.beginPath();
        context.arc(x, y + offset + depth, r1, a0, a1, false);
        context.arc(x, y + offset + depth, r0, a1, a0, true);
        context.closePath();
        _results.push(context.fill());
      }
      return _results;
    }
  };

  PieChart_Renderer_Can.prototype.paintSlices = function(g, x, y, slices) {
    var PI, density, depth, i, leftAngle, numSteps, params, rightAngle, slice, stepOffset, _i, _j, _k, _l, _len, _len1, _len2, _len3, _m, _results;
    depth = this.settings.pie.depth;
    density = 2 * this.settings.advanced.renderQuality;
    stepOffset = 1 / density;
    numSteps = depth * density;
    g.shadowOffsetX = 0;
    g.shadowOffsetY = 0;
    g.shadowBlur = depth * 1.5;
    g.shadowColor = "black";
    g.fillStyle = "black";
    for (_i = 0, _len = slices.length; _i < _len; _i++) {
      slice = slices[_i];
      this.strokeSlice(g, x, y + depth, slice);
      g.fill();
    }
    g.shadowColor = null;
    g.shadowBlur = 0;
    g.lineWidth = 1;
    for (i = _j = 0; _j <= numSteps; i = _j += 1) {
      for (_k = 0, _len1 = slices.length; _k < _len1; _k++) {
        slice = slices[_k];
        this.strokeSlice(g, x, y + depth - i * stepOffset, slice);
        if (i >= numSteps - 1) {
          g.strokeStyle = Base_Graphics.deriveColor(slice.fillColor, 1.35, 1);
        } else {
          g.strokeStyle = Base_Graphics.deriveColor(slice.fillColor, 0.5 + i / numSteps * 0.2, 1);
        }
        g.stroke();
      }
    }
    PI = Math.PI;
    g.shadowBlur = depth;
    g.shadowColor = "rgba(0,0,0,0.1)";
    g.fillStyle = "black";
    for (_l = 0, _len2 = slices.length; _l < _len2; _l++) {
      slice = slices[_l];
      params = slice.renderParams;
      leftAngle = params[4];
      rightAngle = params[5];
      if (leftAngle === rightAngle) {
        continue;
      }
      while (leftAngle > PI) {
        leftAngle -= PI * 2;
        rightAngle -= PI * 2;
      }
      if (leftAngle < 0) {
        if (rightAngle > 0) {
          rightAngle = Math.min(rightAngle, PI);
          if (this.strokeInnerShadowSlice(g, x, y, slice, 0, rightAngle)) {
            g.fill();
          }
        }
      } else if (rightAngle < PI) {
        if (this.strokeInnerShadowSlice(g, x, y, slice, leftAngle, rightAngle)) {
          g.fill();
        }
      } else {
        if (leftAngle < PI) {
          if (this.strokeInnerShadowSlice(g, x, y, slice, leftAngle, PI)) {
            g.fill();
          }
        }
        if (rightAngle > 2 * PI) {
          if (this.strokeInnerShadowSlice(g, x, y, slice, PI * 2, rightAngle)) {
            g.fill();
          }
        }
      }
    }
    _results = [];
    for (_m = 0, _len3 = slices.length; _m < _len3; _m++) {
      slice = slices[_m];
      _results.push(this.strokeAndPaint(g, x, y, slice));
    }
    return _results;
  };

  PieChart_Renderer_Can.prototype.strokeInnerShadowSlice = function(context, x, y, slice, leftAngle, rightAngle) {
    var params, r0, r1;
    params = slice.renderParams;
    r0 = params[0] + 1;
    r1 = Math.min(params[1] - 1, r0 + 10);
    if (r0 >= params[1] || r1 <= params[0]) {
      return false;
    }
    leftAngle += 1 / r0;
    rightAngle -= 1 / r0;
    if (leftAngle >= rightAngle) {
      return;
    }
    context.beginPath();
    context.arc(x, y, r1, leftAngle, rightAngle, false);
    context.arc(x, y, r0, rightAngle, leftAngle, true);
    context.closePath();
    return true;
  };

  return PieChart_Renderer_Can;

})(PieChart_Renderer_Base);
// Generated by CoffeeScript 1.8.0
var PieChart_Renderer_Smoothy,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

PieChart_Renderer_Smoothy = (function(_super) {
  __extends(PieChart_Renderer_Smoothy, _super);

  function PieChart_Renderer_Smoothy() {
    return PieChart_Renderer_Smoothy.__super__.constructor.apply(this, arguments);
  }

  PieChart_Renderer_Smoothy.prototype.gradients = {};

  PieChart_Renderer_Smoothy.prototype.paintSlices = function(g, x, y, slices) {
    var slice, _i, _len, _results;
    this.g = g;
    _results = [];
    for (_i = 0, _len = slices.length; _i < _len; _i++) {
      slice = slices[_i];
      this.strokeAndPaint(g, x, y, slice);
      _results.push(this.elegantGradient(x, y, slice));
    }
    return _results;
  };

  PieChart_Renderer_Smoothy.prototype.getRadialGradient = function(x, y, sr0, x1, y1, sr1, angle) {
    var c1, gradient;
    c1 = Math.abs(Math.sin(angle));
    gradient = this.g.createRadialGradient(x, y, sr0, x1, y1, sr1);
    this.addColorStops(gradient, c1, angle);
    return gradient;
  };

  PieChart_Renderer_Smoothy.prototype.getLinearGradient = function(g, x, y, sr0, x1, y1, sr1, angle) {
    var c1, cosa, dr, gradient, rx0, rx1, ry0, ry1, sina;
    dr = sr1 - sr0;
    sina = Math.sin(angle);
    cosa = Math.cos(angle);
    rx0 = x + cosa * sr0;
    ry0 = y + sina * sr0;
    rx1 = rx0 + cosa * dr;
    ry1 = ry0 + sina * dr;
    c1 = Math.abs(sina);
    gradient = this.g.createLinearGradient(rx0, ry0, rx1, ry1);
    this.addColorStops(gradient, c1, angle);
    return gradient;
  };

  PieChart_Renderer_Smoothy.prototype.addColorStops = function(g, c1, angle) {
    var black, coef1, coef2, coef3, coef4, coef5, col1, col2, white;
    black = "0,0,0";
    white = "255,255,255";
    if (angle <= 0 || angle > Math.PI) {
      col1 = black;
      col2 = white;
    } else {
      col1 = white;
      col2 = black;
    }
    coef1 = 0.4 * c1;
    coef2 = 0.2 * c1;
    coef3 = 0.1 * c1;
    coef4 = 0.3 * c1;
    coef5 = 0.5 * c1;
    g.addColorStop(0, "rgba(" + col1 + "," + coef1.toFixed(3) + ")");
    g.addColorStop(0.1, "rgba(" + col1 + "," + coef2.toFixed(3) + ")");
    g.addColorStop(0.1, "rgba(" + col1 + "," + coef3.toFixed(3) + ")");
    g.addColorStop(0.4, "rgba(" + black + "," + 0.1 + ")");
    g.addColorStop(0.9, "rgba(" + col2 + "," + coef3.toFixed(3) + ")");
    g.addColorStop(0.95, "rgba(" + col2 + "," + coef4.toFixed(3) + ")");
    return g.addColorStop(1, "rgba(" + col2 + "," + coef5.toFixed(3) + ")");
  };

  PieChart_Renderer_Smoothy.prototype.elegantGradient = function(xx, yy, slice) {
    var a1, a2, as1, as2, inc, quality, sr0, sr1, _ref, _results;
    _ref = slice.renderParams, sr0 = _ref[0], sr1 = _ref[1], a1 = _ref[2], a2 = _ref[3];
    quality = this.settings.advanced.renderQuality;
    inc = Math.PI / Math.max(1, 180 * quality);
    as1 = a1;
    _results = [];
    while (as1 < a2) {
      as2 = Math.min(as1 + inc, a2);
      this.g.beginPath();
      this.g.arc(xx, yy, sr1, as1, as2);
      this.g.arc(xx, yy, sr0, as2, as1, true);
      this.g.closePath();
      Base_Graphics.paint(this.g, {
        fillColor: this.getRadialGradient(xx, yy, sr0, xx, yy, sr1, as1)
      });
      _results.push(as1 = as2);
    }
    return _results;
  };

  return PieChart_Renderer_Smoothy;

})(PieChart_Renderer_Base);
// Generated by CoffeeScript 1.8.0
var PieChart_Renderer_Bevel,
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

PieChart_Renderer_Bevel = (function(_super) {
  __extends(PieChart_Renderer_Bevel, _super);

  function PieChart_Renderer_Bevel() {
    this.getSmartGradient = __bind(this.getSmartGradient, this);
    return PieChart_Renderer_Bevel.__super__.constructor.apply(this, arguments);
  }

  PieChart_Renderer_Bevel.prototype.gradients = {};

  PieChart_Renderer_Bevel.prototype.paintSlices = function(g, x, y, slices) {
    var slice, _i, _len, _results;
    this.g = g;
    _results = [];
    for (_i = 0, _len = slices.length; _i < _len; _i++) {
      slice = slices[_i];
      this.strokeAndPaint(g, x, y, slice);
      _results.push(this.smartGradient(x, y, slice));
    }
    return _results;
  };

  PieChart_Renderer_Bevel.prototype.getSmartGradient = function(x, y, sr0, sr1, side, position) {
    var c1, c2, e, gradient, n, x1, x2, y1, y2;
    n = "g" + side + position + sr0 + sr1;
    if ((this.gradients[n] != null) && false) {
      return this.gradients[n];
    }
    if (side === "inside") {
      if (position === "top") {
        y1 = x1 = x2 = y2 = 0;
        y1 = sr1 - sr0;
        y2 = y;
        c1 = "rgba(0,0,0,0.3)";
        c2 = "rgba(0,0,0,0)";
      } else {
        y1 = x1 = x2 = y2 = 0;
        y1 = y;
        y2 = y + sr0;
        c1 = "rgba(255,255,255,0)";
        c2 = "rgba(255,255,255,0.3)";
      }
    } else {
      if (position === "top") {
        y1 = x1 = x2 = y2 = 0;
        y2 = y;
        c1 = "rgba(255,255,255,0.3)";
        c2 = "rgba(255,255,255,0)";
      } else {
        y1 = x1 = x2 = y2 = 0;
        y1 = y;
        y2 = y + sr1;
        c1 = "rgba(0,0,0,0)";
        c2 = "rgba(0,0,0,0.3)";
      }
    }
    try {
      gradient = this.g.createLinearGradient(x1, y1, x2, y2);
      gradient.addColorStop(0, c1);
      gradient.addColorStop(1, c2);
      this.gradients[n] = gradient;
      return gradient;
    } catch (_error) {
      e = _error;
      debugger;
      throw "Could not create linear gradient: " + e;
    }
  };

  PieChart_Renderer_Bevel.prototype.smartOuterShineTop = function(x, y, sr0, sr1, a1, a2, a3, a4) {
    var s;
    if (a1 > 0 && a2 < Math.PI) {
      return;
    }
    if (a2 > 0 && a1 < 0) {
      a2 = 0;
      a4 = 0;
    }
    if (a1 > 0 && a1 < Math.PI) {
      a1 = Math.PI;
      a3 = Math.PI;
    }
    s = {
      renderParams: [sr1 - 0.1 * (sr1 - sr0), sr1, a1, a2, a3, a4],
      x: 0,
      y: 0
    };
    s.fillColor = this.getSmartGradient(x, y, sr0, sr1, "outside", "top");
    return this.strokeAndPaint(this.g, x, y, s);
  };

  PieChart_Renderer_Bevel.prototype.smartOuterShineBottom = function(x, y, sr0, sr1, a1, a2, a3, a4) {
    var s;
    if (a2 < 0 || a1 > Math.PI) {
      return;
    }
    if (a1 < 0) {
      a1 = 0;
      a3 = 0;
    }
    if (a2 > Math.PI) {
      a2 = Math.PI;
      a4 = Math.PI;
    }
    s = {
      renderParams: [sr1 - 0.1 * (sr1 - sr0), sr1, a1, a2, a3, a4],
      x: 0,
      y: 0
    };
    s.fillColor = this.getSmartGradient(x, y, sr0, sr1, "outside", "bottom");
    return this.strokeAndPaint(this.g, x, y, s);
  };

  PieChart_Renderer_Bevel.prototype.smartInnerShineTop = function(x, y, sr0, sr1, a1, a2, a3, a4) {
    var s;
    if (a1 > 0 && a2 < Math.PI) {
      return;
    }
    if (a2 > 0 && a1 < 0) {
      a2 = 0;
      a4 = 0;
    }
    if (a1 > 0 && a1 < Math.PI) {
      a1 = Math.PI;
      a3 = Math.PI;
    }
    s = {
      renderParams: [sr0, sr0 + 0.1 * (sr1 - sr0), a1, a2, a3, a4],
      x: 0,
      y: 0
    };
    s.fillColor = this.getSmartGradient(x, y, sr0, sr1, "inside", "top");
    return this.strokeAndPaint(this.g, x, y, s);
  };

  PieChart_Renderer_Bevel.prototype.smartInnerShineBottom = function(x, y, sr0, sr1, a1, a2, a3, a4) {
    var s;
    if (a2 < 0 || a1 > Math.PI) {
      return;
    }
    if (a1 < 0) {
      a1 = 0;
      a3 = 0;
    }
    if (a2 > Math.PI) {
      a2 = Math.PI;
      a4 = Math.PI;
    }
    s = {
      renderParams: [sr0, sr0 + 0.1 * (sr1 - sr0), a1, a2, a3, a4],
      x: 0,
      y: 0
    };
    s.fillColor = this.getSmartGradient(x, y, sr0, sr1, "inside", "bottom");
    return this.strokeAndPaint(this.g, x, y, s);
  };

  PieChart_Renderer_Bevel.prototype.smartGradient = function(x, y, slice) {
    var a1, a2, a3, a4, sr0, sr1;
    x = x + slice.x;
    y = y + slice.y;
    sr0 = slice.renderParams[0];
    sr1 = slice.renderParams[1];
    a1 = slice.renderParams[2];
    a2 = slice.renderParams[3];
    a3 = slice.renderParams[4];
    a4 = slice.renderParams[5];
    this.smartOuterShineTop(x, y, sr0, sr1, a1, a2, a3, a4);
    this.smartOuterShineBottom(x, y, sr0, sr1, a1, a2, a3, a4);
    this.smartInnerShineTop(x, y, sr0, sr1, a1, a2, a3, a4);
    this.smartInnerShineBottom(x, y, sr0, sr1, a1, a2, a3, a4);
  };

  return PieChart_Renderer_Bevel;

})(PieChart_Renderer_Base);
// Generated by CoffeeScript 1.8.0
var Linearchart_Renderer_Columns;

Linearchart_Renderer_Columns = (function() {
  "use strict";
  function Linearchart_Renderer_Columns(scene, series) {
    this.scene = scene;
    this.series = series;
    this.prevy = [];
  }

  Linearchart_Renderer_Columns.prototype.paintStack = function(context, centers, radii, ystack, styles, zeroY) {
    var approxWidth, i, prevy, ser, series, style, _i, _j, _len, _ref, _results;
    this.zeroY = zeroY;
    if (!(centers.length > 0)) {
      return;
    }
    series = this.series;
    prevy = this.prevy;
    if (prevy.length < centers.length) {
      prevy = this.prevy = new Array(centers.length);
    }
    for (i = _i = 0, _ref = centers.length - 1; _i <= _ref; i = _i += 1) {
      prevy[i] = zeroY;
    }
    approxWidth = radii[0] + radii[radii.length - 1];
    _results = [];
    for (i = _j = 0, _len = series.length; _j < _len; i = ++_j) {
      ser = series[i];
      style = styles[i];
      if (approxWidth >= 2 || style) {
        _results.push(this.plainColumns(context, ser.style, centers, radii, prevy, ystack, style, i));
      } else {
        _results.push(this.outline(context, ser.style, centers, radii, prevy, ystack[i]));
      }
    }
    return _results;
  };

  Linearchart_Renderer_Columns.prototype.hitTest = function(centers, radii, ystack, styles, zeroY, x, y, tolerance) {
    var d, distance, i, len, result, ser, series, x0, x0a, x1, x1a, xind, y0, y00, y1, y11, yy, _i, _len;
    len = centers.length;
    if (!(len > 1)) {
      return [null, Infinity];
    }
    series = this.series;
    xind = Base_Helpers.binSearch(centers, x);
    x0 = centers[xind] - radii[xind];
    x1 = centers[xind] + radii[xind];
    if (x0 > x && xind > 0) {
      x0a = centers[xind - 1] - radii[xind - 1];
      x1a = centers[xind - 1] + radii[xind - 1];
      if (x1a > x || Math.abs(x1a - x) < Math.abs(x0 - x)) {
        xind -= 1;
        x0 = x0a;
        x1 = x1a;
      }
    }
    result = null;
    distance = Infinity;
    y0 = zeroY;
    for (i = _i = 0, _len = series.length; _i < _len; i = ++_i) {
      ser = series[i];
      yy = ystack[i][xind];
      if (yy !== null) {
        y1 = y0 - yy;
        y00 = Math.min(y0, y1);
        y11 = Math.max(y0, y1);
        d = Base_Geometry.distanceToRect(x, y, x0, y00, x1, y11);
        if (d < distance) {
          distance = d;
          result = {
            x0: x0,
            y0: y00,
            x1: x1,
            y1: y11,
            seriesIndex: i,
            isMarker: false
          };
        }
        y0 = y1;
      }
    }
    return [result, distance];
  };

  Linearchart_Renderer_Columns.prototype.outline = function(context, style, centers, radii, ybase, yvalues) {
    var i, len, prevX, x0, x1, y, y0, zeroY, _i, _ref, _results;
    len = centers.length;
    if (!(len > 1)) {
      return;
    }
    if (style.strokeStyle) {
      context.fillStyle = style.lineColor;
    } else {
      context.fillStyle = style.fillColor;
    }
    zeroY = this.zeroY;
    _results = [];
    for (i = _i = 0, _ref = len - 1; _i <= _ref; i = _i += 1) {
      x0 = centers[i] - radii[i];
      x1 = centers[i] + radii[i];
      y = yvalues[i];
      if (y !== null) {
        y0 = ybase[i];
        y = zeroY - y;
        context.fillRect(x0, y0, x1 - x0 + 0.5, y - y0);
        ybase[i] = y;
      }
      _results.push(prevX = x1);
    }
    return _results;
  };

  Linearchart_Renderer_Columns.prototype.plainColumns = function(context, style, centers, radii, ybase, yvaluesAll, styles, yindex) {
    var bottom, center, cheight, cleft, ctop, curStyle, cwidth, dashContext, depth, depthColor, diff, fillStyle, frac, h, i, isFirst, isLast, j, minHeight, newStyle, paintTop, r, shadowColor, strokeWidth, top, v, y, y0, y1, yvalues, zeroY, _i, _j, _len, _len1, _ref, _ref1, _results;
    _ref = [this.scene.y0, this.scene.height], top = _ref[0], h = _ref[1];
    minHeight = style.minHeight;
    bottom = top + h;
    zeroY = this.zeroY;
    yvalues = yvaluesAll[yindex];
    curStyle = null;
    depth = style.depth;
    shadowColor = style.shadowColor;
    _results = [];
    for (i = _i = 0, _len = centers.length; _i < _len; i = ++_i) {
      center = centers[i];
      y = yvalues[i];
      if (y === null) {
        continue;
      }
      r = radii[i];
      y0 = ybase[i];
      y1 = y0 - y;
      ybase[i] = y1;
      cleft = center - r;
      cwidth = r + r;
      if (y0 < y1) {
        cheight = Math.max(y1 - y0, minHeight);
        ctop = y0;
        isFirst = true;
        j = yindex - 1;
        while (j > 0) {
          if (yvaluesAll[j][i] !== null) {
            isFirst = false;
            break;
          }
          j--;
        }
        paintTop = isFirst;
      } else if (y0 > y1) {
        cheight = Math.max(y0 - y1, minHeight);
        ctop = y0 - cheight;
        isLast = true;
        j = yindex + 1;
        while (j < yvaluesAll.length) {
          if (yvaluesAll[j][i] !== null) {
            isLast = false;
            break;
          }
          j++;
        }
        paintTop = isLast;
      } else {
        continue;
      }
      newStyle = styles ? styles[i] : style;
      if (!newStyle) {
        newStyle = style;
      }
      if (curStyle !== newStyle) {
        curStyle = newStyle;
        if (curStyle.lineColor) {
          strokeWidth = curStyle.lineWidth;
        } else {
          strokeWidth = 0;
        }
        if (curStyle.currentFillGradient) {
          fillStyle = curStyle.currentFillGradient;
        } else {
          fillStyle = curStyle.fillColor;
          if ((curStyle.gradient != null) && curStyle.gradient !== 1 && fillStyle) {
            fillStyle = context.createLinearGradient(0, bottom, 0, bottom - h * 2 / 3);
            fillStyle.addColorStop(0, Base_Graphics.deriveColor(curStyle.fillColor, curStyle.gradient, 1));
            fillStyle.addColorStop(1, curStyle.fillColor);
          }
        }
        context.fillStyle = fillStyle;
        if (curStyle.fillColor && depth) {
          depthColor = curStyle.fillColor;
          if (curStyle.depthBrightness != null) {
            depthColor = Base_Graphics.deriveColor(depthColor, curStyle.depthBrightness, 1);
          }
        } else {
          depthColor = null;
        }
      }
      if (depthColor) {
        context.beginPath();
        Base_Graphics.applyShadow(context, curStyle);
        if (!paintTop) {
          context.moveTo(cleft + cwidth, ctop);
          context.lineTo(cleft + cwidth + depth, ctop - depth);
          context.lineTo(cleft + cwidth + depth, ctop + cheight - depth);
          context.lineTo(cleft + cwidth, ctop + cheight);
          context.lineTo(cleft + cwidth, ctop);
        } else {
          context.moveTo(cleft + depth, ctop - depth);
          context.lineTo(cleft + cwidth + depth, ctop - depth);
          context.lineTo(cleft + cwidth + depth, ctop + cheight - depth);
          context.lineTo(cleft + cwidth, ctop + cheight);
          context.lineTo(cleft + cwidth, ctop);
          context.lineTo(cleft, ctop);
        }
        context.closePath();
        context.fillStyle = depthColor;
        context.fill();
        Base_Graphics.clearShadow(context);
        context.fillStyle = fillStyle;
      }
      if (!depthColor && shadowColor) {
        Base_Graphics.applyShadow(context, curStyle);
      }
      if (fillStyle) {
        context.fillRect(cleft, ctop, cwidth, cheight);
        if (!depthColor && shadowColor) {
          Base_Graphics.clearShadow(context);
        }
      }
      if (strokeWidth > 0) {
        ctop += strokeWidth / 2;
        cleft += strokeWidth / 2;
        cwidth -= strokeWidth;
        cheight -= strokeWidth;
        dashContext = Base_Graphics.beginStroke(context, curStyle);
        if (cwidth > 0) {
          if (cheight > 0) {
            dashContext.moveTo(cleft, ctop);
            dashContext.lineTo(cleft + cwidth, ctop);
            dashContext.lineTo(cleft + cwidth, ctop + cheight);
            dashContext.lineTo(cleft, ctop + cheight);
            dashContext.lineTo(cleft, ctop);
          } else if (strokeWidth > 0) {
            context.moveTo(cleft, y0);
            context.lineTo(cleft + cwidth, y0);
          }
        } else if (strokeWidth > 0) {
          context.moveTo(center, ctop);
          context.lineTo(center, ctop + cheight);
        }
        Base_Graphics.endStroke(context, dashContext, curStyle);
      }
      if (!fillStyle && !depthColor && shadowColor) {
        Base_Graphics.clearShadow(context);
      }
      if (curStyle.previewData) {
        context.beginPath();
        frac = 0;
        diff = y1 - y0;
        _ref1 = curStyle.previewData;
        for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
          v = _ref1[_j];
          frac += v;
          y = y0 + frac * diff;
          context.moveTo(cleft, y);
          context.lineTo(cleft + cwidth, y);
        }
        context.lineWidth = 1;
        context.strokeStyle = curStyle.previewLineColor;
        _results.push(context.stroke());
      } else {
        _results.push(void 0);
      }
    }
    return _results;
  };

  return Linearchart_Renderer_Columns;

})();
// Generated by CoffeeScript 1.8.0
var Linearchart_Renderer_Line;

Linearchart_Renderer_Line = (function() {
  "use strict";
  function Linearchart_Renderer_Line(series) {
    var s, _i, _len;
    this.series = series;
    this.centers = [];
    this.seriesData = [];
    for (_i = 0, _len = series.length; _i < _len; _i++) {
      s = series[_i];
      this.seriesData.push({
        markerY: [],
        segments: []
      });
    }
    this.prevyL = [];
    this.prevyR = [];
  }

  Linearchart_Renderer_Line.prototype.paintStack = function(context, centers, radii, ystack, styles, zeroY) {
    var i, ser, _i, _len, _ref, _results;
    this.centers = centers;
    this.styles = styles;
    this.zeroY = zeroY;
    if (!(centers.length > 0)) {
      return;
    }
    this.paintLines(context, this.series, this.seriesData, radii, ystack, zeroY);
    _ref = this.series;
    _results = [];
    for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
      ser = _ref[i];
      _results.push(this.paintMarkers(context, ser, this.centers, ystack[i], this.seriesData[i].markerY));
    }
    return _results;
  };

  Linearchart_Renderer_Line.prototype.paintLines = function(context, series, seriesData, radii, ystack, zeroY) {
    var i, prevSegments, ser, _i, _len, _results;
    this.zeroY = zeroY;
    this.computeLineSegments(radii, this.zeroY, ystack);
    prevSegments = [];
    _results = [];
    for (i = _i = 0, _len = series.length; _i < _len; i = ++_i) {
      ser = series[i];
      this.paintLine(context, ser.style, prevSegments, seriesData[i].segments);
      _results.push(prevSegments = this.seriesData[i].segments);
    }
    return _results;
  };

  Linearchart_Renderer_Line.prototype.paintMarkers = function(context, series, centers, yvalues, ycoords) {
    var fill, j, marker, r, shape, v, _i, _len, _results;
    if (!(series.style.marker && series.style.marker.shape && series.style.marker.width)) {
      return;
    }
    marker = series.style.marker;
    fill = marker.fillColor;
    if (!fill) {
      fill = series.style.lineColor;
    }
    if (!fill) {
      fill = series.style.fillColor;
    }
    context.fillStyle = fill;
    r = marker.width / 2;
    shape = marker.shape;
    _results = [];
    for (j = _i = 0, _len = yvalues.length; _i < _len; j = ++_i) {
      v = yvalues[j];
      if (v === null) {
        continue;
      }
      context.beginPath();
      Base_Graphics.strokeMarker(context, shape, centers[j], ycoords[j], r);
      _results.push(context.fill());
    }
    return _results;
  };

  Linearchart_Renderer_Line.prototype.hitTest = function(centers, radii, ystack, styles, zeroY, x, y, tolerance) {
    var bestDistance, bestResult, data, dd, dist, distToPrevSeries, distanceToSegments, dx, dy, i, j, len, markerDistance, radius, segments, ser, serInd, series, style, v, x0, x1, xind, xlist, xx, y0, y1, ylist, yy, _i, _j, _k, _l, _len, _ref, _ref1, _ref2, _ref3;
    series = this.series;
    centers = this.centers;
    len = centers.length;
    if (!(len > 0)) {
      return [null, Infinity];
    }
    xind = Math.min(Base_Helpers.binSearch(centers, x), len - 2);
    bestResult = null;
    bestDistance = Infinity;
    distToPrevSeries = zeroY - y;
    for (serInd = _i = 0, _len = series.length; _i < _len; serInd = ++_i) {
      ser = series[serInd];
      style = styles[i] ? styles[i][xind] : series[serInd].style;
      data = this.seriesData[serInd];
      for (i = _j = _ref = Math.max(0, xind - 2), _ref1 = Math.min(len, xind + 3); _j < _ref1; i = _j += 1) {
        v = ystack[serInd][i];
        if (v !== null && style.marker) {
          xx = centers[i];
          yy = data.markerY[i];
          radius = style.marker.width / 2;
          dx = x - xx;
          dy = y - yy;
          markerDistance = Math.sqrt(dx * dx + dy * dy);
          if (markerDistance < radius + tolerance && bestDistance > markerDistance - radius) {
            bestDistance = markerDistance - radius;
            bestResult = {
              x0: xx,
              y0: yy,
              x1: xx,
              y1: yy,
              seriesIndex: serInd,
              isMarker: true
            };
          }
        }
      }
      distanceToSegments = null;
      segments = data.segments;
      for (i = _k = 0, _ref2 = segments.length; _k < _ref2; i = _k += 2) {
        xlist = segments[i];
        ylist = segments[i + 1];
        x0 = xlist[0];
        for (j = _l = 1, _ref3 = xlist.length; _l < _ref3; j = _l += 1) {
          x1 = xlist[j];
          if (x0 <= x + tolerance && x1 >= x - tolerance) {
            y0 = ylist[j - 1];
            y1 = ylist[j];
            dist = Math.sqrt(Base_Geometry.distanceToLineSq(x0, y0, x1, y1, x, y));
            if (dist < tolerance && dist <= bestDistance) {
              bestDistance = dist;
              bestResult = {
                x0: x0,
                y0: y0,
                x1: x1,
                y1: y1,
                seriesIndex: serInd,
                isMarker: false
              };
            }
          }
          if (x0 <= x && x1 >= x) {
            y0 = ylist[j - 1];
            y1 = ylist[j];
            dd = Base_Geometry.rayIntersectsLineBidir(x, y, 0, 1, x0, y0, x1, y1);
            if (dd !== Infinity) {
              distanceToSegments = dd;
            }
          }
          x0 = x1;
        }
      }
      if (distanceToSegments !== null) {
        if (Base_Helpers.sign(distanceToSegments) !== Base_Helpers.sign(distToPrevSeries) && (style.fillColor || style.fillGradient)) {
          if (bestDistance >= 0) {
            bestDistance = 0;
            bestResult = {
              x0: 0,
              y0: 0,
              x1: 1,
              y1: 1,
              seriesIndex: serInd,
              isMarker: false
            };
          }
        }
        distToPrevSeries = distanceToSegments;
      }
    }
    return [bestResult, Math.max(bestDistance, 0)];

    /*
      Section: computation
     */
  };

  Linearchart_Renderer_Line.prototype.computeLineSegments = function(radii, zeroY, ystack) {
    var data, i, j, len, prevMarkerY, prevyL, prevyR, ser, _i, _j, _k, _len, _ref, _ref1, _ref2, _ref3, _ref4, _results;
    len = this.centers.length;
    prevyL = this.prevyL;
    prevyR = this.prevyR;
    if (prevyL.length < len) {
      prevyL.length = len;
      prevyR.length = len;
    }
    for (i = _i = 0; _i < len; i = _i += 1) {
      prevyL[i] = zeroY;
      prevyR[i] = zeroY;
    }
    prevMarkerY = prevyL;
    _ref = this.series;
    _results = [];
    for (i = _j = 0, _len = _ref.length; _j < _len; i = ++_j) {
      ser = _ref[i];
      data = this.seriesData[i];
      data.segments.length = 0;
      if (data.markerY.length < len) {
        data.markerY.length = len;
      }
      if (ser.style.steps) {
        _ref1 = this.buildStepSegments(this.centers, radii, zeroY, prevyL, prevyR, prevMarkerY, ystack[i], ser.data.noDataPolicy), data.segments = _ref1[0], data.markerY = _ref1[1];
      } else {
        _ref2 = this.buildLineSegments(this.centers, zeroY, prevyL, prevyR, prevMarkerY, ystack[i], ser.data.noDataPolicy), data.segments = _ref2[0], data.markerY = _ref2[1];
        if (ser.style.smoothing) {
          for (j = _k = 0, _ref3 = data.segments.length; _k < _ref3; j = _k += 2) {
            _ref4 = this.smoothLine(data.segments[j], data.segments[j + 1], ser.style.smoothing), data.segments[j] = _ref4[0], data.segments[j + 1] = _ref4[1];
          }
        }
      }
      _results.push(prevMarkerY = data.markerY);
    }
    return _results;
  };

  Linearchart_Renderer_Line.prototype.buildLineSegments = function(centers, zeroY, prevYL, prevYR, prevMarker, newY, nodataPolicy) {
    var coef, hasPrev, i, j, lastInd, markerY, ppyL, ppyR, pyL, pyR, segments, x, x0, xe, xx, ye, yinc, yinc0, yyinc, _i, _j, _k, _l, _ref, _ref1, _ref2, _ref3;
    markerY = [];
    xe = [];
    ye = [];
    if (nodataPolicy === "zero") {
      for (i = _i = 0, _ref = centers.length; _i < _ref; i = _i += 1) {
        x = centers[i];
        yinc = newY[i];
        pyL = prevYL[i];
        pyR = prevYR[i];
        if (yinc !== null) {
          markerY.push(prevMarker[i] - yinc);
          xe.push(x);
          ye.push(pyL - yinc);
          if (pyL !== pyR) {
            xe.push(x);
            ye.push(pyR - yinc);
          }
          prevYL[i] -= yinc;
          prevYR[i] -= yinc;
        } else {
          markerY.push(prevMarker[i]);
          if (pyL !== pyR) {
            ye.push(pyL);
            ye.push(pyR);
            xe.push(x);
            xe.push(x);
          } else {
            ye.push(pyL);
            xe.push(x);
          }
        }
      }
      return [[xe, ye], markerY];
    } else if (nodataPolicy === "join") {
      lastInd = null;
      for (i = _j = 0, _ref1 = centers.length; _j < _ref1; i = _j += 1) {
        x = centers[i];
        yinc = newY[i];
        pyL = prevYL[i];
        pyR = prevYR[i];
        if (yinc !== null) {
          if (lastInd === null) {
            markerY.push(prevMarker[i] - yinc);
            xe.push(x);
            ye.push(pyR - yinc);
            prevYR[i] -= yinc;
          } else {
            if (lastInd < i - 1) {
              yinc0 = newY[lastInd];
              x0 = centers[lastInd];
              coef = (yinc - yinc0) / (x - x0);
              for (j = _k = _ref2 = lastInd + 1; _k < i; j = _k += 1) {
                xx = centers[j];
                yyinc = yinc0 + coef * (xx - x0);
                markerY.push(prevMarker[j] - yyinc);
                ppyL = prevYL[j];
                ppyR = prevYR[j];
                xe.push(xx);
                ye.push(ppyL - yyinc);
                if (ppyL !== ppyR) {
                  xe.push(xx);
                  ye.push(ppyR - yyinc);
                }
                prevYL[j] -= yyinc;
                prevYR[j] -= yyinc;
              }
            }
            markerY.push(prevMarker[i] - yinc);
            xe.push(x);
            ye.push(pyL - yinc);
            if (pyL !== pyR) {
              xe.push(x);
              ye.push(pyR - yinc);
            }
            prevYL[i] -= yinc;
            prevYR[i] -= yinc;
          }
          lastInd = i;
        } else {
          if (lastInd === null) {
            markerY.push(prevMarker[i]);
          }
        }
      }
      if (xe.length > 2 && (xe[xe.length - 1] === xe[xe.length - 2])) {
        xe.pop();
        ye.pop();
      }
      return [[xe, ye], markerY];
    } else {
      hasPrev = false;
      segments = [];
      for (i = _l = 0, _ref3 = centers.length; _l < _ref3; i = _l += 1) {
        x = centers[i];
        yinc = newY[i];
        pyL = prevYL[i];
        pyR = prevYR[i];
        if (yinc !== null) {
          markerY.push(prevMarker[i] - yinc);
          if (hasPrev) {
            if (xe.length > 1 && prevYL[i - 1] !== prevYR[i - 1]) {
              xe.push(centers[i - 1]);
              ye.push(prevYR[i - 1]);
            }
            xe.push(x);
            ye.push(pyL - yinc);
            prevYL[i] -= yinc;
            prevYR[i] -= yinc;
          } else {
            xe.push(x);
            ye.push(pyR - yinc);
            prevYR[i] -= yinc;
          }
          hasPrev = true;
        } else {
          markerY.push(prevMarker[i]);
          if (hasPrev) {
            if (xe.length > 0) {
              if (xe.length === 1) {
                xe.push(xe[0]);
                ye.push(ye[0]);
              }
              segments.push(xe, ye);
              xe = [];
              ye = [];
            }
            prevYR[i - 1] += newY[i - 1];
          } else {
            1;
          }
          hasPrev = false;
        }
      }
      if (xe.length > 0) {
        if (xe.length === 1) {
          xe.push(xe[0]);
          ye.push(ye[0]);
        }
        segments.push(xe, ye);
      }
      return [segments, markerY];
    }
  };

  Linearchart_Renderer_Line.prototype.buildStepSegments = function(centers, radii, zeroY, prevYL, prevYR, prevMarkerY, newY, nodataPolicy) {
    var i, markerY, mv, segments, x, x0, xe, y, y0, ye, _i, _ref;
    segments = [];
    markerY = [];
    xe = [];
    ye = [];
    y0 = null;
    x0 = 0;
    for (i = _i = 0, _ref = centers.length; _i < _ref; i = _i += 1) {
      x = centers[i] - radii[i];
      y = newY[i];
      if (y !== null) {
        if (y0 !== null) {
          xe.push(x);
          ye.push(y0);
        }
        mv = prevMarkerY[i] - y;
        xe.push(x);
        ye.push(mv);
        y0 = mv;
        x0 = x + radii[i] * 2;
        markerY.push(mv);
        prevYL[i] = prevYR[i] = mv;
      } else {
        if (nodataPolicy === "zero") {
          mv = prevMarkerY[i];
          markerY.push(mv);
          prevYR[i] = prevYL[i] = mv;
          if (y0 !== null) {
            xe.push(x0);
            ye.push(y0);
          }
          xe.push(x);
          ye.push(mv);
          y0 = mv;
          x0 = x + radii[i] * 2;
        } else if (nodataPolicy === "join") {
          mv = y0 !== null ? y0 : prevMarkerY[i];
          markerY.push(mv);
          prevYR[i] = prevYL[i] = mv;
        } else {
          mv = prevMarkerY[i];
          markerY.push(mv);
          prevYR[i] = prevYL[i] = mv;
          if (xe.length > 0) {
            if (y0 !== null) {
              xe.push(x0);
              ye.push(y0);
            }
            y0 = null;
            segments.push(xe, ye);
            xe = [];
            ye = [];
          }
        }
      }
    }
    if (xe.length > 0) {
      if (y0 !== null) {
        xe.push(x0);
        ye.push(y0);
      }
      segments.push(xe, ye);
    }
    return [segments, markerY];
  };

  Linearchart_Renderer_Line.prototype.smoothLine = function(xlist, ylist, smoothing) {
    var c, dx, i, i0, i1, intermediatePoints, ist, newx, newy, pointDistance, x, x1, y1, _i, _ref;
    x = xlist[0];
    x1 = xlist[xlist.length - 1];
    pointDistance = (x1 - x) / xlist.length;
    if (pointDistance < 2) {
      return [xlist, ylist];
    }
    newx = [];
    newy = [];
    newx.push(x);
    newy.push(ylist[0]);
    i0 = 0;
    while (i0 + 1 < xlist.length) {
      i1 = i0 + 1;
      if (xlist[i0] !== xlist[i1]) {
        while (i1 + 1 < xlist.length && xlist[i1] !== xlist[i1 + 1]) {
          i1 += 1;
        }
      }
      if (i1 - i0 === 1) {
        newx.push(xlist[i1]);
        newy.push(ylist[i1]);
      } else {
        c = new Base_MonotoneCurve(xlist, ylist, i0, i1 + 1);
        x1 = xlist[i0];
        for (i = _i = _ref = i0 + 1; _i <= i1; i = _i += 1) {
          x = x1;
          x1 = xlist[i];
          y1 = ylist[i];
          pointDistance = x1 - x;
          intermediatePoints = Math.ceil(Math.min(50, Math.max(2, pointDistance / 3)));
          dx = pointDistance / intermediatePoints;
          ist = newx.length;
          while ((x += dx) < x1) {
            newx.push(x);
          }
          c.interpolateArray(i - 1, newx, ist, newx.length, newy);
          newx.push(x1);
          newy.push(y1);
        }
        c.clear();
      }
      i0 = i1;
    }
    xlist.length = 0;
    ylist.length = 0;
    return [newx, newy];

    /*
      Paint operations
     */
  };

  Linearchart_Renderer_Line.prototype.paintLine = function(context, style, prevSegments, segments) {
    var i, strokeContext, xlist, ylist, _i, _j, _k, _ref, _ref1, _ref2;
    if (style.fillColor || style.currentFillGradient) {
      if (style.shadowColor) {
        Base_Graphics.applyShadow(context, style);
      }
      if (style.currentFillGradient) {
        context.fillStyle = style.currentFillGradient;
      } else {
        context.fillStyle = style.fillColor;
      }
      context.beginPath();
      for (i = _i = 0, _ref = segments.length - 1; _i <= _ref; i = _i += 2) {
        this.paintArea(context, segments[i], segments[i + 1], prevSegments);
      }
      context.fill();
      if (style.shadowColor) {
        Base_Graphics.clearShadow(context);
      }
    }
    if (style.lineColor) {
      if (!style.fillColor && style.shadowColor) {
        Base_Graphics.applyShadow(context, style);
      }
      strokeContext = Base_Graphics.beginStroke(context, style);
      for (i = _j = 0, _ref1 = segments.length - 1; _j <= _ref1; i = _j += 2) {
        xlist = segments[i];
        ylist = segments[i + 1];
        strokeContext.moveTo(xlist[0], ylist[0]);
        for (i = _k = 1, _ref2 = xlist.length; _k < _ref2; i = _k += 1) {
          strokeContext.lineTo(xlist[i], ylist[i]);
        }
      }
      Base_Graphics.endStroke(context, strokeContext, style);
      if (!style.fillColor && style.shadowColor) {
        return Base_Graphics.clearShadow(context);
      }
    }
  };

  Linearchart_Renderer_Line.prototype.paintArea = function(context, xlist, ylist, previousSegments) {
    var curY, curx, i, j, l, prevY, prevx, prop, x, x0, x1, xx, y, yy, yz, _i, _j, _k, _ref, _ref1;
    context.moveTo(xlist[0], ylist[0]);
    for (i = _i = 1, _ref = xlist.length - 1; _i <= _ref; i = _i += 1) {
      context.lineTo(xlist[i], ylist[i]);
    }
    x0 = xlist[0];
    x1 = xlist[xlist.length - 1];
    yz = this.zeroY;
    x = x1;
    for (j = _j = _ref1 = previousSegments.length - 2; _j >= 0; j = _j += -2) {
      xx = previousSegments[j];
      yy = previousSegments[j + 1];
      if (xx.length < 2 || xx[0] > x || xx[xx.length - 1] < x0) {
        continue;
      }
      l = xx.length - 1;
      prevx = xx[l];
      if (prevx < x) {
        context.lineTo(x, yz);
        context.lineTo(prevx, yz);
        x = prevx;
      }
      for (i = _k = l; _k >= 0; i = _k += -1) {
        curx = xx[i];
        if (x === prevx) {
          context.lineTo(prevx, yy[i + 1]);
          x = curx;
        } else if (x < prevx && x > curx) {
          curY = yy[i];
          prevY = yy[i + 1];
          prop = (x - curx) / (prevx - curx);
          y = curY + prop * (prevY - curY);
          context.lineTo(x, y);
          x = curx;
        }
        if (x <= x0) {
          x = x0;
          curY = yy[i];
          prevY = yy[i + 1];
          prop = (x - curx) / (prevx - curx);
          y = curY + prop * (prevY - curY);
          context.lineTo(x, y);
          break;
        }
        prevx = curx;
      }
      if (i === -1 && x === curx) {
        context.lineTo(x, yy[0]);
      }
    }
    if (x !== x0) {
      context.lineTo(x, yz);
      context.lineTo(x0, yz);
    }
    return context.closePath();
  };

  return Linearchart_Renderer_Line;

})();
// Generated by CoffeeScript 1.8.0
var Base_Helpers, lastTime, rafFunc,
  __hasProp = {}.hasOwnProperty;

if (typeof String.prototype.trim === "undefined") {
  String.prototype.trim = function() {
    return this.replace(/^\s\s*/, '').replace(/\s\s*$/, '');
  };
}

if (!window.requestAnimationFrame) {
  rafFunc = window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || window.msRequestAnimationFrame || window.oRequestAnimationFrame;
  if (!rafFunc) {
    lastTime = 0;
    rafFunc = function(callback) {
      var currTime, id, timeToCall;
      currTime = new Date().getTime();
      timeToCall = Math.max(0, 16 - (currTime - lastTime));
      id = window.setTimeout(function() {
        return callback(currTime + timeToCall);
      }, timeToCall);
      lastTime = currTime + timeToCall;
      return id;
    };
  }
  window.requestAnimationFrame = rafFunc;
}

Base_Helpers = (function() {
  "use strict";
  var aggregationCallbacks, decodeTextarea;

  function Base_Helpers() {}

  Base_Helpers.extend = function(object, other) {
    var key, val;
    if (object == null) {
      return {};
    }
    for (key in other) {
      if (!__hasProp.call(other, key)) continue;
      val = other[key];
      object[key] = val;
    }
    return object;
  };

  Base_Helpers.extendDataItem = function(object, other) {
    var key, val;
    for (key in other) {
      if (!__hasProp.call(other, key)) continue;
      val = other[key];
      if (key === "style" && object.style) {
        Base_Helpers.extendDeep(object.style, val);
      } else {
        object[key] = val;
      }
    }
    return object;
  };

  Base_Helpers.extendDeep = function(object, other) {
    var key, val, valBefore;
    if (object == null) {
      return other;
    }
    for (key in other) {
      if (!__hasProp.call(other, key)) continue;
      val = other[key];
      valBefore = object[key];
      if (Base_Helpers.isObject(valBefore) && Base_Helpers.isObject(val) && !Base_Helpers.isDomObject(valBefore) && !Base_Helpers.isDomObject(val)) {
        this.extendDeep(valBefore, val);
      } else {
        object[key] = val;
      }
    }
    return object;
  };

  Base_Helpers.extendCopy = function(object, other) {
    var key, val, valBefore;
    if (other == null) {
      return object;
    }
    for (key in other) {
      if (!__hasProp.call(other, key)) continue;
      val = other[key];
      valBefore = object[key];
      if (this.isObject(valBefore) && this.isObject(val)) {
        this.extendCopy(valBefore, val);
      } else if (this.isObject(val) && !this.isArray(val)) {
        object[key] = this.extendCopy({}, val);
      } else {
        object[key] = val;
      }
    }
    return object;
  };

  Base_Helpers.configure = function(object, defaults) {
    var v;
    for (v in defaults) {
      if (typeof object[v] === "undefined" && defaults[v]) {
        object[v] = defaults[v];
      }
    }
    return object;
  };

  Base_Helpers.clone = function(obj) {
    var key, r, val;
    r = {};
    for (key in obj) {
      if (!__hasProp.call(obj, key)) continue;
      val = obj[key];
      r[key] = val;
    }
    return r;
  };

  Base_Helpers.isArray = function(source) {
    return source instanceof Array;
  };

  Base_Helpers.isObject = function(source) {
    return source !== null && typeof source === "object";
  };

  Base_Helpers.isDomObject = function(source) {
    return source !== null && source instanceof Element;
  };

  Base_Helpers.isFunction = function(source) {
    return typeof source === "function";
  };

  Base_Helpers.isNumber = function(n) {
    return !isNaN(parseFloat(n)) && isFinite(n);
  };

  Base_Helpers.isString = function(source) {
    return Object.prototype.toString.call(source) === '[object String]';
  };

  Base_Helpers.hasProperties = function(o) {
    var k, v;
    if (!o) {
      return false;
    }
    for (k in o) {
      if (!__hasProp.call(o, k)) continue;
      v = o[k];
      return true;
    }
    return false;
  };

  Base_Helpers.removeProperty = function(o) {
    var k, v;
    for (k in o) {
      if (!__hasProp.call(o, k)) continue;
      v = o[k];
      delete o[k];
      return k;
    }
    return null;
  };

  Base_Helpers.removePropertyValue = function(o) {
    var k, v;
    for (k in o) {
      if (!__hasProp.call(o, k)) continue;
      v = o[k];
      delete o[k];
      return [k, v];
    }
    return null;
  };

  Base_Helpers.countProperties = function(o) {
    var c, k, v;
    c = 0;
    for (k in o) {
      if (!__hasProp.call(o, k)) continue;
      v = o[k];
      c += 1;
    }
    return c;
  };

  Base_Helpers.realClone = function(source) {
    var a, d, k, o, v, _i, _len;
    o = this.isObject(source);
    a = this.isArray(source);
    if (a) {
      d = [];
      for (k = _i = 0, _len = source.length; _i < _len; k = ++_i) {
        v = source[k];
        if (typeof v !== "function") {
          d[k] = this.realClone(v);
        } else {
          d[k] = v;
        }
      }
    } else if (o) {
      d = {};
      for (k in source) {
        v = source[k];
        if (typeof v !== "function") {
          d[k] = this.realClone(v);
        } else {
          d[k] = v;
        }
      }
    } else {
      d = source;
    }
    return d;
  };

  Base_Helpers.arrayContains = function(arr, item) {
    var i, _i, _len;
    for (_i = 0, _len = arr.length; _i < _len; _i++) {
      i = arr[_i];
      if (i === item) {
        return true;
      }
    }
    return false;
  };

  Base_Helpers.indexOf = function(arr, item) {
    var i, v, _i, _len;
    for (i = _i = 0, _len = arr.length; _i < _len; i = ++_i) {
      v = arr[i];
      if (v === item) {
        return i;
      }
    }
    return -1;
  };

  Base_Helpers.removeFromArray = function(arr, item) {
    var i, removed, v;
    removed = false;
    for (i in arr) {
      v = arr[i];
      if (v === item) {
        arr.splice(i, 1);
        removed = true;
      }
    }
    return removed;
  };

  Base_Helpers.arraysEqual = function(arr1, arr2) {
    var i, _i, _ref;
    if (!((arr1 != null) && (arr2 != null))) {
      return false;
    }
    if (arr1.length !== arr2.length) {
      return false;
    }
    for (i = _i = 0, _ref = arr1.length - 1; _i <= _ref; i = _i += 1) {
      if (arr1[i] !== arr2[i]) {
        return false;
      }
    }
    return true;
  };

  Base_Helpers.arrayToMap = function(arr, key) {
    var c, dict, i, _i, _len;
    dict = {};
    for (i = _i = 0, _len = arr.length; _i < _len; i = ++_i) {
      c = arr[i];
      c.index = i;
      dict[c[key]] = c;
    }
    return dict;
  };

  Base_Helpers.log = function(message, arg) {
    if (typeof console !== "undefined" && console !== null) {
      if (arg != null) {
        return console.info(message, arg);
      } else {
        return console.info(message);
      }
    }
  };

  Base_Helpers.error = function(message, arg) {
    if (typeof console !== "undefined" && console !== null) {
      if (arg != null) {
        return console.error(message, arg);
      } else {
        return console.error(message);
      }
    }
  };

  Base_Helpers.getExtension = function(name) {
    var re;
    re = /(?:\.([^.]+))?$/;
    return re.exec(name)[1];
  };

  Base_Helpers.createDom = function(tagName, cl, innerHtml, container) {
    var el;
    el = document.createElement(tagName);
    if (cl != null) {
      el.className = cl;
    }
    if (innerHtml != null) {
      el.innerHTML = innerHtml;
    }
    if (container != null) {
      container.appendChild(el);
    }
    return el;
  };

  Base_Helpers.createStyledDom = function(tagName, style, innerHtml, container) {
    var el, k, v;
    el = document.createElement(tagName);
    if (style != null) {
      for (k in style) {
        if (!__hasProp.call(style, k)) continue;
        v = style[k];
        el.style[k] = v;
      }
    }
    if (innerHtml != null) {
      el.innerHTML = innerHtml;
    }
    if (container != null) {
      container.appendChild(el);
    }
    return el;
  };

  Base_Helpers.hasClass = function(el, name) {
    return (el.className.length > 0) && new RegExp("(^|\\s)" + name + "(\\s|$)").test(el.className);
  };

  Base_Helpers.addClass = function(el, name) {
    if (!Base_Helpers.hasClass(el, name)) {
      if (el.className.length === 0) {
        return el.className = name;
      } else {
        return el.className = el.className + " " + name;
      }
    }
  };

  Base_Helpers.toggleClass = function(el, name, isPresent) {
    var has;
    has = Base_Helpers.hasClass(el, name);
    if (!isPresent && has) {
      return Base_Helpers.removeClass(el, name);
    } else if (isPresent && !has) {
      return Base_Helpers.addClass(el, name);
    }
  };

  Base_Helpers.removeClass = function(el, name) {
    var replaceFn;
    replaceFn = function(w, match) {
      if (match === name) {
        return '';
      } else {
        return w;
      }
    };
    return el.className = el.className.replace(/(\S+)\s*/g, replaceFn).replace(/(^\s+|\s+$)/, '');
  };

  Base_Helpers.setClass = function(el, name) {
    return el.className = name;
  };

  Base_Helpers.listen = function(node, event, fn) {
    if (node.addEventListener) {
      return node.addEventListener(event, fn);
    } else {
      return node.attachEvent("on" + event, fn);
    }
  };

  Base_Helpers.unlisten = function(node, event, fn) {
    if (node.removeEventListener) {
      return node.removeEventListener(event, fn);
    } else {
      return node.detachEvent("on" + event, fn);
    }
  };

  Base_Helpers.stopPropagation = function(domEvent) {
    if (domEvent.preventDefault) {
      domEvent.preventDefault();
      return domEvent.stopPropagation();
    } else {
      return domEvent.returnValue = false;
    }
  };

  Base_Helpers.createEvent = function(type) {
    var event;
    if (document.createEvent) {
      event = document.createEvent('Event');
      event.initEvent(type, true, true);
    } else {
      event = document.createEventObject();
    }
    return event;
  };

  Base_Helpers.canvasScaling = function() {
    var r;
    r = 1;
    if (window.devicePixelRatio) {
      r = window.devicePixelRatio;
    } else if (window.screen.systemXDPI) {
      r = window.screen.systemXDPI / window.screen.logicalXDPI;
    }
    return [r, r];
  };

  Base_Helpers.elementPos = function(obj) {
    var box, left, top;
    box = obj.getBoundingClientRect();
    top = box.top + (window.pageYOffset || document.documentElement.scrollTop) - (document.documentElement.clientTop || 0);
    left = box.left + (window.pageXOffset || document.documentElement.scrollLeft) - (document.documentElement.clientLeft || 0);
    return [left, top];
  };

  Base_Helpers.isParentOf = function(parent, child) {
    while (child != null) {
      if (child === parent) {
        return true;
      }
      child = child.parentElement;
    }
    return false;
  };

  Base_Helpers.fadeIn = function(dom) {
    return dom.style.display = "block";
  };

  Base_Helpers.fadeOut = function(dom) {
    return dom.style.display = "none";
  };

  Base_Helpers.hide = function(dom) {
    return dom.style.display = "none";
  };

  Base_Helpers.show = function(dom) {
    return dom.style.display = "block";
  };

  Base_Helpers.getProp = function(obj, route) {
    var part, _i, _len, _ref;
    _ref = route.split(".");
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      part = _ref[_i];
      if (obj.hasOwnProperty(part)) {
        obj = obj[part];
      } else {
        return void 0;
      }
    }
    return obj;
  };

  Base_Helpers.wrapValue = function(obj, route) {
    var part, v, v1, _i, _len, _ref;
    v = obj;
    _ref = route.split(".").reverse();
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      part = _ref[_i];
      v1 = {};
      v1[part] = v;
      v = v1;
    }
    return v;
  };

  Base_Helpers.hasProp = function(obj, route) {
    var part, _i, _len, _ref;
    _ref = route.split(".");
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      part = _ref[_i];
      if (obj.hasOwnProperty(part)) {
        obj = obj[part];
      } else {
        return false;
      }
    }
    return obj !== void 0;
  };

  Base_Helpers.getScroll = function() {
    var body, doc, left, top;
    doc = document.documentElement;
    body = document.body;
    left = doc && doc.scrollLeft || body && body.scrollLeft || 0;
    top = doc && doc.scrollTop || body && body.scrollTop || 0;
    return [left, top];
  };

  Base_Helpers.sign = function(x) {
    if (!x) {
      return 0;
    }
    if (x < 0) {
      return -1;
    }
    return 1;
  };

  Base_Helpers.detectBrowser = function() {
    var m, n, tem, ua;
    n = navigator.appName;
    ua = navigator.userAgent;
    m = ua.match(/(opera|chrome|safari|firefox|msie|phantomjs)\/?\s*(\.?\d+(\.\d+)*)/i);
    if (m && (tem = ua.match(/version\/([\.\d]+)/i)) !== null) {
      m[2] = tem[1];
    }
    if (m) {
      m = [m[1], m[2]];
    } else {
      m = [n, navigator.appVersion, '-?'];
    }
    return m[0].toLowerCase();
  };

  Base_Helpers.nextIdentifier = 0;

  Base_Helpers.getIdentifier = function() {
    return Base_Helpers.nextIdentifier++;
  };

  Base_Helpers.doRequest = function(url, params, success, fail) {
    var o, p, req, _i, _len;
    o = [];
    for (_i = 0, _len = params.length; _i < _len; _i++) {
      p = params[_i];
      o.push("" + (encodeURIComponent(p[0])) + "=" + (encodeURIComponent(p[1])));
    }
    o = o.join("&");
    if (url.indexOf("?") !== -1) {
      url += "&" + o;
    } else {
      url += "?" + o;
    }
    if (window.XMLHttpRequest) {
      req = new XMLHttpRequest();
    } else if (window.ActiveXObject) {
      req = new ActiveXObject("Microsoft.XMLHTTP");
    }
    if (req) {
      req.onreadystatechange = (function(_this) {
        return function() {
          if (req.readyState === 4) {
            if (req.status === 200) {
              return success(req.responseText);
            } else {
              return fail();
            }
          }
        };
      })(this);
      req.open('GET', url, true);
      return req.send('');
    }
  };

  Base_Helpers.openUrl = function(url) {
    if (Base_Helpers.isString(url)) {
      return window.open(url);
    } else {
      return window.open(url.url, url.name, url.specs, url.replace);
    }
  };

  Base_Helpers.parseData = function(text, format, chart) {
    var data, error;
    data = null;
    format = format.toLowerCase();
    if (format === "json" || format === "geojson") {
      if (typeof text === 'string' || text instanceof String) {
        try {
          data = JSON.parse(text);
        } catch (_error) {
          error = _error;
          chart.error("Error: failed to parse JSON response: " + error + ": " + text);
          data = {
            error: "Error: failed to parse JSON response"
          };
        }
      } else {
        data = text;
      }
    } else {
      chart.error("Unsupported data format: " + format);
    }
    return data;
  };

  Base_Helpers.numberFormat = function(n, decPlaces, decSeparator, thouSeparator) {
    var i, j, sign;
    if (decPlaces == null) {
      decPlaces = 2;
    }
    if (decSeparator == null) {
      decSeparator = ".";
    }
    if (thouSeparator == null) {
      thouSeparator = "&nbsp;";
    }
    n = parseFloat(n);
    sign = n < 0 ? "-" : "";
    i = parseInt(n = Math.abs(+n || 0).toFixed(decPlaces)) + "";
    j = (j = i.length) > 3 ? j % 3 : 0;
    return sign + (j ? i.substr(0, j) + thouSeparator : "") + i.substr(j).replace(/(\d{3})(?=\d)/g, "$1" + thouSeparator) + (decPlaces ? decSeparator + Math.abs(n - i).toFixed(decPlaces).slice(2) : "");
  };

  Base_Helpers.buildImage = function(src, onLoad, onError) {
    var image, onErrorFunc, onLoadFunc;
    image = new Image();
    onLoadFunc = function() {
      return onLoad(image);
    };
    onErrorFunc = function() {
      return onError(image);
    };
    image.src = src;
    if (image.complete) {
      if (image.width > 0) {
        onLoadFunc();
      } else {
        setTimeout(onLoadFunc, 0);
      }
    } else {
      image.onload = onLoadFunc;
      image.onerror = onErrorFunc;
    }
    return image;
  };

  Base_Helpers.sort = function(sourceArray, compare) {
    var array, array2, i, i1, i2, l1, l2, len, origin, r, step, step2, v1, v2, _i, _j, _k, _l, _ref, _ref1, _ref2, _ref3, _ref4;
    if (!compare) {
      compare = function(a, b) {
        return a - b;
      };
    }
    array = sourceArray;
    len = array.length | 0;
    for (i = _i = 0, _ref = len - 2; _i <= _ref; i = _i += 2) {
      v1 = array[i];
      v2 = array[i + 1];
      if (compare(v1, v2) > 0) {
        array[i] = v2;
        array[i + 1] = v1;
      }
    }
    array2 = array.slice(0);
    step = 2;
    while (step < len) {
      step2 = step << 1;
      for (origin = _j = 0, _ref1 = len - 1; step2 > 0 ? _j <= _ref1 : _j >= _ref1; origin = _j += step2) {
        i1 = origin;
        i2 = origin + step;
        if (i2 >= len) {
          for (i = _k = i1, _ref2 = len - 1; _k <= _ref2; i = _k += 1) {
            array2[i] = array[i];
          }
        } else {
          l1 = i2;
          l2 = Math.min(i2 + step, len);
          r = origin;
          v1 = array[i1];
          v2 = array[i2];
          while (true) {
            if (compare(v1, v2) <= 0) {
              array2[r] = v1;
              r = (r + 1) | 0;
              i1 = (i1 + 1) | 0;
              if (i1 === l1) {
                array2[r] = v2;
                r = (r + 1) | 0;
                i2 = (i2 + 1) | 0;
                while (i2 < l2) {
                  array2[r] = array[i2];
                  r = (r + 1) | 0;
                  i2 = (i2 + 1) | 0;
                }
                break;
              }
              v1 = array[i1];
            } else {
              array2[r] = v2;
              r = (r + 1) | 0;
              i2 = (i2 + 1) | 0;
              if (i2 === l2) {
                array2[r] = v1;
                r = (r + 1) | 0;
                i1 = (i1 + 1) | 0;
                while (i1 < l1) {
                  array2[r] = array[i1];
                  r = (r + 1) | 0;
                  i1 = (i1 + 1) | 0;
                }
                break;
              }
              v2 = array[i2];
            }
          }
        }
      }
      step = step2;
      _ref3 = [array, array2], array2 = _ref3[0], array = _ref3[1];
    }
    if (sourceArray !== array) {
      for (i = _l = 0, _ref4 = len - 1; _l <= _ref4; i = _l += 1) {
        sourceArray[i] = array[i];
      }
      array.length = 0;
    } else {
      array2.length = 0;
    }
    return sourceArray;
  };

  Base_Helpers.binSearch = function(data, value) {

    /*
      Returns index of first item that is >= value
     */
    var i0, i1, ii;
    i0 = 0;
    i1 = data.length - 1;
    while (i0 < i1) {
      ii = ((i1 + i0) / 2) | 0;
      if (data[ii] < value) {
        i0 = ii + 1;
      } else if (data[ii] > value) {
        i1 = ii;
      } else {
        while (ii > 0 && data[ii - 1] === value) {
          ii -= 1;
        }
        return ii;
      }
    }
    if (i0 < data.length && data[i0] < value) {
      return i0 + 1;
    } else {
      return i0;
    }
  };

  Base_Helpers.listenResize = function(element, fn) {
    var scrollListener;
    if (typeof getComputedStyle !== "undefined" && getComputedStyle !== null) {
      scrollListener = function(e) {
        fn();
        return Base_Helpers.updateResize(this);
      };
      if (getComputedStyle(element).position === 'static') {
        element.style.position = 'relative';
      }
      (element.__resizeTriggers__ = document.createElement('div')).className = 'DVSL-resize-triggers';
      element.__resizeTriggers__.innerHTML = '<div class="DVSL-expand-trigger"><div></div></div><div class="DVSL-contract-trigger"></div>';
      element.insertBefore(element.__resizeTriggers__, element.firstChild);
      Base_Helpers.updateResize(element);
      element.__resizeListener__ = scrollListener;
      element.addEventListener('scroll', scrollListener, true);
    }
    return element.onresize = fn;
  };

  Base_Helpers.updateResize = function(element) {
    var contract, expand, expandChild, triggers;
    triggers = element.__resizeTriggers__;
    if (!triggers) {
      return;
    }
    expand = triggers.firstElementChild;
    contract = triggers.lastElementChild;
    expandChild = expand.firstElementChild;
    contract.scrollLeft = contract.scrollWidth;
    contract.scrollTop = contract.scrollHeight;
    expandChild.style.width = expand.offsetWidth + 1 + 'px';
    expandChild.style.height = expand.offsetHeight + 1 + 'px';
    expand.scrollLeft = expand.scrollWidth;
    return expand.scrollTop = expand.scrollHeight;
  };

  Base_Helpers.unlistenResize = function(element, fn) {
    element.removeEventListener('scroll', element.__resizeListener__);
    element.__resizeListener__ = void 0;
    element.__resizeTriggers__ = !element.removeChild(element.__resizeTriggers__);
    return element.onresize = void 0;
  };

  decodeTextarea = null;

  Base_Helpers.decodeEntities = function(text) {
    if (text.indexOf("&") === -1) {
      return text;
    } else {
      if (!decodeTextarea) {
        decodeTextarea = document.createElement("textarea");
      }
      decodeTextarea.innerHTML = text;
      return decodeTextarea.value;
    }
  };

  aggregationCallbacks = {
    sum: [
      0, function(acc, next) {
        return acc + next;
      }, function(acc, count) {
        return acc;
      }
    ],
    min: [
      Infinity, function(acc, next) {
        return Math.min(acc, next);
      }, function(acc, count) {
        return acc;
      }
    ],
    max: [
      -Infinity, function(acc, next) {
        return Math.max(acc, next);
      }, function(acc, count) {
        return acc;
      }
    ],
    avg: [
      0, function(acc, next) {
        return acc + next;
      }, function(acc, count) {
        return acc / count;
      }
    ],
    count: [
      0, function(acc, next) {
        return 0;
      }, function(acc, count) {
        return count;
      }
    ],
    first: [
      null, function(acc, next) {
        if (acc != null) {
          return acc;
        } else {
          return next;
        }
      }, function(acc, count) {
        return acc;
      }
    ],
    last: [
      null, function(acc, next) {
        if (next != null) {
          return next;
        } else {
          return acc;
        }
      }, function(acc, count) {
        return acc;
      }
    ]
  };

  Base_Helpers.aggregate = function(aggrMethod, hasNextFunc, getNextFunc) {
    var a, acc, count, finishFunc, nextFunc, _ref;
    count = 0;
    _ref = aggregationCallbacks[aggrMethod], acc = _ref[0], nextFunc = _ref[1], finishFunc = _ref[2];
    while (hasNextFunc()) {
      a = getNextFunc();
      nextFunc(acc, a);
      count += 1;
    }
    if (count > 0) {
      return finishFunc(acc, count);
    } else {
      return null;
    }
  };

  return Base_Helpers;

})();
// Generated by CoffeeScript 1.8.0
var Timechart_Data;

Timechart_Data = (function() {
  var RequestData, TimeData;

  Timechart_Data.settings = {
    _doc: {
      doc_file: "time-chart/settings/data.markdown",
      type: "section"
    },
    id: "default",
    units: ["s", "m", "h", "d", "M", "y"],
    units_doc: {
      doc: "Time steps at what data can be fetched.",
      type: "array",
      baseObject: "string"
    },
    urlByUnit: {},
    urlByUnit_doc: {
      doc: "Different urls by data units. Specify specific URL for each time unit. For example, specify data file where time aggregated by years - urlByUnit:{ 'y':'/data/yearData.json}",
      type: "url"
    },
    limitStart: null,
    limitStart_doc: {
      doc: "Hard limit of available data time range. Thus, no data will be asked outside of this.",
      type: "integer"
    },
    limitEnd: null,
    limitEnd_doc: {
      doc: "Hard limit of available data time range. Thus, no data will be asked outside of this.",
      type: "integer"
    },
    requestMaxUnits: 10000,
    requestMaxUnits_doc: {
      doc: "Maximum number of data points to request in one go. Multiple requests will be issued if more data is needed.",
      type: "integer"
    },
    prefetchRatio: 1,
    prefetchRatio_doc: {
      doc: "How much data to load in advance. For example, ratio * chart width worth of data is loaded in both directions.",
      type: "float"
    },
    minimizeRequests: false,
    minimizeRequests_doc: {
      doc: "Whether to request only when scrolling/scaling has stopped.",
      type: "bool"
    },
    cacheSize: 1000000,
    cacheSize_doc: {
      doc: "Maximum number of data entries to store per data unit.",
      type: "integer",
      units: "bitmap"
    },
    timestampInSeconds: false,
    timestampInSeconds_doc: {
      doc: "Whether to use timestamp in seconds instead of milliseconds.",
      type: "bool"
    },
    dataFunction: null,
    dataFunction_doc: {
      doc: "Load more chart data.",
      parameters: {
        "from": "timestamp from which data to be loaded",
        "to": "timestamp from which data to be loaded",
        "unit": "time steps at what data can be fetched",
        "successFunc": "callback function to execute when data arrived correctly",
        "errorFunc": "callback function to execute when error occure while loading data"
      },
      returns: "Specified time range data",
      type: "function"
    }
  };

  "use strict";

  TimeData = (function() {
    TimeData.prototype.unit = "m";

    TimeData.prototype.from = 0;

    TimeData.prototype.to = 1000;

    TimeData.prototype.lastTimestamp = 0;

    TimeData.prototype.values = null;

    function TimeData(unit, from, to, values) {
      this.unit = unit;
      this.from = from;
      this.to = to;
      this.values = values;
      this.updateLastTimestamp();
    }

    TimeData.prototype.updateLastTimestamp = function() {
      if (this.values.length > 0) {
        return this.lastTimestamp = this.values[this.values.length - 1][0];
      } else {
        return this.lastTimestamp = this.from;
      }
    };

    TimeData.prototype.merge = function(newData, maxCount, events, append) {
      var addAfter, addBefore, from, toAdd, v;
      if (!append && (this.from > newData.to || this.to < newData.from)) {
        this.values = newData.values;
        this.from = newData.from;
        this.to = newData.to;
        return;
      }
      if (newData.values.length > 0 && newData.from > newData.values[0][0]) {
        events.error("Data merge - oldest data before from");
      }
      if (newData.values.length > 0 && newData.to < newData.values[newData.values.length - 1][0]) {
        events.error("Data merge - newest data after to");
      }
      addBefore = 0;
      while (addBefore < this.values.length && this.values[addBefore][0] < newData.from) {
        addBefore += 1;
      }
      addAfter = this.values.length;
      while (addAfter > 0 && this.values[addAfter - 1][0] >= newData.to) {
        addAfter -= 1;
      }
      v = newData.values;
      this.from = Math.min(this.from, newData.from);
      this.to = Math.max(this.to, newData.to);
      if (addBefore > 0) {
        from = Math.max(0, v.length + addBefore - maxCount);
        v = this.values.slice(from, +(addBefore - 1) + 1 || 9e9).concat(v);
        if (from > 0) {
          this.from = this.values[from - 1][0] + 1;
        }
      }
      if (addAfter < this.values.length) {
        toAdd = this.values.length - addAfter;
        toAdd = Math.min(toAdd, maxCount - v.length);
        v = v.concat(this.values.slice(addAfter, +(addAfter + toAdd) + 1 || 9e9));
        if (toAdd < this.values.length - addAfter) {
          this.to = this.values[addAfter + toAdd][0];
        }
      }
      this.values = v;
      return this.updateLastTimestamp();
    };

    return TimeData;

  })();

  RequestData = (function() {
    RequestData.prototype.from = null;

    RequestData.prototype.to = null;

    RequestData.prototype.time = 0;

    RequestData.prototype.unit = "y";

    RequestData.prototype.callback = null;

    function RequestData(unit, from, to, callback, time) {
      this.unit = unit;
      this.from = from;
      this.to = to;
      this.callback = callback;
      this.time = time;
      true;
    }

    return RequestData;

  })();

  Timechart_Data.prototype.chart = null;

  Timechart_Data.prototype.scene = null;

  Timechart_Data.prototype.settings = null;

  Timechart_Data.prototype.noData = false;

  Timechart_Data.prototype.dataLimitFrom = null;

  Timechart_Data.prototype.dataLimitTo = null;

  Timechart_Data.prototype.dataFrom = null;

  Timechart_Data.prototype.dataTo = null;

  Timechart_Data.prototype.dataLimitFromUnit = null;

  Timechart_Data.prototype.dataLimitToUnit = null;

  Timechart_Data.prototype.cache = null;

  Timechart_Data.prototype.requests = {};

  function Timechart_Data(chart, dataSettings) {
    this.chart = chart;
    this.dataSettings = dataSettings;
    this.scene = this.chart.scene;
    this.cache = {};
    this.requests = {};
    this.updateDataLimit(null, null, this.dataSettings.limitStart, this.dataSettings.limitEnd, new Base_TimeStep("ms", 1));
  }

  Timechart_Data.prototype.applyPreloadedData = function() {
    if (this.dataSettings.preloaded) {
      return this.addData(this.dataSettings.preloaded);
    }
  };

  Timechart_Data.prototype.remove = function() {
    var r, u, _ref, _results;
    this.scene.setMessage(this, null);
    _ref = this.requests;
    _results = [];
    for (u in _ref) {
      r = _ref[u];
      if (r) {
        _results.push(r.callback = null);
      } else {
        _results.push(void 0);
      }
    }
    return _results;
  };

  Timechart_Data.prototype.determineDataLimits = function(unit, needFrom, needTo, callback) {
    var from, fromData, step, t, to, toData;
    if (unit == null) {
      unit = "y";
    }
    while (unit != null) {
      if (Base_Helpers.arrayContains(this.dataSettings.units, unit)) {
        break;
      }
      unit = Base_TimeStep.toSmallerUnit[unit];
    }
    if (unit == null) {
      this.chart.error("Cannot load data - no suitable data unit configured");
    }
    step = new Base_TimeStep(unit, 1);
    from = null;
    to = null;
    t = step.approxTime();
    if ((this.dataLimitFromUnit != null) && this.dataLimitFromUnit.approxTime() <= t) {
      from = this.dataLimitFrom;
    }
    if ((this.dataLimitToUnit != null) && this.dataLimitToUnit.approxTime() <= t) {
      to = this.dataLimitTo;
    }
    if ((!needFrom || (from != null)) && (!needTo || (to != null))) {
      callback(this.dataLimitFrom, this.dataLimitTo, unit);
      return;
    }
    this.scene.setMessage(this, this.chart.settings.localization.determiningDataBounds, 999);
    toData = (function(_this) {
      return function(f0, t0, from, to, unit) {
        if (!unit) {
          _this.scene.setMessage(_this, null);
          return;
        }
        if (!((_this.dataLimitTo != null) || !needTo)) {
          if (t0 !== to) {
            _this.scheduleDataLoading(unit, to, null, false, function(a, b, c) {
              return toData(f0, to, a, b, c);
            });
            return;
          } else {
            _this.dataLimitTo = to;
          }
        }
        return fromData(f0 + 1, f0, to, unit);
      };
    })(this);
    fromData = (function(_this) {
      return function(f0, from, to, unit) {
        if (!unit) {
          _this.scene.setMessage(_this, null);
          return;
        }
        if (!((_this.dataLimitFrom != null) || !needFrom)) {
          if (f0 !== from) {
            _this.scheduleDataLoading(unit, null, from, false, function(a, b, c) {
              return fromData(from, a, b, c);
            });
            return;
          } else {
            _this.dataLimitFrom = from;
          }
        }
        _this.scene.setMessage(_this, null);
        return callback(_this.dataLimitFrom, _this.dataLimitTo, unit);
      };
    })(this);
    return this.scheduleDataLoading(unit, null, null, false, (function(_this) {
      return function(a, b, c) {
        return toData(a, b - 1, a, b, c);
      };
    })(this));
  };

  Timechart_Data.prototype.getDataForRange = function(from, to, step, callback) {
    var data, endIndex, increasingDirection, loadFrom, loadTo, loadUnit, loadingNeeded, loadingStarted, resultFrom, resultTo, resultUnit, startIndex, _ref;
    resultUnit = step.unit;
    resultFrom = null;
    resultTo = null;
    while (resultUnit) {
      if (this.cache.hasOwnProperty(resultUnit)) {
        data = this.cache[resultUnit];
        if (data !== null && data.from < to && data.to > from) {
          resultFrom = data.from;
          resultTo = data.to;
          data = data.values;
          loadingNeeded = from < resultFrom || to > resultTo;
          break;
        }
      }
      resultUnit = Base_TimeStep.toSmallerUnit[resultUnit];
    }
    if (resultUnit === null) {
      loadingNeeded = true;
    }
    loadingStarted = false;
    if (loadingNeeded) {
      loadingNeeded &= (this.dataSettings.dataFunction != null) || (this.dataSettings.url != null) || (this.dataSettings.urlByUnit != null);
      loadFrom = from;
      loadTo = to;
      if (this.dataLimitFrom != null) {
        loadFrom = Math.max(this.dataLimitFrom, loadFrom);
      }
      if (this.dataLimitTo != null) {
        loadTo = Math.min(this.dataLimitTo, loadTo);
      }
      increasingDirection = false;
      if (loadFrom >= resultFrom) {
        increasingDirection = true;
        loadFrom = Math.max(loadFrom, resultTo);
      }
      if (loadTo <= resultTo) {
        loadTo = Math.min(loadTo, resultFrom);
      }
      loadingNeeded &= loadFrom < loadTo;
      if (loadingNeeded && (!this.dataSettings.minimizeRequests || !this.chart.scrolling.isActive())) {
        loadUnit = step.unit;
        while (loadUnit != null) {
          if (Base_Helpers.arrayContains(this.dataSettings.units, loadUnit) && this.cache[loadUnit] !== null) {
            loadingStarted = this.scheduleDataLoading(loadUnit, loadFrom, loadTo, increasingDirection, callback);
            break;
          }
          loadUnit = Base_TimeStep.toSmallerUnit[loadUnit];
        }
      }
    }
    if (resultUnit) {
      _ref = Timechart_Data.findSubrange(data, from, to), startIndex = _ref[0], endIndex = _ref[1];
      return {
        unit: step.unit,
        count: step.count,
        from: resultFrom,
        to: resultTo,
        values: data,
        startIndex: startIndex,
        endIndex: endIndex,
        loading: loadingStarted
      };
    } else if (loadingStarted) {
      return {
        unit: step.unit,
        count: step.count,
        from: resultFrom,
        to: resultTo,
        values: [],
        startIndex: 0,
        endIndex: 0,
        loading: true
      };
    } else {
      return {
        unit: null,
        count: null,
        from: null,
        to: null,
        values: [],
        startIndex: 0,
        endIndex: 0,
        loading: false
      };
    }
  };

  Timechart_Data.prototype.updateData = function(dataUnit, newTo, callback) {
    var requestFrom, requestTo, u;
    while (dataUnit != null) {
      if (Base_Helpers.arrayContains(this.dataSettings.units, dataUnit)) {
        break;
      }
      dataUnit = Base_TimeStep.toSmallerUnit[dataUnit];
    }
    if (!(this.cache.hasOwnProperty(dataUnit) && !this.requests[dataUnit])) {
      return;
    }
    u = new Base_TimeStep(dataUnit, 1);
    requestTo = u.roundTimeUp(newTo);
    requestFrom = u.roundTimeDown(this.cache[dataUnit].lastTimestamp);
    if (requestFrom <= requestTo) {
      return this.scheduleDataLoading(dataUnit, requestFrom, requestTo, true, callback);
    }
  };

  Timechart_Data.prototype.scheduleDataLoading = function(unit, from0, to0, isIncreasing, callback) {
    var bigFrom, bigTo, biggerUnit, df, fl, from, r, response, succ, time, timeUnitsAsked, to, u;
    if (!unit) {
      throw "No unit";
    }

    /*
      callback - (from, to, unit)
     */
    this.chart.log("Scheduling data loading" + unit + "," + from0 + "," + to0);
    time = new Date().getTime();
    if (this.requests.hasOwnProperty(unit) && (this.requests[unit] != null)) {
      r = this.requests[unit];
      if (r.time + this.dataSettings.requestTimeout < time) {
        r.callback = null;
        delete this.requests[unit];
      } else {
        this.chart.log("Already loading for selected period");
        return true;
      }
    }
    from = from0;
    to = to0;
    u = new Base_TimeStep(unit, 1);
    if (from != null) {
      from = u.roundTimeDown(from);
    }
    if (to != null) {
      to = u.roundTimeUp(to);
    }
    if ((from != null) && (to != null)) {
      timeUnitsAsked = (to - from) / u.approxTime();
      if (timeUnitsAsked > this.dataSettings.requestMaxUnits) {
        if (isIncreasing) {
          to = u.add(from, this.dataSettings.requestMaxUnits);
        } else {
          from = u.sub(to, this.dataSettings.requestMaxUnits);
        }
      }
    }
    biggerUnit = this.getBiggerDataUnit(unit);
    if (biggerUnit != null) {
      u = new Base_TimeStep(biggerUnit, 1);
      if (from != null) {
        bigFrom = u.roundTimeDown(from);
        if ((this.dataLimitFrom != null) && bigFrom <= this.dataLimitFrom) {
          from = this.dataLimitFrom;
        }
      }
      if (to != null) {
        bigTo = u.roundTimeUp(to);
        if ((this.dataLimitTo != null) && bigTo >= this.dataLimitTo) {
          to = this.dataLimitTo;
        }
      }
    }
    r = new RequestData(unit, from, to, callback, time);
    if (df = this.getDataFunction()) {
      succ = (function(_this) {
        return function(data) {
          return _this.dataRecievedRaw(r, data);
        };
      })(this);
      fl = (function(_this) {
        return function() {
          return _this.dataFailed(r);
        };
      })(this);
      this.requests[unit] = r;
      if (this.dataSettings.timestampInSeconds) {
        if (from != null) {
          from = from / 1000;
        }
        if (to != null) {
          to = to / 1000;
        }
      }
      response = df(from, to, unit, succ, fl);
      this.chart.log("Data requested " + unit + ", " + from + ", " + to);
      if ((response != null) && (Base_Helpers.isObject(response) || Base_Helpers.isString(response))) {
        this.dataRecievedRaw(r, response);
      }
      return true;
    } else {
      this.chart.log("No data function. Cannot load data?");
      return false;
    }
  };

  Timechart_Data.prototype.dataRecievedRaw = function(request, data) {
    this.scene.setMessage("data", null);
    delete this.requests[request.unit];
    return this.dataArrived(request, data);
  };

  Timechart_Data.prototype.dataArrived = function(request, rawData) {
    var data;
    this.chart.log("Data arrived");
    data = Base_Helpers.parseData(rawData, this.dataSettings.format, this.chart);
    return this.addDataInt(request, data);
  };

  Timechart_Data.prototype.addData = function(parsedData) {
    return this.addDataInt(null, parsedData, true);
  };

  Timechart_Data.prototype.addDataInt = function(request, parsedData, append) {
    var data, newData;
    if (append == null) {
      append = false;
    }
    if (parsedData === null) {
      return;
    }
    this.cleanupData(parsedData);
    if (parsedData.error) {
      if (parsedData.error === "no-unit" && request) {
        this.cache[request.unit] = null;
      }
      this.chart.error(parsedData.errormessage ? parsedData.errormessage : parsedData.error);
      return;
    }
    if (request) {
      newData = this.analyzeData(parsedData, request);
    } else {
      newData = this.analyzeDataNoRequest(parsedData);
    }
    if (request && Base_TimeStep.timeUnitDiffs[newData.unit] > Base_TimeStep.timeUnitDiffs[request.unit]) {
      this.chart.error("Incorrect data - requested unit " + request.unit + ", got bigger unit - " + newData.unit);
      this.cache[request.unit] = null;
      if (request.callback != null) {
        return request.callback(null, null, null);
      }
    } else {
      if (request && (newData.unit !== request.unit)) {
        this.cache[request.unit] = null;
      }
      if (newData.unit && (newData.from != null) && (newData.to != null)) {
        data = this.cache[newData.unit];
        if (data != null) {
          this.cache[newData.unit].merge(newData, this.dataSettings.cacheSize, this.chart, append);
        } else {
          this.cache[newData.unit] = newData;
        }
      }
      if (request && (request.callback != null)) {
        return request.callback(newData.from, newData.to, newData.unit);
      }
    }
  };

  Timechart_Data.prototype.dataFailed = function(request) {
    if (this.cache[request.unit] == null) {
      this.cache[request.unit] = null;
    }
    this.scene.setMessage("data", this.chart.settings.localization.dataRequestFailed, 1000);
    this.chart.error("Failed data loading request");
    if (request.callback != null) {
      return request.callback(null, null, null);
    }
  };

  Timechart_Data.prototype.updateDataLimit = function(dataFrom, dataTo, limitFrom, limitTo, unit) {
    if (dataFrom != null) {
      if (this.dataFrom === null || this.dataFrom > dataFrom) {
        this.dataFrom = dataFrom;
      }
    }
    if (dataTo != null) {
      if (this.dataTo === null || this.dataTo < dataTo) {
        this.dataTo = dataTo;
      }
    }
    if (limitFrom != null) {
      this.dataLimitFrom = limitFrom;
      this.dataLimitFromUnit = unit;
      this.dataFrom = Math.max(this.dataFrom, limitFrom);
    }
    if (limitTo != null) {
      this.dataLimitTo = limitTo;
      this.dataLimitToUnit = unit;
      return this.dataTo = Math.min(this.dataTo, limitTo);
    }
  };

  Timechart_Data.prototype.cleanupData = function(data) {
    var a, dataFrom, dataLimitFrom, dataLimitTo, dataTo, goodValues, i, prop, required, step, timestamp, v, v1, _i, _j, _k, _l, _len, _len1, _len2, _len3, _ref, _ref1, _ref2, _ref3;
    if (data.error) {
      return;
    }
    data.error = "bad-response";
    if ((data.data != null) && (data.values == null)) {
      data.values = data.data;
    }
    _ref = ["unit", "values"];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      required = _ref[_i];
      if (!data.hasOwnProperty(required)) {
        data.errormessage = "Required field '" + required + "' not set in data";
        return;
      }
    }
    step = Base_TimeStep.parse(data.unit);
    if (step === null) {
      data.errormessage = "Data error: unrecognized data unit: " + data.unit;
      return;
    }
    _ref1 = ["form", "to", "dataLimitForm", "dataLimitTo"];
    for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
      prop = _ref1[_j];
      if (data.hasOwnProperty(prop)) {
        v = data[prop];
        if (v === null) {
          delete data[prop];
        } else {
          v1 = data[prop] = parseInt(v);
          if (!Base_Helpers.isNumber(v1)) {
            data.errormessage = "Field " + prop + " needs to be an integer";
            return;
          }
        }
      }
    }
    data.error = null;
    if ((data.from != null) && (data.to != null) && data.from >= data.to) {
      this.chart.error("Data logic error. from >= to: " + data.from + ", " + data.to);
      delete data.from;
      delete data.to;
    }
    if ((data.dataLimitFrom != null) && (data.dataLimitTo != null) && data.dataLimitFrom >= data.dataLimitTo) {
      this.chart.error("Data logic error. dataLimitFrom >= dataLimitTo: " + data.dataLimitFrom + ", " + data.dataLimitTo);
      delete data.dataLimitFrom;
      delete data.dataLimitTo;
    }
    dataLimitFrom = data.dataLimitFrom;
    dataLimitTo = data.dataLimitTo;
    if (data.values.length > 0) {
      goodValues = [];
      _ref2 = data.values;
      for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
        v = _ref2[_k];
        timestamp = v[0] = parseFloat(v[0]);
        if (!Base_Helpers.isNumber(v[0])) {
          this.chart.error("Data error: time value not a number: " + v[0]);
        } else {
          if (timestamp < dataLimitFrom || timestamp > dataLimitTo) {
            this.chart.error("Data error: value timestamp outside data limits. Limits: " + dataLimitFrom + "..." + dataLimitTo + ", timestamp: " + timestamp);
          }
          for (i in v) {
            a = v[i];
            if (a !== null) {
              v[i] = parseFloat(a);
              if (!Base_Helpers.isNumber(v[i])) {
                this.chart.error("Data error: series value not a number or null: " + v[i]);
                v[i] = null;
              }
            }
          }
          goodValues.push(v);
        }
      }
      data.values = goodValues;
      if (this.dataSettings.timestampInSeconds) {
        _ref3 = data.values;
        for (_l = 0, _len3 = _ref3.length; _l < _len3; _l++) {
          v = _ref3[_l];
          v[0] *= 1000;
        }
      }
      data.values.sort(function(a, b) {
        return a[0] - b[0];
      });
      dataFrom = data.values[0][0];
      dataTo = data.values[data.values.length - 1][0];
    }
    if (this.dataSettings.timestampInSeconds) {
      if (data.from) {
        data.from *= 1000;
      }
      if (data.to) {
        data.to *= 1000;
      }
      if (data.dataLimitFrom) {
        data.dataLimitFrom *= 1000;
      }
      if (data.dataLimitTo) {
        data.dataLimitTo *= 1000;
      }
    }
    if ((data.from != null) && dataFrom < data.from) {
      this.chart.error("Data logic error. Data time " + dataFrom + " outside [from, to) range: " + data.from + ", " + data.to);
      data.from = dataFrom;
    }
    if ((data.to != null) && dataTo >= data.to) {
      this.chart.error("Data logic error. Data time " + dataTo + " outside [from, to) range: " + data.from + ", " + data.to);
      data.to = dataTo + 1;
    }
  };

  Timechart_Data.prototype.analyzeDataNoRequest = function(data) {
    var dataFrom, dataTo, from, r, step, to;
    if (!(data.from != null) && (data.dataLimitFrom != null)) {
      data.from = data.dataLimitFrom;
    }
    if (!(data.to != null) && (data.dataLimitTo != null)) {
      data.to = data.dataLimitTo;
    }
    from = data.from;
    to = data.to;
    step = Base_TimeStep.parse(data.unit);
    if (data.values.length > 0) {
      dataFrom = data.values[0][0];
      dataTo = data.values[data.values.length - 1][0];
      dataFrom = step.roundTimeDown(dataFrom);
      dataTo = step.roundTimeUp(dataTo + 1);
      if (from == null) {
        from = dataFrom;
      }
      if (to == null) {
        to = dataTo;
      }
    }
    this.updateDataLimit(dataFrom, dataTo, data.dataLimitFrom, data.dataLimitTo, step);
    r = new TimeData(data.unit, from, to, data.values);
    if (data.error != null) {
      r.error = data.error;
    }
    return r;
  };

  Timechart_Data.prototype.analyzeData = function(data, request) {
    var dataFrom, dataTo, from, r, rdf, rdt, step, to;
    if ((request.from == null) && (data.from == null) && (data.dataLimitFrom != null)) {
      data.from = data.dataLimitFrom;
    }
    if ((request.to == null) && (data.to == null) && (data.dataLimitTo != null)) {
      data.to = data.dataLimitTo;
    }
    from = data.from;
    to = data.to;
    dataFrom = null;
    dataTo = null;
    if ((from != null) && (to != null) && from >= to) {
      this.chart.error("Data logic error. from >= to: " + from + ", " + to);
    }
    step = Base_TimeStep.parse(data.unit);
    if (data.values.length > 0) {
      dataFrom = data.values[0][0];
      dataTo = data.values[data.values.length - 1][0];
      dataFrom = step.roundTimeDown(dataFrom);
      dataTo = step.roundTimeUp(dataTo + 1);
      if (from == null) {
        if (request.from != null) {
          from = Math.min(request.from, dataFrom);
        } else {
          from = dataFrom;
        }
      }
      if (to == null) {
        if (request.to != null) {
          to = Math.max(request.to, dataTo);
        } else {
          to = dataTo;
        }
      }
    } else {
      if (from == null) {
        from = request.from;
      }
      if (to == null) {
        to = request.to;
      }
      if ((data.from != null) && (data.to != null)) {
        dataFrom = data.from;
        dataTo = data.to;
      } else {
        dataFrom = request.from;
        dataTo = request.to;
        if (request.from === null && request.to === null && (from == null) && (to == null) && (data.dataLimitFrom == null) && (data.dataLimitTo == null)) {
          this.noData = true;
          data.dataLimitFrom = 0;
          data.dataLimitTo = 0;
          data.from = 0;
          data.to = 0;
        }
      }
    }
    this.updateDataLimit(dataFrom, dataTo, data.dataLimitFrom, data.dataLimitTo, step);
    if ((request.from != null) && (data.to != null)) {
      rdt = step.roundTimeDown(data.to);
      if (rdt <= request.from) {
        this.updateDataLimit(null, null, null, data.to, step);
      }
    }
    if ((request.to != null) && (data.from != null)) {
      rdf = step.roundTimeUp(data.from);
      if (rdf >= request.to) {
        this.updateDataLimit(null, null, data.from, null, step);
      }
    }
    if (!((data.from != null) || (data.dataLimitFrom != null))) {
      if (((this.dataLimitFrom != null) && (request.from === null || (request.from <= this.dataLimitFrom && dataFrom > this.dataLimitFrom))) || ((this.dataLimitFrom == null) && (request.from == null))) {
        this.updateDataLimit(null, null, dataFrom, null, step);
        from = dataFrom;
      }
    }
    if (!((data.to != null) || (data.dataLimitTo != null))) {
      if (((this.dataLimitTo != null) && (request.to === null || (request.to >= this.dataLimitTo && dataTo < this.dataLimitTo))) || ((this.dataLimitTo == null) && (request.to == null))) {
        this.updateDataLimit(null, null, null, dataTo, step);
        to = dataTo;
      }
    }
    r = new TimeData(data.unit, from, to, data.values);
    if (data.error != null) {
      r.error = data.error;
    }
    return r;
  };

  Timechart_Data.prototype.getBiggerDataUnit = function(unit) {
    var units;
    while (unit != null) {
      unit = Base_TimeStep.toBiggerUnit[unit];
      units = this.dataSettings.units;
      if (Base_Helpers.arrayContains(units, unit)) {
        return unit;
      }
    }
    return null;
  };

  Timechart_Data.binSearch = function(data, timestamp) {

    /*
      Returns index of first item that is >= timestamp.
     */
    var i0, i1, ii;
    i0 = 0;
    if (!data) {
      throw "no data";
    }
    i1 = data.length - 1;
    while (i0 < i1) {
      ii = ((i1 + i0) / 2) | 0;
      if (data[ii][0] < timestamp) {
        i0 = ii + 1;
      } else if (data[ii][0] > timestamp) {
        i1 = ii;
      } else {
        while (ii > 0 && data[ii - 1][0] === timestamp) {
          ii -= 1;
        }
        return ii;
      }
    }
    if (i0 < data.length && data[i0][0] < timestamp) {
      return i0 + 1;
    } else {
      return i0;
    }
  };

  Timechart_Data.linSearchUp = function(data, start, dataIndex, dataFunction) {
    var i, _i, _j, _ref, _ref1, _ref2, _ref3;
    if (dataFunction) {
      for (i = _i = _ref = start + 1, _ref1 = data.length - 1; _i <= _ref1; i = _i += 1) {
        if (dataFunction(data[i]) !== null) {
          return i;
        }
      }
    } else {
      for (i = _j = _ref2 = start + 1, _ref3 = data.length - 1; _j <= _ref3; i = _j += 1) {
        if (data[i][dataIndex] !== null) {
          return i;
        }
      }
    }
    return -1;
  };

  Timechart_Data.linSearchDown = function(data, start, dataIndex, dataFunction) {
    var i, _i, _j, _ref, _ref1;
    if (dataFunction) {
      for (i = _i = _ref = start - 1; _i >= 0; i = _i += -1) {
        if (dataFunction(data[i]) !== null) {
          return i;
        }
      }
    } else {
      for (i = _j = _ref1 = start - 1; _j >= 0; i = _j += -1) {
        if (data[i][dataIndex] !== null) {
          return i;
        }
      }
    }
    return -1;
  };

  Timechart_Data.findSubrange = function(data, from, to) {
    var i0, i1;
    i0 = Timechart_Data.binSearch(data, from);
    i1 = Timechart_Data.binSearch(data, to);
    return [i0, i1];
  };

  Timechart_Data.prototype.getDataFunction = function() {
    var config;
    config = this.dataSettings;
    if (config.dataFunction) {
      return config.dataFunction;
    } else if (config.url || Base_Helpers.hasProperties(config.urlByUnit)) {
      return (function(_this) {
        return function(from, to, step, success, fail) {
          var params, url;
          if (Base_Helpers.hasProperties(config.urlByUnit)) {
            url = config.urlByUnit[step];
            if (!url) {
              return "{\"error\":\"no-unit\", \"errormessage\":\"no data url for this time unit: " + step + "\"}";
            }
          } else {
            url = config.url;
          }
          if (!step) {
            throw "No step";
          }
          params = [];
          if (from != null) {
            params.push(["from", from]);
          }
          if (to != null) {
            params.push(["to", to]);
          }
          params.push(["unit", step]);
          return Base_Data.doRequest(url, _this.dataSettings, params, success, fail);
        };
      })(this);
    } else {
      return null;
    }
  };

  Timechart_Data.prototype.hasPendingRequests = function() {
    return Base_Helpers.hasProperties(this.requests);
  };

  return Timechart_Data;

})();
// Generated by CoffeeScript 1.8.0
var Base_Label, Base_LabelLayoutBase, Base_LabelRenderer;

Base_Label = (function() {
  Base_Label.styleSettings = {
    _doc: {
      doc: "Label style.",
      type: "object"
    },
    aspectRatio: 3,
    aspectRatio_doc: {
      doc: "Ratio between label sizes in different dimensions",
      type: "float"
    },
    maxWidth: null,
    maxWidth_doc: {
      doc: "Maximum width of the label.",
      type: "float",
      units: "pixels"
    },
    lineSpacing: 0,
    lineSpacing_doc: {
      doc: "Vertical space between the lines of text. In multiples of text line height.",
      type: "float"
    },
    align: "left",
    align_doc: {
      doc: "Text alignment.",
      type: "enum",
      values: ["left", "right", "center"]
    },
    padding: 0,
    padding_doc: {
      doc: "Padding between item content and item border.",
      type: "float",
      units: "pixels"
    },
    margin: 0,
    margin_doc: {
      doc: "Margin around label text",
      type: "float",
      units: "pixels"
    },
    angle: 0,
    angle_doc: {
      doc: "The angle at which the label are rotated",
      type: "integer"
    },
    text: null,
    text_doc: {
      doc: "Label text.",
      type: "string"
    },
    image: null,
    image_doc: {
      doc: "Label image.",
      type: "imageUrl"
    },
    borderRadius: 0,
    borderRadiu_doc: {
      doc: "Radius of item border. Similar to CSS border radius property. Zero radius will show a rectangle",
      type: "float",
      units: "pixels"
    },
    backgroundStyle: null,
    backgroundS_doc: {
      doc: "Background style including fill color.",
      type: "object"
    },
    textStyle: null,
    textStyle_doc: {
      doc: "Text style including fill color and font.",
      type: "object"
    },
    imageSlicing: null,
    imageSlicing_doc: {
      doc: "Slicing to use tiled images. Array of 4 values: [left, top, width, height]",
      type: "array",
      baseObject: "integer"
    }
  };

  Base_Label.prototype.data = null;

  Base_Label.prototype.aspectRatio = 3;

  Base_Label.prototype.maxWidth = null;

  Base_Label.prototype.lineSpacing = 0.2;

  Base_Label.prototype.align = "left";

  Base_Label.prototype.padding = 0;

  Base_Label.prototype.margin = 0;

  Base_Label.prototype.angle = 0;

  Base_Label.prototype.text = null;

  Base_Label.prototype.image = null;

  Base_Label.prototype.borderRadius = 0;

  Base_Label.prototype.backgroundStyle = null;

  Base_Label.prototype.textStyle = null;

  Base_Label.prototype.imageSlicing = null;

  Base_Label.prototype.onClick = null;

  Base_Label.prototype.onHover = null;

  Base_Label.prototype.url = null;

  Base_Label.prototype.visible = true;

  Base_Label.prototype.userPlaced = false;

  Base_Label.prototype.id = null;

  Base_Label.prototype.measureDone = false;

  Base_Label.prototype.loadedImage = null;

  Base_Label.prototype.rows = null;

  Base_Label.prototype.lineHeight = 0;

  Base_Label.prototype.lineHeightM = 0;

  Base_Label.prototype.hwidth = 0;

  Base_Label.prototype.hheight = 0;

  Base_Label.prototype.curX = 0;

  Base_Label.prototype.curY = 0;

  Base_Label.prototype.x = null;

  Base_Label.prototype.y = null;

  function Base_Label(base) {
    Base_Helpers.extendCopy(this, base);
  }

  return Base_Label;

})();

Base_LabelRenderer = (function() {
  var CS;

  function Base_LabelRenderer(events, settings, chartContainer) {
    this.events = events;
    this.settings = settings;
    this.chartContainer = chartContainer;
    if (!this.chartContainer) {
      throw new Error("chartContainer must be specified");
    }
    this.scene = this.events.scene;
    this.cache = {};
    this.frameLabels = {};
    this.textLayout = null;
    this.numPaints = 0;
    this.numCachedPaints = 0;
  }

  Base_LabelRenderer.prototype.printStats = function() {
    var cp, fp;
    fp = Base_Helpers.countProperties(this.frameLabels);
    cp = Base_Helpers.countProperties(this.cache);
    //console.log("Paints:" + this.numPaints + ", cached: " + this.numCachedPaints + ", cache size:" + cp + ", frame size:" + fp);
    this.numPaints = 0;
    return this.numCachedPaints = 0;
  };

  Base_LabelRenderer.prototype.nextFrame = function() {
    var cc, fc, k;
    fc = Base_Helpers.countProperties(this.frameLabels);
    cc = Base_Helpers.countProperties(this.cache);
    if (cc > fc * 3) {
      for (k in this.cache) {
        if (this.frameLabels[k] == null) {
          delete this.cache[k];
        }
      }
    }
    return this.frameLabels = {};
  };

  Base_LabelRenderer.prototype.measure = function(g, item, style) {
    var done, h, hh, i, padding, r, w, ww, _ref;
    if (style == null) {
      style = item;
    }
    if (item.measureDone) {
      return;
    }
    item.id = null;
    done = true;
    padding = style.padding;
    w = 0;
    h = 0;
    if (item.text) {
      _ref = this.measureText(g, item, style), ww = _ref[0], hh = _ref[1];
      h = Math.max(h, hh);
      w += ww;
    } else {
      item.rows = [[], []];
    }
    if (item.image) {
      if (item.imageSlicing) {
        w += item.imageSlicing[2];
        h = Math.max(h, item.imageSlicing[3]);
      } else {
        i = this.settings.getAssetImage(item.image);
        if (i && i.width) {
          w += i.width;
          h = Math.max(h, i.height);
        } else {
          done = false;
        }
      }
    }
    if (w === 0) {
      w = 10;
      h = 10;
    }
    w += padding * 2;
    h += padding * 2;
    if (item.borderRadius > 0 && item.text) {
      r = Math.min(item.borderRadius, h / 2);
      w += r * .45;
      if (!item.image) {
        w += r * .45;
      }
    }
    item.hwidth = w / 2;
    item.hheight = h / 2;
    return item.measureDone = done;
  };

  Base_LabelRenderer.prototype.measureText = function(g, item, style) {
    var aspect, breaks, h, i, locationFromHeight, map, maxW, padding, rw, sl, textLayout, w, words, _ref, _ref1;
    aspect = style.aspectRatio;
    maxW = style.maxWidth;
    textLayout = new Base_LabelLayoutBase(g, style);
    padding = style.padding;
    if ((aspect > 0 || maxW > 0) && item.text.split(" ").length > 1) {
      if (!aspect) {
        aspect = 1e9;
      }
      if (!maxW) {
        maxW = 1e9;
      }
      locationFromHeight = function(height) {
        return [0, 0, 0, 0, Math.min(maxW, height * (aspect + 0.2))];
      };
      textLayout.fitLabelInRect(item, style.align, style.align, locationFromHeight, false);
      w = item.hwidth * 2;
      h = item.hheight * 2;
    } else {
      _ref = textLayout.styleTagParser(item.text), words = _ref[0], map = _ref[1], breaks = _ref[2];
      breaks = (function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = breaks.length; _i < _len; _i++) {
          i = breaks[_i];
          _results.push(i - 1);
        }
        return _results;
      })();
      _ref1 = textLayout.stringsByFont(words, map, breaks), sl = _ref1[0], rw = _ref1[1];
      item.lineHeight = h = Base_Graphics.getTextHeight(g, style.textStyle.font);
      item.rows = [sl, rw];
      Base_Graphics.textStyleNoShadow(g, style.textStyle);
      w = rw.reduce(function(a, b) {
        return Math.max(a, b);
      });
      h = h * (1 + item.lineSpacing) * rw.length + padding;
    }
    return [w, h];
  };


  /* Determines if the given style requires a canvas to be appended to the document before it can be drawn onto. */

  Base_LabelRenderer.prototype.styleRequiresDocumentCanvas = function(style) {
    if (style.font && /[0-9]+em/.test(style.font)) {
      return true;
    }
    return false;
  };

  Base_LabelRenderer.prototype.canCache = function(scene, settings, item, style, scale) {
    var chartArea, imgExists, itemArea;
    if (!(settings != null ? settings.advanced.labelCache : void 0)) {
      return false;
    }
    chartArea = this.scene.height * this.scene.width;
    itemArea = 2 * (item.hwidth * item.hheight * scale * scale);
    if (chartArea / itemArea < 10) {
      return false;
    }
    if (item.image != null) {
      imgExists = this.settings.getAssetImage(item.image);
      if (!imgExists) {
        return false;
      }
    }
    return true;
  };

  Base_LabelRenderer.prototype.paint = function(g, x, y, scale, item) {
    return this.paintWithStyle(g, x, y, scale, item, item);
  };

  Base_LabelRenderer.prototype.realPaint = function(g, x, y, scaleX, scaleY, item, style) {
    var align, angle, background, borderRadius, count, f, font, gr, hh, hw, i, image, left, lineHeight, padding, right, row, rowStartPos, rowWidths, sl, slWidth, slicing, subLines, totalWidth, x0, xpos, xx, y0, _i, _len, _ref;
    hw = item.hwidth;
    hh = item.hheight;
    background = style.backgroundStyle;
    padding = style.padding;
    borderRadius = Math.min(item.borderRadius, hh);
    angle = (style.angle || 0) / 180 * Math.PI;
    if (scaleX !== 1 || angle !== 0) {
      g.save();
      g.transform(scaleX, 0, 0, scaleY, x, y);
      if (angle !== 0) {
        g.rotate(angle);
      }
      x = 0;
      y = 0;
    }
    if (background) {
      gr = Base_Graphics.beginStrokeAndFill(g, background);
      if (borderRadius >= hh) {
        xx = x + hw - hh;
        gr.moveTo(xx, y - hh);
        gr.arc(xx, y, hh, -Math.PI / 2, Math.PI / 2, false);
        xx = x - hw + hh;
        gr.lineTo(xx, y + hh);
        gr.arc(xx, y, hh, Math.PI / 2, -Math.PI / 2, false);
        gr.closePath();
      } else if (borderRadius > 0) {
        gr.moveTo(x - hw + borderRadius, y - hh);
        gr.lineTo(x + hw - borderRadius, y - hh);
        gr.arc(x + hw - borderRadius, y - hh + borderRadius, borderRadius, -Math.PI / 2, 0, false);
        gr.lineTo(x + hw, y + hh - borderRadius);
        gr.arc(x + hw - borderRadius, y + hh - borderRadius, borderRadius, 0, +Math.PI / 2, false);
        gr.lineTo(x - hw + borderRadius, y + hh);
        gr.arc(x - hw + borderRadius, y + hh - borderRadius, borderRadius, +Math.PI / 2, Math.PI, false);
        gr.lineTo(x - hw, y - hh + borderRadius);
        gr.arc(x - hw + borderRadius, y - hh + borderRadius, borderRadius, Math.PI, Math.PI + Math.PI / 2, false);
      } else {
        gr.moveTo(x - hw, y - hh);
        gr.lineTo(x + hw, y - hh);
        gr.lineTo(x + hw, y + hh);
        gr.lineTo(x - hw, y + hh);
        gr.closePath();
      }
      Base_Graphics.endStrokeAndFill(g, gr, background);
    }
    image = item.image;
    hw -= padding;
    hh -= padding;
    left = x - hw;
    right = x + hw;
    if (image != null) {
      i = this.settings.getAssetImage(image);
      if (i) {
        slicing = item.imageSlicing;
        if (slicing) {
          g.drawImage(i, slicing[0], slicing[1], slicing[2], slicing[3], x - hw, y - hh, slicing[2], slicing[3]);
          left += slicing[2];
        } else {
          g.drawImage(i, x - hw, y - hh);
          left += image.width;
        }
      }
    }
    _ref = item.rows, subLines = _ref[0], rowWidths = _ref[1];
    count = rowWidths.length;
    if (subLines.length > 0) {
      lineHeight = item.lineHeight * (1 + item.lineSpacing);
      align = style.align;
      g.textBaseline = "bottom";
      y0 = y - (((count + 1) * lineHeight) / 2) + item.lineHeight * .58;
      if (align === "left") {
        x0 = left;
        if (image == null) {
          x0 += borderRadius * .45;
        }
        g.textAlign = "start";
      } else if (align === "right") {
        x0 = right - borderRadius * .45;
        g.textAlign = "end";
      } else {
        x0 = (left + right) / 2;
        g.textAlign = "center";
      }
      Base_Graphics.textStyle(g, style.textStyle);
      row = -1;
      slWidth = 0;
      align = g.textAlign;
      font = style.textStyle.font;
      for (_i = 0, _len = subLines.length; _i < _len; _i++) {
        sl = subLines[_i];
        xpos = slWidth;
        slWidth += sl.width;
        if (row !== sl.row) {
          row = sl.row;
          y0 += lineHeight;
          xpos = 0;
          slWidth = sl.width;
          totalWidth = rowWidths[row];
          if (align === "center") {
            rowStartPos = x0 - totalWidth / 2;
          } else if (align === "start") {
            rowStartPos = x0;
          } else {
            rowStartPos = x0 - totalWidth;
          }
        }
        g.textAlign = "left";
        f = sl.font;
        if (font !== f) {
          font = f;
          g.font = f;
        }
        xpos += rowStartPos;
        g.fillText(sl.text, xpos, y0);
      }
    }
    if (scaleX !== 1 || angle !== 0) {
      return g.restore();
    }
  };

  CS = String.fromCharCode(0xf8ff);

  Base_LabelRenderer.prototype.paintWithStyle = function(g, x, y, scale, item, style) {
    var angle, bkg, bs, c, container, effectiveScaleX, effectiveScaleY, externalBkg, hHeight, hWidth, hh, hw, id, ig, imHeight, imWidth, image, imageId, needsAppend, s, scaleX, scaleY, ts, _ref, _ref1;
    if (!item.measureDone) {
      this.measure(g, item, style);
    }
    item.curx = x;
    item.cury = y;
    if (!this.canCache(this.scene, this.settings, item, style, scale)) {
      this.numPaints += 1;
      return this.realPaint(g, x, y, scale, scale, item, style);
    } else {
      scaleX = this.events.scaleX;
      scaleY = this.events.scaleY;
      effectiveScaleX = scaleX * scale;
      effectiveScaleY = scaleY * scale;
      hw = item.hwidth;
      hh = item.hheight;
      angle = (style.angle || 0) / 180 * Math.PI;
      if (!item.id) {
        id = "" + item.text + CS + "," + hw + "," + hh + "," + style.lineSpacing + ", " + style.angle + ", " + style.align + "," + style.image + "," + style.borderRadius + "," + style.imageSlicing + "," + style.maxWidth + "," + style.aspectRatio;
        if (style.backgroundStyle) {
          bs = style.backgroundStyle;
          id += "" + CS + bs.fillColor + "," + bs.lineColor + "," + bs.lineWidth + "," + bs.shadowColor + "," + bs.shadowOffsetX + "," + bs.shadowOffsetY + "," + bs.shadowBlur;
        }
        if (style.textStyle) {
          ts = style.textStyle;
          id += "" + CS + ts.fillColor + "," + ts.font;
        }
        item.id = id;
      }
      imageId = item.id + ("" + (effectiveScaleX.toFixed(2)) + "," + (effectiveScaleY.toFixed(2)));
      image = this.cache[imageId] || null;
      if (!image) {
        bkg = style.backgroundStyle;
        externalBkg = (bkg != null) && (bkg.lineWidth != null) ? bkg.lineWidth : 0;
        imWidth = Math.ceil(2 * hw + externalBkg + 1) * effectiveScaleX;
        imHeight = Math.ceil(2 * hh + externalBkg + 1) * effectiveScaleY;
        image = document.createElement("canvas");
        if (angle !== 0) {
          c = Math.cos(angle);
          s = Math.sin(angle);
          _ref = [Math.abs(imWidth * c) + Math.abs(imHeight * s), Math.abs(imHeight * c) + Math.abs(imWidth * s)], imWidth = _ref[0], imHeight = _ref[1];
        }
        imWidth = Math.ceil(imWidth / 2) * 2;
        imHeight = Math.ceil(imHeight / 2) * 2;
        _ref1 = [imWidth, imHeight], image.width = _ref1[0], image.height = _ref1[1];
        ig = image.getContext("2d");
        hWidth = imWidth / 2;
        hHeight = imHeight / 2;
        needsAppend = this.styleRequiresDocumentCanvas(style.textStyle);
        if (needsAppend) {
          container = this.chartContainer;
          if (!container.ownerDocument) {
            if (console) {
              console.error("chartContainer must be appended to the document");
            }
            container = document.body;
          }
          image.style.display = "none";
          container.appendChild(image);
        }
        this.realPaint(ig, hWidth, hHeight, effectiveScaleX, effectiveScaleY, item, style);
        if (needsAppend) {
          container.removeChild(image);
        }
        this.cache[imageId] = image;
        this.numPaints += 1;
      } else {
        imWidth = image.width;
        imHeight = image.height;
        hWidth = imWidth / 2;
        hHeight = imHeight / 2;
        this.numCachedPaints += 1;
      }
      x = Math.round(x * scaleX) / scaleX;
      y = Math.round(y * scaleY) / scaleY;
      g.drawImage(image, 0, 0, imWidth, imHeight, x - hWidth / scaleX, y - hHeight / scaleY, imWidth / scaleX, imHeight / scaleY);
      return this.frameLabels[imageId] = 1;
    }
  };

  return Base_LabelRenderer;

})();

Base_LabelLayoutBase = (function() {
  Base_LabelLayoutBase.prototype.replaces = [
    {
      smb: String.fromCharCode(0xf8fe),
      reg: new RegExp(String.fromCharCode(0xf8fe), "g")
    }, {
      smb: String.fromCharCode(0xf8fc),
      reg: new RegExp(String.fromCharCode(0xf8fc), "g")
    }
  ];

  function Base_LabelLayoutBase(g, config) {
    var height, lineSpacing;
    this.g = g;
    this.textStyle = config.textStyle;
    this.angle = (config.angle || 0) / 180 * Math.PI;
    this.borderRadius = config.borderRadius || 0;
    this.margin = config.margin || 0;
    this.padding = config.padding || 0;
    height = Base_Graphics.getTextHeight(g, this.textStyle.font);
    lineSpacing = config.lineSpacing;
    this.lineHeight = height;
    this.lineHeightM = height * (lineSpacing + 1);
    this.lineHeightC = -height * lineSpacing;
    this.replaceSymbols = this.replaces;
  }

  Base_LabelLayoutBase.prototype.fitLabelInRect = function(label, align, noSpaceAlign, locationFromHeight, storePosition) {
    var actualWidth, availableWidth, bestActualWidth, bestDx, bestDy, bestLineBreaks, bestProp, bestWidth, bestX, bestY, breaks, centerOffset, dx, dy, fontMap, height, lineCount, lineHeightC, lineHeightM, lineTargetWidth, margin, maxLines, padding, parsedData, positions, prop, totalWidth, v, words, x, y, _i, _j, _len, _ref, _ref1, _ref2, _ref3;
    if (storePosition == null) {
      storePosition = true;
    }
    margin = this.margin;
    padding = this.padding;
    lineHeightC = this.lineHeightC;
    lineHeightM = this.lineHeightM;
    if (!label.measureDone || !label._textCache) {
      label._textCache = parsedData = this.styleTagParser(label.text);
    }
    _ref = label._textCache, words = _ref[0], fontMap = _ref[1], breaks = _ref[2], totalWidth = _ref[3], maxLines = _ref[4];
    bestProp = -Infinity;
    bestLineBreaks = null;
    bestX = 0;
    bestY = 0;
    bestWidth = 0;
    bestActualWidth = 0;
    for (lineCount = _i = _ref1 = breaks.length; _i <= maxLines; lineCount = _i += 1) {
      height = lineHeightC + lineHeightM * lineCount;
      _ref2 = locationFromHeight(height / 2 + margin + padding), x = _ref2[0], y = _ref2[1], dx = _ref2[2], dy = _ref2[3], availableWidth = _ref2[4];
      availableWidth -= (margin + padding) * 2;
      lineTargetWidth = totalWidth / lineCount;
      _ref3 = this.splitWordsToLines(words, breaks, lineCount, function(lineNo) {
        return availableWidth;
      }), prop = _ref3[0], actualWidth = _ref3[1], positions = _ref3[2];
      if (prop > bestProp) {
        bestLineBreaks = positions;
        bestProp = prop;
        bestDx = dx;
        bestDy = dy;
        bestX = x;
        bestY = y;
        bestWidth = availableWidth;
        bestActualWidth = 0;
        for (_j = 0, _len = actualWidth.length; _j < _len; _j++) {
          v = actualWidth[_j];
          bestActualWidth = Math.max(v, bestActualWidth);
        }
      }
      if (prop >= 1) {
        break;
      }
    }
    if (bestLineBreaks) {
      if (!label.userPlaced) {
        if (bestProp < 1) {
          align = noSpaceAlign;
        }
        if (align === "left") {
          centerOffset = (bestActualWidth - bestWidth) / 2;
        } else if (align === "right") {
          centerOffset = (bestWidth - bestActualWidth) / 2;
        } else {
          centerOffset = 0;
        }
        bestX = bestX + bestDx * centerOffset;
        bestY = bestY + bestDy * centerOffset;
      }
      if (storePosition) {
        label.x = bestX;
        label.y = bestY;
      }
      label.rows = this.stringsByFont(words, fontMap, bestLineBreaks);
      label.hheight = (lineHeightC + lineHeightM * bestLineBreaks.length) / 2 + padding;
      label.lineHeight = this.lineHeight;
      label.lineHeightM = lineHeightM;
      label.hwidth = bestActualWidth / 2 + padding;
      label.align = align;
      label.measureDone = true;
      label.visible = true;
      label.padding = padding;
      label.borderRadius = this.borderRadius;
      if (this.borderRadius > 0) {
        label.hwidth += 0.45 * Math.min(this.borderRadius, label.hheight);
      }
    } else {
      label.rows = [[], []];
      label.visible = false;
    }
    return bestProp;
  };

  Base_LabelLayoutBase.prototype.styleTagParser = function(text) {
    var bolds, br, breaks, charToChar, charToSpace, close, containsTags, count, cumulativeDif, curChar, curFont, end, font, fontChanges, fontMap, g, i, italics, lastChar, lastFont, lastLetter, lastW, letter, letters, maxLines, newLine, o, open, parsedText, period, replacedText, replaces, spFonts, spaceToChar, spaceWidth, split, start, str, sw, tag, totalWidth, word, wordWidth, words, _i, _j, _ref, _ref1, _ref2;
    g = this.g;
    Base_Graphics.textStyleNoShadow(g, this.textStyle);
    curFont = font = g.font;
    _ref = this.replaceSymbols, open = _ref[0], close = _ref[1];
    fontMap = {};
    fontMap[font] = {
      swidth: g.measureText(" ").width
    };
    spaceWidth = 0;
    totalWidth = 0;
    maxLines = 0;
    words = [];
    breaks = [];
    replaces = [];
    br = 0;
    cumulativeDif = 0;
    replacedText = text.replace(/<b>|<\/b>|<i>|<\/i>|<br>/g, function(m, i) {
      var marker;
      replaces.push(i - cumulativeDif);
      cumulativeDif += m.length - 2;
      if (m.indexOf("</") !== -1) {
        marker = m.substr(2, m.length - 3);
        return close.smb + marker;
      }
      marker = m.substr(1, m.length - 2);
      if (m === "<br>") {
        br++;
        marker = "r";
      }
      return open.smb + marker;
    });
    containsTags = br !== replaces.length;
    parsedText = Base_Helpers.decodeEntities(replacedText);
    words.push({
      word: "",
      width: 0,
      font: font,
      spaceWidth: 0,
      spaceFonts: null
    });
    if (!containsTags) {
      str = "";
      count = 0;
      parsedText = parsedText.replace(new RegExp(open.smb + "r", 'gi'), " " + open.smb + "r ");
      sw = g.measureText(" ").width;
      split = parsedText.split(" ");
      for (i = _i = 0, _ref1 = split.length; _i <= _ref1; i = _i += 1) {
        word = split[i];
        if (word === open.smb + "r") {
          breaks.push(words.length);
          continue;
        }
        if (!!word) {
          spaceWidth = sw * count;
          if (spaceWidth) {
            lastW = words[words.length - 1];
            lastW.spaceWidth = spaceWidth;
            lastW.spaceFonts = [
              {
                font: font,
                space: str,
                count: count
              }
            ];
            totalWidth += spaceWidth;
          }
          count = 1;
          str = " ";
          wordWidth = g.measureText(word).width;
          words.push({
            word: word,
            width: wordWidth,
            spaceWidth: 0,
            font: font
          });
          totalWidth += wordWidth;
        } else {
          str += " ";
          count++;
          continue;
        }
      }
      words[words.length - 1].space = {
        fonts: []
      };
    } else {
      letters = parsedText.split("");
      start = -1;
      end = -1;
      fontChanges = false;
      newLine = false;
      lastChar = false;
      period = true;
      spFonts = [];
      count = 0;
      bolds = 0;
      italics = 0;
      for (i = _j = 0, _ref2 = letters.length - 1; _j <= _ref2; i = _j += 1) {
        if (i === replaces[0]) {
          tag = letters[i + 1];
          o = [letters[i].match(open.reg) != null, letters[i].match(close.reg) != null][0];
          if (o) {
            if (tag === "i") {
              font = font.indexOf("italic") === -1 ? "italic " + font : font;
              italics++;
            }
            if (tag === "b") {
              font = font.indexOf("bold") === -1 ? "bold " + font : font;
              bolds++;
            }
            if (tag === "r") {
              newLine = true;
            }
          } else {
            if (tag === "i") {
              italics--;
              if (italics <= 0) {
                font = font.replace(/(italic)/g, "");
              }
            }
            if (tag === "b") {
              bolds--;
              if (bolds <= 0) {
                font = font.replace(/(bold)/g, "");
              }
            }
          }
          font = font.replace(/^\s+|\s+$/g, "");
          if (!fontMap.hasOwnProperty(font)) {
            fontMap[font] = {
              swidth: g.measureText(" ").width
            };
          }
          if (end === -1) {
            curFont = font;
          }
          continue;
        }
        if (i - 1 === replaces[0]) {
          replaces.shift();
          continue;
        }
        letter = letters[i];
        lastLetter = letters[end];
        curChar = letter !== " ";
        lastChar = lastLetter == null ? null : lastLetter !== " ";
        period = lastChar != null;
        if (start === -1) {
          start = i;
        }
        if (end === -1) {
          end = i;
        }
        if (count === 0) {
          count = 1;
        }
        fontChanges = end + 1 !== i;
        if (period) {
          charToSpace = !curChar && lastChar;
          spaceToChar = curChar && !lastChar;
          charToChar = fontChanges && curChar && lastChar;
        }
        if (!(fontChanges && curChar && lastChar) && (period && !spaceToChar && !charToSpace) && !newLine) {
          count++;
          end = i;
        }
        if (!curChar && !newLine) {
          spaceWidth += fontMap[font].swidth;
          lastFont = spFonts[spFonts.length - 1];
          if ((lastFont != null) && lastFont.font === font) {
            lastFont.space += " ";
            lastFont.count++;
          } else {
            spFonts.push({
              font: font,
              space: " ",
              count: 1
            });
          }
        }
        if ((period && ((charToSpace || spaceToChar) || charToChar)) || newLine) {
          if (newLine) {
            breaks.push(words.length + (lastChar ? 1 : 0));
          }
          if (charToSpace || charToChar || (newLine && lastChar)) {
            g.font = curFont;
            str = parsedText.substr(start, count);
            wordWidth = g.measureText(str).width;
            words.push({
              word: str,
              width: wordWidth,
              spaceWidth: 0,
              font: curFont,
              spaceFonts: null
            });
            if (newLine) {
              words[words.length - 1].spaceFonts = [];
            }
            totalWidth += wordWidth;
          }
          if (spaceToChar || (newLine && !lastChar)) {
            lastW = words[words.length - 1];
            if (lastW.space == null) {
              lastW.spaceWidth = spaceWidth;
              lastW.spaceFonts = spFonts;
              totalWidth += spaceWidth;
            }
          }
          newLine = false;
          end = start = i;
          count = 1;
          curFont = font;
          if (!charToChar && spaceToChar) {
            spaceWidth = 0;
            spFonts = [];
          }
        }
      }
      if (count >= 1 && curChar) {
        str = parsedText.substr(start, count);
        wordWidth = g.measureText(str).width;
        words.push({
          word: str,
          width: wordWidth,
          spaceWidth: 0,
          font: curFont,
          spaceFonts: []
        });
        totalWidth += wordWidth;
      }
    }
    if (breaks[breaks.length - 1] !== words.length) {
      breaks.push(words.length);
    }
    maxLines = words[0].spaceWidth === 0 ? words.length - 1 : words.length;
    return [words, fontMap, breaks, totalWidth, maxLines];
  };

  Base_LabelLayoutBase.prototype.stringsByFont = function(words, fontMap, bestLineBreaks) {
    var breaks, curFont, h, i, row, rowChanges, rowWidths, rw, spaceFonts, str, strw, subLines, w, _i, _j, _len, _ref;
    curFont = this.textStyle.font !== words[0].font ? words[0].font : this.textStyle.font;
    breaks = Base_Helpers.realClone(bestLineBreaks);
    subLines = [];
    rowWidths = [];
    h = fontMap[curFont].height;
    rw = 0;
    strw = 0;
    str = "";
    row = 0;
    for (i = _i = 0, _ref = words.length - 1; _i <= _ref; i = _i += 1) {
      w = words[i];
      rowChanges = i === breaks[0];
      if (w.font !== curFont) {
        h = Math.max(h, fontMap[curFont].height);
        if (!!strw) {
          subLines.push({
            text: str,
            width: strw,
            font: curFont,
            row: row
          });
        }
        curFont = w.font;
        str = "";
        strw = 0;
      }
      strw += w.width;
      str += w.word;
      rw += w.width + w.spaceWidth;
      if (rowChanges) {
        subLines.push({
          text: str,
          width: strw,
          font: curFont,
          row: row
        });
        rowWidths.push(rw - w.spaceWidth);
        str = "";
        row++;
        strw = rw = 0;
        breaks.shift();
      }
      if (rowChanges) {
        continue;
      }
      spaceFonts = w.spaceFonts;
      if (spaceFonts != null) {
        for (_j = 0, _len = spaceFonts.length; _j < _len; _j++) {
          i = spaceFonts[_j];
          if (i.font !== curFont) {
            subLines.push({
              text: str,
              width: strw,
              font: curFont,
              row: row
            });
            curFont = i.font;
            str = "";
            strw = 0;
          }
          strw += i.count * fontMap[curFont].swidth;
          str += i.space;
        }
      }
    }
    if (!!str) {
      subLines.push({
        text: str,
        width: strw,
        font: curFont,
        row: row
      });
      rowWidths.push(rw - w.spaceWidth);
    }
    return [subLines, rowWidths];
  };

  Base_LabelLayoutBase.prototype.fitLabelInLines = function(label, x, y, align, noSpaceAlign, leftRightFromXY) {
    var a, availableLines, availableWidthFunc, bestLineBreaks, bestLinesActualWidth, bestLinesAvailableWidth, bestProp, bestX, bestY, bestY0, breaks, center, diff, evenLinesAvailableSize, fontMap, height, i, left, leftAnchor, lineCount, lineHeightC, lineHeightM, linesWidth, margin, maxLines, missingSpace, missingSpaceLeft, missingSpaceRight, oddLinesAvailableSize, padding, parsedData, positions, prop, right, rightAnchor, totalWidth, width, words, x0, x1, _i, _j, _k, _l, _m, _n, _o, _p, _ref, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7, _ref8, _ref9;
    margin = this.margin;
    padding = this.padding;
    lineHeightC = this.lineHeightC;
    lineHeightM = this.lineHeightM;
    if (!label.measureDone || !label._textCache) {
      label._textCache = parsedData = this.styleTagParser(label.text);
    }
    _ref = label._textCache, words = _ref[0], fontMap = _ref[1], breaks = _ref[2], totalWidth = _ref[3], maxLines = _ref[4];
    bestProp = -Infinity;
    bestLineBreaks = null;
    bestX = 0;
    bestX = 0;
    bestY = 0;
    bestLinesActualWidth = null;
    bestLinesAvailableWidth = null;
    oddLinesAvailableSize = [];
    evenLinesAvailableSize = [];
    evenLinesAvailableSize.push(leftRightFromXY(x, y));
    for (lineCount = _i = 1, _ref1 = breaks.length - 1; _i <= _ref1; lineCount = _i += 1) {
      if (lineCount % 2 === 1) {
        availableLines = oddLinesAvailableSize;
      } else {
        availableLines = evenLinesAvailableSize;
      }
      a = leftRightFromXY(x, y - height / 2 - margin);
      availableLines.unshift([a[0] - margin, a[1] - margin]);
      a = leftRightFromXY(x, y + height / 2 + margin);
      availableLines.push([a[0] - margin, a[1] - margin]);
    }
    for (lineCount = _j = _ref2 = breaks.length; _j <= maxLines; lineCount = _j += 1) {
      height = lineHeightC + lineHeightM * lineCount;
      if (lineCount % 2 === 1) {
        availableLines = oddLinesAvailableSize;
      } else {
        availableLines = evenLinesAvailableSize;
      }
      a = leftRightFromXY(x, y - height / 2 - margin);
      availableLines.unshift([a[0] - margin, a[1] - margin]);
      a = leftRightFromXY(x, y + height / 2 + margin);
      availableLines.push([a[0] - margin, a[1] - margin]);
      availableWidthFunc = function(linePos) {
        return Math.min(availableLines[linePos][0] + availableLines[linePos][1], availableLines[linePos + 1][0] + availableLines[linePos + 1][1]);
      };
      _ref3 = this.splitWordsToLines(words, breaks, lineCount, availableWidthFunc), prop = _ref3[0], linesWidth = _ref3[1], positions = _ref3[2];
      if (prop > bestProp) {
        bestY0 = y - height / 2;
        bestLineBreaks = positions;
        bestProp = prop;
        bestLinesActualWidth = linesWidth;
        bestLinesAvailableWidth = availableLines.slice(0);
        if (positions.length + 1 > availableLines.length) {
          throw "Internal error";
        }
      }
      if (prop >= 1) {
        break;
      }
    }
    if (bestLineBreaks) {
      missingSpaceLeft = 0;
      missingSpaceRight = 0;
      if (align === "left") {
        left = 1e30;
        for (i = _k = 0, _ref4 = bestLineBreaks.length; _k <= _ref4; i = _k += 1) {
          left = Math.min(bestLinesAvailableWidth[i][0]);
        }
        leftAnchor = -left;
        x0 = leftAnchor;
        x1 = leftAnchor;
        for (i = _l = 0, _ref5 = bestLineBreaks.length - 1; _l <= _ref5; i = _l += 1) {
          width = bestLinesActualWidth[i];
          right = Math.min(bestLinesAvailableWidth[i][1], bestLinesAvailableWidth[i + 1][1]);
          x1 = Math.max(leftAnchor + width);
          missingSpaceRight = Math.max(missingSpaceRight, width - (right - leftAnchor));
        }
      } else if (align === "right") {
        right = 1e30;
        for (i = _m = 0, _ref6 = bestLineBreaks.length; _m <= _ref6; i = _m += 1) {
          right = Math.min(bestLinesAvailableWidth[i][1]);
        }
        rightAnchor = right;
        missingSpace = 0;
        x0 = rightAnchor;
        x1 = rightAnchor;
        for (i = _n = 0, _ref7 = bestLineBreaks.length - 1; _n <= _ref7; i = _n += 1) {
          width = bestLinesActualWidth[i];
          left = Math.min(bestLinesAvailableWidth[i][0], bestLinesAvailableWidth[i + 1][0]);
          x0 = Math.min(rightAnchor - width);
          missingSpaceLeft = Math.max(missingSpaceLeft, width - (right + rightAnchor));
        }
      } else if (align === "center") {
        left = 1e30;
        right = 1e30;
        for (i = _o = 0, _ref8 = bestLineBreaks.length - 1; _o <= _ref8; i = _o += 1) {
          width = bestLinesActualWidth[i] / 2;
          left = Math.min(bestLinesAvailableWidth[i][0] - width, Math.min(bestLinesAvailableWidth[i + 1][0] - width, left));
          right = Math.min(bestLinesAvailableWidth[i][1] - width, Math.min(bestLinesAvailableWidth[i + 1][1] - width, right));
        }
        if (left > 0 && right > 0) {
          center = 0;
        } else if (left > -right) {
          center = right;
        } else if (right > -left) {
          center = -left;
        } else {
          center = (right - left) / 2;
        }
        missingSpace = 0;
        x0 = center;
        x1 = center;
        for (i = _p = 0, _ref9 = bestLineBreaks.length - 1; _p <= _ref9; i = _p += 1) {
          width = bestLinesActualWidth[i];
          left = Math.min(bestLinesAvailableWidth[i][0], bestLinesAvailableWidth[i + 1][0]);
          right = Math.min(bestLinesAvailableWidth[i][1], bestLinesAvailableWidth[i + 1][1]);
          x0 = Math.min(x0, center - width / 2);
          x1 = Math.max(x1, center + width / 2);
          missingSpaceLeft = Math.max(missingSpaceLeft, width / 2 - left - center);
          missingSpaceRight = Math.max(missingSpaceRight, width / 2 - right + center);
        }
      }
      if (noSpaceAlign === "left" && missingSpaceLeft > 0) {
        x0 += missingSpaceLeft;
        x1 += missingSpaceLeft;
      } else if (noSpaceAlign === "right" && missingSpaceRight > 0) {
        x0 -= missingSpaceRight;
        x1 -= missingSpaceRight;
      } else if (noSpaceAlign === "center") {
        diff = (missingSpaceLeft - missingSpaceRight) / 2;
        x0 += diff;
        x1 += diff;
      }
      label.rows = this.stringsByFont(words, fontMap, bestLineBreaks);
      label.hwidth = (x1 - x0) / 2 + padding;
      label.hheight = (lineHeightC + lineHeightM * bestLineBreaks.length) / 2 + padding;
      label.lineHeight = this.lineHeight;
      label.lineHeightM = lineHeightM;
      label.visible = true;
      label.align = align;
      label.measureDone = true;
      label.padding = padding;
      label.borderRadius = this.borderRadius;
      if (this.borderRadius > 0) {
        label.hwidth += 0.45 * Math.min(this.borderRadius, label.hheight);
      }
      if (!label.userPlaced) {
        label.x = x + (x0 + x1) / 2;
        label.y = bestY0 + label.hheight;
      }
    } else {
      label.rows = [[], []];
      label.visible = false;
    }
    return bestProp;
  };

  Base_LabelLayoutBase.prototype.splitWordsToLines = function(words, breaks, lineCount, availableWidthFunc) {

    /*
       Splits words to lines using specified constraints.
       Params:
         * words: array of words generated by styleTagParser, first word is special denoting whitespace before first real word.
         * breaks: indices in words array where mandatory line breaks after word are needed.
         * lineCount: number of lines to build
         * availableWidthFunc: function(lineNo) -> maxLineWidth
       Returns:
         * prop: proportion of available width filled. >1 is good, <1 is not enough space
         * actualWidthForLines: array if used widths for each line
         * positions: line break positions in words array
     */
    var actualWidthForLines, availableBreaks, availableWidth, lineNo, lineWidth, longerLineWidth, nextBrPos, nextBreakIndex, pos, positions, prevWord, prop, word, _i, _ref;
    prop = 100;
    actualWidthForLines = [];
    positions = [];
    nextBreakIndex = 0;
    nextBrPos = breaks[nextBreakIndex];
    availableBreaks = lineCount - breaks.length;
    prevWord = words[0];
    lineWidth = 0;
    availableWidth = availableWidthFunc(0);
    lineNo = 0;
    for (pos = _i = 1, _ref = words.length - 1; _i <= _ref; pos = _i += 1) {
      word = words[pos];
      longerLineWidth = lineWidth + (prevWord.spaceWidth + word.width);
      if (nextBrPos === pos || (prevWord.spaceWidth > 0 && longerLineWidth > availableWidth && availableBreaks > 0)) {
        positions.push(pos - 1);
        actualWidthForLines.push(lineWidth);
        prop = Math.min(prop, availableWidth / lineWidth);
        lineWidth = word.width;
        lineNo += 1;
        availableWidth = availableWidthFunc(lineNo);
        if (nextBrPos !== pos) {
          availableBreaks -= 1;
        } else {
          nextBreakIndex += 1;
          nextBrPos = breaks[nextBreakIndex];
        }
      } else {
        lineWidth = longerLineWidth;
      }
      prevWord = word;
    }
    positions.push(words.length);
    actualWidthForLines.push(lineWidth);
    prop = Math.min(prop, availableWidth / lineWidth);
    return [prop, actualWidthForLines, positions];
  };

  Base_LabelLayoutBase.prototype.lineBreaking = function(g, lengths, words, space, width) {
    var a, dif, l, lines, llen, prevl, sum, tl, w;
    lines = [];
    sum = 0;
    a = 0;
    while (words.length !== 0) {
      w = g.measureText(words[a]).width;
      if (sum + w <= width) {
        sum += w + space;
        if (a === words.length - 1) {
          lines.push(words.join(" "));
          return lines;
        }
        a++;
        continue;
      }
      tl = lengths.reduce(function(x, y) {
        return x + y;
      }) + (space * lengths.length - 1);
      dif = tl - sum - (a * space);
      if (dif / width > 1) {
        if (a === 0) {
          1;
        } else {
          a;
        }
        lines.push(words.splice(0, a).join(" "));
        lengths.splice(0, a);
        a = 0;
        sum = 0;
        continue;
      }
      l = words.splice(a).join(" ");
      lengths.splice(a);
      a = words.length - 1;
      llen = g.measureText(l).width;
      prevl = lengths.reduce(function(x, y) {
        return x + y;
      });
      if (llen / prevl <= .5) {
        while (llen + g.measureText(words[a]).width + space <= prevl - g.measureText(words[a]).width) {
          l = words.pop() + " " + l;
          lengths.splice(-1);
          llen += g.measureText(words[a]).width;
          prevl -= g.measureText(words[a]).width;
          a = words.length - 1;
        }
      }
      lines.push(words.join(" "));
      lines.push(l);
      break;
    }
    return lines;
  };

  return Base_LabelLayoutBase;

})();
// Generated by CoffeeScript 1.8.0
var Linearchart_ValueAxis,
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

Linearchart_ValueAxis = (function() {
  "use strict";
  Linearchart_ValueAxis.settings = {
    _doc: {
      doc_file: "linearchart/settings/valueAxis.markdown",
      type: "section"
    },
    enabled: true,
    enabled_doc: {
      doc: "Show/hide value axis.",
      type: "bool"
    },
    logScale: false,
    logScale_doc: {
      doc: "Whether to use logarithmic scale.",
      type: "bool"
    },
    position: "outside",
    position_doc: {
      doc: "Location of the value axis.",
      type: "enum",
      values: {
        "inside": "on the left side, outside of the chart",
        "outside": "on the left side, inside of the chart"
      }
    },
    side: "left",
    side_doc: {
      doc: "Value axis side in chart",
      type: "enum",
      values: ["left", "right"]
    },
    title: null,
    title_doc: {
      doc: "Title text for the value axis.",
      type: "string"
    },
    minValue: null,
    minValue_doc: {
      doc: "Fixed minimum value for value axis. If not set it will be computed automatically from visible data and zeroLine settings.",
      type: "float"
    },
    maxValue: null,
    maxValue_doc: {
      doc: "Fixed maximum value for value axis. If not set it will be computed automatically from visible data and zeroLine settings.",
      type: "float"
    },
    size: null,
    size_doc: {
      doc: "Fixed width of the value axis. If not set it will be computed automatically from font size.",
      type: "integer",
      units: "pixels"
    },
    hgrid: true,
    hgrid_doc: {
      doc: "Whether to show horizontal grid lines",
      type: "bool"
    },
    axisLine: false,
    axisLine_doc: {
      doc: "Whether to show vertical line along value axis",
      type: "bool"
    },
    scaleAdjustmentTolerance: 0.3,
    scaleAdjustmentTolerance_doc: {
      doc: "This tolerance specifies how big that part is as fraction of total chart height. When part of the vertical space is not used chart scale is automatically adjusted.",
      type: "float"
    },
    scaleAdjustmentAnimationDelay: 200,
    scaleAdjustmentAnimationDelay_doc: {
      doc: "Scale adjustment animation duration.",
      type: "integer",
      units: "milliseconds"
    },
    scaleAdjustmentAnimation: "=",
    scaleStep: null,
    scaleStep_doc: {
      doc: "Difference between two values on the axis. If not set (default), will be automatically calculated from chart height, min, max value and style.labelSpacing.",
      type: "float",
      units: "scale"
    },
    scaleMinStep: 0,
    scaleMinStep_doc: {
      doc: "Smallest difference between two labels. For example, use 1 to disallow the labels to go into fractions.",
      type: "float",
      units: "scale"
    },
    zeroLine: "visible",
    zeroLine_doc: {
      doc: "Zero line.",
      type: "enum",
      values: {
        "visible": "adjusts position accordingly to the min/max values",
        "center": "always centered",
        "floating": "can be outside the visible chart - shown only range between min-max values."
      }
    },
    valueFormatterFunction: null,
    valueFormatterFunction_doc: {
      doc: "Prepare custom format values to display in value axis. If using this, also set the `size` parameter to accommodate your label size.",
      parameters: {
        "value": "numerical value to display",
        "unitName": "name of multiplier - 'K' for thousands, 'M' for millions",
        "unitValue": "multiplier value - 1000 for thousands, 1 000 000 for millions",
        "name": "value string that is displayed by default"
      },
      returns: "string to display at the value",
      type: "function"
    },
    style: {
      _doc: {
        doc: "Style for parts of value axis.",
        type: "object"
      },
      title: {
        _doc: {
          doc: "Title text for the value axis.",
          type: "object",
          baseObject: Base_Label.styleSettings
        },
        fillColor: "#000000",
        font: "13px Arial",
        reverseDirection: false,
        alignment: "center",
        margin: 5
      },
      tick: {
        lineColor: "#AAAAAA"
      },
      tick_doc: {
        doc: "Value axis tick lines style.",
        type: "object"
      },
      axisLine: {
        _doc: {
          doc: "Rendering style for the vertical line along value axis.",
          type: "object"
        },
        lineColor: "rgba(127,127,127,0.5)",
        lineWidth: 1
      },
      valueLabel: {
        _doc: {
          doc: "Value axis label rendering settings.",
          type: "object",
          baseObject: Base_Label.styleSettings
        },
        fillColor: "#000000",
        font: "11px Arial",
        margin: 0
      },
      labelSpacing: 25,
      labelSpacing_doc: {
        doc: "Distance between value axis labels.",
        type: "float",
        units: "pixels"
      },
      baseLine: {
        _doc: {
          doc: "Base line settings. It is the horizontal line showing zero value.",
          type: "object"
        },
        lineColor: "rgba(127,127,127,0.5)",
        depthColor: "rgba(127,127,127,0.5)",
        lineWidth: 1,
        lineDepth: 1
      },
      hgrid: {
        _doc: {
          doc: "Horizontal grid lines.",
          type: "object"
        },
        lineColor: "rgba(255,255,255,0.2)"
      }
    }
  };

  function Linearchart_ValueAxis(chart, options) {
    this.options = options;
    this.computePanelSize = __bind(this.computePanelSize, this);
    this.events = chart.events;
    this.scene = chart.scene;
    this.isLogScale = this.options.logScale;
    this.isInside = this.options.position === "inside";
    this.locations = [];
    this.values = [];
    this.title = null;
    this.cachedUnits = [];
    this.panel = new Base_ChartPanel();
    this.panel.packingOrder = 110;
    this.panel.computeSize = this.computePanelSize;
    this.lastMaxValue = 0;
    this.lastMinValue = 0;
    this.minValue = 0;
    this.maxValue = 0;
    this.scale = 0;
    this.zeroY = 0;
    this.logOffset = 1;
    this.minValueAnimation = null;
    this.maxValueAnimation = null;
    this.axisChanged = false;
    this.seriesDepth = 0;
    this.seriesMinValue = null;
    this.seriesMaxValue = null;
    this.series = 0;
  }

  Linearchart_ValueAxis.prototype.getPanel = function() {
    if (!this.options.enabled) {
      return null;
    }
    this.panel.location = this.options.position;
    this.panel.side = this.options.side;
    return this.panel;
  };

  Linearchart_ValueAxis.prototype.computePanelSize = function(availableWidth, availableHeight, context, labelRenderer) {
    var angle, isRightSide, reverseDirection, size, title;
    size = 0;
    if (this.options.title && Base_Helpers.isString(this.options.title)) {
      title = new Base_Label();
      title.text = this.options.title;
      title.textStyle = this.options.style.title;
      title.maxWidth = availableHeight;
      title.align = this.options.style.title.alignment;
      title.aspectRatio = 0;
      isRightSide = this.options.side === "right";
      reverseDirection = this.options.style.title.reverseDirection;
      angle = isRightSide ? 90 : -90;
      title.angle = reverseDirection ? -angle : angle;
      labelRenderer.measure(context, title, title);
      size += 2 * (this.options.style.title.margin + title.hheight);
      this.title = title;
    }
    if (this.options.size) {
      size = this.options.size;
    } else {
      Base_Graphics.textStyle(context, this.options.style.valueLabel);
      size += 2 * this.options.style.valueLabel.margin + context.measureText("1999.9 M").width;
    }
    return [Math.round(size), availableHeight];
  };

  Linearchart_ValueAxis.prototype.recieveSeriesGeometry = function(min, max, depth) {
    if (this.options.minValue !== null) {
      this.seriesMinValue = this.options.minValue;
    } else if (min !== void 0) {
      if (this.seriesMinValue !== null) {
        this.seriesMinValue = Math.min(min, this.seriesMinValue);
      } else {
        this.seriesMinValue = min;
      }
    }
    if (this.options.maxValue !== null) {
      this.seriesMaxValue = this.options.maxValue;
    } else if (max !== void 0) {
      if (this.seriesMaxValue !== null) {
        this.seriesMaxValue = Math.max(max, this.seriesMaxValue);
      } else {
        this.seriesMaxValue = max;
      }
    }
    return this.seriesDepth = Math.max(depth, this.seriesDepth);
  };

  Linearchart_ValueAxis.prototype.updateMinMax = function(event) {
    var hasChanges, max, min, _ref;
    hasChanges = ((_ref = event.changes) != null ? _ref.bounds : void 0) || this.locations.length === 0;
    if (event.changes.settings) {
      this.isLogScale = this.options.logScale;
      this.isInside = this.options.position === "inside";
      hasChanges = true;
    }
    if (this.shouldChangeScale()) {
      if (this.seriesMinValue !== this.lastMinValue) {
        hasChanges = true;
        if ((this.lastMinValue == null) || event.changes.displayUnit || this.minValue === this.maxValue) {
          this.minValueAnimation = null;
        } else {
          if (this.minValueAnimation != null) {
            this.minValueAnimation.retarget(this.seriesMinValue, event.timeStamp);
          } else {
            this.minValueAnimation = new Base_Animator(this.lastMinValue, this.seriesMinValue, this.options.scaleAdjustmentAnimationDelay, this.options.scaleAdjustmentAnimation, event.timeStamp);
          }
        }
        this.lastMinValue = this.seriesMinValue;
      }
      if (this.seriesMaxValue !== this.lastMaxValue) {
        hasChanges = true;
        if ((this.lastMaxValue == null) || event.changes.displayUnit || this.minValue === this.maxValue) {
          this.maxValueAnimation = null;
        } else {
          if (this.maxValueAnimation != null) {
            this.maxValueAnimation.retarget(this.seriesMaxValue, event.timeStamp);
          } else {
            this.maxValueAnimation = new Base_Animator(this.lastMaxValue, this.seriesMaxValue, this.options.scaleAdjustmentAnimationDelay, this.options.scaleAdjustmentAnimation, event.timeStamp);
          }
        }
        this.lastMaxValue = this.seriesMaxValue;
      }
    }
    this.seriesMaxValue = this.options.minValue;
    this.seriesMinValue = this.options.maxValue;
    if (this.minValueAnimation) {
      hasChanges = true;
      min = this.minValueAnimation.get(event.timeStamp);
      if (this.minValueAnimation.finished(event.timeStamp)) {
        this.minValueAnimation = null;
      }
    } else {
      min = this.lastMinValue;
    }
    if (this.maxValueAnimation) {
      hasChanges = true;
      max = this.maxValueAnimation.get(event.timeStamp);
      if (this.maxValueAnimation.finished(event.timeStamp)) {
        this.maxValueAnimation = null;
      }
    } else {
      max = this.lastMaxValue;
    }
    this.axisChanged = hasChanges;
    if (hasChanges) {
      this.computeNewScale(min, max);
    }
    if (this.minValueAnimation || this.maxValueAnimation) {
      return event.animating = true;
    }
  };

  Linearchart_ValueAxis.prototype.doAnimations = function(event) {
    var align, fractionDigits, i, isRightSide, logMul, logUnit, name, textAboveLine, unitMultiplier, unitName, v, valLabel, value, valueFunction, valuePerLine, valueY, vstep, y, y0, y1, _i, _len, _ref, _ref1, _ref2, _ref3, _results;
    if (!this.axisChanged) {
      return;
    }
    this.axisChanged = false;
    if (!this.options.enabled) {
      return;
    }
    this.locations = [];
    this.values = [];
    textAboveLine = parseInt(this.options.style.valueLabel.font) / 2 * 1.5;
    isRightSide = this.options.side === "right";
    y0 = this.scene.y0;
    y1 = y0 + this.scene.height;
    if (!(this.scale > 0)) {
      if (this.options.scaleStep) {
        valuePerLine = this.options.scaleStep;
      } else {
        valuePerLine = 100;
      }
      vstep = this.options.style.labelSpacing;
      y = y1 - vstep;
      if (this.options.logScale) {
        v = 1;
      } else {
        v = valuePerLine;
      }
      while (y > y0) {
        this.locations.push(y | 0);
        this.values.push(v);
        if (this.options.logScale) {
          v *= 10;
        } else {
          v += valuePerLine;
        }
        y -= vstep;
      }
    } else {
      if (!this.isLogScale) {
        valuePerLine = this.calcLinearValuePerLine();
        value = 0;
        while (true) {
          value += valuePerLine;
          valueY = this.zeroY - this.valueToRelativeY(value);
          if (valueY - textAboveLine <= y0) {
            break;
          }
          this.locations.push(valueY | 0);
          this.values.push(value);
        }
        value = 0;
        while (true) {
          value -= valuePerLine;
          valueY = this.zeroY - this.valueToRelativeY(value);
          if (valueY >= y1) {
            break;
          }
          this.locations.push(valueY | 0);
          this.values.push(value);
        }
      } else {
        _ref = this.calcExpValuePerLine(), logUnit = _ref[0], logMul = _ref[1];
        value = 1 / logUnit;
        while (true) {
          value *= logMul;
          valueY = this.zeroY - this.valueToRelativeY(value);
          if (valueY - textAboveLine < y0) {
            break;
          }
          this.locations.push((valueY | 0) - 0.5);
          this.values.push(value);
        }
        value = -1 / logUnit;
        while (true) {
          value *= logMul;
          valueY = this.zeroY - this.valueToRelativeY(value);
          if (valueY >= y1) {
            break;
          }
          this.locations.push((valueY | 0) - 0.5);
          this.values.push(value);
        }
      }
      if (this.minValue < 0 && this.maxValue > 0) {
        this.locations.push(this.zeroY | 0);
        this.values.push(0);
      }
    }
    valueFunction = this.options.valueFormatterFunction;
    if (!this.isLogScale) {
      _ref1 = this.getUnitAndName(valuePerLine, this.scene.settings), unitMultiplier = _ref1[0], fractionDigits = _ref1[1], unitName = _ref1[2];
    }
    _ref2 = this.values;
    _results = [];
    for (i = _i = 0, _len = _ref2.length; _i < _len; i = ++_i) {
      value = _ref2[i];
      if (this.isLogScale) {
        _ref3 = this.getUnitAndName(value, this.scene.settings), unitMultiplier = _ref3[0], fractionDigits = _ref3[1], unitName = _ref3[2];
      }
      name = (value / unitMultiplier).toFixed(fractionDigits);
      if (unitMultiplier !== "" && value) {
        name = name + " " + unitName;
      }
      if (valueFunction) {
        name = valueFunction(value, unitName, unitMultiplier, name);
      }
      if (!this.isInside) {
        align = isRightSide ? "start" : "end";
      }
      valLabel = new Base_Label();
      valLabel.text = name.toString();
      valLabel.align = align;
      valLabel.aspectRatio = 0;
      valLabel.textStyle = this.options.style.valueLabel;
      _results.push(this.values[i] = valLabel);
    }
    return _results;
  };

  Linearchart_ValueAxis.prototype.paintUnder = function(event) {
    if (this.options.enabled && this.locations.length > 0) {
      return this.paintZeroLine(event.context);
    }
  };

  Linearchart_ValueAxis.prototype.paint = function(event) {
    var context, g;
    context = event.context;
    if (this.options.enabled && this.locations.length > 0) {
      this.paintGrid(context);
      this.paintLabels(context, event.labelRenderer);
    }
    if (this.options.enabled && this.options.axisLine) {
      g = Base_Graphics.beginStrokeAndFill(context, this.options.style.axisLine);
      this.paintAxisLine(g);
      return Base_Graphics.endStrokeAndFill(context, g, this.options.style.axisLine);
    }
  };

  Linearchart_ValueAxis.prototype.shouldChangeScale = function() {
    var seriesMax, seriesMin, tolerance;
    seriesMin = this.seriesMinValue;
    seriesMax = this.seriesMaxValue;
    if (seriesMin === null || seriesMax === null) {
      return false;
    }
    if (this.lastMinValue === null || this.lastMaxValue === null || !(this.lastMinValue < this.lastMaxValue)) {
      return true;
    }
    if (this.options.zeroLine === "center") {
      seriesMax = Math.max(seriesMax, -seriesMin);
      seriesMin = -seriesMax;
    } else if (this.options.zeroLine === "visible") {
      seriesMin = Math.min(seriesMin, 0);
      seriesMax = Math.max(seriesMax, 0);
    }
    if (seriesMin < this.minValue || seriesMax > this.maxValue) {
      return true;
    }
    tolerance = (this.lastMaxValue - this.lastMinValue) * this.options.scaleAdjustmentTolerance;
    if (seriesMin > this.lastMinValue + tolerance || seriesMax < this.lastMaxValue - tolerance) {
      return true;
    }
    return false;
  };

  Linearchart_ValueAxis.prototype.computeNewScale = function(min, max) {
    var diff, height, max2, min2, minStep, range, topPos, y0;
    height = this.scene.height;
    y0 = this.scene.y0;
    if (this.options.zeroLine === "center") {
      max = Math.max(max, -min);
      min = -max;
    } else if (this.options.zeroLine === "visible") {
      min = Math.min(min, 0);
      max = Math.max(max, 0);
    }
    if (this.options.minValue !== null) {
      min = this.options.minValue;
    }
    if (this.options.maxValue !== null) {
      max = this.options.maxValue;
    }
    if (!height > 0 || !(min < max)) {
      this.minValue = 0;
      this.maxValue = 0;
      this.logOffset = 1;
      this.scale = 0;
      this.zeroY = y0 + height;
      return;
    }
    if (this.options.scaleStep > 0) {
      minStep = this.options.scaleStep;
    } else if (this.options.scaleMinStep > 0) {
      minStep = this.options.scaleMinStep;
    }
    if (minStep > 0) {
      if (min < 0) {
        min = Math.floor(min / minStep) * minStep;
      }
      if (max > 0) {
        max = Math.ceil(max / minStep) * minStep;
      }
    }
    diff = max - min;
    if (min !== 0 && min !== -100) {
      if (this.isLogScale) {
        min = Base_Helpers.sign(min) * Math.pow(Math.abs(min), 1 - Base_Helpers.sign(min) * this.options.scaleAdjustmentTolerance);
      } else {
        min2 = min - diff * this.options.scaleAdjustmentTolerance;
        if (min > 0) {
          min = Math.max(0, min2);
        } else if (min < 0) {
          min = Math.min(0, min2);
        }
      }
    }
    if (max !== 0 && max !== 100) {
      if (this.isLogScale) {
        max = Base_Helpers.sign(max) * Math.pow(Math.abs(max), 1 + Base_Helpers.sign(max) * this.options.scaleAdjustmentTolerance);
      } else {
        max2 = max + diff * this.options.scaleAdjustmentTolerance;
        if (max > 0) {
          max = Math.max(0, max2);
        } else if (max < 0) {
          max = Math.min(0, max2);
        }
      }
    }
    if (this.options.minValue !== null) {
      min = this.options.minValue;
    }
    if (this.options.maxValue !== null) {
      max = this.options.maxValue;
    }
    this.minValue = min;
    this.maxValue = max;
    if (!this.isLogScale) {
      range = max - min;
    } else {
      if (min <= 0 || max >= 0) {
        this.logOffset = 1;
        range = Math.log(max + this.logOffset) + Math.log(-min + this.logOffset);
      } else if (min < 0) {
        this.logOffset = 1 - min;
        range = Math.log(max + this.logOffset);
      } else if (max > 0) {
        this.logOffset = 1 + max;
        range = Math.log(-min + this.logOffset);
      }
    }
    this.scale = height / range;
    topPos = this.valueToRelativeY(min);
    return this.zeroY = y0 + height + topPos;
  };

  Linearchart_ValueAxis.prototype.valueToRelativeY = function(value) {
    if (!this.isLogScale) {
      return this.scale * value;
    } else {
      if (value > 0) {
        return this.scale * Math.log(value + this.logOffset);
      } else if (value < 0) {
        return -this.scale * Math.log(-value + this.logOffset);
      } else {
        return 0;
      }
    }
  };

  Linearchart_ValueAxis.prototype.calcLinearValuePerLine = function() {
    var base, desired, orderOfMagnitude;
    if (this.options.scaleStep) {
      return this.options.scaleStep;
    }
    desired = this.options.style.labelSpacing / this.scale;
    orderOfMagnitude = Math.log(desired) / Math.log(10);
    base = Math.pow(10, Math.floor(orderOfMagnitude - 1));
    base = Math.max(base, this.options.scaleMinStep);
    while (base < desired) {
      if (base * 2 >= desired) {
        return base * 2;
      }
      if (base > 10 && base * 2.5 >= desired) {
        return base * 2.5;
      }
      if (base * 5 >= desired) {
        return base * 5;
      }
      base *= 10;
    }
    return base;
  };

  Linearchart_ValueAxis.prototype.calcExpValuePerLine = function() {
    var pixelsPer10Times, stepSize, unit, valueMultiplier;
    pixelsPer10Times = this.valueToRelativeY(10) - this.valueToRelativeY(1);
    valueMultiplier = 10;
    unit = 10;
    stepSize = pixelsPer10Times;
    if (stepSize > this.options.style.labelSpacing * 4) {
      return [2, 2];
    }
    while (stepSize < this.options.style.labelSpacing) {
      valueMultiplier *= 10;
      stepSize += pixelsPer10Times;
    }
    return [unit, valueMultiplier];
  };

  Linearchart_ValueAxis.prototype.getUnitAndName = function(base, settings) {
    var digitsAfterComma, i, m, name, s, u, unit, x, _ref;
    base = Math.abs(base);
    i = this.isLogScale ? "log" : "lin";
    if (typeof this.cachedUnits[i] === "undefined") {
      this.cachedUnits[i] = [];
    }
    unit = 1;
    name = "";
    if (this.cachedUnits[i][base]) {
      return this.cachedUnits[i][base];
    }
    _ref = settings.localization.valueUnits;
    for (u in _ref) {
      m = _ref[u];
      s = Math.abs(base / m);
      if (i === "lin") {
        if (s < 1000 && s >= 1) {
          unit = m;
          name = u;
          break;
        }
      } else if (i === "log") {
        if (base === Math.round(base / m) * m && unit < m) {
          unit = m;
          name = u;
        }
      }
    }
    digitsAfterComma = 0;
    if (base > 0) {
      x = 1;
      while (base < x) {
        digitsAfterComma += 1;
        x /= 10;
      }
    }
    this.cachedUnits[i][base] = [unit, digitsAfterComma, name];
    return [unit, digitsAfterComma, name];
  };

  Linearchart_ValueAxis.prototype.paintGrid = function(g) {
    var cc, gr, hgrid1, hgrid2, i, x1, x2, y, _i, _j, _len, _len1, _ref, _ref1;
    if (!this.options.hgrid) {
      return;
    }
    hgrid1 = this.options.style.hgrid.lineColor;
    this.options.style.hgrid.lineColor = hgrid1;
    this.options.style.hgrid.lineWidth = 1;
    gr = Base_Graphics.beginStrokeAndFill(g, this.options.style.hgrid);
    Base_Graphics.clearShadow(gr);
    x1 = this.scene.x0;
    x2 = this.scene.x0 + this.scene.width;
    _ref = this.locations;
    for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
      y = _ref[i];
      if (this.values[i] === 0) {
        continue;
      }
      gr.moveTo(x1, y + 0.5);
      gr.lineTo(x2, y + 0.5);
    }
    Base_Graphics.endStrokeAndFill(g, gr, this.options.style.hgrid);
    cc = Base_Graphics.parseColor(hgrid1);
    if (cc[3] < 0.3) {
      hgrid2 = Base_Graphics.deriveColor(hgrid1, 0.5, 0.5);
      this.options.style.hgrid.lineColor = hgrid2;
      gr = Base_Graphics.beginStrokeAndFill(g, this.options.style.hgrid);
      _ref1 = this.locations;
      for (i = _j = 0, _len1 = _ref1.length; _j < _len1; i = ++_j) {
        y = _ref1[i];
        if (this.values[i] === 0) {
          continue;
        }
        gr.moveTo(x1, y - .5);
        gr.lineTo(x2, y - .5);
      }
      Base_Graphics.endStrokeAndFill(g, gr, this.options.style.hgrid);
      return this.options.style.hgrid.lineColor = hgrid1;
    }
  };

  Linearchart_ValueAxis.prototype.paintAxisLine = function(g) {
    var x0, x1, xt, yt;
    x0 = this.panel.left;
    x1 = this.panel.right;
    yt = this.scene.y0 + this.scene.height;
    if (this.isInside) {
      if (this.options.side === "right") {
        xt = x0;
      }
      if (this.options.side === "left") {
        xt = x1;
      }
      g.moveTo(xt, this.scene.y0);
      return g.lineTo(xt, yt);
    } else if (this.options.side === "right") {
      xt = x0 - 0.5;
      g.moveTo(xt, this.scene.y0);
      return g.lineTo(xt, yt);
    } else {
      xt = x1 + 0.5;
      g.moveTo(xt, this.scene.y0);
      return g.lineTo(xt, yt);
    }
  };

  Linearchart_ValueAxis.prototype.paintZeroLine = function(context) {
    var d, g, x1, x2, z;
    d = Math.max(this.options.style.baseLine.lineDepth, this.seriesDepth);
    x1 = this.scene.x0;
    x2 = this.scene.x0 + this.scene.width;
    z = this.zeroY;
    if (d > 0) {
      context.beginPath();
      context.fillStyle = this.options.style.baseLine.depthColor;
      context.moveTo(x1, z);
      context.lineTo(x1 + d, z - d);
      context.lineTo(x2, z - d);
      context.lineTo(x2, z);
      context.closePath();
      return context.fill();
    } else {
      g = Base_Graphics.beginStroke(context, this.options.style.baseLine);
      g.moveTo(x1, z);
      g.lineTo(x2, z);
      return Base_Graphics.endStroke(context, g, this.options.style.baseLine);
    }
  };

  Linearchart_ValueAxis.prototype.paintLabels = function(g, labelRenderer) {
    var centerX, centerY, hHeight, height, i, isRightSide, label, labelX, margin, midX, tickx, valueY, x0, x1, y, y0, _i, _j, _len, _ref, _ref1, _results;
    x0 = this.panel.left;
    x1 = this.panel.right;
    isRightSide = this.options.side === "right";
    if (this.options.title && Base_Helpers.isString(this.options.title)) {
      y0 = this.scene.y0;
      height = this.scene.height;
      hHeight = this.title.hheight;
      margin = this.options.style.title.margin;
      centerY = y0 + height * 0.5;
      if (isRightSide) {
        centerX = x1 - margin - hHeight;
        x1 -= hHeight + margin * 2;
      } else {
        centerX = x0 + margin + hHeight;
        x0 += hHeight + margin * 2;
      }
      labelRenderer.paintWithStyle(g, centerX, centerY, 1, this.title, this.title);
    }
    midX = (x0 + x1) / 2;
    if (isRightSide) {
      tickx = x0;
    } else {
      tickx = x1 - 4;
    }
    if (!this.isInside) {
      g.beginPath();
      _ref = this.locations;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        y = _ref[_i];
        g.moveTo(tickx, y);
        g.lineTo(tickx + 4, y);
      }
      Base_Graphics.stroke(g, this.options.style.tick);
    }
    _results = [];
    for (i = _j = 0, _ref1 = this.locations.length; _j < _ref1; i = _j += 1) {
      valueY = this.locations[i];
      label = this.values[i];
      labelRenderer.measure(g, label);
      if (this.isInside) {
        labelX = midX;
      } else if (isRightSide) {
        labelX = tickx + label.hwidth + 7;
      } else {
        labelX = tickx - label.hwidth - 3;
      }
      _results.push(labelRenderer.paintWithStyle(g, labelX, valueY, 1, label, label));
    }
    return _results;
  };

  return Linearchart_ValueAxis;

})();
// Generated by CoffeeScript 1.8.0
var Linearchart_ValueAxisSet;

Linearchart_ValueAxisSet = (function() {
  function Linearchart_ValueAxisSet(chart, axisConfigList) {
    var v, va, _i, _len, _ref;
    this.chart = chart;
    this.axisConfigList = axisConfigList;
    this.axis = [];
    this.baseConfig = this.chart.settings.valueAxisDefault;
    if (!(this.axisConfigList.length > 0)) {
      return;
    }
    _ref = this.axisConfigList;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      va = _ref[_i];
      v = this.axis[va.id] = new Linearchart_ValueAxis(chart, va);
    }
  }

  Linearchart_ValueAxisSet.prototype.getAxis = function(id) {
    return this.axis[id];
  };

  Linearchart_ValueAxisSet.prototype.getPanels = function() {
    var panel, panels, va, _i, _len, _ref;
    panels = [];
    _ref = this.axisConfigList;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      va = _ref[_i];
      panel = this.axis[va.id].getPanel();
      if (panel) {
        panels.push(panel);
      }
    }
    return panels;
  };

  Linearchart_ValueAxisSet.prototype.updateMinMax = function(event) {
    var name, o, _ref, _results;
    if (!(this.axisConfigList.length > 0)) {
      return;
    }
    _ref = this.axis;
    _results = [];
    for (name in _ref) {
      o = _ref[name];
      _results.push(o.updateMinMax(event));
    }
    return _results;
  };

  Linearchart_ValueAxisSet.prototype.doAnimations = function(event) {
    var name, o, _ref, _results;
    _ref = this.axis;
    _results = [];
    for (name in _ref) {
      o = _ref[name];
      _results.push(o.doAnimations(event));
    }
    return _results;
  };

  Linearchart_ValueAxisSet.prototype.paintUnder = function(event) {
    var name, o, _ref, _results;
    _ref = this.axis;
    _results = [];
    for (name in _ref) {
      o = _ref[name];
      _results.push(o.paintUnder(event));
    }
    return _results;
  };

  Linearchart_ValueAxisSet.prototype.paint = function(event) {
    var name, o, _ref, _results;
    _ref = this.axis;
    _results = [];
    for (name in _ref) {
      o = _ref[name];
      _results.push(o.paint(event));
    }
    return _results;
  };

  return Linearchart_ValueAxisSet;

})();
// Generated by CoffeeScript 1.8.0
var Base_Scene;

Base_Scene = (function() {
  "use strict";
  function Base_Scene() {
    this.settings = null;
    this.chartWidth = 1;
    this.chartHeight = 1;
    this.mainData = null;
    this.x0 = 0;
    this.y0 = 0;
    this.height = 0;
    this.width = 0;
    this.leftMargin = 0;
    this.rightMargin = 0;
    this.topMargin = 0;
    this.bottomMargin = 0;
    this.loading = true;
    this.messages = {};
    this.selection = [];
    this.backStack = [];
  }

  Base_Scene.prototype.setMessage = function(origin, msg, pri) {
    var changed;
    if (msg != null) {
      changed = (this.messages[origin] == null) || this.messages[origin].msg !== msg || this.messages[origin].pri !== pri;
      this.messages[origin] = {
        msg: msg,
        pri: pri
      };
    } else {
      changed = this.messages[origin] != null;
      delete this.messages[origin];
    }
    return changed;
  };

  Base_Scene.prototype.getMessage = function() {
    var k, m, mm, pri, _ref;
    m = null;
    pri = 0;
    _ref = this.messages;
    for (k in _ref) {
      mm = _ref[k];
      if (mm.pri > pri) {
        m = mm.msg;
        pri = mm.pri;
      }
    }
    return m;
  };

  Base_Scene.prototype.pushBack = function(state) {
    this.backStack.push(state);
    if (this.backStack.length > 1000) {
      return this.backStack = this.backStack.slice(200);
    }
  };

  return Base_Scene;

})();
// Generated by CoffeeScript 1.8.0

/*
  Represents a single pointer. On multitouch, separate event for each pointer will be fired.
 */
var Base_MouseEvent, Base_MouseEvents, Base_MousePointer,
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  __hasProp = {}.hasOwnProperty;

Base_MouseEvent = (function() {
  Base_MouseEvent.prototype.time = 0;

  Base_MouseEvent.prototype.changes = {};

  Base_MouseEvent.prototype.consumed = false;

  Base_MouseEvent.prototype.defaultPrevented = false;

  Base_MouseEvent.prototype.preventDefault = function() {
    return this.defaultPrevented = true;
  };

  Base_MouseEvent.prototype.x = 0;

  Base_MouseEvent.prototype.y = 0;

  Base_MouseEvent.prototype.dx = 0;

  Base_MouseEvent.prototype.dy = 0;

  Base_MouseEvent.prototype.vx = 0;

  Base_MouseEvent.prototype.vy = 0;

  Base_MouseEvent.prototype.wheely = 0;

  Base_MouseEvent.prototype.wheelx = 0;

  Base_MouseEvent.prototype.identifier = 0;

  Base_MouseEvent.prototype.pressed = false;

  Base_MouseEvent.prototype.touch = false;

  Base_MouseEvent.prototype._leaving = false;

  Base_MouseEvent.prototype.swipeUp = false;

  Base_MouseEvent.prototype.swipeDown = false;

  Base_MouseEvent.prototype.swipeLeft = false;

  Base_MouseEvent.prototype.swipeRight = false;

  function Base_MouseEvent(x, y, timeStamp, identifier) {
    this.x = x;
    this.y = y;
    this.timeStamp = timeStamp;
    this.identifier = identifier;
    1;
  }

  Base_MouseEvent.prototype.distance = function(p) {
    return Math.sqrt((p.x - this.x) * (p.x - this.x) + (p.y - this.y) * (p.y - this.y));
  };

  Base_MouseEvent.prototype.isWithinDistance = function(previous, dist, timeStamp) {
    var dx, dy;
    if (!previous) {
      return false;
    }
    dx = this.pageX - previous.pageX;
    dy = this.pageY - previous.pageY;
    return dx * dx + dy * dy < dist * dist && previous.timeStamp + timeStamp > this.timeStamp;
  };

  return Base_MouseEvent;

})();

Base_MousePointer = (function() {
  function Base_MousePointer(event, settings) {
    this.settings = settings;
    this.identifier = event.identifier;
    this.x = event.x;
    this.y = event.y;
    this.pageX = event.pageX;
    this.pageY = event.pageY;
    this.timeStamp = event.timeStamp;
    this.pts = [[this.x, this.y, this.timeStamp]];
  }

  Base_MousePointer.prototype.moveTo = function(e) {
    if (e.timeStamp === this.timeStamp) {
      this.pts.pop();
    }
    this.timeStamp = e.timeStamp;
    if (e.x || e.y) {
      this.x = e.x;
      this.y = e.y;
    }
    this.pts.push([this.x, this.y, this.timeStamp]);
    if (this.pts.length > 6) {
      return this.pts.unshift();
    }
  };

  Base_MousePointer.prototype.getPosAndSpeed = function(e, isUp) {
    var dt, fraction, fromI, i, lastI, smallestDt, vx, vy, _i, _j, _k;
    e.x = this.x;
    e.y = this.y;
    e.touch = this.touch;
    lastI = this.pts.length - 2;
    if (lastI >= 0) {
      e.dx = this.pts[lastI + 1][0] - this.pts[lastI][0];
      e.dy = this.pts[lastI + 1][1] - this.pts[lastI][1];
    } else {
      e.dx = 0;
      e.dy = 0;
    }
    smallestDt = Infinity;
    for (i = _i = 0; _i <= lastI; i = _i += 1) {
      dt = this.pts[i + 1][2] - this.pts[i][2];
      smallestDt = Math.min(smallestDt, this.pts[i + 1][2] - this.pts[i][2]);
    }
    smallestDt = Math.max(smallestDt, 20);
    fromI = -1;
    for (i = _j = lastI; _j >= 0; i = _j += -1) {
      dt = this.pts[i + 1][2] - this.pts[i][2];
      if (dt > smallestDt * 2) {
        break;
      }
      fromI = i;
    }
    if (fromI === -1) {
      e.vx = 0;
      e.vy = 0;
      return;
    }
    vx = 0;
    vy = 0;
    fraction = 1;
    for (i = _k = fromI; _k <= lastI; i = _k += 1) {
      dt = this.pts[i + 1][2] - this.pts[i][2];
      vx = vx * (1 - fraction) + (this.pts[i + 1][0] - this.pts[i][0]) / dt * fraction;
      vy = vx * (1 - fraction) + (this.pts[i + 1][1] - this.pts[i][1]) / dt * fraction;
      fraction = 0.6;
    }
    e.vx = vx * 1000;
    return e.vy = vy * 1000;
  };

  return Base_MousePointer;

})();

Base_MouseEvents = (function() {
  "use strict";
  Base_MouseEvents.prototype.ID_MOUSE = "mouse";

  Base_MouseEvents.EVENT_MOVE = "move";

  Base_MouseEvents.EVENT_DOWN = "down";

  Base_MouseEvents.EVENT_GLOBAL_DOWN = "gdown";

  Base_MouseEvents.EVENT_DRAG = "drag";

  Base_MouseEvents.EVENT_CANCEL = "cancel";

  Base_MouseEvents.EVENT_UP = "up";

  Base_MouseEvents.EVENT_LEAVE = "leave";

  Base_MouseEvents.EVENT_CLICK = "click";

  Base_MouseEvents.EVENT_RCLICK = "rclick";

  Base_MouseEvents.EVENT_DBLCLICK = "dblclick";

  Base_MouseEvents.EVENT_WHEEL = "mwheel";

  Base_MouseEvents.EVENT_KEY = "key";

  function Base_MouseEvents(container, settings) {
    var ev, fn, _ref, _ref1;
    this.container = container;
    this.settings = settings;
    this.fireClick = __bind(this.fireClick, this);
    this.handleTouchMove = __bind(this.handleTouchMove, this);
    this.handleTouchCancel = __bind(this.handleTouchCancel, this);
    this.handleTouchEnd = __bind(this.handleTouchEnd, this);
    this.handleTouchStart = __bind(this.handleTouchStart, this);
    this.handleMouseOut = __bind(this.handleMouseOut, this);
    this.handleMouseMove = __bind(this.handleMouseMove, this);
    this.handleMouseUp = __bind(this.handleMouseUp, this);
    this.handleMouseWheel = __bind(this.handleMouseWheel, this);
    this.handleCMenu = __bind(this.handleCMenu, this);
    this.handleMouseDown = __bind(this.handleMouseDown, this);
    this.handlePointerLeave = __bind(this.handlePointerLeave, this);
    this.handlePointerCancel = __bind(this.handlePointerCancel, this);
    this.handlePointerUp = __bind(this.handlePointerUp, this);
    this.handlePointerMove = __bind(this.handlePointerMove, this);
    this.handlePointerDown = __bind(this.handlePointerDown, this);
    this.filterEvent = __bind(this.filterEvent, this);
    this.handleKeyDown = __bind(this.handleKeyDown, this);
    this.scaleX = 1.0;
    this.scaleY = 1.0;
    this.mm = 1;
    this.lastEvent = null;
    this.lastTouchEvent = null;
    this.clickEvent = null;
    this.clickTimeout = null;
    this.longPressTimeout = null;
    this.listeners = {};
    this.downPointers = {};
    this.inPointers = {};
    this.containerList = [];
    if (window.PointerEvent) {
      this.container.style["touch-action"] = "none";
      this.containerEvents = {
        "pointerdown": (function(_this) {
          return function(ev) {
            return _this.filterEvent(ev, _this.handlePointerDown);
          };
        })(this),
        "contextmenu": (function(_this) {
          return function(ev) {
            return _this.filterEvent(ev, _this.handleCMenu);
          };
        })(this),
        "mousewheel": (function(_this) {
          return function(ev) {
            return _this.filterEvent(ev, _this.handleMouseWheel);
          };
        })(this)
      };
      this.windowEvents = {
        "pointermove": (function(_this) {
          return function(ev) {
            return _this.filterEvent(ev, _this.handlePointerMove);
          };
        })(this),
        "pointerup": (function(_this) {
          return function(ev) {
            return _this.filterEvent(ev, _this.handlePointerUp);
          };
        })(this),
        "pointercancel": (function(_this) {
          return function(ev) {
            return _this.filterEvent(ev, _this.handlePointerCancel);
          };
        })(this),
        "pointerleave": (function(_this) {
          return function(ev) {
            return _this.filterEvent(ev, _this.handlePointerLeave);
          };
        })(this)
      };
    } else if (window.MSPointerEvent) {
      this.container.style["-ms-touch-action"] = "none";
      this.containerEvents = {
        "MSPointerDown": (function(_this) {
          return function(ev) {
            return _this.filterEvent(ev, _this.handlePointerDown);
          };
        })(this),
        "contextmenu": (function(_this) {
          return function(ev) {
            return _this.filterEvent(ev, _this.handleCMenu);
          };
        })(this),
        "mousewheel": (function(_this) {
          return function(ev) {
            return _this.filterEvent(ev, _this.handleMouseWheel);
          };
        })(this)
      };
      this.windowEvents = {
        "MSPointerMove": (function(_this) {
          return function(ev) {
            return _this.filterEvent(ev, _this.handlePointerMove);
          };
        })(this),
        "MSPointerUp": (function(_this) {
          return function(ev) {
            return _this.filterEvent(ev, _this.handlePointerUp);
          };
        })(this),
        "MSPointerCancel": (function(_this) {
          return function(ev) {
            return _this.filterEvent(ev, _this.handlePointerCancel);
          };
        })(this),
        "MSPointerLeave": (function(_this) {
          return function(ev) {
            return _this.filterEvent(ev, _this.handlePointerLeave);
          };
        })(this)
      };
    } else {
      this.containerEvents = {
        "mousedown": (function(_this) {
          return function(ev) {
            return _this.filterEvent(ev, _this.handleMouseDown);
          };
        })(this),
        "contextmenu": (function(_this) {
          return function(ev) {
            return _this.filterEvent(ev, _this.handleCMenu);
          };
        })(this),
        "mousewheel": (function(_this) {
          return function(ev) {
            return _this.filterEvent(ev, _this.handleMouseWheel);
          };
        })(this),
        "DOMMouseScroll": (function(_this) {
          return function(ev) {
            return _this.filterEvent(ev, _this.handleMouseWheel);
          };
        })(this),
        "touchstart": (function(_this) {
          return function(ev) {
            return _this.filterEvent(ev, _this.handleTouchStart);
          };
        })(this)
      };
      this.windowEvents = {
        "mouseup": (function(_this) {
          return function(ev) {
            return _this.filterEvent(ev, _this.handleMouseUp);
          };
        })(this),
        "mousemove": (function(_this) {
          return function(ev) {
            return _this.filterEvent(ev, _this.handleMouseMove);
          };
        })(this),
        "touchend": (function(_this) {
          return function(ev) {
            return _this.filterEvent(ev, _this.handleTouchEnd);
          };
        })(this),
        "touchcancel": (function(_this) {
          return function(ev) {
            return _this.filterEvent(ev, _this.handleTouchCancel);
          };
        })(this),
        "touchmove": (function(_this) {
          return function(ev) {
            return _this.filterEvent(ev, _this.handleTouchMove);
          };
        })(this),
        "mouseout": (function(_this) {
          return function(ev) {
            return _this.filterEvent(ev, _this.handleMouseOut);
          };
        })(this)
      };
    }
    _ref = this.containerEvents;
    for (ev in _ref) {
      fn = _ref[ev];
      Base_Helpers.listen(window, ev, fn);
    }
    _ref1 = this.windowEvents;
    for (ev in _ref1) {
      fn = _ref1[ev];
      Base_Helpers.listen(window, ev, fn);
    }
    this.addContainer(container);
  }

  Base_MouseEvents.prototype.addContainer = function(item) {
    var ev, fn, _ref, _ref1;
    this.containerList.push(item);
    _ref = this.windowEvents;
    for (ev in _ref) {
      fn = _ref[ev];
      Base_Helpers.listen(item, ev, fn);
    }
    _ref1 = this.containerEvents;
    for (ev in _ref1) {
      fn = _ref1[ev];
      Base_Helpers.listen(item, ev, fn);
    }
    return Base_Helpers.listen(item, "keydown", this.handleKeyDown);
  };

  Base_MouseEvents.prototype.remove = function() {
    var container, ev, fn, _i, _len, _ref, _ref1, _ref2, _ref3, _results;
    _ref = this.windowEvents;
    for (ev in _ref) {
      fn = _ref[ev];
      Base_Helpers.unlisten(window, ev, fn);
    }
    _ref1 = this.containerEvents;
    for (ev in _ref1) {
      fn = _ref1[ev];
      Base_Helpers.unlisten(window, ev, fn);
    }
    _ref2 = this.containerList;
    _results = [];
    for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
      container = _ref2[_i];
      _ref3 = this.containerEvents;
      for (ev in _ref3) {
        fn = _ref3[ev];
        Base_Helpers.unlisten(container, ev, fn);
      }
      _results.push(Base_Helpers.unlisten(container, "keydown", this.handleKeyDown));
    }
    return _results;
  };


  /*
    Simple variant - only one listener per event
   */

  Base_MouseEvents.prototype.listen = function(eventName, func) {
    return this.listeners[eventName] = func;
  };

  Base_MouseEvents.prototype.processConsumed = function(domEvent, chartsEvent) {
    if (chartsEvent.consumed) {
      return Base_Helpers.stopPropagation(domEvent);
    }
  };

  Base_MouseEvents.prototype.handleKeyDown = function(event) {
    if (!event.keyCode) {
      event.keyCode = event.which;
    }
    this.fireEvent(Base_MouseEvents.EVENT_KEY, event);
    return this.processConsumed(event, event);
  };

  Base_MouseEvents.prototype.filterEvent = function(event, func) {
    if (event !== this.lastEvent) {
      this.lastEvent = event;
      return func(event);
    }
  };

  Base_MouseEvents.prototype.handlePointerDown = function(event) {
    var consumed, e, isTouch;
    consumed = false;
    e = this.buildEvent(event, event.pointerId, event.timeStamp, event.buttons > 0);
    isTouch = event.pointerType === "touch" || event.pointerType === 2;
    this.downHappened(e, isTouch);
    return this.processConsumed(event, e);
  };

  Base_MouseEvents.prototype.handlePointerMove = function(event) {
    var e;
    e = this.buildEvent(event, event.pointerId, event.timeStamp, event.buttons > 0);
    this.moveHappened(e);
    return this.processConsumed(event, e);
  };

  Base_MouseEvents.prototype.handlePointerUp = function(event) {
    var e;
    if (event.buttons !== 0) {
      return;
    }
    e = this.buildEvent(event, event.pointerId, event.timeStamp, false);
    e.isRightMB = event.button === 2;
    this.upHappened(e);
    return this.processConsumed(event, e);
  };

  Base_MouseEvents.prototype.handlePointerCancel = function(event) {
    var e;
    e = this.buildEvent(event, event.pointerId, event.timeStamp, false);
    return this.cancelHappened(e);
  };

  Base_MouseEvents.prototype.handlePointerLeave = function(event) {
    var e;
    e = this.buildEvent(event, event.pointerId, event.timeStamp, false);
    return this.moveHappened(e);
  };

  Base_MouseEvents.prototype.handleMouseDown = function(event) {
    var e;
    e = this.buildEvent(event, this.ID_MOUSE, event.timeStamp, true);
    if (e.isWithinDistance(this.lastTouchEvent, this.settings.doubleClickSensitivity, this.settings.longPressTimeout)) {
      return;
    }
    this.downHappened(e, false);
    return this.processConsumed(event, e);
  };

  Base_MouseEvents.prototype.handleCMenu = function(event) {
    var e, isRightMB, k, p, _ref;
    if (event.which) {
      isRightMB = event.which === 3;
    } else {
      isRightMB = event.button === 2;
    }
    if (isRightMB) {
      e = this.buildEvent(event, this.ID_MOUSE, event.timeStamp, true);
      _ref = this.downPointers;
      for (k in _ref) {
        if (!__hasProp.call(_ref, k)) continue;
        p = _ref[k];
        e = this.rebuildEvent(event, p, false);
        this.cancelHappened(e);
      }
      this.rclickHappened(e);
      return this.processConsumed(event, e);
    }
  };

  Base_MouseEvents.prototype.handleMouseWheel = function(event) {
    var e;
    if (!this.isTargetOkay(event.target)) {
      return;
    }
    e = this.buildEvent(event, this.ID_MOUSE, event.timeStamp, true);
    e.wheely = event.wheelDelta | (event.detail * -40);
    this.wheelHappened(e);
    return this.processConsumed(event, e);
  };

  Base_MouseEvents.prototype.handleMouseUp = function(event) {
    var e, removeAll;
    if (event.shiftKey && event.ctrlKey) {
      this.ID_MOUSE = "mouse" + this.mm;
      this.mm += 1;
      return;
    } else {
      removeAll = true;
    }
    e = this.buildEvent(event, this.ID_MOUSE, event.timeStamp, false);
    e.isRightMB = event.witch ? event.which === 3 : event.button === 2;
    this.upHappened(e);
    this.processConsumed(event, e);
    if (removeAll) {
      return this.removeLostTouches(event, [], []);
    }
  };

  Base_MouseEvents.prototype.handleMouseMove = function(event) {
    var e;
    e = this.buildEvent(event, this.ID_MOUSE, event.timeStamp, false);
    if (e.isWithinDistance(this.lastTouchEvent, this.settings.doubleClickSensitivity, this.settings.longPressTimeout)) {
      return;
    }
    this.moveHappened(e);
    return this.processConsumed(event, e);
  };

  Base_MouseEvents.prototype.handleMouseOut = function(event) {
    var e;
    e = this.buildEvent(event, this.ID_MOUSE, event.timeStamp, false);
    e.target = event.relatedTarget;
    return this.moveHappened(e);
  };

  Base_MouseEvents.prototype.handleTouchStart = function(event) {
    var consumed, e, list, t, _i, _len;
    this.removeLostTouches(event, event.touches, event.changedTouches);
    consumed = false;
    list = event.changedTouches || event.touches;
    for (_i = 0, _len = list.length; _i < _len; _i++) {
      t = list[_i];
      e = this.buildEvent(t, t.identifier, event.timeStamp, true);
      this.lastTouchEvent = e;
      this.downHappened(e, true);
      consumed || (consumed = e.consumed);
    }
    return this.processConsumed(event, e);
  };

  Base_MouseEvents.prototype.handleTouchEnd = function(event) {
    var consumed, e, list, t, _i, _len;
    list = event.changedTouches || event.touches;
    consumed = false;
    for (_i = 0, _len = list.length; _i < _len; _i++) {
      t = list[_i];
      e = this.buildEvent(t, t.identifier, event.timeStamp, false);
      this.lastTouchEvent = e;
      this.upHappened(e);
      this.pointerLeave(e);
      consumed || (consumed = e.consumed);
      this.removeLostTouches(event, event.touches);
    }
    return this.processConsumed(event, e);
  };

  Base_MouseEvents.prototype.handleTouchCancel = function(event) {
    var e, list, t, _i, _len;
    list = event.changedTouches || event.touches;
    for (_i = 0, _len = list.length; _i < _len; _i++) {
      t = list[_i];
      e = this.buildEvent(t, t.identifier, event.timeStamp, false);
      this.lastTouchEvent = e;
      this.cancelHappened(e);
    }
    return this.removeLostTouches(event, event.touches);
  };

  Base_MouseEvents.prototype.handleTouchMove = function(event) {
    var consumed, e, list, t, _i, _len;
    consumed = false;
    this.removeLostTouches(event, event.touches);
    list = event.changedTouches || event.touches;
    for (_i = 0, _len = list.length; _i < _len; _i++) {
      t = list[_i];
      e = this.buildEvent(t, t.identifier, event.timeStamp, true);
      this.lastTouchEvent = e;
      this.moveHappened(e);
      consumed || (consumed = e.consumed);
    }
    return this.processConsumed(event, e);
  };

  Base_MouseEvents.prototype.removeLostTouches = function(event, touches, freshTouches) {
    var e, k, p, presentTouches, t, _i, _j, _len, _len1, _ref, _results;
    presentTouches = [];
    for (_i = 0, _len = touches.length; _i < _len; _i++) {
      t = touches[_i];
      presentTouches[t.identifier] = true;
    }
    _ref = this.downPointers;
    for (k in _ref) {
      if (!__hasProp.call(_ref, k)) continue;
      p = _ref[k];
      if (!presentTouches[k]) {
        e = this.rebuildEvent(event, p, false);
        this.upHappened(e);
      }
    }
    if (freshTouches != null) {
      _results = [];
      for (_j = 0, _len1 = freshTouches.length; _j < _len1; _j++) {
        t = freshTouches[_j];
        p = this.downPointers[t.identifier];
        if (p != null) {
          e = this.rebuildEvent(event, p, false);
          _results.push(this.upHappened(e));
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    }
  };

  Base_MouseEvents.prototype.rebuildEvent = function(event, obj, pressed) {
    var e;
    e = new Base_MouseEvent(obj.x, obj.y, event.timeStamp, obj.identifier);
    e.pageX = obj.pageX;
    e.pageY = obj.pageY;
    e.pressed = pressed;
    e.shiftKey = event.shiftKey;
    e.altKey = event.altKey;
    e.ctrlKey = event.ctrlKey;
    return e;
  };

  Base_MouseEvents.prototype.buildEvent = function(event, id, timestamp, pressed) {
    var dx, dy, e, pageX, pageY, x, y, _ref;
    _ref = Base_Helpers.elementPos(this.container), dx = _ref[0], dy = _ref[1];
    if (typeof event.pageX !== "undefined") {
      pageX = event.pageX;
      pageY = event.pageY;
    } else {
      pageX = event.clientX + document.documentElement.scrollLeft;
      pageY = event.clientY + document.documentElement.scrollTop;
    }
    x = pageX - dx;
    y = pageY - dy;
    e = new Base_MouseEvent(Math.round(x * this.scaleX), Math.round(y * this.scaleY), timestamp, "" + id);
    e.target = event.target || event.srcElement;
    e.pageX = pageX;
    e.pageY = pageY;
    e.shiftKey = event.shiftKey;
    e.altKey = event.altKey;
    e.ctrlKey = event.ctrlKey;
    e.pressed = pressed;
    return e;
  };

  Base_MouseEvents.prototype.downHappened = function(e, isTouch) {
    var p;
    e.pressed = true;
    this.fireEvent(Base_MouseEvents.EVENT_GLOBAL_DOWN, e);
    if (!this.isTargetOkay(e.target)) {
      return;
    }
    this.container.focus();
    if (this.downPointers[e.identifier] != null) {
      return;
    }
    if (this.clickTimeout != null) {
      clearTimeout(this.clickTimeout);
      this.clickTimeout = null;
    }
    this.downPointers[e.identifier] = p = new Base_MousePointer(e, this.settings);
    p.touch = isTouch;
    this.inPointers[e.identifier] = true;
    this.fireEvent(Base_MouseEvents.EVENT_DOWN, e);
    return this.startLongPress(e);
  };

  Base_MouseEvents.prototype.upHappened = function(e) {
    var p;
    if (this.downPointers[e.identifier] == null) {
      return false;
    }
    p = this.downPointers[e.identifier];
    this.cancelLongPress(e);
    p.moveTo(e);
    p.getPosAndSpeed(e, true);
    delete this.downPointers[e.identifier];
    if (Math.abs(e.vx) > Math.abs(e.vy) * 2) {
      e.swipeSpeed = Math.abs(e.vx);
      if (e.vx > 0) {
        e.swipeLeft = true;
      }
      if (e.vx < 0) {
        e.swipeRight = true;
      }
    } else if (Math.abs(e.vy) > Math.abs(e.vx) * 2) {
      e.swipeSpeed = Math.abs(e.vy);
      if (e.vy < 0) {
        e.swipeUp = true;
      }
      if (e.vy > 0) {
        e.swipeDown = true;
      }
    }
    this.fireEvent(Base_MouseEvents.EVENT_UP, e);
    if (!(p.scrolling || e.isRightMB || e.consumed || p.noClick)) {
      if ((this.clickEvent != null) && this.clickEvent.timeStamp + this.settings.doubleClickTimeout >= e.timeStamp && this.clickEvent.distance(e) < this.settings.doubleClickSensitivity) {
        if (!this.settings.noClickOnDoubleClick) {
          this.fireEvent(Base_MouseEvents.EVENT_CLICK, e);
        }
        this.clickEvent = null;
        return this.fireEvent(Base_MouseEvents.EVENT_DBLCLICK, e);
      } else if (this.settings.noClickOnDoubleClick) {
        this.clickEvent = e;
        return this.clickTimeout = setTimeout(this.fireClick, this.settings.doubleClickTimeout);
      } else {
        this.fireEvent(Base_MouseEvents.EVENT_CLICK, e);
        this.clickEvent = e;
        return setTimeout((function(_this) {
          return function() {
            return _this.clickEvent = null;
          };
        })(this), this.settings.doubleClickTimeout);
      }
    }
  };

  Base_MouseEvents.prototype.cancelHappened = function(e) {
    var p;
    if (this.downPointers[e.identifier] == null) {
      return;
    }
    this.cancelLongPress(e);
    p = this.downPointers[e.identifier];
    delete this.downPointers[e.identifier];
    return this.fireEvent(Base_MouseEvents.EVENT_CANCEL, e);
  };

  Base_MouseEvents.prototype.moveHappened = function(e) {
    var p;
    p = this.downPointers[e.identifier];
    e.pressed = p != null;
    if (p != null) {
      if (e.distance(p) >= this.settings.dragSensitivity || p.scrolling) {
        this.cancelLongPress(e);
        p.scrolling = true;
        p.moveTo(e);
        p.getPosAndSpeed(e, false);
        this.fireEvent(Base_MouseEvents.EVENT_DRAG, e);
        return this.clickEvent = null;
      }
    } else if (this.clickEvent && this.settings.noClickOnDoubleClick) {
      if (this.clickEvent.distance(e) > this.settings.doubleClickSensitivity) {
        this.fireEvent(Base_MouseEvents.EVENT_CLICK, this.clickEvent);
        return this.clickEvent = null;
      }
    } else if (this.isTargetOkay(e.target)) {
      this.inPointers[e.identifier] = true;
      return this.fireEvent(Base_MouseEvents.EVENT_MOVE, e);
    } else {
      return this.pointerLeave(e);
    }
  };

  Base_MouseEvents.prototype.pointerLeave = function(e) {
    if (!this.inPointers.hasOwnProperty(e.identifier)) {
      return;
    }
    if (this.clickEvent && this.clickEvent.identifier === e.identifier) {
      return this.clickEvent._leaving = true;
    } else {
      delete this.inPointers[e.identifier];
      return this.fireEvent(Base_MouseEvents.EVENT_LEAVE, e);
    }
  };

  Base_MouseEvents.prototype.fireClick = function(e) {
    if (!this.clickEvent) {
      return;
    }
    this.fireEvent(Base_MouseEvents.EVENT_CLICK, this.clickEvent);
    if (this.clickEvent._leaving) {
      this.fireEvent(Base_MouseEvents.EVENT_LEAVE, this.clickEvent);
    }
    return this.clickEvent = null;
  };

  Base_MouseEvents.prototype.startLongPress = function(e) {
    var fireLongPress;
    fireLongPress = (function(_this) {
      return function() {
        e.consumed = false;
        _this.fireEvent(Base_MouseEvents.EVENT_RCLICK, e);
        if (e.consumed) {
          return _this.downPointers[e.identifier].noClick = true;
        }
      };
    })(this);
    this.cancelLongPress();
    return this.longPressTimeout = setTimeout(fireLongPress, this.settings.longPressTimeout);
  };

  Base_MouseEvents.prototype.cancelLongPress = function() {
    if (this.longPressTimeout !== null) {
      clearTimeout(this.longPressTimeout);
      return this.longPressTimeout = null;
    }
  };

  Base_MouseEvents.prototype.wheelHappened = function(e) {
    return this.fireEvent(Base_MouseEvents.EVENT_WHEEL, e);
  };

  Base_MouseEvents.prototype.rclickHappened = function(e) {
    return this.fireEvent(Base_MouseEvents.EVENT_RCLICK, e);
  };

  Base_MouseEvents.prototype.fireEvent = function(name, event) {
    if (this.listeners[name]) {
      return this.listeners[name].call(this, event);
    }
  };

  Base_MouseEvents.prototype.isTargetOkay = function(target) {
    var k, v, _i, _len, _ref;
    _ref = this.containerList;
    for (k = _i = 0, _len = _ref.length; _i < _len; k = ++_i) {
      v = _ref[k];
      if ((v === target) || Base_Helpers.isParentOf(v, target)) {
        return true;
      }
    }
    return false;
  };

  return Base_MouseEvents;

})();
// Generated by CoffeeScript 1.8.0
var Base_Bar_Button, Base_Bar_Item,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

Base_Bar_Item = (function() {
  function Base_Bar_Item(chart) {
    this.chart = chart;
    this.domElement = null;
  }

  Base_Bar_Item.prototype.updateSettings = function() {
    return 1;
  };

  Base_Bar_Item.prototype.remove = function() {
    return 1;
  };

  Base_Bar_Item.prototype.onSceneChange = function(changes) {
    return 1;
  };

  Base_Bar_Item.prototype.doAnimations = function(event) {
    return 1;
  };

  return Base_Bar_Item;

})();

Base_Bar_Button = (function(_super) {
  "use strict";
  __extends(Base_Bar_Button, _super);

  function Base_Bar_Button(chart) {
    Base_Bar_Button.__super__.constructor.call(this, chart);
  }

  Base_Bar_Button.prototype.createButton = function(options) {
    var _this;
    this.options = options;
    this.li = Base_Helpers.createDom("li", null, null, null);
    this.a = Base_Helpers.createDom("a", null, null, this.li);
    this.p = Base_Helpers.createDom("p", null, null, this.a);
    _this = this;
    this.onClickProxy = function(ev) {
      return _this.onClick(ev);
    };
    this.domElement = this.li;
    Base_Helpers.listen(this.a, "click", this.onClickProxy);
    return this.updateSettings();
  };

  Base_Bar_Button.prototype.updateSettings = function() {
    var css, title;
    title = this.options.title || this.options.label || "";
    this.a.setAttribute("title", title);
    css = "DVSL-bar-btn " + (this.options.cssClass ? this.options.cssClass : this.options.image ? "DVSL-bar-btn-image" : "DVSL-bar-btn-none");
    this.a.className = css;
    if (this.options.showLabels !== false) {
      this.p.innerHTML = this.options.label || "";
    } else {
      this.p.innerHTML = "";
    }
    if (this.options.image) {
      return this.p.style.backgroundImage = "url('" + this.options.image + "')";
    } else {
      return this.p.style.backgroundImage = null;
    }
  };

  Base_Bar_Button.prototype.remove = function() {
    return Base_Helpers.unlisten(this.a, "click", this.onClickProxy);
  };

  Base_Bar_Button.prototype.onClick = function(event) {
    return 1;
  };

  return Base_Bar_Button;

})(Base_Bar_Item);
// Generated by CoffeeScript 1.8.0
var Linearchart_Series_Stack;

Linearchart_Series_Stack = (function() {
  function Linearchart_Series_Stack(scene, cluster, options, va) {
    this.scene = scene;
    this.cluster = cluster;
    this.options = options;
    this.va = va;
    this.va.series++;
    this.series = [];
    this.seriesId = [];
    this.min = 0;
    this.max = 0;
    this.renderingType = null;
    this.needsAfterProcess = false;
    this.paddingLeft = 0;
    this.paddingRight = 0;
    this.centers = [];
    this.radii = [];
    this.vstack = [];
    this.ystack = [];
    this.xes = [];
    this.times = [];
    this.styles = [];
    this.calculatedDepth = 0;
  }

  Linearchart_Series_Stack.prototype.addSeries = function(seriesId, seriesOptions) {
    if (!this.renderingType) {
      this.renderingType = seriesOptions.type;
    }
    this.series.push(seriesOptions);
    this.seriesId.push(seriesId);
    this.calculatedDepth = Math.max(this.calculatedDepth, seriesOptions.style.depth);
    if (this.renderingType !== "line") {
      this.paddingLeft = Math.max(this.paddingLeft, seriesOptions.style.padding[0]);
      return this.paddingRight = Math.max(this.paddingRight, seriesOptions.style.padding[1]);
    }
  };

  Linearchart_Series_Stack.prototype.afterInit = function() {
    if (this.renderingType === "line") {
      return this.renderer = new Linearchart_Renderer_Line(this.series);
    } else {
      return this.renderer = new Linearchart_Renderer_Columns(this.scene, this.series);
    }
  };

  Linearchart_Series_Stack.prototype.process = function(seriesData) {
    this.processData(seriesData);
    this.computeMinMax();
    this.addLeads(seriesData);
    return this.needsAfterProcess = true;
  };

  Linearchart_Series_Stack.prototype.afterProcess = function() {
    if (this.needsAfterProcess || this.va.axisChanged) {
      this.needsAfterProcess = false;
      return this.computeY();
    }
  };

  Linearchart_Series_Stack.prototype.paint = function(context) {
    var s, _i, _len, _ref;
    _ref = this.series;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      s = _ref[_i];
      if (s.style.fillGradient) {
        s.style.currentFillGradient = this.computeFillGradient(context, s.style.fillGradient);
      }
    }
    if (!(this.ystack.length > 0)) {
      return;
    }
    if (this.ystackNegative) {
      this.renderer.paintStack(context, this.centers, this.radii, this.ystackNegative, this.styles, this.va.zeroY);
    }
    return this.renderer.paintStack(context, this.centers, this.radii, this.ystack, this.styles, this.va.zeroY);
  };

  Linearchart_Series_Stack.prototype.hitTestStack = function(x, y) {
    var x0, x0a, x1, x1a, xind;
    xind = Base_Helpers.binSearch(this.centers, x);
    x0 = this.centers[xind] - this.radii[xind];
    x1 = this.centers[xind] + this.radii[xind];
    if (x0 > x && xind > 0) {
      x0a = this.centers[xind - 1] - this.radii[xind - 1];
      x1a = this.centers[xind - 1] + this.radii[xind - 1];
      if (x1a > x || Math.abs(x1a - x) < Math.abs(x0 - x)) {
        xind -= 1;
        x0 = x0a;
        x1 = x1a;
      }
    }
    return [
      {
        x0: x0,
        y0: 0,
        x1: x1,
        y1: 0,
        series: null,
        stack: this
      }, Base_Geometry.distanceToRect(x, 0, x0, 0, x1, 0)
    ];
  };

  Linearchart_Series_Stack.prototype.hitTest = function(x, y, tolerance) {
    var d1, distance, i1, item, _ref, _ref1;
    _ref = this.renderer.hitTest(this.centers, this.radii, this.ystack, this.styles, this.va.zeroY, x, y, tolerance), item = _ref[0], distance = _ref[1];
    if (this.ystackNegative) {
      _ref1 = this.renderer.hitTest(this.centers, this.radii, this.ystackNegative, this.styles, this.va.zeroY, x, y, tolerance), i1 = _ref1[0], d1 = _ref1[1];
      if (d1 < distance) {
        item = i1;
      }
    }
    if (item !== null) {
      item.seriesIndex = this.seriesId[item.seriesIndex];
      item.stack = this;
    }
    return [item, distance];
  };

  Linearchart_Series_Stack.prototype.computeFillGradient = function(context, gradientArray) {
    var col, fraction, g, height, pos, prev, stop, stops, valueAxis, x0, y0, ypos, zeroY, _i, _j, _len, _len1;
    valueAxis = this.va;
    zeroY = valueAxis.zeroY;
    y0 = this.scene.y0;
    x0 = this.scene.x0;
    height = this.scene.height;
    stops = [];
    for (_i = 0, _len = gradientArray.length; _i < _len; _i++) {
      stop = gradientArray[_i];
      ypos = zeroY - valueAxis.valueToRelativeY(stop[0]);
      fraction = (ypos - y0) / height;
      stops.push([fraction, stop[1]]);
    }
    stops.sort(function(a, b) {
      return a[0] - b[0];
    });
    g = context.createLinearGradient(x0, y0, x0, y0 + height);
    prev = null;
    for (_j = 0, _len1 = stops.length; _j < _len1; _j++) {
      stop = stops[_j];
      pos = stop[0];
      col = stop[1];
      if (pos > 0) {
        if (prev && prev[0] < 0) {
          g.addColorStop(0, Base_Graphics.blendColors(prev[1], col, (0 - prev[0]) / (pos - prev[0])));
        }
        if (pos > 1) {
          if (prev) {
            g.addColorStop(1, Base_Graphics.blendColors(prev[1], col, (1 - prev[0]) / (pos - prev[0])));
          }
          break;
        } else {
          g.addColorStop(pos, col);
        }
      }
      prev = stop;
    }
    return g;
  };

  Linearchart_Series_Stack.prototype.processData = function(dataMap) {
    var i, seriesId, slice, _i, _len, _ref, _results;
    this.vstack = [];
    this.styles = [];
    slice = dataMap[this.seriesId[0]];
    if (slice.times.length === 0) {
      return;
    }
    this.xes = slice.xes.slice(slice.fromIndex, slice.toIndex);
    this.times = slice.times.slice(slice.fromIndex, slice.toIndex);
    this.centers = new Array(this.xes.length - 1);
    this.radii = new Array(this.xes.length - 1);
    this.cluster.computeStackCenterRadius(this, this.xes, this.centers, this.radii);
    _ref = this.seriesId;
    _results = [];
    for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
      seriesId = _ref[i];
      slice = dataMap[seriesId];
      this.vstack.push(slice.values.slice(slice.fromIndex, slice.toIndex - 1));
      if (slice.style) {
        _results.push(this.styles.push(slice.style.slice(slice.fromIndex, slice.toIndex - 1)));
      } else {
        _results.push(this.styles.push(null));
      }
    }
    return _results;
  };

  Linearchart_Series_Stack.prototype.addLeads = function(dataMap) {
    var i, id, slice, _i, _len, _ref, _results;
    _ref = this.seriesId;
    _results = [];
    for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
      id = _ref[i];
      slice = dataMap[id];
      if (slice.leadIn) {
        this.injectLead(slice.leadIn, i);
      }
      if (slice.leadOut) {
        _results.push(this.injectLead(slice.leadOut, i));
      } else {
        _results.push(void 0);
      }
    }
    return _results;
  };

  Linearchart_Series_Stack.prototype.injectLead = function(lead, dataIndex) {
    var center, count, i, j, rad, t0, val, _i, _ref;
    count = this.series.length;
    val = lead.values[0];
    t0 = lead.times[0];
    center = [0];
    rad = [0];
    this.cluster.computeStackCenterRadius(this, lead.xes, center, rad);
    center = center[0];
    rad = rad[0];
    i = 0;
    while (i < this.centers.length && this.centers[i] < center) {
      i++;
    }
    if (i === this.centers.length || this.centers[i] > center) {
      this.centers.splice(i, 0, center);
      this.radii.splice(i, 0, rad);
      this.times.splice(i, 0, t0);
      for (j = _i = 0, _ref = count - 1; _i <= _ref; j = _i += 1) {
        this.vstack[j].splice(i, 0, null);
        if (this.styles[j]) {
          this.styles[j].splice(i, 0, null);
        }
      }
    }
    return this.vstack[dataIndex][i] = val;
  };

  Linearchart_Series_Stack.prototype.getSeparateNegative = function() {
    var v;
    v = this.options.separateNegativeValues;
    if (v === null) {
      v = this.renderingType !== "line";
    }
    return v;
  };

  Linearchart_Series_Stack.prototype.computeMinMax = function() {
    var from, i, j, left, len, max, maxs, min, mins, right, s, separateNegativeValues, stacks, to, type, v, values, vstack, _i, _j, _k, _l, _m, _n, _o, _ref, _ref1, _ref2;
    min = Infinity;
    max = -Infinity;
    if (this.vstack.length > 0) {
      vstack = this.vstack;
      len = vstack[0].length;
      stacks = vstack.length;
      type = this.options.type;
      separateNegativeValues = this.getSeparateNegative();
      left = this.scene.x0;
      right = left + this.scene.width;
      from = 0;
      to = len - 1;
      while (from < len && this.centers[from] + this.radii[from] < left) {
        from += 1;
      }
      while (to >= from && this.centers[to] - this.radii[to] > right) {
        to -= 1;
      }
      if (type === "proportional") {
        min = 0;
        max = 100;
      } else if (stacks === 1) {
        values = vstack[0];
        for (i = _i = from; from <= to ? _i <= to : _i >= to; i = from <= to ? ++_i : --_i) {
          v = values[i];
          if (v !== null) {
            min = Math.min(min, v);
            max = Math.max(max, v);
          }
        }
      } else if (type === "based") {
        for (i = _j = from; _j <= to; i = _j += 1) {
          for (j = _k = 0, _ref = stacks - 1; _k <= _ref; j = _k += 1) {
            v = vstack[j][i];
            if (v !== null) {
              min = Math.min(min, v);
              max = Math.max(max, v);
            }
          }
        }
      } else if (type === "normal" && !separateNegativeValues) {
        for (i = _l = from; _l <= to; i = _l += 1) {
          s = 0;
          for (j = _m = 0, _ref1 = stacks - 1; _m <= _ref1; j = _m += 1) {
            v = vstack[j][i];
            if (v !== null) {
              s += v;
            }
            min = Math.min(min, s);
            max = Math.max(max, s);
          }
        }
      } else if (type === "normal") {
        for (i = _n = from; _n <= to; i = _n += 1) {
          mins = 0;
          maxs = 0;
          for (j = _o = 0, _ref2 = stacks - 1; _o <= _ref2; j = _o += 1) {
            v = vstack[j][i];
            if (v > 0) {
              maxs += v;
            } else if (v < 0) {
              mins += v;
            }
            min = Math.min(min, mins);
            max = Math.max(max, maxs);
          }
        }
      } else {
        throw "stack.type unknown value: " + type;
      }
    }
    this.min = min;
    this.max = max;
    if (min <= max) {
      return this.va.recieveSeriesGeometry(min, max, this.calculatedDepth);
    } else {
      return this.va.recieveSeriesGeometry(void 0, void 0, this.calculatedDepth);
    }
  };

  Linearchart_Series_Stack.prototype.computeY = function() {
    var count, i, j, prevY, separateNegativeValues, stacks, sum, type, v, va, values, vstack, y, ys, ystack, ystackNeg, _i, _j, _k, _l, _len, _len1, _m, _n, _o, _p, _q, _r, _ref, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7;
    if (this.vstack.length === 0) {
      return;
    }
    type = this.options.type;
    separateNegativeValues = this.getSeparateNegative();
    vstack = this.vstack;
    stacks = vstack.length;
    count = vstack[0].length;
    va = this.va;
    ystackNeg = null;
    if (type === "proportional") {
      ystack = (function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = vstack.length; _i < _len; _i++) {
          i = vstack[_i];
          _results.push([]);
        }
        return _results;
      })();
      for (i = _i = 0, _ref = count - 1; _i <= _ref; i = _i += 1) {
        sum = 0;
        for (j = _j = 0, _ref1 = stacks - 1; _j <= _ref1; j = _j += 1) {
          v = vstack[j][i];
          if (v !== null) {
            sum += Math.abs(v);
          }
        }
        if (sum > 0) {
          sum *= 0.01;
          for (j = _k = 0, _ref2 = stacks - 1; _k <= _ref2; j = _k += 1) {
            v = vstack[j][i];
            if (v !== null) {
              ystack[j].push(va.valueToRelativeY(Math.abs(v) / sum));
            } else {
              ystack[j].push(null);
            }
          }
        } else {
          for (j = _l = 0, _ref3 = stacks - 1; _l <= _ref3; j = _l += 1) {
            ystack[j].push(null);
          }
        }
      }
    } else if (type === "based" || stacks === 1) {
      ystack = [];
      prevY = (function() {
        var _len, _m, _ref4, _results;
        _ref4 = vstack[0];
        _results = [];
        for (_m = 0, _len = _ref4.length; _m < _len; _m++) {
          i = _ref4[_m];
          _results.push(0);
        }
        return _results;
      })();
      for (j = _m = 0, _len = vstack.length; _m < _len; j = ++_m) {
        values = vstack[j];
        ys = new Array(count);
        for (i = _n = 0, _len1 = values.length; _n < _len1; i = ++_n) {
          v = values[i];
          if (v !== null) {
            y = va.valueToRelativeY(v);
            ys[i] = y - prevY[i];
            prevY[i] = y;
          } else {
            ys[i] = null;
          }
        }
        ystack.push(ys);
      }
    } else if (type === "normal" && separateNegativeValues && (this.min < 0 && this.max > 0)) {
      ystack = (function() {
        var _len2, _o, _results;
        _results = [];
        for (_o = 0, _len2 = vstack.length; _o < _len2; _o++) {
          i = vstack[_o];
          _results.push([]);
        }
        return _results;
      })();
      ystackNeg = (function() {
        var _len2, _o, _results;
        _results = [];
        for (_o = 0, _len2 = vstack.length; _o < _len2; _o++) {
          i = vstack[_o];
          _results.push([]);
        }
        return _results;
      })();
      for (i = _o = 0, _ref4 = count - 1; _o <= _ref4; i = _o += 1) {
        for (j = _p = 0, _ref5 = stacks - 1; _p <= _ref5; j = _p += 1) {
          v = vstack[j][i];
          if (v > 0) {
            ystack[j].push(va.valueToRelativeY(v));
            ystackNeg[j].push(null);
          } else if (v < 0) {
            ystack[j].push(null);
            ystackNeg[j].push(va.valueToRelativeY(v));
          } else {
            ystack[j].push(null);
            ystackNeg[j].push(null);
          }
        }
      }
    } else if (type === "normal") {
      ystack = (function() {
        var _len2, _q, _results;
        _results = [];
        for (_q = 0, _len2 = vstack.length; _q < _len2; _q++) {
          i = vstack[_q];
          _results.push([]);
        }
        return _results;
      })();
      for (i = _q = 0, _ref6 = count - 1; _q <= _ref6; i = _q += 1) {
        for (j = _r = 0, _ref7 = stacks - 1; _r <= _ref7; j = _r += 1) {
          v = vstack[j][i];
          if (v !== null) {
            ystack[j].push(va.valueToRelativeY(v));
          } else {
            ystack[j].push(null);
          }
        }
      }
    } else {
      throw "stack.type unknown value: " + type;
    }
    this.ystackNegative = ystackNeg;
    return this.ystack = ystack;
  };

  Linearchart_Series_Stack.prototype.exportData = function(from, to) {
    var avg, change, config, count, data, first, fromIndex, i, k, last, max, min, results, sum, times, toIndex, v, values, x, _i, _j, _k, _len, _len1, _ref, _ref1;
    if (this.times && this.vstack) {
      times = this.times;
      count = this.centers.length;
      i = 0;
      while (i < count && times[i + 1] <= from) {
        i++;
      }
      fromIndex = i;
      while (i < count && times[i + 1] < to) {
        i++;
      }
      toIndex = i;
      results = [];
      _ref = this.vstack;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        values = _ref[_i];
        sum = 0;
        max = -Infinity;
        min = Infinity;
        first = null;
        last = null;
        count = 0;
        for (i = _j = fromIndex; _j <= toIndex; i = _j += 1) {
          v = values[i];
          if (v !== null && !isNaN(v)) {
            sum += v;
            max = Math.max(max, v);
            min = Math.min(min, v);
            if (first === null) {
              first = v;
            }
            last = v;
            count += 1;
          }
        }
        if (count > 0) {
          if (count > 0) {
            avg = Math.round(sum / count * 100) / 100;
          }
          change = last - first;
          results.push({
            sum: sum,
            max: max,
            min: min,
            first: first,
            last: last,
            count: count,
            avg: avg,
            change: change
          });
        } else {
          results.push(null);
        }
      }
    } else {
      results = (function() {
        var _k, _len1, _ref1, _results;
        _ref1 = this.series;
        _results = [];
        for (_k = 0, _len1 = _ref1.length; _k < _len1; _k++) {
          x = _ref1[_k];
          _results.push(null);
        }
        return _results;
      }).call(this);
    }
    data = [];
    _ref1 = this.series;
    for (k = _k = 0, _len1 = _ref1.length; _k < _len1; k = ++_k) {
      config = _ref1[k];
      data.push({
        name: config.name != null ? config.name : "",
        values: results[k],
        config: config
      });
    }
    return {
      name: this.options.name,
      stack: this,
      config: this.options,
      data: data
    };
  };

  return Linearchart_Series_Stack;

})();
// Generated by CoffeeScript 1.8.0
var Linearchart_Series_Cluster;

Linearchart_Series_Cluster = (function() {
  function Linearchart_Series_Cluster(scene) {
    this.scene = scene;
    this.stacks = [];
    this.idToStack = {};
    this.paddingSum = 0;
  }

  Linearchart_Series_Cluster.prototype.addSeries = function(seriesId, seriesConfig, stackConfig, valueAxis) {
    var stack, stackId;
    if (seriesConfig.stack) {
      stackId = seriesConfig.stack + "#" + seriesConfig.type;
      stack = this.idToStack[stackId];
      if (!stack) {
        stack = this.idToStack[stackId] = new Linearchart_Series_Stack(this.scene, this, stackConfig, valueAxis);
        this.stacks.push(stack);
      }
    } else {
      stack = new Linearchart_Series_Stack(this.scene, this, stackConfig, valueAxis);
      this.stacks.push(stack);
    }
    return stack.addSeries(seriesId, seriesConfig);
  };

  Linearchart_Series_Cluster.prototype.afterInit = function() {
    var stack, _i, _len, _ref, _results;
    _ref = this.stacks;
    _results = [];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      stack = _ref[_i];
      _results.push(stack.afterInit());
    }
    return _results;
  };

  Linearchart_Series_Cluster.prototype.process = function(seriesData) {
    var stack, _i, _len, _ref, _results;
    _ref = this.stacks;
    _results = [];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      stack = _ref[_i];
      _results.push(stack.process(seriesData));
    }
    return _results;
  };

  Linearchart_Series_Cluster.prototype.afterProcess = function() {
    var stack, _i, _len, _ref, _results;
    _ref = this.stacks;
    _results = [];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      stack = _ref[_i];
      _results.push(stack.afterProcess());
    }
    return _results;
  };

  Linearchart_Series_Cluster.prototype.paint = function(context) {
    var stack, _i, _len, _ref, _results;
    _ref = this.stacks;
    _results = [];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      stack = _ref[_i];
      _results.push(stack.paint(context));
    }
    return _results;
  };

  Linearchart_Series_Cluster.prototype.hitTestStack = function(x, y) {
    var d, distance, i, item, stack, _i, _ref, _ref1;
    item = null;
    distance = Infinity;
    _ref = this.stacks;
    for (_i = _ref.length - 1; _i >= 0; _i += -1) {
      stack = _ref[_i];
      _ref1 = stack.hitTestStack(x, y), i = _ref1[0], d = _ref1[1];
      if (d < distance) {
        distance = d;
        item = i;
      }
    }
    return [item, distance];
  };

  Linearchart_Series_Cluster.prototype.hitTest = function(x, y, tolerance) {
    var d, distance, i, item, stack, _i, _ref, _ref1;
    item = null;
    distance = Infinity;
    _ref = this.stacks;
    for (_i = _ref.length - 1; _i >= 0; _i += -1) {
      stack = _ref[_i];
      _ref1 = stack.hitTest(x, y, tolerance), i = _ref1[0], d = _ref1[1];
      if (d < distance) {
        distance = d;
        item = i;
      }
    }
    return [item, distance];
  };

  Linearchart_Series_Cluster.prototype.exportData = function(from, to, result) {
    var s, _i, _len, _ref, _results;
    _ref = this.stacks;
    _results = [];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      s = _ref[_i];
      _results.push(result.push(s.exportData(from, to)));
    }
    return _results;
  };

  Linearchart_Series_Cluster.prototype.computeStackCenterRadius = function(stack, xes, center, radius) {
    var approxStep, centerCoef, i, index, paddingAdd, paddingSubstract, radiusCoef, ss, sum, width, x, _i, _j, _k, _len, _len1, _ref, _ref1, _ref2, _results;
    if (xes.length < 2) {
      return;
    }
    sum = this.stacks.length;
    index = Base_Helpers.indexOf(this.stacks, stack);
    centerCoef = (index + 0.5) / sum;
    radiusCoef = 0.5 / sum;
    paddingSubstract = 0;
    paddingAdd = 0;
    _ref = this.stacks;
    for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
      ss = _ref[i];
      paddingSubstract += ss.paddingLeft + ss.paddingRight;
    }
    _ref1 = this.stacks;
    for (i = _j = 0, _len1 = _ref1.length; _j < _len1; i = ++_j) {
      ss = _ref1[i];
      paddingAdd += ss.paddingLeft;
      if (ss === stack) {
        break;
      }
      paddingAdd += ss.paddingRight;
    }
    approxStep = xes[1] - xes[0];
    if (paddingSubstract > approxStep / 2) {
      paddingSubstract = approxStep / 2;
      paddingAdd = paddingAdd / approxStep * (approxStep - paddingSubstract);
    }
    _results = [];
    for (i = _k = 0, _ref2 = xes.length - 2; _k <= _ref2; i = _k += 1) {
      x = xes[i];
      width = xes[i + 1] - x - paddingSubstract;
      center[i] = x + width * centerCoef + paddingAdd;
      _results.push(radius[i] = width * radiusCoef);
    }
    return _results;
  };

  return Linearchart_Series_Cluster;

})();
// Generated by CoffeeScript 1.8.0
var Base_Bar_DropdownBase,
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

Base_Bar_DropdownBase = (function(_super) {
  "use strict";
  __extends(Base_Bar_DropdownBase, _super);

  function Base_Bar_DropdownBase(chart, options) {
    this.options = options;
    this.hideDropdown = __bind(this.hideDropdown, this);
    this.createButton(options);
    Base_Helpers.createDom("span", null, null, this.a);
    Base_Helpers.addClass(this.a, "DVSL-bar-show-more");
  }

  Base_Bar_DropdownBase.prototype.buildDropdownList = function() {
    return 1;
  };

  Base_Bar_DropdownBase.prototype.onHideDropdown = function() {
    return 1;
  };

  Base_Bar_DropdownBase.prototype.onClick = function(ev) {
    if (this.dropdown) {
      this.hideDropdown();
    } else {
      this.showDropdown();
    }
    return Base_Helpers.stopPropagation(ev);
  };

  Base_Bar_DropdownBase.prototype.showDropdown = function() {
    var item, ul, _i, _len, _ref, _results;
    this.dropdown = Base_Helpers.createDom("div", "DVSL-bar-dropdown", null, this.li);
    this.dropdown.style.display = "block";
    ul = Base_Helpers.createDom("ul", null, null, this.dropdown);
    _ref = this.buildDropdownList();
    _results = [];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      item = _ref[_i];
      _results.push(ul.appendChild(item));
    }
    return _results;
  };

  Base_Bar_DropdownBase.prototype.hideDropdown = function() {
    this.onHideDropdown();
    this.dropdown.parentNode.removeChild(this.dropdown);
    return this.dropdown = null;
  };

  Base_Bar_DropdownBase.prototype.previewPointerDown = function(ev) {
    var bottom, cleft, ctop, isInside, left, right, top, _ref, _ref1;
    isInside = Base_Helpers.isParentOf(this.li, ev.target);
    if (this.dropdown && !isInside) {
      _ref = Base_Helpers.elementPos(this.chart.layers.container), cleft = _ref[0], ctop = _ref[1];
      _ref1 = Base_Helpers.elementPos(this.dropdown), left = _ref1[0], top = _ref1[1];
      left -= cleft;
      top -= ctop;
      right = left + this.dropdown.offsetWidth;
      bottom = top + this.dropdown.offsetHeight;
      if (left > ev.x || top > ev.y || bottom < ev.y || right < ev.x) {
        return this.hideDropdown();
      }
    }
  };

  return Base_Bar_DropdownBase;

})(Base_Bar_Button);
// Generated by CoffeeScript 1.8.0
var Piechart_Icon, Piechart_Pie, Piechart_Scene, Piechart_Slice,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

Piechart_Icon = (function() {
  function Piechart_Icon() {}

  Piechart_Icon.prototype.hwidth = 0;

  Piechart_Icon.prototype.hheight = 0;

  Piechart_Icon.prototype.x = null;

  Piechart_Icon.prototype.y = null;

  Piechart_Icon.prototype.userPlaced = false;

  Piechart_Icon.prototype.inside = true;

  return Piechart_Icon;

})();

Piechart_Slice = (function() {
  Piechart_Slice.styleSettings = {
    _doc: {
      doc: "Slice style.",
      type: "object"
    },
    lineBrightness: 0,
    lineBrightness_doc: {
      doc: "Brightness applied to slice line color",
      type: "integer"
    },
    brightness: 1,
    brightness_doc: {
      doc: "Brightness applied to slice line and fill color",
      type: "enum",
      values: {
        "0": "black",
        "1": "unchanged",
        "2": "transparent"
      }
    },
    cutoutDistance: 0,
    cutoutDistance_doc: {
      doc: "Distance how far the slice is moved away from pie.",
      type: "float",
      units: "pixels"
    },
    fillColor: null,
    fillColor_doc: {
      doc: "Slice fill color.",
      type: "color"
    },
    lineColor: null,
    lineColor_doc: {
      doc: "Outline color.",
      type: "color"
    },
    lineWidth: 1,
    lineWidth_doc: {
      doc: "Width of the slice outline.",
      type: "integer"
    },
    label: null,
    label_doc: {
      doc: "Text style outside of pie.",
      type: "object",
      baseObject: Base_Label.styleSettings
    },
    insideLabel: null,
    insideLabel_doc: {
      doc: "Text style inside the slice",
      type: "object",
      baseObject: Base_Label.styleSettings
    },
    url: null,
    url_doc: {
      doc: "Url to open on click.",
      type: "url"
    },
    icon: null,
    icon_doc: {
      doc: "Icon to display on slice.",
      type: "imageUrl"
    },
    lineDash: null,
    lineDash_doc: {
      doc: "Line dash array that is a pattern to get a dashed line. The array contains length of dash followed by length of space. Note that a sequence of multiple dash-space values is supported.",
      type: "array",
      baseObject: "float",
      units: "pixels"
    }
  };

  Piechart_Slice.prototype.id = null;

  Piechart_Slice.prototype.pie = null;

  Piechart_Slice.prototype.data = null;

  Piechart_Slice.prototype.index = 0;

  Piechart_Slice.prototype.value = 0;

  Piechart_Slice.prototype.fraction = 0;

  Piechart_Slice.prototype.cutoutDistance = 0;

  Piechart_Slice.prototype.brightness = 1;

  Piechart_Slice.prototype.expandable = true;

  Piechart_Slice.prototype.expandable_doc = {
    doc: "Whether to expand the slice as a default click behavior.",
    type: "bool"
  };

  Piechart_Slice.prototype.selected = false;

  Piechart_Slice.prototype.active = false;

  Piechart_Slice.prototype.icon = null;

  Piechart_Slice.prototype.iconOffset = null;

  Piechart_Slice.prototype.url = null;

  Piechart_Slice.prototype.userPlaced = false;

  Piechart_Slice.prototype.inside = true;

  Piechart_Slice.prototype.x = 0;

  Piechart_Slice.prototype.y = 0;

  Piechart_Slice.prototype.currentCutoutDistance = null;

  Piechart_Slice.prototype.currentFraction = null;

  Piechart_Slice.prototype.currentInsideLabel = null;

  Piechart_Slice.prototype.currentLabel = null;

  Piechart_Slice.prototype.currentIcon = null;

  Piechart_Slice.prototype.currentLineColor = null;

  Piechart_Slice.prototype.currentFillColor = null;

  Piechart_Slice.prototype.label = null;

  Piechart_Slice.prototype.insideLabel = null;

  Piechart_Slice.prototype.lineColor = null;

  Piechart_Slice.prototype.fillColor = null;

  Piechart_Slice.prototype.lineWidth = 1;

  Piechart_Slice.prototype.labelStyle = null;

  Piechart_Slice.prototype.lineDash = null;

  function Piechart_Slice(pie, index) {
    this.pie = pie;
    this.index = index;
    Base_Helpers.extend(this, Piechart_Slice.prototype.styleSettings);
  }

  return Piechart_Slice;

})();

Piechart_Pie = (function() {
  function Piechart_Pie() {}

  Piechart_Pie.styleSettings = {
    _doc: {
      doc: "Pie style settings.",
      type: "object"
    },
    background: false,
    brightness: 0,
    brightness_doc: {
      doc: "Pie background brightness.",
      type: "integer"
    },
    fillColor: null,
    fillColor_doc: {
      doc: "Pie background fill color. Useful while pie slices are loading.",
      type: "color"
    },
    sliceColors: null,
    sliceColors_doc: {
      doc: "Color set for pie slices.",
      type: "array",
      baseObject: "color"
    },
    colorDistribution: null,
    colorDistribution_doc: {
      doc: "Color distribution among slices.",
      type: "enum",
      values: ["list", "gradientProportional", "gradient"]
    }
  };

  Piechart_Pie.prototype.id = null;

  Piechart_Pie.prototype.data = null;

  Piechart_Pie.prototype.total = 1;

  Piechart_Pie.prototype.parentSlice = null;

  Piechart_Pie.prototype.othersSlice = null;

  Piechart_Pie.prototype.previousSlice = null;

  Piechart_Pie.prototype.slices = [];

  Piechart_Pie.prototype.allSlices = [];

  Piechart_Pie.prototype.offset = 0;

  Piechart_Pie.prototype.count = 0;

  Piechart_Pie.prototype.background = false;

  Piechart_Pie.prototype.activeSliceId = null;

  Piechart_Pie.prototype.brightness = 1;

  Piechart_Pie.prototype.loading = false;

  Piechart_Pie.prototype.scrollOffset = 0;

  Piechart_Pie.prototype.fillColor = null;

  Piechart_Pie.prototype.x = 0;

  Piechart_Pie.prototype.y = 0;

  Piechart_Pie.prototype.startAngle = 0;

  Piechart_Pie.prototype.endAngle = 0;

  Piechart_Pie.prototype.currentStartAngle = null;

  Piechart_Pie.prototype.currentEndAngle = null;

  Piechart_Pie.prototype.currentRadius = 0;

  Piechart_Pie.prototype.currentInnerRadius = 0;

  Piechart_Pie.prototype.colorDistribution = null;

  Piechart_Pie.prototype.sliceColors = null;

  Piechart_Pie.prototype.getActiveSlice = function() {
    var slice, _i, _len, _ref;
    if (!this.activeSliceId) {
      return null;
    }
    _ref = this.slices;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      slice = _ref[_i];
      if (slice.id === this.activeSliceId) {
        return slice;
      }
    }
    return null;
  };

  return Piechart_Pie;

})();

Piechart_Scene = (function(_super) {
  __extends(Piechart_Scene, _super);

  function Piechart_Scene() {
    Piechart_Scene.__super__.constructor.call(this);
    this.radius = 100;
    this.innerRadius = 0;
    this.pies = [];
    this.stack = [];
    this.selection = [];
    this.selectionIds = [];
    this.hoverSlice = null;
    this.hoverLabel = null;
    this.hoverPie = null;
    this.view = null;
    this.pendingAction = null;
    this.pendingOffset = null;
  }

  Piechart_Scene.prototype.addPie = function(pie) {
    this.pies.push(pie);
    this.stack.push(pie);
    return pie;
  };

  Piechart_Scene.prototype.removePie = function(pie) {
    var i, slice, _results;
    pie.removed = true;
    Base_Helpers.removeFromArray(this.stack, pie);
    i = 0;
    _results = [];
    while (i < this.selection.length) {
      slice = this.selection[i];
      if (slice.pie === pie) {
        _results.push(Base_Helpers.removeFromArray(this.selection, slice));
      } else {
        _results.push(i++);
      }
    }
    return _results;
  };

  Piechart_Scene.prototype.deletePie = function(pie) {
    Base_Helpers.removeFromArray(this.pies, pie);
    return Base_Helpers.removeFromArray(this.stack, pie);
  };

  Piechart_Scene.prototype.length = function() {
    return this.stack.length;
  };

  Piechart_Scene.prototype.peek = function() {
    if (this.stack.length === 0) {
      return null;
    }
    return this.stack[this.stack.length - 1];
  };

  Piechart_Scene.prototype.push = function(pie, originSlice) {
    var a0, a1, originPie, parent, slice, _i, _j, _len, _len1, _ref, _ref1, _ref2;
    parent = this.peek();
    if (parent && !originSlice) {
      _ref = parent.slices;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        slice = _ref[_i];
        if (slice.id === pie.id) {
          originSlice = slice;
          break;
        }
      }
    }
    if (originSlice) {
      pie.parentSlice = originSlice;
      originPie = originSlice.pie;
      _ref1 = this.getSliceAngles(originSlice), a0 = _ref1[0], a1 = _ref1[1];
      pie.currentStartAngle = a0;
      pie.currentEndAngle = a1;
      pie.currentRadius = originPie.currentRadius;
      pie.currentInnerRadius = originPie.currentInnerRadius;
      parent.activeSliceId = originSlice.id;
      _ref2 = pie.allSlices;
      for (_j = 0, _len1 = _ref2.length; _j < _len1; _j++) {
        slice = _ref2[_j];
        if (originSlice) {
          slice.currentFillColor = originSlice.currentFillColor;
          slice.currentLineColor = originSlice.currentLineColor;
        }
      }
    } else if (parent) {
      parent.activeSliceId = null;
    }
    if (parent) {
      parent.background = true;
    }
    return this.addPie(pie);
  };

  Piechart_Scene.prototype.pop = function() {
    var pie;
    if (!(this.stack.length > 0)) {
      return;
    }
    this.removePie(this.peek());
    pie = this.peek();
    pie.background = false;
    return pie.brightness = 1;
  };

  Piechart_Scene.prototype.getParent = function(pie) {
    var p, parent, _i, _len, _ref;
    parent = null;
    _ref = this.stack;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      p = _ref[_i];
      if (p === pie) {
        return parent;
      }
      parent = p;
    }
    return null;
  };

  Piechart_Scene.prototype.getChild = function(pie) {
    var p, parent, _i, _len, _ref;
    parent = null;
    _ref = this.stack;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      p = _ref[_i];
      if (parent === pie) {
        return p;
      }
      parent = p;
    }
    return null;
  };

  Piechart_Scene.prototype.updateOnPieChanged = function(pie) {
    var child, parent, slice, _i, _j, _len, _len1, _ref, _ref1, _results;
    parent = this.getParent(pie);
    child = this.getChild(pie);
    if (parent && !pie.parentSlice) {
      _ref = parent.slices;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        slice = _ref[_i];
        if (slice.id === pie.id) {
          pie.parentSlice = slice;
          parent.activeSliceId = slice.id;
          break;
        }
      }
    }
    if (child && !child.parentSlice) {
      _ref1 = pie.slices;
      _results = [];
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        slice = _ref1[_j];
        if (slice.id === child.id) {
          child.parentSlice = slice;
          pie.activeSliceId = slice.id;
          break;
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    }
  };

  Piechart_Scene.prototype.findPieAt = function(x, y, t) {
    return this.view.findPieAt(x, y, t);
  };

  Piechart_Scene.prototype.findSliceAt = function(x, y, t) {
    return this.view.findSliceAt(x, y, t);
  };

  Piechart_Scene.prototype.findLabelAt = function(x, y, t) {
    return this.view.findLabelAt(x, y, t);
  };

  Piechart_Scene.prototype.getSliceAngles = function(slice) {
    var a0, da, f0, f1, pie, s, _i, _len, _ref;
    f1 = 0;
    pie = slice.pie;
    _ref = pie.allSlices;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      s = _ref[_i];
      f0 = f1;
      f1 = f1 + s.currentFraction;
      if (s.id === slice.id) {
        break;
      }
    }
    da = pie.currentEndAngle - pie.currentStartAngle;
    a0 = pie.currentStartAngle + da * pie.scrollOffset;
    return [a0 + da * f0, a0 + da * f1];
  };

  Piechart_Scene.prototype.getSliceTargetAngles = function(slice) {
    var a0, da, f0, f1, pie, s, _i, _len, _ref;
    f1 = 0;
    pie = slice.pie;
    _ref = pie.allSlices;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      s = _ref[_i];
      f0 = f1;
      f1 = f1 + s.currentFraction;
      if (s.id === slice.id) {
        break;
      }
    }
    da = pie.currentEndAngle - pie.currentStartAngle;
    a0 = pie.currentStartAngle + da * pie.scrollOffset;
    return [a0 + da * f0, a0 + da * f1];
  };

  return Piechart_Scene;

})(Base_Scene);
// Generated by CoffeeScript 1.8.0

/*
  Mouse events - have base properties from Base_MouseEvents.
  Additional properties:
  consumed = false, if true - the target tool will be set as active and recieve all future events exclusively until consumed is no longer set.
  cursor = null, cursor to use, (only when consumed = true)
  changes = {}, changes made in scene.
 */
var Base_ChartElement, Base_ChartEvents, Base_ChartPanel, Base_Profiler, Base_SceneEvent,
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

Base_SceneEvent = (function() {
  function Base_SceneEvent() {}

  Base_SceneEvent.prototype.time = 0;

  Base_SceneEvent.prototype.animating = false;

  Base_SceneEvent.prototype.changes = {};

  return Base_SceneEvent;

})();

Base_ChartPanel = (function() {
  function Base_ChartPanel() {}

  Base_ChartPanel.styleSettings = {
    _doc: {
      doc: "Chart panel.",
      type: "object"
    },
    side: "top",
    side_doc: {
      doc: "Panel side",
      type: "enum",
      values: ["top", "bottom", "left", "right"]
    },
    align: "fill",
    align_doc: {
      doc: "Panel alignment",
      type: "enum",
      values: ["left", "right", "top", "bottom", "center", "fill"]
    },
    floating: false,
    floating_doc: {
      doc: "Whether allow packing over other panels",
      type: "bool"
    },
    margin: 0,
    margin_doc: {
      doc: "Margin around the panel",
      type: "float",
      units: "pixels"
    },
    location: "outside"
  };

  Base_ChartPanel.prototype.packingOrder = 0;

  Base_ChartPanel.prototype.location = "outside";

  Base_ChartPanel.prototype.side = "top";

  Base_ChartPanel.prototype.align = "fill";

  Base_ChartPanel.prototype.floating = false;

  Base_ChartPanel.prototype.desiredWidth = 0;

  Base_ChartPanel.prototype.desiredHeight = 0;

  Base_ChartPanel.prototype.margin = 0;

  Base_ChartPanel.prototype.left = 0;

  Base_ChartPanel.prototype.top = 0;

  Base_ChartPanel.prototype.right = 0;

  Base_ChartPanel.prototype.bottom = 0;

  Base_ChartPanel.prototype.computeSize = function(availableWidth, availableHeight, context, labelRenderer) {
    return [this.desiredWidth, this.desiredHeight];
  };

  Base_ChartPanel.prototype.placePanel = function(left, top, right, bottom) {
    this.left = left;
    this.top = top;
    this.right = right;
    this.bottom = bottom;
    return 1;
  };

  return Base_ChartPanel;

})();

Base_ChartElement = (function() {
  function Base_ChartElement() {}

  Base_ChartElement.prototype.animationOrder = 0;

  Base_ChartElement.prototype.remove = function() {
    return false;
  };

  Base_ChartElement.prototype.onSceneChange = function(event) {
    return false;
  };

  Base_ChartElement.prototype.getPanels = function(forExport) {
    return [];
  };

  Base_ChartElement.prototype.doAnimations = function(sceneEvent) {
    return false;
  };

  Base_ChartElement.prototype.paintScene = function(sceneEvent) {
    return false;
  };

  Base_ChartElement.prototype.onClick = function(mouseEvent) {
    return false;
  };

  Base_ChartElement.prototype.onRClick = function(mouseEvent) {
    return false;
  };

  Base_ChartElement.prototype.onDoubleClick = function(mouseEvent) {
    return false;
  };

  Base_ChartElement.prototype.onPointerDown = function(mouseEvent) {
    return false;
  };

  Base_ChartElement.prototype.onPointerUp = function(mouseEvent) {
    return false;
  };

  Base_ChartElement.prototype.onPointerDrag = function(mouseEvent) {
    return false;
  };

  Base_ChartElement.prototype.onPointerMove = function(mouseEvent) {
    return false;
  };

  Base_ChartElement.prototype.onPointerOut = function(mouseEvent) {
    return false;
  };

  Base_ChartElement.prototype.onPointerCancel = function(mouseEvent) {
    return false;
  };

  Base_ChartElement.prototype.onWheel = function(mouseEvent) {
    return false;
  };

  Base_ChartElement.prototype.onKeyDown = function(keyEvent) {
    return false;
  };

  Base_ChartElement.prototype.previewWheel = function(mouseEvent) {
    return false;
  };

  Base_ChartElement.prototype.previewGlobalPointerDown = function(mouseEvent) {
    return false;
  };

  Base_ChartElement.prototype.previewPointerDown = function(mouseEvent) {
    return false;
  };

  Base_ChartElement.prototype.previewPointerUp = function(mouseEvent) {
    return false;
  };

  Base_ChartElement.prototype.previewPointerDrag = function(mouseEvent) {
    return false;
  };

  Base_ChartElement.prototype.previewPointerMove = function(mouseEvent) {
    return false;
  };

  Base_ChartElement.prototype.previewPointerOut = function(mouseEvent) {
    return false;
  };

  return Base_ChartElement;

})();

Base_ChartEvents = (function() {
  "use strict";
  Base_ChartEvents.prototype.verbose = false;

  Base_ChartEvents.prototype.mouseEventConfig = [
    {
      ev: Base_MouseEvents.EVENT_GLOBAL_DOWN,
      name: "GlobalPointerDown"
    }, {
      ev: Base_MouseEvents.EVENT_DOWN,
      name: "PointerDown",
      captures: true
    }, {
      ev: Base_MouseEvents.EVENT_UP,
      name: "PointerUp",
      needsCapture: true,
      releasesCapture: true
    }, {
      ev: Base_MouseEvents.EVENT_DRAG,
      name: "PointerDrag",
      needsCapture: false,
      captures: true
    }, {
      ev: Base_MouseEvents.EVENT_MOVE,
      name: "PointerMove",
      captures: true
    }, {
      ev: Base_MouseEvents.EVENT_LEAVE,
      name: "PointerOut"
    }, {
      ev: Base_MouseEvents.EVENT_CANCEL,
      name: "PointerCancel",
      needsCapture: true
    }, {
      ev: Base_MouseEvents.EVENT_CLICK,
      name: "Click"
    }, {
      ev: Base_MouseEvents.EVENT_RCLICK,
      name: "RightClick"
    }, {
      ev: Base_MouseEvents.EVENT_DBLCLICK,
      name: "DoubleClick"
    }, {
      ev: Base_MouseEvents.EVENT_WHEEL,
      name: "Wheel"
    }
  ];

  function Base_ChartEvents(container, canvas, chart) {
    var event, _fn, _i, _len, _ref;
    this.container = container;
    this.canvas = canvas;
    this.chart = chart;
    this._paintScene = __bind(this._paintScene, this);
    this.kd = __bind(this.kd, this);
    this.scene = this.chart.scene;
    this.settings = this.chart.settings;
    this.pointerToElement = {};
    this.sceneChanges = {};
    this.paintRequested = null;
    this.paintNowInProgreess = false;
    this.labelRenderer = new Base_LabelRenderer(this, this.settings, this.container);
    this.animationOrder = [];
    this.updateOrder = [];
    this.paintOrder = [];
    this.prevTime = 0;
    this.animationInProgress = false;
    this.mouseEvents = new Base_MouseEvents(this.container, this.settings.advanced.pointer, this.chart, this.whiteList);
    _ref = this.mouseEventConfig;
    _fn = (function(_this) {
      return function() {
        var config;
        config = event;
        return _this.mouseEvents.listen(config.ev, function(ev) {
          return _this._notifyMouseEvent(ev, config);
        });
      };
    })(this);
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      event = _ref[_i];
      _fn();
    }
    this.mouseEvents.listen(Base_MouseEvents.EVENT_KEY, this.kd);
    this.profiler = new Base_Profiler(this);
  }

  Base_ChartEvents.prototype.addContainer = function(item) {
    return this.mouseEvents.addContainer(item);
  };

  Base_ChartEvents.prototype.remove = function() {
    return this.mouseEvents.remove();
  };

  Base_ChartEvents.prototype.setScaling = function(x, y) {
    this.mouseEvents.scaleX = x;
    return this.mouseEvents.scaleY = y;
  };

  Base_ChartEvents.prototype.addElement = function(element) {
    this.paintOrder.push(element);
    this.updateOrder.push(element);
    this.animationOrder.push(element);
    this.animationOrder.sort(function(a, b) {
      return a.animationOrder - b.animationOrder;
    });
    this.paintOrder.sort(function(a, b) {
      return a.paintOrder - b.paintOrder;
    });
    this.updateOrder.sort(function(a, b) {
      return a.updateOrder - b.updateOrder;
    });
    return element;
  };

  Base_ChartEvents.prototype.removeElement = function(element) {
    Base_Helpers.removeFromArray(this.paintOrder, element);
    Base_Helpers.removeFromArray(this.animationOrder, element);
    return Base_Helpers.removeFromArray(this.updateOrder, element);
  };

  Base_ChartEvents.prototype.notifySceneChanges = function(changes) {
    if (!Base_Helpers.hasProperties(changes)) {
      return;
    }
    Base_Helpers.extendDeep(this.sceneChanges, changes);
    this._requestPaint();
  };

  Base_ChartEvents.prototype.clearSceneChanges = function(changes) {
    var k, v, _results;
    _results = [];
    for (k in changes) {
      v = changes[k];
      _results.push(delete this.sceneChanges[k]);
    }
    return _results;
  };

  Base_ChartEvents.prototype.kd = function(event) {
    this._notifyKeyEvent(event, "KeyDown");
    return this.notifySceneChanges(event.changes);
  };

  Base_ChartEvents.prototype._notifyMouseEvent = function(event, config) {
    var capturedByElement, element, firstCursor, funcName, name, oldElement, str, _i, _j, _len, _len1, _ref, _ref1;
    if (this.profiler.mouseEvent(event, config)) {
      return;
    }
    name = config.name;
    event.changes = {};
    event.consumed = false;
    event.capture = false;
    event.noDefault = false;
    event.cursor = null;
    capturedByElement = null;
    firstCursor = null;
    funcName = "preview" + name;
    _ref = this.updateOrder;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      element = _ref[_i];
      if (element[funcName] != null) {
        element[funcName].call(element, event);
      }
    }
    funcName = "on" + name;
    oldElement = element = this.pointerToElement[event.identifier];
    if (element && (element[funcName] != null)) {
      element[funcName].call(element, event);
      if ((event.consumed || event.capture || (config.captures && config.needsCapture)) && !config.releasesCapture) {
        capturedByElement = element;
        event.capture = true;
        firstCursor = event.cursor;
      }
    }
    if (!event.capture && !config.needsCapture) {
      _ref1 = this.updateOrder;
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        element = _ref1[_j];
        if ((element[funcName] != null) && element !== oldElement) {
          element[funcName].call(element, event);
          if (event.consumed || event.capture) {
            firstCursor = event.cursor;
            capturedByElement = element;
            event.capture = true;
            break;
          }
        }
      }
    }
    if (event.target && event.target.style) {
      event.target.style.cursor = firstCursor;
    }
    event.consumed || (event.consumed = event.noDefault);
    if (this.verbose) {
      str = "" + (this.chart.constructor.name.toString()) + " " + name + ": " + event.identifier;
      if (capturedByElement) {
        str += " captured By " + capturedByElement.constructor.name;
      }
      console.log(str);
    }
    this.pointerToElement[event.identifier] = config.captures ? capturedByElement : null;
    return this.notifySceneChanges(event.changes);
  };

  Base_ChartEvents.prototype._notifyKeyEvent = function(event, name) {
    var element, funcName, _i, _len, _ref;
    if (this.profiler.keyEvent(event, name)) {
      return;
    }
    event.changes = {};
    event.consumed = false;
    event.cursor = null;
    funcName = "on" + name;
    _ref = this.updateOrder;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      element = _ref[_i];
      if (element[funcName] != null) {
        element[funcName].call(element, event);
        if (event.consumed) {
          break;
        }
      }
    }
    return null;
  };

  Base_ChartEvents.prototype._requestPaint = function() {
    var timeout;
    if (this.paintRequested === null) {
      if (this.settings.advanced.useAnimationFrame) {
        return this.paintRequested = window.requestAnimationFrame(this._paintScene);
      } else {
        timeout = 0;
        if (this.prevTime) {
          timeout = Math.max(5, this.prevTime + 16 - new Date().getTime());
        }
        return this.paintRequested = window.setTimeout(((function(_this) {
          return function() {
            return _this._paintScene(new Date().getTime());
          };
        })(this)), timeout);
      }
    }
  };


  /*
  Recalculate size for the chart panels.
  Save new size in scene.
   */

  Base_ChartEvents.prototype.updateSize = function(width, height, forExport) {
    var bounds, context, e, extBounds, p, panels, _i, _j, _k, _l, _len, _len1, _len2, _len3, _m, _ref;
    if (forExport == null) {
      forExport = false;
    }
    context = this.canvas.getContext("2d");
    panels = [];
    _ref = this.paintOrder;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      e = _ref[_i];
      if (e.getPanels) {
        panels = panels.concat(e.getPanels(forExport));
      }
    }
    Base_Helpers.sort(panels, function(a, b) {
      return a.packingOrder - b.packingOrder;
    });
    this.scene.chartHeight = height;
    this.scene.chartWidth = width;
    extBounds = new Base_Rect(0, 0, width, height);
    bounds = new Base_Rect(0, 0, width, height);
    for (_j = panels.length - 1; _j >= 0; _j += -1) {
      p = panels[_j];
      if (p.location === "external") {
        this._placePanel(p, extBounds, true, context);
      }
    }
    for (_k = 0, _len1 = panels.length; _k < _len1; _k++) {
      p = panels[_k];
      if (p.location === "outside" || p.location === "outsideFill") {
        this._placePanel(p, bounds, false, context);
      }
    }
    for (_l = 0, _len2 = panels.length; _l < _len2; _l++) {
      p = panels[_l];
      if (p.location !== "inside") {
        this._placePanelFinal(p, bounds);
      }
    }
    this.scene.x0 = bounds.x0;
    this.scene.width = bounds.x1 - bounds.x0;
    this.scene.y0 = bounds.y0;
    this.scene.height = bounds.y1 - bounds.y0;
    this.scene.leftMargin = bounds.x0;
    this.scene.rightMargin = width - bounds.x1;
    this.scene.topMargin = bounds.y0;
    this.scene.bottomMargin = height - bounds.y1;
    for (_m = 0, _len3 = panels.length; _m < _len3; _m++) {
      p = panels[_m];
      if (p.location === "inside") {
        this._placePanel(p, bounds, false, context);
        this._placePanelFinal(p, bounds);
      }
    }
    return extBounds;
  };


  /*
  Place panel within bounds, update bounds for next placement.
  External: true - place outside of existing bounds, extend bounds
  External: false - place inside existing bounds, shrink bounds
   */

  Base_ChartEvents.prototype._placePanel = function(panel, bounds, external, context) {
    var bottom, desiredHeight, desiredWidth, left, margin, right, top, _ref;
    left = bounds.x0;
    top = bounds.y0;
    right = bounds.x1;
    bottom = bounds.y1;
    margin = panel.margin;
    _ref = panel.computeSize(bounds.x1 - bounds.x0, bounds.y1 - bounds.y0, context, this.labelRenderer), desiredWidth = _ref[0], desiredHeight = _ref[1];
    desiredWidth += margin * 2;
    desiredHeight += margin * 2;
    if (external) {
      if (panel.side === "top") {
        bottom = top;
        top = bottom - desiredHeight;
        if (!panel.floating) {
          bounds.y0 = top;
        }
      } else if (panel.side === "bottom") {
        top = bottom;
        bottom = top + desiredHeight;
        if (!panel.floating) {
          bounds.y1 = bottom;
        }
      } else if (panel.side === "left") {
        right = left;
        left = right - desiredWidth;
        if (!panel.floating) {
          bounds.x0 = left;
        }
      } else if (panel.side === "right") {
        left = right;
        right = left + desiredWidth;
        if (!panel.floating) {
          bounds.x1 = right;
        }
      }
    } else {
      if (panel.side === "top") {
        bottom = Math.min(bottom, top + desiredHeight);
        if (!panel.floating) {
          bounds.y0 = bottom;
        }
      } else if (panel.side === "bottom") {
        top = Math.max(top, bottom - desiredHeight);
        if (!panel.floating) {
          bounds.y1 = top;
        }
      } else if (panel.side === "left") {
        right = Math.min(right, left + desiredWidth);
        if (!panel.floating) {
          bounds.x0 = right;
        }
      } else if (panel.side === "right") {
        left = Math.max(left, right - desiredWidth);
        if (!panel.floating) {
          bounds.x1 = left;
        }
      }
    }
    return panel._tempData = [left, right, top, bottom, desiredWidth, desiredHeight];
  };

  Base_ChartEvents.prototype._placePanelFinal = function(panel, chartBounds) {
    var bottom, desiredHeight, desiredWidth, left, margin, right, top, xsub, ysub, _ref;
    _ref = panel._tempData, left = _ref[0], right = _ref[1], top = _ref[2], bottom = _ref[3], desiredWidth = _ref[4], desiredHeight = _ref[5];
    if (panel.location === "outside") {
      if (panel.side === "top" || panel.side === "bottom") {
        left = Math.max(left, chartBounds.x0);
        right = Math.min(right, chartBounds.x1);
      } else {
        top = Math.max(top, chartBounds.y0);
        bottom = Math.min(bottom, chartBounds.y1);
      }
    }
    if (panel.align === "left") {
      right = Math.min(right, left + desiredWidth);
    } else if (panel.align === "right") {
      left = Math.max(left, right - desiredWidth);
    } else if (panel.align === "top") {
      bottom = Math.min(bottom, top + desiredHeight);
    } else if (panel.align === "bottom") {
      top = Math.max(top, bottom - desiredHeight);
    } else if (panel.align === "center") {
      xsub = Math.max(0, right - left - desiredWidth) / 2;
      ysub = Math.max(0, bottom - top - desiredHeight) / 2;
      left += xsub;
      right -= xsub;
      top += ysub;
      bottom -= ysub;
    } else {
      1;
    }
    margin = panel.margin;
    return panel.placePanel(left + margin, top + margin, right - margin, bottom - margin);
  };

  Base_ChartEvents.prototype.paintNow = function(force) {
    if (force == null) {
      force = false;
    }
    if (this.paintNowInProgreess) {
      this.chart.erorr("painNow called from within paintNow call");
      return;
    }
    this.paintNowInProgreess = true;
    if (this.paintRequested !== null || force) {
      if (this.settings.advanced.useAnimationFrame) {
        if (window.cancelRequestAnimationFrame) {
          cancelAnimationFrame(this.paintRequested);
        }
      } else {
        window.clearTimeout(this.paintRequested);
      }
      this._paintScene(null);
    }
    return this.paintNowInProgreess = false;
  };

  Base_ChartEvents.prototype._paintScene = function(timeStamp) {
    var e, el, event, labRenderer, _i, _j, _k, _len, _len1, _len2, _ref, _ref1, _ref2;
    if (timeStamp == null) {
      timeStamp = this.prevTime;
    }
    if (this.chart.removed) {
      return;
    }
    this.paintRequested = null;
    event = new Base_SceneEvent();
    event.timeStamp = timeStamp;
    event.changes = this.sceneChanges;
    event["export"] = false;
    event.context = this.canvas.getContext("2d");
    event.labelRenderer = this.labelRenderer;
    if (!this.prevTime || !this.animationInProgress) {
      event.dtime = 30;
    } else {
      event.dtime = event.timeStamp - this.prevTime;
      if (event.dtime > 1000) {
        event.dtime = 1000;
      }
      if (event.dtime < 1) {
        event.dtime = 1;
      }
    }
    this.prevTime = timeStamp;
    this.sceneChanges = {};
    _ref = this.updateOrder;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      el = _ref[_i];
      if (el.onSceneChange != null) {
        el.onSceneChange(event);
      }
    }
    if (event.changes.bounds) {
      this.updateSize(this.scene.chartWidth, this.scene.chartHeight, false);
    }
    event.context = this.prepareContext(event);
    _ref1 = this.animationOrder;
    for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
      e = _ref1[_j];
      if (e.doAnimations != null) {
        e.doAnimations(event);
      }
    }
    _ref2 = this.paintOrder;
    for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
      e = _ref2[_k];
      if (e.paintScene != null) {
        e.paintScene(event);
      }
    }
    if (this.settings.advanced.labelCache) {
      labRenderer = this.chart.labelRenderer;
      if (this.settings.advanced.logging) {
        this.labelRenderer.printStats();
      }
      this.labelRenderer.nextFrame();
    }
    if (event.animating) {
      this.animationInProgress = true;
      this._requestPaint();
    } else {
      this.animationInProgress = false;
    }
    if (event.changes.position) {
      this.chart.notifyPositionChange(event);
    }
    this.finalizeContext(event);
    return this.profiler.paintDone();
  };

  Base_ChartEvents.prototype.prepareContext = function(event) {
    var canvasScaleX, canvasScaleY, context, heightPx, scene, sx, sy, widthPx, _ref;
    if (event.changes.bounds) {
      scene = this.chart.scene;
      if (this.settings.advanced.highDPI) {
        _ref = Base_Helpers.canvasScaling(), sx = _ref[0], sy = _ref[1];
        canvasScaleX = sx;
        canvasScaleY = sy;
      } else {
        canvasScaleX = 1;
        canvasScaleY = 1;
      }
      this.scaleX = Math.min(canvasScaleX, scene.settings.advanced.maxCanvasWidth / scene.chartWidth);
      this.scaleY = Math.min(canvasScaleY, scene.settings.advanced.maxCanvasHeight / scene.chartHeight);
      widthPx = Math.round(scene.chartWidth * this.scaleX);
      heightPx = Math.round(scene.chartHeight * this.scaleY);
      this.canvas.width = widthPx;
      this.canvas.height = heightPx;
      this.canvas.style.width = "" + scene.chartWidth + "px";
      this.canvas.style.height = "" + scene.chartHeight + "px";
    }
    context = this.canvas.getContext("2d");
    context.setTransform(1, 0, 0, 1, 0, 0);
    context.clearRect(0, 0, this.canvas.width, this.canvas.height);
    Base_Graphics.rectStyle(context, this.settings.area.style);
    context.fillRect(0, 0, this.canvas.width, this.canvas.height);
    context.setTransform(this.scaleX, 0, 0, this.scaleY, 0, 0);
    return context;
  };

  Base_ChartEvents.prototype.finalizeContext = function(event) {
    var context;
    if (this.settings.area.style.overlayColor) {
      context = event.context;
      context.fillStyle = this.settings.area.style.overlayColor;
      context.setTransform(1, 0, 0, 1, 0, 0);
      return context.fillRect(0, 0, this.canvas.width, this.canvas.height);
    }
  };

  Base_ChartEvents.prototype.exportToImageGetDimensions = function() {
    this.exportBounds = this.updateSize(this.scene.chartWidth, this.scene.chartHeight, true);
    this.updateSize(this.scene.chartWidth, this.scene.chartHeight, false);
    return [this.exportBounds.w(), this.exportBounds.h()];
  };

  Base_ChartEvents.prototype.exportToContext = function(context, left, top, scale) {
    var e, event, _i, _len, _ref;
    this.updateSize(this.scene.chartWidth, this.scene.chartHeight, true);
    left = top = 0;
    context.save();
    context.setTransform(scale, 0, 0, scale, left - this.exportBounds.x0 * scale, top - this.exportBounds.y0 * scale);
    event = new Base_SceneEvent();
    event["export"] = true;
    event.timeStamp = new Date().getTime();
    event.changes = {};
    event.context = context;
    event.labelRenderer = this.labelRenderer;
    _ref = this.paintOrder;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      e = _ref[_i];
      if (e.paintScene != null) {
        e.paintScene(event);
      }
    }
    this.updateSize(this.scene.chartWidth, this.scene.chartHeight, false);
    return context.restore();
  };

  return Base_ChartEvents;

})();

Base_Profiler = (function() {
  function Base_Profiler(events) {
    this.events = events;
    this.playNextEvent = __bind(this.playNextEvent, this);
    this.record = {};
    this.recording = false;
    this.playback = false;
    this.eventPlays = false;
    this.playbackCallack = null;
    this.playbackTimeDiff = 0;
    this.playbackIndex = 0;
    this.measureFpsIters = 0;
    this.measureFpsT0 = 0;
    this.measureFpsIter = 0;
    this.measureFpsCallback = null;
  }

  Base_Profiler.prototype.hasPendingRequests = function() {
    return this.events.chart.hasPendingRequests();
  };

  Base_Profiler.prototype.measureFps = function(measureFpsIters, measureFpsCallback) {
    var currentSetting, orig_measureFpsCallback;
    this.measureFpsIters = measureFpsIters;
    this.measureFpsCallback = measureFpsCallback;
    currentSetting = this.events.settings.advanced.useAnimationFrame;
    if (currentSetting) {
      this.events.chart.updateSettings({
        advanced: {
          useAnimationFrame: false
        }
      });
      orig_measureFpsCallback = this.measureFpsCallback;
      this.measureFpsCallback = (function(_this) {
        return function() {
          _this.events.chart.updateSettings({
            advanced: {
              useAnimationFrame: true
            }
          });
          if (orig_measureFpsCallback) {
            return orig_measureFpsCallback.apply(window, arguments);
          }
        };
      })(this);
    }
    this.measureFpsIter = 0;
    this.measureFpsT0 = new Date().getTime();
    this.events.notifySceneChanges({
      animation: true
    });
    return true;
  };

  Base_Profiler.prototype.startRecording = function() {
    this.record = {
      width: this.events.scene.chartWidth,
      height: this.events.scene.chartHeight,
      events: []
    };
    this.recording = true;
    this.playback = false;
    return true;
  };

  Base_Profiler.prototype.stopRecording = function() {
    var result;
    this.recording = false;
    result = this.record;
    this.record = {};
    return result;
  };

  Base_Profiler.prototype.startPlayback = function(record, playbackCallack) {
    var _ref;
    this.playbackCallack = playbackCallack;
    if (!(((_ref = record.events) != null ? _ref.length : void 0) > 0)) {
      return;
    }
    this.record = record;
    this.recording = false;
    this.playback = true;
    this.playbackIndex = 0;
    this.events.updateSize(this.record.width, this.record.height, false);
    this.playbackTimeDiff = new Date().getTime() - record.events[0].event.timeStamp;
    setTimeout(this.playNextEvent, 100);
    return true;
  };

  Base_Profiler.prototype.stopPlayback = function() {
    this.playback = false;
    return this.record = {};
  };

  Base_Profiler.prototype.playNextEvent = function() {
    var config, ee, ev, event, timeToNext, type, _i, _len, _ref;
    if (!this.playback) {
      return;
    }
    ee = this.record.events[this.playbackIndex];
    event = Base_Helpers.clone(ee.event);
    event.target = this.events.container;
    type = ee.type;
    event.timeStamp += this.playbackTimeDiff;
    this.eventPlays = true;
    if (type === "KeyDown") {
      this.events._notifyKeyEvent(event, type);
    } else {
      config = null;
      _ref = this.events.mouseEventConfig;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        ev = _ref[_i];
        if (ev.ev === type) {
          config = ev;
          break;
        }
      }
      this.events._notifyMouseEvent(event, config);
    }
    this.eventPlays = false;
    this.playbackIndex += 1;
    if (this.playbackIndex < this.record.events.length) {
      ee = this.record.events[this.playbackIndex];
      timeToNext = ee.event.timeStamp + this.playbackTimeDiff - new Date().getTime();
      return setTimeout(this.playNextEvent, Math.max(0, timeToNext));
    } else {
      this.stopPlayback();
      if (this.playbackCallack) {
        return this.playbackCallack();
      }
    }
  };

  Base_Profiler.prototype.mouseEvent = function(event, config) {
    if (this.playback && !this.eventPlays) {
      return true;
    }
    if (!this.recording) {
      return false;
    }
    event = Base_Helpers.clone(event);
    delete event.target;
    this.record.events.push({
      type: config.ev,
      event: event
    });
    return false;
  };

  Base_Profiler.prototype.keyEvent = function(event, name) {
    if (this.playback && !this.eventPlays) {
      return true;
    }
    if (!this.recording) {
      return false;
    }
    event = Base_Helpers.clone(event);
    delete event.target;
    this.record.events.push({
      type: name,
      event: event
    });
    return false;
  };

  Base_Profiler.prototype.paintDone = function() {
    var fps, time;
    if (!this.measureFpsIters) {
      return;
    }
    this.measureFpsIter += 1;
    time = new Date().getTime() - this.measureFpsT0;
    if (this.measureFpsIter >= this.measureFpsIters || (time > 2000 && this.measureFpsIter >= 5)) {
      fps = this.measureFpsIter * 1000 / Math.max(0.1, time);
      this.measureFpsCallback(fps, this.measureFpsIter, time);
      this.measureFpsCallback = 0;
      return this.measureFpsIters = 0;
    } else {
      return this.events.notifySceneChanges({
        animation: true
      });
    }
  };

  return Base_Profiler;

})();
// Generated by CoffeeScript 1.8.0
var Itemschart_Selection,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

Itemschart_Selection = (function(_super) {
  __extends(Itemschart_Selection, _super);

  Itemschart_Selection.prototype.animationOrder = 2000;

  Itemschart_Selection.prototype.paintOrder = 25;

  Itemschart_Selection.prototype.updateOrder = 1100;

  Itemschart_Selection.prototype.scene = null;

  Itemschart_Selection.prototype.events = null;

  Itemschart_Selection.prototype.currentObject = null;

  Itemschart_Selection.prototype.currentSlice = null;

  function Itemschart_Selection(chart) {
    this.chart = chart;
    this.scene = chart.scene;
    this.events = chart.events;
    this.navigator = chart.navigator;
    this.dragPointers = {};
  }

  Itemschart_Selection.prototype.onPointerMove = function(event) {
    this.updateCurrentObject(event);
    if (this.currentObject) {
      this.updateCursor(event);
      return event.consumed = true;
    }
  };

  Itemschart_Selection.prototype.onPointerOut = function(event) {
    return this.switchCurrentObject(null, null, event);
  };

  Itemschart_Selection.prototype.onPointerDown = function(event) {
    this.updateCurrentObject(event);
    if (this.currentObject instanceof Itemschart_Node) {
      this.updateSelection(event, this.currentObject, true);
      this.updateCursor(event);
      if (this.scene.settings.interaction.nodesMovable) {
        this.setPointerNode(event, this.currentObject);
        return event.consumed = true;
      }
    }
  };

  Itemschart_Selection.prototype.onPointerUp = function(event) {
    if (this.dragPointers[event.identifier]) {
      if (this.dragPointers[event.identifier].dragging) {
        event.consumed = true;
        this.updateLastNode(event, this.dragPointers[event.identifier].node);
      }
      this.updateCursor(event);
      return this.setPointerNode(event, null);
    }
  };

  Itemschart_Selection.prototype.onPointerCancel = function(event) {
    return this.onPointerUp(event);
  };

  Itemschart_Selection.prototype.onPointerDrag = function(event) {
    var newX, newY, p, _ref;
    p = this.dragPointers[event.identifier];
    if (!p) {
      return;
    }
    _ref = this.scene.fromDisplay(event.x, event.y), newX = _ref[0], newY = _ref[1];
    p.mouseX = event.x;
    p.mouseY = event.y;
    p.dragging = true;
    this.dragNodes(p, newX, newY, this.scene.settings.interaction.selection.lockNodesOnMove);
    this.updateCursor(event);
    return event.consumed = true;
  };

  Itemschart_Selection.prototype.onClick = function(event) {
    var e;
    if (!this.scene.xyInChart(event.x, event.y)) {
      return;
    }
    this.buildClickEvent(event);
    e = this.chart.notifyClick(event);
    if (e.defaultPrevented) {
      return event.consumed = true;
    }
  };

  Itemschart_Selection.prototype.onRightClick = function(event) {
    var e;
    if (!this.scene.xyInChart(event.x, event.y)) {
      return;
    }
    this.buildClickEvent(event);
    this.updateSelection(event, this.currentObject, false);
    e = this.chart.notifyRightClick(event);
    if (e.defaultPrevented) {
      return event.consumed = true;
    }
  };

  Itemschart_Selection.prototype.onDoubleClick = function(event) {
    var e;
    if (!this.scene.xyInChart(event.x, event.y)) {
      return;
    }
    this.buildClickEvent(event);
    e = this.chart.notifyDoubleClick(event);
    if (e.defaultPrevented) {
      return event.consumed = true;
    }
  };

  Itemschart_Selection.prototype.doAnimations = function(event) {
    var id, newX, newY, p, _ref, _ref1, _results;
    _ref = this.dragPointers;
    _results = [];
    for (id in _ref) {
      p = _ref[id];
      _ref1 = this.scene.fromDisplay(p.mouseX, p.mouseY), newX = _ref1[0], newY = _ref1[1];
      this.dragNodes(p, newX, newY, false);
      _results.push(event.changes.coordinates = true);
    }
    return _results;
  };

  Itemschart_Selection.prototype.updateSelection = function(event, target, softDeselect) {
    if (!this.scene.settings.interaction.selection.enabled) {
      return;
    }
    if ((!event.shiftKey && !event.ctrlKey) && (!target || (!this.scene.settings.interaction.selection.nodesSelectable && target.isNode) || (!this.scene.settings.interaction.selection.linksSelectable && target.isLink))) {
      return this.setSelection([], "user");
    } else if (target && event.ctrlKey) {
      if (target.selected) {
        this.scene.removeFromSelection(target);
      } else {
        this.scene.addToSelection(target);
      }
      return this.notifySelectionChanged("user");
    } else if (target && event.shiftKey || (softDeselect && target.selected)) {
      if (!this.scene.addToSelection(target)) {
        return this.notifySelectionChanged();
      }
    } else if (target) {
      return this.setSelection([target], "user");
    }
  };

  Itemschart_Selection.prototype.dragNodes = function(p, newX, newY, lock) {
    var dx, dy, n, _i, _len, _ref;
    dx = newX + p.x - p.node.x;
    dy = newY + p.y - p.node.y;
    if (!(dx !== 0 || dy !== 0)) {
      return;
    }
    if (Base_Helpers.countProperties(this.dragPointers) === 1 && this.scene.selection.length > 0) {
      _ref = this.scene.selection;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        n = _ref[_i];
        if (n.isNode) {
          this.moveNode(n, dx, dy, lock);
        }
      }
    } else {
      this.moveNode(p.node, dx, dy, lock);
    }
    return this.events.notifySceneChanges({
      coordinates: true
    });
  };

  Itemschart_Selection.prototype.moveNode = function(node, dx, dy, lock) {
    var bounds, sizeX, sizeY;
    node.x += dx;
    node.y += dy;
    if (lock) {
      node.userLock = true;
    }
    if (!this.scene.settings.interaction.selection.allowMoveNodesOffscreen) {
      bounds = this.scene.getVisibleBounds();
      sizeX = node.renderHwidth * 1.2 / this.scene.zoom;
      sizeY = node.renderHheight * 1.2 / this.scene.zoom;
      node.x = Math.min(Math.max(node.x, bounds.x0 + sizeX), bounds.x1 - sizeX);
      return node.y = Math.min(Math.max(node.y, bounds.y0 + sizeY), bounds.y1 - sizeY);
    }
  };

  Itemschart_Selection.prototype.setPointerNode = function(event, node) {
    var id, oldP, x, y, _ref;
    id = event.identifier;
    oldP = this.dragPointers[id];
    if (oldP) {
      oldP.node.locks -= 1;
      delete this.dragPointers[id];
    }
    if (node) {
      _ref = this.scene.fromDisplay(event.x, event.y), x = _ref[0], y = _ref[1];
      this.dragPointers[event.identifier] = {
        x: node.x - x,
        y: node.y - y,
        node: node,
        mouseX: event.x,
        mouseY: event.y
      };
      return node.locks += 1;
    }
  };

  Itemschart_Selection.prototype.updateCurrentObject = function(event) {
    var item, n;
    if (!this.scene.xyInChart(event.x, event.y)) {
      return;
    }
    n = this.chart.renderer.findObjectAt(event.x, event.y, this.scene.settings.interaction.selection.tolerance);
    item = n ? this.scene.findItem(event.x, event.y, n, this.scene.settings.interaction.selection.tolerance) : null;
    return this.switchCurrentObject(n, item, event);
  };

  Itemschart_Selection.prototype.updateCursor = function(event) {
    if (this.currentObject && this.currentObject.cursor) {
      return event.cursor = this.currentObject.cursor;
    } else {
      return event.cursor = "default";
    }
  };

  Itemschart_Selection.prototype.switchCurrentObject = function(obj, item, event) {
    if (obj === this.currentObject && item === this.currentItem) {
      return;
    }
    event.changes.current = true;
    this.scene.setActiveObject(obj, item);
    if (this.currentObject instanceof Itemschart_Node) {
      this.currentObject.locks -= 1;
    }
    this.currentObject = obj;
    this.currentItem = item;
    if (this.currentObject instanceof Itemschart_Node) {
      this.currentObject.locks += 1;
    }
    return this.chart.notifyHoverChanged(event);
  };

  Itemschart_Selection.prototype.buildClickEvent = function(event) {
    event.clickItem = this.currentItem;
    if (this.currentObject instanceof Itemschart_Node) {
      event.clickNode = this.currentObject;
      return this.updateLastNode(event, this.currentObject);
    } else {
      return event.clickLink = this.currentObject;
    }
  };

  Itemschart_Selection.prototype.updateLastNode = function(event, node) {
    this.scene.lastClickedNode = node;
    if (this.scene.settings.interaction.zooming.autoZoomAfterClick) {
      this.scene.autoZoomMode = true;
      return event.changes.zoom = true;
    }
  };

  Itemschart_Selection.prototype.setSelection = function(selection, origin) {
    var hasChanges;
    hasChanges = this.scene.setSelection(selection);
    if (hasChanges) {
      return this.notifySelectionChanged(origin);
    }
  };

  Itemschart_Selection.prototype.notifySelectionChanged = function(origin) {
    this.events.notifySceneChanges({
      selection: true
    });
    return this.chart.notifySelectionChanged("api");
  };

  return Itemschart_Selection;

})(Base_ChartElement);
// Generated by CoffeeScript 1.8.0
var Itemschart_Menu,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

Itemschart_Menu = (function(_super) {
  "use strict";
  __extends(Itemschart_Menu, _super);

  Itemschart_Menu.prototype.animationOrder = 600;

  Itemschart_Menu.prototype.paintOrder = 40;

  Itemschart_Menu.prototype.updateOrder = 2000;

  Itemschart_Menu.prototype.node = null;

  Itemschart_Menu.prototype.link = null;

  Itemschart_Menu.prototype.contents = null;

  Itemschart_Menu.prototype.x = 0;

  Itemschart_Menu.prototype.y = 0;

  function Itemschart_Menu(chart) {
    var closeButton;
    this.chart = chart;
    this.container = chart.layers.container;
    this.scene = chart.scene;
    this.events = chart.events;
    this.buttons = [];
    this.popup = Base_Helpers.createDom("div", "DVSL-Menu", null, this.container);
    closeButton = Base_Helpers.createDom("a", "DVSL-Menu-close", "X", this.popup);
    this.popupValue = Base_Helpers.createDom("div", "DVSL-Menu-title", null, this.popup);
    this.detailsDiv = Base_Helpers.createDom("div", "DVSL-Menu-details", null, this.popup);
    this.popupActions = Base_Helpers.createDom("nav", null, null, this.popup);
    this.buildDetailsPanel(this.detailsDiv);
    this.buildCloseButton(closeButton);
    this.popup.style.position = "absolute";
    this.popup.style.display = "none";
  }

  Itemschart_Menu.prototype.doAnimations = function(event) {
    if (this.node == null) {
      return;
    }
    if (((this.node != null) && this.node.removed) || ((this.link != null) && this.link.removed)) {
      return this.hideMenu();
    } else if ((this.node != null) && this.node.layer.modifiedNodes.hasOwnProperty(this.node.id)) {
      return this.updateMenu();
    }
  };

  Itemschart_Menu.prototype.previewPointerDown = function(event) {
    return this.hideMenu();
  };

  Itemschart_Menu.prototype.previewWheel = function(event) {
    return this.hideMenu();
  };

  Itemschart_Menu.prototype.toggleNodeMenu = function(node) {
    if (this.node === node) {
      return this.hideMenu();
    } else {
      return this.showNodeMenu(node);
    }
  };

  Itemschart_Menu.prototype.toggleLinkMenu = function(x, y, link) {
    if (this.link === link) {
      return this.hideMenu();
    } else {
      return this.showLinkMenu(x, y, link);
    }
  };

  Itemschart_Menu.prototype.showNodeMenu = function(node) {
    if (!this.scene.settings.nodeMenu.enabled) {
      return;
    }
    if (this.node === node) {
      return this.updateMenu();
    } else {
      this.hideMenu();
      return this.showPopup(node, null);
    }
  };

  Itemschart_Menu.prototype.showLinkMenu = function(x, y, link) {
    if (!this.scene.settings.linkMenu.enabled) {
      return;
    }
    this.x = x;
    this.y = y;
    if (this.link === link) {
      return this.updateMenu();
    } else {
      this.hideMenu();
      return this.showPopup(null, link);
    }
  };

  Itemschart_Menu.prototype.showPopup = function(node, link) {
    this.node = node;
    this.link = link;
    if (this.node) {
      this.node.locks += 1;
    }
    this.buildButtons();
    this.contents = null;
    this.updateMenu();
    this.popup.style.display = "block";
    this.updateXY();
  };

  Itemschart_Menu.prototype.hideMenu = function() {
    if (!this.node && !this.link) {
      return false;
    }
    if (this.node) {
      this.node.locks -= 1;
    }
    this.node = null;
    this.link = null;
    this.popup.style.display = "none";
    return false;
  };

  Itemschart_Menu.prototype.updateMenu = function() {
    var callback, contents, curLink, curNode, obj, settings, text;
    if (this.node != null) {
      settings = this.scene.settings.nodeMenu;
      obj = this.node;
    } else {
      settings = this.scene.settings.linkMenu;
      obj = this.link;
    }
    if (settings.contentsFunction) {
      curNode = this.node;
      curLink = this.link;
      callback = function(data) {
        if (this.node === curNode && this.link === curLink) {
          this.contents = data;
          return this.popupValue.innerHTML = data;
        }
      };
      text = settings.contentsFunction.call(this.chart.api, obj.data, obj, callback);
      if (Base_Helpers.isString(text)) {
        contents = text;
      } else if (this.contents === null) {
        contents = "<small>" + this.scene.settings.localization.loadingLabel + "</small>";
      } else {
        contents = this.contents;
      }
    } else {
      contents = obj.label;
    }
    if (contents !== this.contents) {
      this.contents = contents;
      this.popupValue.innerHTML = contents;
    }
    this.updateButtons();
    if (settings.showData) {
      this.details.innerHTML = JSON.stringify(obj.data, null, "  ");
      return this.detailsDiv.style.display = "block";
    } else {
      return this.detailsDiv.style.display = "none";
    }
  };

  Itemschart_Menu.prototype.updateXY = function() {
    var h, margin, nx, nx0, nx1, ny, ny0, ny1, w, x0, x1, _ref;
    margin = 12;
    if (this.node != null) {
      _ref = this.scene.toDisplay(this.node.x, this.node.y), nx = _ref[0], ny = _ref[1];
      ny0 = ny - this.node.renderHheight - margin;
      ny1 = ny + this.node.renderHheight + margin;
      nx0 = nx - this.node.renderHheight - margin;
      nx1 = nx + this.node.renderHheight + margin;
    } else {
      ny0 = ny1 = ny = this.y;
      nx0 = this.x - margin;
      nx1 = this.x + margin;
    }
    x0 = this.scene.x0;
    x1 = this.scene.x0 + this.scene.width;
    w = this.popup.offsetWidth;
    h = this.popup.offsetHeight;
    ny = Math.max(Math.min(ny, this.scene.y0 + this.scene.height - h), this.scene.y0);
    if (nx1 + w <= x1) {
      nx = nx1;
    } else if (nx0 - w >= x0) {
      nx = nx0 - w;
    } else {
      nx = Math.max(nx0 - w / 2, x0);
      ny = ny1;
    }
    this.popup.style.left = nx + "px";
    return this.popup.style.top = ny + "px";
  };

  Itemschart_Menu.prototype.buildButtons = function() {
    var action, button, div, _i, _len, _ref, _results;
    this.popupActions.innerHTML = "";
    this.buttons = [];
    if (this.node != null) {
      _ref = this.scene.settings.nodeMenu.buttons;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        button = _ref[_i];
        if (button === "expand") {
          div = Base_Helpers.createDom("a", "DVSL-NC-button-expand", null, this.popupActions);
          action = this.updateExpandButton;
        } else if (button === "focus") {
          div = Base_Helpers.createDom("a", "DVSL-NC-button-focus", null, this.popupActions);
          action = this.updateFocusButton;
        } else if (button === "lock") {
          div = Base_Helpers.createDom("a", "DVSL-NC-button-lock", null, this.popupActions);
          action = this.updateLockButton;
        } else if (button === "hide") {
          div = Base_Helpers.createDom("a", "DVSL-NC-button-hide", null, this.popupActions);
          action = this.updateHideButton;
        }
        div.href = "#";
        _results.push(this.buttons.push({
          e: div,
          a: action
        }));
      }
      return _results;
    }
  };

  Itemschart_Menu.prototype.updateButtons = function() {
    var b, _i, _len, _ref;
    _ref = this.buttons;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      b = _ref[_i];
      b.a.call(this, b.e);
    }
  };

  Itemschart_Menu.prototype.updateExpandButton = function(div) {
    var name;
    if (!this.node.expanded || this.node.dataLinksFiltered.length > this.node.links.length) {
      name = this.scene.settings.localization.menu.expand;
      div.className = "DVSL-NC-button-expand";
      div.title = name;
      div.innerHTML = name;
      return div.onclick = (function(_this) {
        return function(e) {
          _this.chart.expandNode(_this.node.id, 1);
          return e.preventDefault();
        };
      })(this);
    } else {
      name = this.scene.settings.localization.menu.collapse;
      div.className = "DVSL-NC-button-collapse";
      div.title = name;
      div.innerHTML = name;
      return div.onclick = (function(_this) {
        return function(e) {
          _this.chart.collapseNode(_this.node.id);
          return e.preventDefault();
        };
      })(this);
    }
  };

  Itemschart_Menu.prototype.updateFocusButton = function(div) {
    var name;
    if (this.node.focused) {
      name = this.scene.settings.localization.menu.unfocus;
      div.className = "DVSL-NC-button-unfocus";
      div.title = name;
      div.innerHTML = name;
      return div.onclick = (function(_this) {
        return function(e) {
          _this.chart.removeFocusNode(_this.node.id);
          return e.preventDefault();
        };
      })(this);
    } else {
      name = this.scene.settings.localization.menu.focus;
      div.className = "DVSL-NC-button-focus";
      div.title = name;
      div.innerHTML = name;
      return div.onclick = (function(_this) {
        return function(e) {
          _this.chart.addFocusNode(_this.node.id, -1);
          return e.preventDefault();
        };
      })(this);
    }
  };

  Itemschart_Menu.prototype.updateLockButton = function(div) {
    var name;
    if (this.node.userLock) {
      name = this.scene.settings.localization.menu.fixed;
      div.className = "DVSL-NC-button-lock";
      div.title = name;
      div.innerHTML = name;
      return div.onclick = (function(_this) {
        return function(e) {
          _this.chart.unlockNode(_this.node.id);
          _this.updateLockButton(div);
          return e.preventDefault();
        };
      })(this);
    } else {
      name = this.scene.settings.localization.menu.dynaminc;
      div.className = "DVSL-NC-button-unlock";
      div.title = name;
      div.innerHTML = name;
      return div.onclick = (function(_this) {
        return function(e) {
          _this.chart.lockNode(_this.node.id);
          _this.updateLockButton(div);
          return e.preventDefault();
        };
      })(this);
    }
  };

  Itemschart_Menu.prototype.updateHideButton = function(div) {
    var name;
    name = this.scene.settings.localization.menu.hide;
    div.className = "DVSL-NC-button-hide";
    div.title = name;
    div.innerHTML = name;
    return div.onclick = (function(_this) {
      return function(e) {
        _this.chart.hideNode(_this.node.id);
        return e.preventDefault();
      };
    })(this);
  };

  Itemschart_Menu.prototype.buildCloseButton = function(a) {
    a.title = this.scene.settings.localization.closeButton;
    a.href = "#";
    return a.onclick = (function(_this) {
      return function(e) {
        _this.hideMenu();
        return e.preventDefault();
      };
    })(this);
  };

  Itemschart_Menu.prototype.buildDetailsPanel = function(div) {
    var a, d;
    a = Base_Helpers.createDom("small", null, "Technical data", div);
    this.details = d = Base_Helpers.createDom("pre", null, "", div);
    d.style.display = "none";
    return a.onclick = function() {
      if (d.style.display === "none") {
        return d.style.display = "block";
      } else {
        return d.style.display = "none";
      }
    };
  };

  return Itemschart_Menu;

})(Base_ChartElement);
// Generated by CoffeeScript 1.8.0
var Itemschart_Scene,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

Itemschart_Scene = (function(_super) {
  __extends(Itemschart_Scene, _super);

  function Itemschart_Scene() {
    Itemschart_Scene.__super__.constructor.call(this);
    this.centerX = 0;
    this.centerY = 0;
    this.zoom = 1;
    this.selection = [];
    this.hoverNode = null;
    this.hoverLink = null;
    this.hoverItem = null;
    this.lastClickedNode = null;
  }

  Itemschart_Scene.prototype.xyInChart = function(x, y) {
    return (x >= this.x0) && (x < this.x0 + this.width) && (y >= this.y0) && (y < this.y0 + this.height);
  };

  Itemschart_Scene.prototype.toDisplay = function(x, y) {
    return [(x - this.centerX) * this.zoom + this.x0 + this.width * 0.5, (y - this.centerY) * this.zoom + this.y0 + this.height * 0.5];
  };

  Itemschart_Scene.prototype.fromDisplay = function(x, y) {
    return [(x - this.x0 - this.width * 0.5) / this.zoom + this.centerX, (y - this.y0 - this.height * 0.5) / this.zoom + this.centerY];
  };

  Itemschart_Scene.prototype.toDisplayTransform = function(x, y) {
    return [this.zoom, this.x0 + this.width * 0.5 - this.centerX * this.zoom, this.zoom, this.y0 + this.height * 0.5 - this.centerY * this.zoom];
  };

  Itemschart_Scene.prototype.objectRemoved = function(obj) {
    if (Base_Helpers.removeFromArray(this.selection, obj)) {
      obj.selected = false;
    }
    if (this.hoverNode === obj || this.hoverLink === obj) {
      return this.setActiveObject(null, null);
    }
  };

  Itemschart_Scene.prototype.addToSelection = function(newItem) {
    if (!Base_Helpers.arrayContains(this.selection, newItem)) {
      this.selection.push(newItem);
      newItem.layer.touchNodeOrLink(newItem);
      newItem.selected = true;
      return true;
    }
    return false;
  };

  Itemschart_Scene.prototype.removeFromSelection = function(newItem) {
    if (Base_Helpers.removeFromArray(this.selection, newItem)) {
      newItem.selected = false;
      newItem.layer.touchNodeOrLink(newItem);
      return true;
    }
    return false;
  };

  Itemschart_Scene.prototype.setSelection = function(newSelected) {
    var hasChanges, i, s, sPos, ss, _i, _len;
    sPos = 0;
    hasChanges = false;
    for (i = _i = 0, _len = newSelected.length; _i < _len; i = ++_i) {
      s = newSelected[i];
      while ((sPos < this.selection.length) && this.selection[sPos] !== s) {
        ss = this.selection[sPos];
        ss.selected = false;
        ss.layer.touchNodeOrLink(ss);
        hasChanges = true;
        sPos += 1;
      }
      if (sPos < this.selection.length) {
        sPos += 1;
      } else {
        s.selected = true;
        s.layer.touchNodeOrLink(s);
        hasChanges = true;
      }
    }
    while (sPos < this.selection.length) {
      ss = this.selection[sPos];
      ss.selected = false;
      ss.layer.touchNodeOrLink(ss);
      hasChanges = true;
      sPos += 1;
    }
    this.selection = newSelected;
    return hasChanges;
  };

  Itemschart_Scene.prototype.setActiveObject = function(obj, item) {
    var link, _i, _j, _len, _len1, _ref, _ref1, _results;
    if (this.hoverNode != null) {
      this.hoverNode.layer.touchNode(this.hoverNode);
      _ref = this.hoverNode.links;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        link = _ref[_i];
        link.layer.touchLink(link);
      }
      this.hoverNode.hovered = false;
    }
    if (this.hoverLink != null) {
      this.hoverLink.layer.touchLink(this.hoverLink);
      this.hoverLink.from.layer.touchNode(this.hoverLink.from);
      this.hoverLink.to.layer.touchNode(this.hoverLink.to);
      this.hoverLink.hovered = false;
    }
    this.hoverNode = null;
    this.hoverLink = null;
    this.hoverItem = item;
    if (obj instanceof Itemschart_Node) {
      this.hoverNode = obj;
      obj.hovered = true;
      this.hoverNode.layer.touchNode(this.hoverNode);
      _ref1 = this.hoverNode.links;
      _results = [];
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        link = _ref1[_j];
        _results.push(link.layer.touchLink(link));
      }
      return _results;
    } else if (obj instanceof Itemschart_Link) {
      this.hoverLink = obj;
      obj.hovered = true;
      this.hoverLink.layer.touchLink(this.hoverLink);
      this.hoverLink.from.layer.touchNode(this.hoverLink.from);
      return this.hoverLink.to.layer.touchNode(this.hoverLink.to);
    } else if (obj !== null) {
      throw "scene.setActiveObject invalid active object type " + obj;
    }
  };

  Itemschart_Scene.prototype.getVisibleBounds = function() {
    var x0, x1, y0, y1, _ref, _ref1;
    _ref = this.fromDisplay(this.x0, this.y0), x0 = _ref[0], y0 = _ref[1];
    _ref1 = this.fromDisplay(this.x0 + this.width, this.y0 + this.height), x1 = _ref1[0], y1 = _ref1[1];
    return new Base_Rect(x0, y0, x1, y1);
  };

  Itemschart_Scene.prototype.findItem = function(displayX, displayY, obj, tolerance) {
    var h, hi, i, w, x, y, _i, _j, _len, _len1, _ref, _ref1;
    if (!obj) {
      return null;
    }
    hi = this.hoverItem;
    _ref = obj.currentItems;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      i = _ref[_i];
      if (i.data === hi && i.hwidth) {
        x = i.curx;
        y = i.cury;
        w = i.hwidth;
        h = i.hheight;
        if (displayX > x - w - tolerance && displayX < x + w + tolerance && displayY > y - h - tolerance && displayY < y + h + tolerance) {
          return i;
        }
      }
    }
    _ref1 = obj.currentItems;
    for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
      i = _ref1[_j];
      if (!i.hwidth) {
        continue;
      }
      x = i.curx;
      y = i.cury;
      w = i.hwidth;
      h = i.hheight;
      if (displayX > x - w - tolerance && displayX < x + w + tolerance && displayY > y - h - tolerance && displayY < y + h + tolerance) {
        return i.data;
      }
    }
    return null;
  };

  return Itemschart_Scene;

})(Base_Scene);
// Generated by CoffeeScript 1.8.0
var Linearchart_Scrolling,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

Linearchart_Scrolling = (function(_super) {
  "use strict";
  __extends(Linearchart_Scrolling, _super);

  Linearchart_Scrolling.prototype.animationOrder = 1000;

  Linearchart_Scrolling.prototype.chart = null;

  Linearchart_Scrolling.prototype.scene = null;

  Linearchart_Scrolling.prototype.events = null;

  Linearchart_Scrolling.prototype._minDisplayRange = 0;

  Linearchart_Scrolling.prototype.currentFrom = 0;

  Linearchart_Scrolling.prototype.currentTo = 0;

  Linearchart_Scrolling.prototype.pointer1 = null;

  Linearchart_Scrolling.prototype.pointer2 = null;

  Linearchart_Scrolling.prototype.t1 = 0;

  Linearchart_Scrolling.prototype.t2 = 0;

  Linearchart_Scrolling.prototype.x1 = 0;

  Linearchart_Scrolling.prototype.x2 = 0;

  Linearchart_Scrolling.prototype.scaleOrigin = null;

  Linearchart_Scrolling.prototype.initialZoom = null;

  Linearchart_Scrolling.prototype.dragStartFrom = null;

  Linearchart_Scrolling.prototype.dragStartTo = null;

  Linearchart_Scrolling.prototype.active = false;

  Linearchart_Scrolling.prototype.lastScrollingY = 0;

  Linearchart_Scrolling.prototype.scrollingActive = false;

  Linearchart_Scrolling.prototype.scalingActive = false;

  Linearchart_Scrolling.prototype.scrollingSpeed = null;

  Linearchart_Scrolling.prototype.scrollingDuration = null;

  Linearchart_Scrolling.prototype.from = null;

  Linearchart_Scrolling.prototype.to = null;

  Linearchart_Scrolling.prototype.highlight = null;

  Linearchart_Scrolling.prototype.highlightRemoveWhenDone = false;

  function Linearchart_Scrolling(chart) {
    this.chart = chart;
    this.scene = this.chart.scene;
    this.events = this.chart.events;
  }

  Linearchart_Scrolling.prototype.xyInArea = function(x, y) {
    return false;
  };

  Linearchart_Scrolling.prototype.xyToPosition = function(x, y) {
    return 0;
  };

  Linearchart_Scrolling.prototype.onStartDragging = function(oldFrom, oldTo, pos) {
    return null;
  };

  Linearchart_Scrolling.prototype.onSnapWhileDragging = function(from, to, center, isScrolling, isScaling) {
    return [from, to];
  };

  Linearchart_Scrolling.prototype.onSnapAfterDragging = function(from, to, center, isScrolling, isScaling) {
    return [from, to];
  };

  Linearchart_Scrolling.prototype.onCancelDragging = function(oldFrom, toldTo) {
    return null;
  };

  Linearchart_Scrolling.prototype.onZoomOut = function(from, to, center, scale) {
    if (scale == null) {
      scale = 2;
    }
    return [center - (center - from) * scale, center + (to - center) * scale, center];
  };

  Linearchart_Scrolling.prototype.onZoomIn = function(from, to, center, scale) {
    if (scale == null) {
      scale = 0.5;
    }
    return [center - (center - from) * scale, center + (to - center) * scale, center];
  };

  Linearchart_Scrolling.prototype.onScroll = function(from, to, direction) {
    if (direction === "<") {
      return [from * 2 - to, from];
    } else {
      return [to, 2 * to - from];
    }
  };

  Linearchart_Scrolling.prototype.onGoHome = function(from, to) {
    return [from, to, to];
  };

  Linearchart_Scrolling.prototype.onPositionChanged = function(from, to) {
    return 1;
  };

  Linearchart_Scrolling.prototype.onAnimationDone = function(from, to) {
    return 1;
  };

  Linearchart_Scrolling.prototype.getFrom = function() {
    if (this.panAnimF != null) {
      return this.panAnimF.to;
    } else {
      return this.currentFrom;
    }
  };

  Linearchart_Scrolling.prototype.getTo = function() {
    if (this.panAnimT != null) {
      return this.panAnimT.to;
    } else {
      return this.currentTo;
    }
  };

  Linearchart_Scrolling.prototype.onWheel = function(event) {
    var ds, from, origin, r, to;
    if (!(this.currentFrom < this.currentTo)) {
      return;
    }
    if (!this.xyInArea(event.x, event.y) || (!this.scene.settings.interaction.zooming.wheel) || (!this.scene.settings.interaction.zooming.enabled)) {
      return;
    }
    this.active = true;
    origin = this.scaleOrigin != null ? this.scaleOrigin : this.scene.xyToPosition(event.x, event.y);
    ds = Math.pow(1 + this.scene.settings.interaction.zooming.sensitivity, event.wheely * 0.004);
    from = this.getFrom();
    to = this.getTo();
    from = (from - origin) * ds + origin;
    to = (to - origin) * ds + origin;
    r = this.onSnapAfterDragging(from, to, origin, false, true);
    if (r) {
      this.goToPosition(r[0], r[1], true);
      if (this.pointer1 != null) {
        this.scalingActive = true;
      }
    }
    event.consumed = true;
    return this.active = false;
  };

  Linearchart_Scrolling.prototype.onPointerDown = function(event) {
    var pos;
    if (!(this.currentFrom < this.currentTo)) {
      return;
    }
    if (!this.xyInArea(event.x, event.y) || (!this.scene.settings.interaction.scrolling.enabled && !this.scene.settings.interaction.zooming.enabled)) {
      return;
    }
    pos = this.xyToPosition(event.x, event.y);
    if (this.pointer1 === null) {
      this.pointer1 = event.identifier;
      this.x1 = event.x;
      this.t1 = pos;
      this.scaleOrigin = pos;
      this.onStartDragging(this.getFrom(), this.getTo(), pos);
      this.lastScrollingY = event.y;
      this.dragStartFrom = this.currentFrom;
      this.dragStartTo = this.currentTo;
      this.dragCurFrom = this.currentFrom;
      this.dragCurTo = this.currentTo;
      event.consumed = true;
      if ((this.panAnimF != null) || (this.panAnimT != null)) {
        this.stopAnimations();
        this.scrollingActive = true;
      }
      this.scene.anchor = null;
      this.chart.cancelChartUpdateNotify();
      return event.noDefault = true;
    } else if (this.pointer2 === null) {
      this.pointer2 = event.identifier;
      this.x2 = event.x;
      this.t2 = pos;
      this.initialZoom = this.currentTo - this.currentFrom;
      this.scaleOrigin = (this.t1 + this.t2) / 2;
      return event.consumed = true;
    } else {
      if (this.scalingActive || this.scrollingActive) {
        return event.consumed = true;
      }
    }
  };

  Linearchart_Scrolling.prototype.xyToDragPosition = function(x, y) {
    var r;
    r = this.dragCurFrom + (x - this.scene.x0) / this.scene.width * (this.dragCurTo - this.dragCurFrom);
    return r;
  };

  Linearchart_Scrolling.prototype.onPointerDrag = function(event) {
    var ds, dt, from, pos, to, _ref, _ref1, _ref2;
    from = this.dragCurFrom;
    to = this.dragCurTo;
    pos = this.xyToDragPosition(event.x, event.y);
    if (event.identifier === this.pointer1 && (this.pointer2 == null)) {
      this.scaleOrigin = this.t1;
      this.x1 = event.x;
      if (Math.abs(event.dx) > Math.abs(event.dy)) {
        this.lastScrollingY = event.y;
        if (Math.abs(event.dx) > Math.abs(event.dy) * 4 && this.scene.settings.interaction.scrolling.enabled) {
          this.scrollingActive = true;
        }
      } else if (this.scene.settings.interaction.zooming.enabled && this.scene.settings.interaction.zooming.swipe && Math.abs(this.lastScrollingY - event.y) > this.scene.settings.interaction.zooming.upDownTreshold) {
        this.scalingActive = true;
      }
      if (this.scalingActive) {
        this.clearZoomHighlight();
        ds = Math.pow(1 + this.scene.settings.interaction.zooming.sensitivity, -event.dy / this.scene.height);
        from = (from - this.scaleOrigin) * ds + this.scaleOrigin;
        to = (to - this.scaleOrigin) * ds + this.scaleOrigin;
        event.consumed = true;
      }
      if (this.scrollingActive) {
        dt = this.t1 - pos;
        from = from + dt;
        to = to + dt;
      }
    } else if (event.identifier === this.pointer1 && this.scene.settings.interaction.scrolling.enabled) {
      this.x1 = event.x;
      this.clearZoomHighlight();
      _ref = this.twoPointerDrag(), from = _ref[0], to = _ref[1];
    } else if (event.identifier === this.pointer2 && this.scene.settings.interaction.scrolling.enabled) {
      this.x2 = event.x;
      this.clearZoomHighlight();
      _ref1 = this.twoPointerDrag(), from = _ref1[0], to = _ref1[1];
    } else {
      if (this.scalingActive || this.scrollingActive) {
        event.consumed = true;
      }
      return;
    }
    this.dragCurFrom = from;
    this.dragCurTo = to;
    _ref2 = this.onSnapWhileDragging(from, to, this.scaleOrigin, this.scrollingActive, this.scalingActive), from = _ref2[0], to = _ref2[1];
    this.goToPositionDragging(from, to);
    return event.consumed = true;
  };

  Linearchart_Scrolling.prototype.twoPointerDrag = function() {
    var centerFraction, centerT, dFraction, dt, dtInitial, from, maxVisible, maxZoom, minVisible, ta, targetVisible, tb, to, x1Pos, x2Pos;
    maxZoom = this.scene.settings.interaction.zooming.fingersMaxZoom;
    this.scaleOrigin = (this.t1 + this.t2) / 2;
    dtInitial = this.t2 - this.t1;
    from = this.dragCurFrom;
    to = this.dragCurTo;
    x1Pos = this.xyToDragPosition(this.x1, 0);
    x2Pos = this.xyToDragPosition(this.x2, 0);
    if (this.scene.settings.interaction.scrolling.enabled && this.scene.settings.interaction.zooming.enabled && this.scene.settings.interaction.zooming.fingers && dtInitial !== 0) {
      centerT = (this.t1 + this.t2) / 2;
      centerFraction = ((x1Pos + x2Pos) / 2 - this.currentFrom) / (this.currentTo - this.currentFrom);
      dFraction = (x2Pos - x1Pos) / (this.currentTo - this.currentFrom);
      if (dtInitial * dFraction > 0) {
        targetVisible = dtInitial / dFraction;
      } else {
        targetVisible = Infinity;
      }
      maxVisible = this.initialZoom * maxZoom;
      minVisible = Math.max(this.initialZoom / maxZoom, this._minDisplayRange);
      targetVisible = Math.max(minVisible, Math.min(maxVisible, targetVisible));
      from = centerT - centerFraction * targetVisible;
      to = centerT + (1 - centerFraction) * targetVisible;
      this.scalingActive = true;
      this.scrollingActive = true;
    } else if (this.scene.settings.interaction.scrolling.enabled) {
      ta = (this.t1 + this.t2) / 2;
      tb = (x1Pos + x2Pos) / 2;
      dt = ta - tb;
      from += dt;
      to += dt;
      this.scrollingActive = true;
    }
    return [from, to];
  };

  Linearchart_Scrolling.prototype.onPointerUp = function(event) {
    var direction, dt, dur, from, r, speed, to, vx, _ref, _ref1, _ref2;
    if (event.identifier === this.pointer2) {
      this.pointer2 = null;
      event.consumed = true;
      return this.scaleOrigin = this.t1;
    } else if (event.identifier === this.pointer1 && (this.pointer2 != null)) {
      this.pointer1 = this.pointer2;
      this.pointer2 = null;
      this.t1 = this.t2;
      this.scaleOrigin = this.t1;
      return event.consumed = true;
    } else if (event.identifier === this.pointer1) {
      this.pointer1 = null;
      this.active = true;
      if (this.scene.settings.interaction.scrolling.swipePageFlipping && event.swipeUp && this.scalingActive && event.swipeSpeed > this.scene.height / this.scene.settings.interaction.swipeSensitivity) {
        _ref = this.onZoomOut(this.dragStartFrom, this.dragStartTo, this.scaleOrigin), from = _ref[0], to = _ref[1];
      } else if (this.scene.settings.interaction.scrolling.swipePageFlipping && event.swipeDown && this.scalingActive && event.swipeSpeed > this.scene.height / this.scene.settings.interaction.swipeSensitivity) {
        _ref1 = this.onZoomIn(this.dragStartFrom, this.dragStartTo, this.scaleOrigin), from = _ref1[0], to = _ref1[1];
      } else if (this.scrollingActive || this.scalingActive) {
        if (this.scrollingActive && !this.scalingActive && this.scene.settings.interaction.scrolling.swipePageFlipping && (event.swipeLeft || event.swipeRight) && event.swipeSpeed > this.scene.width / this.scene.settings.interaction.swipeSensitivity * 0.7) {
          direction = event.swipeLeft ? "<" : ">";
          _ref2 = this.onScroll(this.dragStartFrom, this.dragStartTo, direction), from = _ref2[0], to = _ref2[1];
        } else {
          from = this.currentFrom;
          to = this.currentTo;
          if (this.scrollingActive && !this.scalingActive) {
            vx = -event.vx;
            if (vx > 0) {
              vx = Math.min(vx, this.scene.width * 2);
            } else {
              vx = Math.max(vx, -this.scene.width * 2);
            }
            speed = (this.xyToPosition(event.x, event.y) - this.xyToPosition(event.x - vx / 1000, event.y)) * 1000;
            dur = Math.abs(event.vx / this.scene.width) / this.scene.settings.interaction.scrolling.kineticFriction;
            dur = Math.min(dur, 1);
            dt = dur * speed / 2;
            this.scrollingSpeed = speed;
            this.scrollingDuration = dur * 1000;
            from += dt;
            to += dt;
          }
        }
        this.scaleOrigin = (from + to) / 2;
      }
      if (from || to) {
        r = this.onSnapAfterDragging(from, to, this.scaleOrigin, this.scrollingActive, this.scalingActive);
        if (r) {
          this.goToPosition(r[0], r[1], true);
        }
        event.consumed = true;
        this.scaleOrigin = null;
      }
      this.active = false;
      this.dragStartFrom = null;
      this.dragStartTo = null;
      this.dragStartUnit = null;
      this.scalingActive = false;
      return this.scrollingActive = false;
    } else {
      if (this.scalingActive || this.scrollingActive) {
        return event.consumed = true;
      }
    }
  };

  Linearchart_Scrolling.prototype.onPointerCancel = function(event) {
    var r;
    if (event.identifier === this.pointer2) {
      this.pointer2 = null;
      return this.scaleOrigin = this.t1;
    } else if (event.identifier === this.pointer1 && (this.pointer2 != null)) {
      this.pointer1 = this.pointer2;
      this.t1 = this.t2;
      this.scaleOrigin = this.t1;
      this.pointer2 = null;
      return this.t2 = null;
    } else if (event.identifier === this.pointer1) {
      this.active = true;
      r = this.onCancelDragging(this.dragStartFrom, this.dragStartTo);
      if (r) {
        this.goToPosition(r[0], r[1], false);
      }
      this.pointer1 = null;
      this.t1 = null;
      this.scaleOrigin = null;
      this.dragStartFrom = null;
      this.dragStartTo = null;
      this.scalingActive = false;
      this.scrollingActive = false;
      return this.active = false;
    }
  };

  Linearchart_Scrolling.prototype.onKeyDown = function(event) {
    var from, origin, r, scaling, scrolling, to, zoom, _ref, _ref1, _ref2, _ref3, _ref4;
    this.active = true;
    from = this.getFrom();
    to = this.getTo();
    if (!(from < to)) {
      return;
    }
    origin = (from + to) / 2;
    scrolling = false;
    scaling = false;
    if (event.keyCode === 37) {
      scrolling = true;
      _ref = this.onScroll(from, to, "<"), from = _ref[0], to = _ref[1];
      origin = (from + to) / 2;
    } else if (event.keyCode === 39) {
      scrolling = true;
      _ref1 = this.onScroll(from, to, ">"), from = _ref1[0], to = _ref1[1];
      origin = (from + to) / 2;
    } else if (event.keyCode === 36) {
      scaling = true;
      scrolling = true;
      _ref2 = this.onGoHome(from, to), from = _ref2[0], to = _ref2[1], origin = _ref2[2];
    } else if (event.keyCode === 38) {
      zoom = this.scene.settings.interaction.zooming.keyboardFactor;
      scaling = true;
      _ref3 = this.onZoomOut(from, to, origin, zoom), from = _ref3[0], to = _ref3[1], origin = _ref3[2];
    } else if (event.keyCode === 40) {
      zoom = 1 / this.scene.settings.interaction.zooming.keyboardFactor;
      scaling = true;
      _ref4 = this.onZoomIn(from, to, origin, zoom), from = _ref4[0], to = _ref4[1];
    }
    if (scaling || scrolling) {
      r = this.onSnapAfterDragging(from, to, origin, scrolling, scaling);
      if (r) {
        this.goToPosition(r[0], r[1], true);
      }
      event.consumed = true;
    }
    return this.active = false;
  };

  Linearchart_Scrolling.prototype.goToPositionDragging = function(from, to) {
    var oldFromAnim, oldToAnim, _ref;
    _ref = this.stopAnimations(), oldFromAnim = _ref[0], oldToAnim = _ref[1];
    this.currentFrom = from;
    this.currentTo = to;
    this.clearZoomHighlight();
    return this.onPositionChanged(from, to);
  };

  Linearchart_Scrolling.prototype.goToPosition = function(from, to, animate) {
    var diff, f, oldFromAnim, oldToAnim, t, _ref;
    if (!(from < to)) {
      return;
    }
    if (!(this.currentFrom < this.currentTo)) {
      animate = false;
    }
    _ref = this.stopAnimations(), oldFromAnim = _ref[0], oldToAnim = _ref[1];
    if (animate) {
      if (this.scrollingDuration > 0) {
        this.panAnimF = new Base_Animator(this.currentFrom, from, this.scrollingDuration, "scroll");
        this.panAnimT = new Base_Animator(this.currentTo, to, this.scrollingDuration, "scroll");
        this.scrollingDuration = null;
      } else if (oldFromAnim || oldToAnim) {
        this.panAnimF = oldFromAnim.retarget(from);
        this.panAnimT = oldToAnim.retarget(to);
      } else {
        this.panAnimF = new Base_Animator(this.currentFrom, from, this.scene.settings.interaction.animation.scrollDuration, "<>");
        this.panAnimT = new Base_Animator(this.currentTo, to, this.scene.settings.interaction.animation.scrollDuration, "<>");
      }
      diff = Math.abs((from - to) / (this.currentFrom - this.currentTo + 1));
      if (diff < 1 / this.scene.settings.interaction.zooming.zoomHighlightThreshold) {
        this.setZoomHighlight(from, to, true);
      } else if (diff > this.scene.settings.interaction.zooming.zoomHighlightThreshold) {
        f = this.dragStartFrom != null ? this.dragStartFrom : this.currentFrom;
        t = this.dragStartTo != null ? this.dragStartTo : this.currentTo;
        this.setZoomHighlight(f, t, false);
      }
      return this.events.notifySceneChanges({
        animation: true
      });
    } else {
      this.currentFrom = from;
      this.currentTo = to;
      this.clearZoomHighlight();
      this.onPositionChanged(from, to);
      return this.onAnimationDone(from, to);
    }
  };

  Linearchart_Scrolling.prototype.switchCoordinates = function(from, to) {
    var f0, t0, trAdd, trMul;
    f0 = this.getFrom();
    t0 = this.getTo();
    if (f0 < t0) {
      trMul = (from - f0) / (to - t0);
      trAdd = from - f0 * trMul;
      this.currentFrom = this.currentFrom * trMul + trAdd;
      this.currentTo = this.currentTo * trMul + trAdd;
      if (this.panAnimF) {
        this.panAnimF.switchCoordinates(trAdd, trMul);
      }
      if (this.panAnimT) {
        return this.panAnimT.switchCoordinates(trAdd, trMul);
      }
    } else {
      this.stopAnimations();
      this.currentFrom = from;
      return this.currentTo = to;
    }
  };

  Linearchart_Scrolling.prototype.doAnimations = function(event) {
    var newFrom, newTo, time;
    time = event.timeStamp;
    if ((this.panAnimF != null) || this.panAnimT) {
      newFrom = this.currentFrom;
      newTo = this.currentTo;
      if (this.panAnimF != null) {
        newFrom = this.currentFrom = this.panAnimF.get(time);
        if (this.panAnimF.finished(time)) {
          this.panAnimF = null;
        }
      }
      if (this.panAnimT != null) {
        newTo = this.currentTo = this.panAnimT.get(time);
        if (this.panAnimT.finished(time)) {
          this.panAnimT = null;
        }
      }
      if ((this.panAnimF != null) || this.panAnimT) {
        this.onPositionChanged(newFrom, newTo);
        event.animating = true;
      } else {
        this.stopAnimations();
        this.onPositionChanged(newFrom, newTo);
        this.onAnimationDone(newFrom, newTo);
      }
    }
  };

  Linearchart_Scrolling.prototype.stopAnimations = function() {
    var oldFrom, oldTo;
    oldFrom = this.panAnimF;
    oldTo = this.panAnimT;
    this.panAnimF = null;
    this.panAnimT = null;
    if (this.highlight != null) {
      if (this.highlightRemoveWhenDone) {
        this.clearZoomHighlight();
      } else {
        this.highlight.style.fillColor = this.scene.settings.area.style.zoomHighlightInactive.fillColor;
        this.events.notifySceneChanges({
          highlight: true
        });
      }
    }
    return [oldFrom, oldTo];
  };

  Linearchart_Scrolling.prototype.isActive = function() {
    return this.active || this.panAnimF || this.pointer1;
  };

  Linearchart_Scrolling.prototype.clearZoomHighlight = function() {
    if (this.highlight != null) {
      this.scene.removeHighlight("zoomTrace");
      this.highlight = null;
      return this.events.notifySceneChanges({
        highlight: true
      });
    }
  };

  Linearchart_Scrolling.prototype.setZoomHighlight = function(from, to, removeWhenDone) {
    this.highlight = this.scene.setHighlight("zoomTrace", from, to, this.scene.settings.area.style.zoomHighlight);
    this.highlightRemoveWhenDone = removeWhenDone;
    return this.events.notifySceneChanges({
      highlight: true
    });
  };

  return Linearchart_Scrolling;

})(Base_ChartElement);
// Generated by CoffeeScript 1.8.0
var Base_TouchMarkers,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

Base_TouchMarkers = (function(_super) {
  "use strict";
  __extends(Base_TouchMarkers, _super);

  Base_TouchMarkers.prototype.animationOrder = 0;

  Base_TouchMarkers.prototype.scene = null;

  Base_TouchMarkers.prototype.touches = {};

  Base_TouchMarkers.prototype.text = null;

  Base_TouchMarkers.prototype.fps = 0;

  Base_TouchMarkers.prototype.fpsAveragingPeriod = 1000;

  Base_TouchMarkers.prototype.prevFrame = null;

  function Base_TouchMarkers(scene) {
    this.scene = scene;
    this.scene.frameCount = 0;
    this.touches = {};
  }

  Base_TouchMarkers.prototype.paintScene = function(event) {
    var count, dt, fp, g, k, message, p, prop, t, _i, _j, _len, _len1, _ref, _ref1, _ref2, _ref3;
    message = "";
    if (this.scene.settings.advanced.showFPS) {
      this.scene.frameCount += 1;
      if (this.prevFrame) {
        dt = Math.max(event.timeStamp - this.prevFrame, 1) / 1000;
        fp = 1 / dt;
        prop = Math.min(1, dt * 3);
        this.fps = this.fps * (1 - prop) + fp * prop;
      }
      this.prevFrame = event.timeStamp;
      message += "FPS:" + (Math.round(this.fps));
    }
    g = event.context;
    if (this.scene.settings.advanced.showTouches) {
      count = 0;
      _ref = this.touches;
      for (k in _ref) {
        if (!__hasProp.call(_ref, k)) continue;
        t = _ref[k];
        g.beginPath();
        g.moveTo(t.dx, t.dy);
        _ref1 = t.trace;
        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
          p = _ref1[_i];
          g.lineTo(p.x, p.y);
        }
        if (t.cancelled) {
          g.strokeStyle = "red";
          g.fillStyle = "red";
          g.lineWidth = 1;
        } else if (t.up) {
          g.strokeStyle = "gray";
          g.fillStyle = "gray";
          g.lineWidth = 3;
        } else {
          g.strokeStyle = "rgba(0,139,139,0.5)";
          g.fillStyle = "rgba(0,139,139,0.5)";
          g.lineWidth = 3;
        }
        g.moveTo(t.x + 30, t.y);
        g.stroke();
        g.beginPath();
        g.arc(t.x, t.y, 30, 0, Math.PI * 2);
        g.fill();
        if (!t.up) {
          count += 1;
        }
      }
      g.beginPath();
      g.fillStyle = "black";
      _ref2 = this.touches;
      for (k in _ref2) {
        if (!__hasProp.call(_ref2, k)) continue;
        t = _ref2[k];
        _ref3 = t.trace;
        for (_j = 0, _len1 = _ref3.length; _j < _len1; _j++) {
          p = _ref3[_j];
          g.rect(p.x - 1, p.y - 1, 2, 2);
        }
      }
      g.fill();
      message += " touches:" + count;
    }
    if (message.length > 0) {
      g.fillStyle = "#000";
      g.textAlign = "start";
      g.textBaseline = "middle";
      return g.fillText(message, this.scene.x0 + this.scene.width / 3, 20);
    }
  };

  Base_TouchMarkers.prototype.previewPointerDown = function(event) {
    var k, t, _ref;
    _ref = this.touches;
    for (k in _ref) {
      if (!__hasProp.call(_ref, k)) continue;
      t = _ref[k];
      if (t.up) {
        delete this.touches[k];
      }
    }
    this.touches[event.identifier] = {
      dx: event.x,
      dy: event.y,
      up: false,
      cancelled: false,
      trace: []
    };
    return event.changes.pointers = true;
  };

  Base_TouchMarkers.prototype.previewPointerDrag = function(event) {
    var t;
    t = this.touches[event.identifier];
    t.x = event.x;
    t.y = event.y;
    t.trace.push({
      x: t.x,
      y: t.y
    });
    return event.changes.pointers = true;
  };

  Base_TouchMarkers.prototype.previewPointerUp = function(event) {
    this.touches[event.identifier].up = true;
    return this.previewPointerDrag(event);
  };

  Base_TouchMarkers.prototype.previewPointerCancel = function(event) {
    this.touches[event.identifier].up = true;
    this.touches[event.identifier].cancelled = true;
    this.previewPointerDrag(event);
    return event.changes.pointers = true;
  };

  return Base_TouchMarkers;

})(Base_ChartElement);
// Generated by CoffeeScript 1.8.0
var Linearchart_Markers,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

Linearchart_Markers = (function(_super) {
  "use strict";
  __extends(Linearchart_Markers, _super);

  Linearchart_Markers.prototype.animationOrder = 2000;

  Linearchart_Markers.prototype.paintOrder = 40;

  Linearchart_Markers.prototype.updateOrder = 800;

  Linearchart_Markers.prototype.scene = null;

  function Linearchart_Markers(chart) {
    this.chart = chart;
    this.scene = this.chart.scene;
  }

  Linearchart_Markers.prototype.paintScene = function(event) {
    var format, g, gr, height, marker, text, w, x, x0, x1, y0, y1, yLabel, _i, _len, _ref;
    if (!(this.scene.markers.length > 0 && (this.scene.displayUnit != null))) {
      return;
    }
    x0 = this.scene.x0;
    x1 = x0 + this.scene.width;
    y0 = Math.round(this.scene.y0);
    height = this.scene.height;
    yLabel = Math.round(y0 + height + this.scene.bottomAxisSize * 0.5);
    y1 = Math.round(y0 + height + this.scene.bottomAxisSize);
    g = event.context;
    Base_Graphics.pushClip(g, x0, y0, this.scene.width, this.scene.height + this.scene.bottomAxisSize);
    g.textBaseline = "middle";
    format = this.scene.settings.localization.markerDates.timeFormats[this.scene.displayUnit.unit];
    Base_Graphics.textStyle(g, this.scene.settings.area.style.markerText);
    _ref = this.scene.markers;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      marker = _ref[_i];
      x = this.scene.timeToX(marker.time);
      if (!(x + 200 >= x0 - 1 && x - 200 <= x1 + 1)) {
        continue;
      }
      gr = Base_Graphics.beginStrokeAndFill(g, marker.style);
      gr.moveTo(x, y0);
      gr.lineTo(x, y1);
      Base_Graphics.endStrokeAndFill(g, gr, marker.style);
      Base_Graphics.textStyle(gr, marker.style);
      text = moment(marker.time).utc().format(format);
      w = g.measureText(text).width;
      if (x + w >= x1) {
        g.textAlign = "end";
        x -= 2;
      } else {
        g.textAlign = "start";
        x += 2;
      }
      g.fillText(text, x, yLabel);
    }
    return Base_Graphics.popClip(g);
  };

  return Linearchart_Markers;

})(Base_ChartElement);
// Generated by CoffeeScript 1.8.0
var Linearchart_Highlights,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

Linearchart_Highlights = (function(_super) {
  "use strict";
  __extends(Linearchart_Highlights, _super);

  Linearchart_Highlights.prototype.animationOrder = 2000;

  Linearchart_Highlights.prototype.paintOrder = 45;

  Linearchart_Highlights.prototype.updateOrder = 700;

  Linearchart_Highlights.prototype.scene = null;

  Linearchart_Highlights.prototype.customId = 0;

  Linearchart_Highlights.prototype.animating = false;

  Linearchart_Highlights.prototype.highlights = {};

  function Linearchart_Highlights(chart) {
    this.chart = chart;
    this.scene = chart.scene;
    this.highlights = {};
  }

  Linearchart_Highlights.prototype.doAnimations = function(event) {
    var existingHighlights, k, m, mm, newAnimating, time, _i, _len, _ref, _ref1, _ref2, _ref3;
    if (event.changes.highlight) {
      existingHighlights = [];
      _ref = this.highlights;
      for (k in _ref) {
        m = _ref[k];
        m.mode = "exiting";
        if (m.origin.keepTrack === false) {
          delete this.highlights[k];
          existingHighlights.push(m);
        }
      }
      for (_i = 0, _len = existingHighlights.length; _i < _len; _i++) {
        m = existingHighlights[_i];
        this.highlights["__" + this.customId] = m;
        this.customId += 1;
      }
      _ref1 = this.scene.highlights;
      for (k in _ref1) {
        mm = _ref1[k];
        if (this.highlights[k] != null) {
          m = this.highlights[k];
          m.mode = null;
          m.from = mm.from;
          m.to = mm.to;
          if (m.style.fillColor !== mm.style.fillColor && mm.style.fadeCross > 0) {
            this.animating = true;
            m.animator = new Base_Animator(m.style.fillColor, mm.style.fillColor, mm.style.fadeCross, "=", event.timeStamp);
          } else {
            m.style = Base_Helpers.clone(mm.style);
          }
        } else {
          m = {
            from: mm.from,
            to: mm.to,
            style: Base_Helpers.clone(mm.style),
            origin: mm
          };
          this.highlights[k] = m;
          if (mm.style.fadeIn > 0) {
            this.animating = true;
            m.animator = new Base_Animator(Base_Graphics.deriveColor(m.style.fillColor, 1, 0), m.style.fillColor, m.style.fadeIn, "=", event.timeStamp);
          }
        }
      }
      _ref2 = this.highlights;
      for (k in _ref2) {
        m = _ref2[k];
        if (m.mode === "exiting" && !m.animator) {
          mm = m.origin;
          if (mm.style.fadeOut > 0) {
            this.animating = true;
            m.animator = new Base_Animator(m.style.fillColor, Base_Graphics.deriveColor(m.style.fillColor, 1, 0), m.style.fadeOut, "=", event.timeStamp);
          } else {
            delete this.highlights[k];
          }
        }
      }
    }
    if (this.animating) {
      newAnimating = false;
      time = event.timeStamp;
      _ref3 = this.highlights;
      for (k in _ref3) {
        m = _ref3[k];
        if (m.animator != null) {
          m.style.fillColor = m.animator.getColor(time);
          if (m.animator.finished(time)) {
            m.animator = null;
            if (m.mode === "exiting") {
              delete this.highlights[k];
            }
          } else {
            newAnimating = true;
          }
        }
      }
      this.animating = newAnimating;
      return event.animating |= newAnimating;
    }
  };

  Linearchart_Highlights.prototype.paintScene = function(event) {
    var g, height, highlight, hx0, hx1, k, x0, x1, y0, _ref, _results;
    x0 = this.scene.x0;
    x1 = x0 + this.scene.width;
    y0 = Math.round(this.scene.y0);
    height = this.scene.height;
    g = event.context;
    _ref = this.highlights;
    _results = [];
    for (k in _ref) {
      highlight = _ref[k];
      hx0 = Math.max(this.scene.timeToX(highlight.from), x0);
      hx1 = Math.min(this.scene.timeToX(highlight.to), x1);
      if (!(hx1 >= x0 && hx0 <= x1)) {
        continue;
      }
      Base_Graphics.rectStyle(g, highlight.style);
      _results.push(g.fillRect(hx0, y0, hx1 - hx0, height));
    }
    return _results;
  };

  return Linearchart_Highlights;

})(Base_ChartElement);
// Generated by CoffeeScript 1.8.0
var Linearchart_Layers,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

Linearchart_Layers = (function(_super) {
  __extends(Linearchart_Layers, _super);

  Linearchart_Layers.prototype.animationOrder = 2000;

  Linearchart_Layers.prototype.paintOrder = 50;

  Linearchart_Layers.prototype.updateOrder = 600;

  Linearchart_Layers.prototype.chart = null;

  Linearchart_Layers.prototype.scene = null;

  Linearchart_Layers.prototype.container = null;

  Linearchart_Layers.prototype.background = null;

  Linearchart_Layers.prototype.backgroundImage = null;

  Linearchart_Layers.prototype.canvas = null;

  Linearchart_Layers.prototype.valueAxisPanel = null;

  Linearchart_Layers.prototype.timeAxisPanel = null;

  Linearchart_Layers.prototype.outerBorder = null;

  Linearchart_Layers.prototype.mouseTrackLayer = null;

  Linearchart_Layers.prototype.curTheme = null;

  function Linearchart_Layers(chart) {
    this.chart = chart;
    this.scene = this.chart.scene;
    this.container = Base_Helpers.createDom("div", "DVSL-container");
    this.container.style.position = "relative";
    this.container.style.width = "100%";
    this.container.style.height = "300px";
    this.background = Base_Helpers.createDom("div", "DVSL-background", null, this.container);
    this.setContainerStyle(this.background);
    this.backgroundImage = Base_Helpers.createDom("div", "DVSL-background-image", null, this.container);
    this.setContainerStyle(this.backgroundImage);
    this.timeAxisPanel = Base_Helpers.createDom("div", "DVSL-TC-timeAxis", null, this.container);
    this.setContainerStyle(this.timeAxisPanel);
    this.canvas = Base_Helpers.createDom("canvas", "DVSL-canvas", null, this.container);
    this.setContainerStyle(this.canvas);
    this.valueAxisPanel = Base_Helpers.createDom("div", "DVSL-valueAxis", null, this.container);
    this.setContainerStyle(this.valueAxisPanel);
    this.secondaryValueAxisPanel = Base_Helpers.createDom("div", "DVSL-valueAxis", null, this.container);
    this.setContainerStyle(this.secondaryValueAxisPanel);
    this.resizerBar = Base_Helpers.createDom("div", "DVSL-resizer", null, this.container);
    this.outerBorder = Base_Helpers.createDom("div", "DVSL-border", null, this.container);
    this.setContainerStyle(this.outerBorder);
    this.mouseTrackLayer = Base_Helpers.createDom("div", null, null, this.container);
    this.mouseTrackLayer.tabIndex = 0;
    this.mouseTrackLayer.style.outline = "none";
    this.setContainerStyle(this.mouseTrackLayer);
    this.updateSettings(this.scene.settings, "init");
  }

  Linearchart_Layers.prototype.updateSettings = function(changes) {
    if (Base_Helpers.hasProp(changes, "area.style.image")) {
      if (changes.area.style.image) {
        this.backgroundImage.style.backgroundImage = "url(" + changes.area.style.image + ")";
      } else {
        this.backgroundImage.style.backgroundImage = "";
      }
    }
    if (Base_Helpers.hasProp(changes, "advanced.themeCSSClass")) {
      if (this.curTheme != null) {
        Base_Helpers.removeClass(this.container, this.curTheme);
      }
      this.curTheme = this.scene.settings.advanced.themeCSSClass;
      return Base_Helpers.addClass(this.container, this.curTheme);

      /*if Base_Helpers.getProp(changes, "valueAxis.default.position")?
       * TODO - this is now different, axis can be both inside and outside
      if @scene.settings.valueAxis.default.position == "outside"
        Base_Helpers.removeClass(@container, "DVSL-valueAxisInside")
        Base_Helpers.addClass(@container, "DVSL-valueAxisOutside")
      else
        Base_Helpers.removeClass(@container, "DVSL-valueAxisOutside")
        Base_Helpers.addClass(@container, "DVSL-valueAxisInside")
      
          if Base_Helpers.getProp(changes, "valueAxis.secondary.position")?
      if @scene.settings.valueAxis.secondary.position == "outside"
        Base_Helpers.removeClass(@container, "TC-secondaryValueAxisInside")
        Base_Helpers.addClass(@container, "TC-secondaryValueAxisOutside")
      else
        Base_Helpers.removeClass(@container, "TC-secondaryValueAxisOutside")
        Base_Helpers.addClass(@container, "TC-secondaryValueAxisInside")
       */
    }
  };

  Linearchart_Layers.prototype.doAnimations = function(event) {
    var setHeight, setWidth;
    if (!event.changes.bounds) {
      return;
    }
    setWidth = this.scene.settings.width;
    setHeight = this.scene.settings.height;
    if (this.scene.chartWidth > 10 + this.container.clientWidth && this.container && this.container.style.display !== "") {
      setWidth = this.scene.chartWidth;
    }
    if (this.scene.chartHeight > 10 + this.container.clientHeight && this.container && this.container.style.display !== "") {
      setHeight = this.scene.chartHeight;
    }
    if (setWidth) {
      this.container.style.width = "" + setWidth + "px";
    }
    if (setHeight) {
      this.container.style.height = "" + setHeight + "px";
    }
    this.background.style.left = "" + this.scene.x0 + "px";
    this.background.style.right = "" + (this.scene.chartWidth - (this.scene.x0 + this.scene.width)) + "px";
    this.backgroundImage.style.left = "" + this.scene.x0 + "px";
    this.backgroundImage.style.right = "" + (this.scene.chartWidth - (this.scene.x0 + this.scene.width)) + "px";
    this.backgroundImage.style.bottom = "" + this.scene.bottomMargin + "px";
    this.valueAxisPanel.style.width = "" + this.scene.leftMargin + "px";
    this.valueAxisPanel.style.bottom = "" + this.scene.bottomMargin + "px";
    this.secondaryValueAxisPanel.style.width = "" + this.scene.rightMargin + "px";
    this.secondaryValueAxisPanel.style.bottom = "" + this.scene.bottomMargin + "px";
    this.timeAxisPanel.style.top = "" + (this.scene.y0 + this.scene.height) + "px";
    this.timeAxisPanel.style.left = "" + this.scene.x0 + "px";
    this.timeAxisPanel.style.width = "" + this.scene.width + "px";
    this.outerBorder.style.left = "" + this.scene.x0 + "px";
    this.outerBorder.style.width = "" + this.scene.width + "px";
    this.resizerBar.style.width = "" + this.scene.width + "px";
    return this.resizerBar.style.left = "" + this.scene.x0 + "px";
  };

  Linearchart_Layers.prototype.setContainerStyle = function(c) {
    c.style.position = "absolute";
    c.style.left = "0px";
    c.style.right = "0px";
    c.style.top = "0px";
    return c.style.bottom = "0px";
  };

  return Linearchart_Layers;

})(Base_ChartElement);
// Generated by CoffeeScript 1.8.0
var Linearchart_Highlight, Linearchart_Marker, Linearchart_Scene,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

Linearchart_Marker = (function() {
  function Linearchart_Marker() {}

  Linearchart_Marker.prototype.time = 0;

  Linearchart_Marker.prototype.label = 0;

  Linearchart_Marker.prototype.style = null;

  return Linearchart_Marker;

})();

Linearchart_Highlight = (function() {
  function Linearchart_Highlight() {}

  Linearchart_Highlight.prototype.from = 0;

  Linearchart_Highlight.prototype.to = 0;

  Linearchart_Highlight.prototype.style = null;

  return Linearchart_Highlight;

})();

Linearchart_Scene = (function(_super) {
  "use strict";
  __extends(Linearchart_Scene, _super);

  Linearchart_Scene.prototype.settings = null;

  Linearchart_Scene.prototype.bottomAxisSize = 0;

  Linearchart_Scene.prototype.hoverSeriesItem = null;

  function Linearchart_Scene() {
    Linearchart_Scene.__super__.constructor.call(this);
    this.highlights = {};
    this.markers = [];
  }

  Linearchart_Scene.prototype.xyInChart = function(x, y) {
    return (x >= this.x0) && (x < this.x0 + this.width) && (y >= this.y0) && (y < this.y0 + this.height);
  };

  Linearchart_Scene.prototype.xyInChartOrBottom = function(x, y) {
    return (x >= this.x0) && (x < this.x0 + this.width) && (y >= this.y0) && (y < this.y0 + this.height + this.bottomAxisSize);
  };

  Linearchart_Scene.prototype.xyInBottom = function(x, y) {
    return x >= this.x0 && x < this.x0 + this.width && y >= this.y0 + this.height && y < this.y0 + this.height + this.bottomAxisSize;
  };

  Linearchart_Scene.prototype.timeToX = function(t) {
    throw "Need to implement timeToX";
  };

  Linearchart_Scene.prototype.xToTime = function(t) {
    throw "Need to implement xToTime";
  };

  Linearchart_Scene.prototype.setHighlight = function(name, from, to, style) {
    var h;
    h = this.highlights[name];
    if (h == null) {
      h = {};
      this.highlights[name] = h;
    }
    h.from = from;
    h.to = to;
    h.style = style;
    return h;
  };

  Linearchart_Scene.prototype.removeHighlight = function(name, keepTrack) {
    if (keepTrack == null) {
      keepTrack = false;
    }
    if (this.highlights[name] == null) {
      return;
    }
    this.highlights[name].keepTrack = keepTrack;
    return delete this.highlights[name];
  };

  return Linearchart_Scene;

})(Base_Scene);
// Generated by CoffeeScript 1.8.0
var Base_KeyShortcuts,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

Base_KeyShortcuts = (function(_super) {
  __extends(Base_KeyShortcuts, _super);

  Base_KeyShortcuts.prototype.animationOrder = 2000;

  Base_KeyShortcuts.prototype.paintOrder = 65;

  Base_KeyShortcuts.prototype.updateOrder = 0;

  function Base_KeyShortcuts(chart) {
    this.chart = chart;
  }

  Base_KeyShortcuts.prototype.onKeyDown = function(ev) {
    var origin;
    if (this.chart.isFullscreen() && event.keyCode === 27) {
      this.chart.setFullscreen(false);
      return ev.consumed = true;
    } else if (event.keyCode === 8) {
      if (this.chart.back(true, origin = "user")) {
        return ev.consumed = true;
      }
    }
  };

  return Base_KeyShortcuts;

})(Base_ChartElement);
// Generated by CoffeeScript 1.8.0
var Base_InfoPopup,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

Base_InfoPopup = (function(_super) {
  "use strict";
  __extends(Base_InfoPopup, _super);

  function Base_InfoPopup(chart) {
    this.chart = chart;
    this.container = chart.layers.container;
    this.scene = chart.scene;
    this.events = chart.events;
    this.popup = Base_Helpers.createDom("div", "DVSL-info-center", null, this.container);
    Base_Helpers.createDom("em", null, null, this.popup);
    this.events.addContainer(this.popup);
    this.popup.style.position = "absolute";
    this.popup.style.display = "none";
    this.contents = null;
    this.visible = false;
    this.x0 = null;
    this.x1 = null;
    this.y = null;
    this.contentsChanged = false;
    this.chart.events.addContainer(this.popup);
  }

  Base_InfoPopup.prototype.hide = function() {
    if (!this.visible) {
      return false;
    }
    this.visible = false;
    this.popup.style.display = "none";
    return true;
  };

  Base_InfoPopup.prototype.show = function(x0, x1, y, contents) {
    this.visible = true;
    if (contents) {
      if (contents.indexOf("<") === -1 && contents.indexOf(">") === -1) {
        contents = "<b>" + contents + "</b>";
      }
      this.popup.style.display = "block";
      if (contents !== this.popup.innerHTML) {
        this.popup.innerHTML = contents;
        this.contentsChanged = true;
      }
      return this.updateXY(x0, x1, y);
    } else {
      return this.popup.style.display = "none";
    }
  };

  Base_InfoPopup.prototype.updateContents = function(contents) {
    if (!!this.visible) {
      return;
    }
    if (contents === null) {
      return this.hide();
    } else {
      return this.show(this.x0, this.x1, this.y, contents);
    }
  };

  Base_InfoPopup.prototype.updateXY = function(x0, x1, y) {
    var arrowWidth, cl, h, margin, w, x;
    if (!(this.visible || this.contentsChanged || this.x0 !== x0 || this.x1 !== x1 || this.y !== y)) {
      return;
    }
    if (this.contentsChanged) {
      this.contentsChanged = false;
      this.width = this.popup.offsetWidth;
      this.height = this.popup.offsetHeight;
    }
    this.x0 = x0;
    this.x1 = x1;
    this.y = y;
    margin = 12;
    arrowWidth = 10;
    w = this.width;
    h = this.height;
    if (this.scene.x0 <= x0 - w - arrowWidth) {
      x = x0 - w - arrowWidth;
      cl = "DVSL-info-left";
    } else if (this.scene.x0 + this.scene.width >= x1 + w + arrowWidth) {
      x = x1 + arrowWidth;
      cl = "DVSL-info-right";
    } else {
      x = (Math.max(x0, this.scene.x0) + Math.min(x1, this.scene.x0 + this.scene.width) - w) / 2;
      cl = "DVSL-info-center";
    }
    y = Math.min(Math.max(this.scene.y0 + margin, y - h / 2), this.scene.y0 + this.scene.height - h);
    this.popupX = x;
    this.popupY = y;
    this.popup.style.left = x + "px";
    this.popup.style.top = y + "px";
    if (this.popupClass !== cl) {
      this.popupClass = cl;
      return Base_Helpers.setClass(this.popup, cl);
    }
  };

  return Base_InfoPopup;

})(Base_ChartElement);
// Generated by CoffeeScript 1.8.0
var Piechart_View,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

Piechart_View = (function(_super) {
  __extends(Piechart_View, _super);

  function Piechart_View(chart) {
    this.chart = chart;
    this.animationOrder = 1007;
  }

  Piechart_View.prototype.updatePie = function(pie) {
    return true;
  };

  Piechart_View.prototype.scrollForward = function(pie, offset) {
    return true;
  };

  Piechart_View.prototype.scrollBackward = function(pie, offset) {
    return false;
  };

  Piechart_View.prototype.onSceneChange = function(event) {};

  Piechart_View.prototype.doAnimations = function(event) {};

  Piechart_View.prototype.paintScene = function(event) {};

  Piechart_View.prototype.getMovement = function(pie, event) {
    return [0, 0];
  };

  Piechart_View.prototype.findSliceAt = function(x, y, tolerance) {};

  Piechart_View.prototype.findPieAt = function(x, y, tolerance) {};

  Piechart_View.prototype.findLabelAt = function(x, y, tolerance) {};

  return Piechart_View;

})(Base_ChartElement);
// Generated by CoffeeScript 1.8.0
var Piechart_Animations;

Piechart_Animations = (function() {
  function Piechart_Animations(chart) {
    this.chart = chart;
    this.scene = chart.scene;
    this.events = chart.events;
    this.prevTime = 0;
    this.radiusAnimator = null;
    this.innerRadiusAnimator = null;
  }

  Piechart_Animations.prototype.doAnimations = function(event) {
    var a0Animator, a1Animator, c, c0, c1, c2, c3, cc, changedPies, cutoutAnimator, diff, dt, fillAnimator, hoverDuration, lineAnimator, minRad, pie, pieChanges, piesToRemove, r0Animator, r1Animator, radiusChanges, removePie, slice, slicesToRemove, time, transitionDuration, _i, _j, _k, _l, _len, _len1, _len2, _len3, _len4, _m, _ref, _ref1, _ref10, _ref11, _ref12, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7, _ref8, _ref9;
    if (this.prevTime) {
      dt = Math.min(30, event.timeStamp - this.prevTime);
    } else {
      dt = 0;
    }
    transitionDuration = this.scene.settings.interaction.animation.scrollDuration;
    hoverDuration = this.scene.settings.interaction.animation.hoverDuration;
    time = event.timeStamp;
    piesToRemove = [];
    changedPies = [];
    radiusChanges = false;
    if (this.scene.settings.pie.adaptiveRadius) {
      if (!this.innerRadiusAnimator) {
        this.innerRadiusAnimator = new Base_Animator(0, this.scene.innerRadius, transitionDuration, "<>", time);
        this.radiusAnimator = new Base_Animator(0, this.scene.radius, transitionDuration, "<>", time);
      }
      _ref = this.radiusAnimator.updateAndGet(this.scene.radius, time), this.scene.currentRadius = _ref[0], c0 = _ref[1];
      _ref1 = this.innerRadiusAnimator.updateAndGet(this.scene.innerRadius, time), this.scene.currentInnerRadius = _ref1[0], c1 = _ref1[1];
      radiusChanges || (radiusChanges = c0 || c1);
      event.animating || (event.animating = radiusChanges);
    } else if (this.scene.currentRadius !== this.scene.radius || this.scene.currentInnerRadius !== this.scene.innerRadius) {
      radiusChanges = true;
      this.scene.currentRadius = this.scene.radius;
      this.scene.currentInnerRadius = this.scene.innerRadius;
    }
    diff = this.scene.currentRadius - this.scene.currentInnerRadius;
    minRad = diff > 0 ? -this.scene.currentInnerRadius / diff : 0;
    _ref2 = this.scene.pies;
    for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
      pie = _ref2[_i];
      pieChanges = false;
      if (event.changes.pie || event.changes.bounds) {
        pieChanges = true;
      }
      removePie = false;
      if (pie.removed === true) {
        pie.removed = time + transitionDuration;
      }
      if (pie.removed) {
        event.animating = true;
        removePie = pie.removed < time;
      }
      if (!removePie) {
        if (!pie.animatorA0) {
          pieChanges = true;
          pie.animatorA0 = new Base_Animator(pie.currentStartAngle, pie.startAngle, transitionDuration, "<>", time);
          pie.animatorA1 = new Base_Animator(pie.currentEndAngle, pie.endAngle, transitionDuration, "<>", time);
          pie.animatorR0 = new Base_Animator(pie.currentInnerRadius, pie.innerRadius, transitionDuration, "<>", time);
          pie.animatorR1 = new Base_Animator(pie.currentRadius, pie.radius, transitionDuration, "<>", time);
          if (!this.scene.settings.advanced.initialAnimation) {
            pie.animatorA0.jump(pie.startAngle);
            pie.animatorA1.jump(pie.endAngle);
            pie.animatorR0.jump(pie.innerRadius);
            pie.animatorR1.jump(pie.radius);
          }
        }
        a0Animator = pie.animatorA0;
        a1Animator = pie.animatorA1;
        r0Animator = pie.animatorR0;
        r1Animator = pie.animatorR1;
        _ref3 = a0Animator.updateAndGet(pie.startAngle, time), pie.currentStartAngle = _ref3[0], c0 = _ref3[1];
        _ref4 = a1Animator.updateAndGet(pie.endAngle, time), pie.currentEndAngle = _ref4[0], c1 = _ref4[1];
        _ref5 = r1Animator.updateAndGet(pie.radius, time), pie.currentRadius = _ref5[0], c2 = _ref5[1];
        _ref6 = r0Animator.updateAndGet(pie.innerRadius, time), pie.currentInnerRadius = _ref6[0], c3 = _ref6[1];
        pie.currentInnerRadius = Math.min(pie.currentInnerRadius, pie.currentRadius);
        pieChanges || (pieChanges = c0 || c1 || c2 || c3);
        slicesToRemove = [];
        cc = false;
        _ref7 = pie.allSlices;
        for (_j = 0, _len1 = _ref7.length; _j < _len1; _j++) {
          slice = _ref7[_j];
          if (!slice.animatorF) {
            pieChanges = true;
            slice.animatorF = new Base_Animator(slice.currentFraction, slice.fraction, transitionDuration, "<>", time);
          }
          _ref8 = slice.animatorF.updateAndGetFixed(slice.fraction, time), slice.currentFraction = _ref8[0], c = _ref8[1];
          cc || (cc = c);
          if (slice.removed && slice.currentFraction === 0) {
            slicesToRemove.push(slice);
          }
        }
        pieChanges || (pieChanges = cc);
        if (slicesToRemove.length > 0) {
          pieChanges = true;
          for (_k = 0, _len2 = slicesToRemove.length; _k < _len2; _k++) {
            slice = slicesToRemove[_k];
            Base_Helpers.removeFromArray(pie.slices, slice);
            Base_Helpers.removeFromArray(pie.allSlices, slice);
            if (slice === pie.othersSlice) {
              pie.othersSlice = null;
            }
            if (slice === pie.previousSlice) {
              pie.previousSlice = null;
            }
          }
        }
        _ref9 = pie.allSlices;
        for (_l = 0, _len3 = _ref9.length; _l < _len3; _l++) {
          slice = _ref9[_l];
          if (!slice.animatorLineColor) {
            pieChanges = true;
            slice.animatorLineColor = new Base_Animator(slice.currentLineColor, slice.targetLineColor, hoverDuration, "<>", time);
            slice.animatorFillColor = new Base_Animator(slice.currentFillColor, slice.targetFillColor, hoverDuration, "<>", time);
            slice.animatorCutout = new Base_Animator(slice.currentCutoutDistance, slice.cutoutDistance, hoverDuration, "<>", time);
          }
          lineAnimator = slice.animatorLineColor;
          fillAnimator = slice.animatorFillColor;
          cutoutAnimator = slice.animatorCutout;
          _ref10 = lineAnimator.updateColorAndGet(slice.targetLineColor, time), slice.currentLineColor = _ref10[0], c0 = _ref10[1];
          _ref11 = fillAnimator.updateColorAndGet(slice.targetFillColor, time), slice.currentFillColor = _ref11[0], c1 = _ref11[1];
          if (!slice.userPlaced) {
            _ref12 = cutoutAnimator.updateAndGet(slice.cutoutDistance, time), slice.currentCutoutDistance = _ref12[0], c2 = _ref12[1];
          }
          pieChanges || (pieChanges = c0 || c1 || c2);
        }
        if (pieChanges || radiusChanges) {
          changedPies.push(pie);
        }
        event.animating || (event.animating = pieChanges);
      } else {
        piesToRemove.push(pie);
      }
    }
    for (_m = 0, _len4 = piesToRemove.length; _m < _len4; _m++) {
      pie = piesToRemove[_m];
      this.scene.deletePie(pie);
    }
    this.prevTime = time;
    return changedPies;
  };

  return Piechart_Animations;

})();
// Generated by CoffeeScript 1.8.0
var Piechart_LabelLayout, Piechart_PieLayout,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

Piechart_PieLayout = (function() {
  "use strict";
  function Piechart_PieLayout(chart, view) {
    this.chart = chart;
    this.view = view;
    this.scene = chart.scene;
    this.events = chart.events;
  }

  Piechart_PieLayout.prototype.placeStack = function(pie, context) {
    var add, chartR, depth, endAngle, height, i, innerMinRadius, innerRadius, maxR, mul, pieChanges, pieIndex, pies, radius, radiusStep, remainingSlices, settings, startAngle, x, y, _i, _j, _len, _ref, _ref1, _ref2;
    settings = this.scene.settings;
    depth = settings.pie.depth;
    pieChanges = false;
    height = this.scene.height - depth * 2;
    height = Math.max(2, height);
    x = settings.pie.x;
    y = settings.pie.y;
    if (x === null) {
      x = this.scene.x0 + this.scene.width / 2;
    } else if (x >= 0 && x <= 1) {
      x = this.scene.x0 + this.scene.width * x;
    }
    if (y === null) {
      y = this.scene.y0 + height / 2;
    } else if (y >= 0 && y <= 1) {
      y = this.scene.y0 + this.scene.height * y;
    }
    maxR = Math.min(height / 2, this.scene.width / 2);
    maxR -= settings.pie.outerMargin;
    radius = settings.pie.radius;
    if (!radius) {
      if (settings.labels.enabled && settings.pie.adaptiveRadius) {
        chartR = this.computeDesiredRadiusFromLabels(pie, context);
        chartR = Math.min(maxR, chartR);
        chartR -= settings.labels.connectorLength;
        chartR = Math.max(chartR, maxR / 3);
        radius = chartR;
      } else {
        radius = maxR;
      }
    } else if (radius <= 1) {
      radius = maxR * radius;
    }
    innerRadius = settings.pie.innerRadius;
    if (innerRadius < 1) {
      innerRadius = radius * innerRadius;
    }
    if (this.scene.stack.length > 1) {
      innerMinRadius = settings.pie.innerRadiusWhenDrilldown;
      if (innerMinRadius < 1) {
        innerMinRadius = radius * innerMinRadius;
      }
      innerRadius = Math.max(innerRadius, innerMinRadius);
    }
    startAngle = settings.pie.startAngle;
    endAngle = settings.pie.endAngle;
    if (radius === innerRadius) {
      mul = 0;
      add = 0;
    } else {
      mul = 1 / (radius - innerRadius);
      add = -innerRadius * mul;
    }
    if (pie.x !== x || pie.y !== y || this.scene.radius !== radius || this.scene.innerRadius !== innerRadius || startAngle !== pie.startAngle || endAngle !== pie.endAngle) {
      pieChanges = true;
    }
    this.scene.radius = radius;
    this.scene.innerRadius = innerRadius;
    pie.x = x;
    pie.y = y;
    pie.radius = 1;
    pie.innerRadius = innerRadius * mul + add;
    pie.startAngle = startAngle;
    pie.endAngle = endAngle;
    pies = this.scene.stack;
    pieIndex = pies.length - 1;
    if (pieIndex > 0) {
      innerRadius = innerRadius - settings.pie.margin;
      remainingSlices = pieIndex;
      radiusStep = Math.max(0, Math.min(radius - innerRadius, (innerRadius - settings.pie.centerMargin) / remainingSlices));
      for (i = _i = _ref = pieIndex - 1; _i >= 0; i = _i += -1) {
        radius = innerRadius;
        innerRadius -= radiusStep;
        pie = pies[i];
        y += depth;
        pie.x = x;
        pie.y = y;
        pie.radius = radius * mul + add;
        pie.innerRadius = (innerRadius + settings.pie.margin) * mul + add;
        pie.brightness = 0.8 - 0.8 * (remainingSlices - i - 1) / remainingSlices;
        pie.startAngle = settings.pie.startAngle;
        pie.endAngle = settings.pie.endAngle;
      }
    }
    _ref1 = this.scene.pies;
    for (_j = 0, _len = _ref1.length; _j < _len; _j++) {
      pie = _ref1[_j];
      if (pie.removed && pie.parentSlice) {
        _ref2 = this.scene.getSliceTargetAngles(pie.parentSlice), pie.startAngle = _ref2[0], pie.endAngle = _ref2[1];
      }
    }
    return pieChanges;
  };

  Piechart_PieLayout.prototype.computeDesiredRadiusFromLabels = function(pie, g) {
    var a, a0, a1, am, astart, availableArea, chartArea, da, effectiveHeight, endAngle, fsum, l, labelHeight, labelLayout, leftLabelArea, leftLongestWord, longestWord, lw, radiusByArea, radiusByLongestWord, rightLabelArea, rightLongestWord, slice, sliceAngle0, sliceAngle1, startAngle, w, x, _i, _j, _len, _len1, _ref, _ref1;
    labelLayout = new Piechart_LabelLayout(g, 1, 0, 100, 0, 100, this.scene.settings.slice.labelStyle, this.scene.settings.labels);
    labelHeight = labelLayout.lineHeightC + labelLayout.lineHeightM;
    leftLongestWord = 0;
    rightLongestWord = 0;
    leftLabelArea = 0;
    rightLabelArea = 0;
    fsum = 0;
    startAngle = pie.startAngle;
    endAngle = pie.endAngle;
    da = endAngle - startAngle;
    astart = pie.startAngle + pie.scrollOffset * da;
    sliceAngle1 = astart;
    _ref = pie.slices;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      slice = _ref[_i];
      sliceAngle0 = sliceAngle1;
      fsum = Math.min(1, fsum + slice.fraction);
      sliceAngle1 = astart + fsum * da;
      a0 = Math.max(sliceAngle0, startAngle);
      a1 = Math.min(sliceAngle1, endAngle);
      if (a0 >= endAngle || a1 <= startAngle) {
        continue;
      }
      am = (a0 + a1) / 2;
      if (slice.label) {
        longestWord = "";
        _ref1 = slice.label.split(" ");
        for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
          w = _ref1[_j];
          if (w.length > longestWord.length) {
            longestWord = w;
          }
        }
        l = g.measureText(longestWord).width;
        w = g.measureText(slice.label).width;
        a = labelHeight * w * 1.2;
        x = Math.cos(am);
        if (x > 0) {
          rightLabelArea += a;
          rightLongestWord = Math.max(rightLongestWord, l);
        } else {
          leftLabelArea += a;
          leftLongestWord = Math.max(leftLongestWord, l);
        }
      }
    }
    effectiveHeight = Math.min(this.scene.width, this.scene.height);
    availableArea = this.scene.width * effectiveHeight;
    chartArea = Math.max(1, availableArea - 2 * Math.max(leftLabelArea, rightLabelArea) * 1.2);
    radiusByArea = Math.sqrt(chartArea / Math.PI);
    lw = Math.max(leftLongestWord, rightLongestWord);
    radiusByLongestWord = this.scene.width / 2 - lw * 1.1;
    return Math.min(radiusByArea, radiusByLongestWord);
  };

  Piechart_PieLayout.prototype.placeLabels = function(pie, g) {
    var a0, a1, add, am, astart, bottom, config, da, endAngle, fsum, icon, iconAutohide, iconMaxSize, iconMinSize, iconPlacement, iconSize, insideLabelLayout, insideLablelProp, label, labelsEnabled, left, leftOutsideLabels, margin, mul, outsideLabelLayout, pr0, pr1, r0, r1, right, rightOutsideLabels, slice, sliceAngle0, sliceAngle1, startAngle, text, top, x, y, _i, _len, _ref, _ref1, _ref2;
    config = this.scene.settings.labels;
    labelsEnabled = config.enabled;
    _ref = this.scene.settings.icons.sizeExtent, iconMinSize = _ref[0], iconMaxSize = _ref[1];
    iconPlacement = this.scene.settings.icons.placement;
    iconAutohide = this.scene.settings.icons.autohideWhenTooSmall;
    if (this.scene.settings.advanced.iconMinSize) {
      iconMinSize = this.scene.settings.advanced.iconMinSize;
    }
    margin = this.scene.settings.slice.margin;
    x = pie.x;
    y = pie.y;
    add = this.scene.currentInnerRadius;
    mul = this.scene.currentRadius - add;
    pr0 = pie.currentInnerRadius * mul + add;
    pr1 = pie.currentRadius * mul + add;
    fsum = 0;
    startAngle = pie.currentStartAngle;
    endAngle = pie.currentEndAngle;
    da = endAngle - startAngle;
    astart = pie.currentStartAngle + pie.scrollOffset * da;
    left = this.scene.x0 - x;
    right = left + this.scene.width;
    top = this.scene.y0 - y;
    bottom = top + this.scene.height;
    insideLabelLayout = new Piechart_LabelLayout(g, pr1, left, right, top, bottom, this.scene.settings.slice.insideLabelStyle, this.scene.settings.labels);
    outsideLabelLayout = new Piechart_LabelLayout(g, pr1, left, right, top, bottom, this.scene.settings.slice.labelStyle, this.scene.settings.labels);
    leftOutsideLabels = [];
    rightOutsideLabels = [];
    sliceAngle1 = astart;
    _ref1 = pie.allSlices;
    for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
      slice = _ref1[_i];
      sliceAngle0 = sliceAngle1;
      fsum = Math.min(1, fsum + slice.currentFraction);
      sliceAngle1 = astart + fsum * da;
      a0 = Math.max(sliceAngle0, startAngle);
      a1 = Math.min(sliceAngle1, endAngle);
      r0 = pr0 + slice.currentCutoutDistance;
      r1 = pr1 + slice.currentCutoutDistance;
      if (a0 >= endAngle || a1 <= startAngle) {
        slice.currentLabel = null;
        slice.currentInsideLabel = null;
        slice.currentIcon = null;
        continue;
      }
      am = (a0 + a1) / 2;
      if (!slice.removed && !pie.background) {
        if (slice.insideLabel && labelsEnabled) {
          text = slice.insideLabel;
          if (!slice.currentInsideLabel) {
            label = slice.currentInsideLabel = new Base_Label();
            label.align = "center";
          } else {
            label = slice.currentInsideLabel;
          }
          if (slice.currentInsideLabel.text !== text) {
            label.text = text;
            label.measureDone = false;
          }
          insideLablelProp = insideLabelLayout.fitLabelInSlice(label, r0, r1, a0, a1);
          label.shouldBeVisible = config.insideLabel === "always" || insideLablelProp >= config.insideLabelVisibilityFraction;
          if (!label.shouldBeVisible && slice !== this.scene.hoverSlice && !label.userPlaced) {
            label.visible = false;
          }
        } else {
          slice.currentInsideLabel = null;
        }
        text = slice.label && labelsEnabled ? slice.label : "";
        if (config.insideLabel === "append" && slice.insideLabel && labelsEnabled && !slice.currentInsideLabel.userPlaced && !slice.currentInsideLabel.shouldBeVisible) {
          if (text) {
            x = Math.cos(am);
            if (x > 0) {
              text = slice.insideLabel + ", " + text;
            } else {
              text = text + ", " + slice.insideLabel;
            }
          } else {
            text = slice.insideLabel;
          }
        }
        if (text) {
          label = null;
          if (!slice.currentLabel) {
            label = slice.currentLabel = new Base_Label();
          } else {
            label = slice.currentLabel;
          }
          if (slice.currentLabel.text !== text) {
            label.text = text;
            label.measureDone = false;
          }
          if (!label.userPlaced) {
            outsideLabelLayout.placeOutsideLabelInitial(label, am);
          }
          if (label.x > 0) {
            label.align = "left";
            rightOutsideLabels.push(label);
          } else {
            label.align = "right";
            leftOutsideLabels.push(label);
          }
        } else {
          slice.currentLabel = null;
        }
      } else {
        slice.currentLabel = null;
        slice.currentInsideLabel = null;
      }
      icon = null;
      if (slice.icon && (!pie.background || slice.id === pie.activeSliceId)) {
        _ref2 = insideLabelLayout.fitBoxInSlice(1, 1, r0, r1, a0, a1), x = _ref2[0], y = _ref2[1], iconSize = _ref2[2];
        iconSize -= margin;
        if (!iconAutohide || iconSize * 2 >= iconMinSize) {
          iconSize = Math.max(Math.min(iconSize, iconMaxSize / 2), iconMinSize / 2);
          icon = new Piechart_Icon();
          icon.hwidth = iconSize;
          icon.hheight = iconSize;
          icon.inside = true;
          if (slice.iconOffset) {
            icon.x = 0;
            icon.y = 0;
            this.applyOffset(icon, slice.iconOffset, r0, r1, a0, a1);
          } else if (iconPlacement === "center") {
            icon.x = 0;
            icon.y = 0;
            this.applyOffset(icon, [0, 0, 0, 0], r0, r1, a0, a1);
          } else {
            icon.x = x;
            icon.y = y;
          }
        } else {

        }
      }
      slice.currentIcon = icon;
    }
    return outsideLabelLayout.computeOutsideLabelLocations(leftOutsideLabels, rightOutsideLabels);
  };

  Piechart_PieLayout.prototype.applyOffset = function(item, offset, r0, r1, a0, a1) {
    var dx, dy, oa, oc, offsetAngle, offsetCenter;
    if (offset.length >= 2) {
      dx = offset[0];
      dy = offset[1];
    }
    if (offset.length >= 4) {
      oc = offset[2];
      oa = offset[3];
    } else {
      oc = 0;
      oa = 0;
    }
    offsetCenter = r0 + (r1 - r0) * (oc + 1) / 2;
    offsetAngle = a0 + (a1 - a0) * (oa + 1) / 2;
    dx += Math.cos(offsetAngle) * offsetCenter;
    dy += Math.sin(offsetAngle) * offsetCenter;
    item.x += dx;
    return item.y += dy;
  };

  return Piechart_PieLayout;

})();

Piechart_LabelLayout = (function(_super) {
  __extends(Piechart_LabelLayout, _super);

  function Piechart_LabelLayout(g, r1, left, right, top, bottom, labelStyle, config) {
    this.left = left;
    this.right = right;
    this.top = top;
    this.bottom = bottom;
    this.config = config;
    Piechart_LabelLayout.__super__.constructor.call(this, g, labelStyle);
    this.rr = r1 + config.connectorLength;
    this.interLabelSpacing = Math.max(config.interLabelSpacing * this.lineHeight, this.margin);
  }

  Piechart_LabelLayout.prototype.placeOutsideLabelInitial = function(label, angle) {
    var shortenProp, x, y;
    x = this.rr * Math.cos(angle);
    y = this.rr * Math.sin(angle);
    shortenProp = 1;
    if (y < this.top) {
      shortenProp = Math.min(shortenProp, this.top / y);
    }
    if (y > this.bottom) {
      shortenProp = Math.min(shortenProp, this.bottom / y);
    }
    if (x < this.left) {
      shortenProp = Math.min(shortenProp, this.left / x);
    }
    if (x > this.right) {
      shortenProp = Math.min(shortenProp, this.right / x);
    }
    label.x = x * shortenProp;
    return label.y = y * shortenProp;
  };

  Piechart_LabelLayout.prototype.computeOutsideLabelLocations = function(leftLabels, rightLabels) {
    var alignVariants, aligned, bottom, h, hasMultiline, height, label, labelBottom, labelSpacing, labelTop, labels, maxHeight, prop, top, visibleLabels, worstProp, _i, _j, _k, _l, _len, _len1, _len2, _len3, _len4, _len5, _len6, _m, _n, _o, _ref, _ref1, _results;
    bottom = this.bottom - this.margin;
    top = this.top + this.margin;
    labelSpacing = this.interLabelSpacing;
    leftLabels.sort(function(a, b) {
      return b.y - a.y;
    });
    rightLabels.sort(function(a, b) {
      return a.y - b.y;
    });
    for (_i = 0, _len = leftLabels.length; _i < _len; _i++) {
      label = leftLabels[_i];
      label.originX = label.x;
    }
    for (_j = 0, _len1 = rightLabels.length; _j < _len1; _j++) {
      label = rightLabels[_j];
      label.originX = label.x;
    }
    alignVariants = this.config.placement === "wrap" ? [false] : [true, false];
    _results = [];
    for (_k = 0, _len2 = alignVariants.length; _k < _len2; _k++) {
      aligned = alignVariants[_k];
      worstProp = 100;
      hasMultiline = false;
      _ref = [leftLabels, rightLabels];
      for (_l = 0, _len3 = _ref.length; _l < _len3; _l++) {
        labels = _ref[_l];
        for (_m = 0, _len4 = labels.length; _m < _len4; _m++) {
          label = labels[_m];
          label.prop = this.fitLabelOutside(label, aligned);
        }
        maxHeight = bottom - top;
        visibleLabels = [];
        height = 0;
        for (_n = 0, _len5 = labels.length; _n < _len5; _n++) {
          label = labels[_n];
          if (label.visible) {
            h = label.hheight * 2 + labelSpacing;
            if (height + h < maxHeight) {
              visibleLabels.push(label);
              height += h;
            } else {
              label.visible = label.userPlaced;
              worstProp = 0.5;
            }
          }
        }
        labelBottom = bottom;
        labelTop = top;
        if (labels === leftLabels) {
          labelTop += height;
        } else {
          labelBottom -= height;
        }
        for (_o = 0, _len6 = visibleLabels.length; _o < _len6; _o++) {
          label = visibleLabels[_o];
          if (labels === leftLabels) {
            labelTop -= label.hheight * 2 + labelSpacing;
          } else {
            labelBottom += label.hheight * 2 + labelSpacing;
          }
          if (!label.userPlaced && (label.y + label.hheight > labelBottom || label.y - label.hheight < labelTop)) {
            label.y = Math.min(Math.max(label.y, labelTop + label.hheight), labelBottom - label.hheight);
            prop = this.fitLabelOutside(label, aligned);
            worstProp = Math.min(prop, worstProp);
            hasMultiline || (hasMultiline = ((_ref1 = label.rows) != null ? _ref1[0][label.rows[0].length - 1].row : void 0) > 0);
          } else {
            worstProp = Math.min(worstProp, label.prop);
          }
          if (labels === leftLabels) {
            labelBottom = label.y - label.hheight - labelSpacing;
          } else {
            labelTop = label.y + label.hheight + labelSpacing;
          }
        }
      }
      if (worstProp >= 1 || !hasMultiline) {
        break;
      } else {
        _results.push(void 0);
      }
    }
    return _results;
  };

  Piechart_LabelLayout.prototype.fitLabelOutside = function(label, aligned) {
    var locationFunc;
    if (aligned == null) {
      aligned = false;
    }
    locationFunc = (function(_this) {
      return function(hheight) {
        if (label.userPlaced) {
          return _this.getOutsideMaxWidth(label.x, label.y, hheight, false);
        } else {
          return _this.placeOutsideMaxWidth(label.originX, label.y, hheight, aligned);
        }
      };
    })(this);
    return this.fitLabelInRect(label, label.align, label.align, locationFunc);
  };

  Piechart_LabelLayout.prototype.fitLabelInSlice = function(label, r0, r1, a0, a1) {
    var a, am, b, bottom, cosa, left, noSpaceAlign, right, rm, rprop, sina, sliceLocationFunc, top, x, y;
    a = Math.cos(a0);
    b = Math.cos(a1);
    left = Math.min(a, b);
    right = Math.max(a, b);
    if ((left < 0 && right < 0) || -left > right * 2) {
      noSpaceAlign = "right";
    } else if ((left > 0 && right > 0) || -left * 2 < right) {
      noSpaceAlign = "left";
    } else {
      noSpaceAlign = "center";
    }
    if (label.userPlaced) {
      x = label.x;
      y = label.y;
    } else {
      if (r0 * 2 >= r1) {
        rprop = 0.5;
      } else {
        rprop = 0.5 + (r1 - r0 * 2) / r1 / 4;
      }
      rm = r0 + (r1 - r0) * rprop;
      am = (a0 + a1) / 2;
      cosa = Math.cos(am);
      sina = Math.sin(am);
      x = rm * cosa;
      y = rm * sina;
    }
    top = y - this.rayIntersectsSlice(x, y, 0, -1, r0, r1, a0, a1);
    bottom = y + this.rayIntersectsSlice(x, y, 0, 1, r0, r1, a0, a1);
    sliceLocationFunc = (function(_this) {
      return function(xx, yy) {
        var le, ri;
        if (!(r1 > 0) || yy <= top || yy >= bottom) {
          return [1e-5, 1e-5];
        }
        le = _this.rayIntersectsSlice(xx, yy, -1, 0, r0, r1, a0, a1);
        ri = _this.rayIntersectsSlice(xx, yy, 1, 0, r0, r1, a0, a1);
        return [le, ri];
      };
    })(this);
    return this.fitLabelInLines(label, x, y, "center", noSpaceAlign, sliceLocationFunc);
  };

  Piechart_LabelLayout.prototype.placeOutsideMaxWidth = function(x, y, hheight, aligned) {
    var diff, distanceFromCenter, lbottom, lleft, lright, ltop, radius;
    radius = this.rr;
    ltop = y - hheight / 2;
    lbottom = ltop + hheight;
    if (ltop < this.top) {
      diff = this.top - ltop;
      ltop += diff;
      lbottom += diff;
    }
    if (lbottom > this.bottom) {
      diff = this.bottom - lbottom;
      ltop += diff;
      lbottom += diff;
    }
    lleft = this.left;
    lright = this.right;
    if (aligned) {
      distanceFromCenter = radius;
    } else {
      if (ltop > radius || lbottom < -radius) {
        distanceFromCenter = 0;
      } else if (ltop > 0) {
        distanceFromCenter = Math.sqrt(radius * radius - ltop * ltop);
      } else if (lbottom < 0) {
        distanceFromCenter = Math.sqrt(radius * radius - lbottom * lbottom);
      } else {
        distanceFromCenter = radius;
      }
    }
    if (x > 0) {
      lleft = Math.max(distanceFromCenter, x);
    } else {
      lright = Math.min(x, -distanceFromCenter);
    }
    return [(lleft + lright) / 2, (ltop + lbottom) / 2, 1, 0, lright - lleft];
  };

  Piechart_LabelLayout.prototype.getOutsideMaxWidth = function(x, y, hheight, aligned) {
    var dist, distanceFromCenter, lbottom, lleft, lright, ltop, radius;
    ltop = y - hheight / 2;
    lbottom = ltop + hheight;
    lleft = this.left;
    lright = this.right;
    radius = this.rr;
    if (aligned) {
      distanceFromCenter = radius;
    } else {
      if (ltop > radius || lbottom < -radius) {
        distanceFromCenter = 0;
      } else if (ltop > 0) {
        distanceFromCenter = Math.sqrt(radius * radius - ltop * ltop);
      } else if (lbottom < 0) {
        distanceFromCenter = Math.sqrt(radius * radius - lbottom * lbottom);
      } else {
        distanceFromCenter = radius;
      }
    }
    if (x > 0) {
      lleft = distanceFromCenter;
    } else {
      lright = -distanceFromCenter;
    }
    dist = Math.min(Math.abs(x - lleft), Math.abs(x - lright));
    return [x, y, 1, 0, dist * 2];
  };

  Piechart_LabelLayout.prototype.fitBoxInSlice = function(hwidth, hheight, r0, r1, a0, a1) {
    var am, cosa, d0, d1, d2, d3, dx, dy, prop, rm, rprop, sina, x, y;
    rprop = 0.5 + (r1 - r0) / r1 / 4;
    rm = r0 + (r1 - r0) * rprop;
    am = (a0 + a1) / 2;
    cosa = Math.cos(am);
    sina = Math.sin(am);
    x = rm * cosa;
    y = rm * sina;
    dx = hwidth;
    dy = hheight;
    d0 = this.rayIntersectsSlice(x, y, dx, dy, r0, r1, a0, a1);
    d1 = this.rayIntersectsSlice(x, y, -dx, dy, r0, r1, a0, a1);
    d2 = this.rayIntersectsSlice(x, y, -dx, -dy, r0, r1, a0, a1);
    d3 = this.rayIntersectsSlice(x, y, dx, -dy, r0, r1, a0, a1);
    prop = Math.min(d0, d1, d2, d3);
    return [x, y, prop];
  };

  Piechart_LabelLayout.prototype.rayIntersectsSlice = function(x0, y0, dx, dy, r0, r1, a0, a1) {
    var cosa, d, sina;
    d = Base_Geometry.rayIntersectsCircle(x0, y0, dx, dy, r0);
    d = Math.min(d, Base_Geometry.rayIntersectsCircle(x0, y0, dx, dy, r1));
    cosa = Math.cos(a0);
    sina = Math.sin(a0);
    d = Math.min(d, Base_Geometry.rayIntersectsLine(x0, y0, dx, dy, r0 * cosa, r0 * sina, r1 * cosa, r1 * sina));
    cosa = Math.cos(a1);
    sina = Math.sin(a1);
    d = Math.min(d, Base_Geometry.rayIntersectsLine(x0, y0, dx, dy, r0 * cosa, r0 * sina, r1 * cosa, r1 * sina));
    return d;
  };

  return Piechart_LabelLayout;

})(Base_LabelLayoutBase);
// Generated by CoffeeScript 1.8.0
var Piechart_PieRenderer;

Piechart_PieRenderer = (function() {
  "use strict";
  function Piechart_PieRenderer(chart) {
    this.chart = chart;
    this.settings = chart.settings;
    this.scene = chart.scene;
    this.events = chart.events;
  }

  Piechart_PieRenderer.prototype.onSceneChange = function(event) {
    if (event.changes.settings) {
      return this.buildSeries();
    }
  };

  Piechart_PieRenderer.prototype.buildSeries = function() {
    var c, e, theme;
    theme = this.settings.pie.theme;
    c = "PieChart_Renderer_" + theme.charAt(0).toUpperCase() + theme.slice(1);
    try {
      return eval("this.renderer = new " + c + "(this);");
    } catch (_error) {
      e = _error;
      throw "Renderer " + theme + " is not available: " + e;
    }
  };

  Piechart_PieRenderer.prototype.paintScene = function(event) {
    var g, innerPies, labelRenderer, pie, pieindex, _i, _len, _ref;
    g = event.context;
    labelRenderer = event.labelRenderer;
    innerPies = event["export"] ? this.settings.pie.showInnerPiesExport : this.settings.pie.showInnerPies;
    _ref = this.scene.pies;
    for (pieindex = _i = 0, _len = _ref.length; _i < _len; pieindex = ++_i) {
      pie = _ref[pieindex];
      if (innerPies || !pie.background) {
        this.paintPie(g, labelRenderer, pie);
      }
    }
    if (Base_Helpers.arrayContains(this.scene.pies, this.scene.hoverPie) || this.scene.settings.advanced.backAlwaysVisible) {
      this.paintBackArrow(event);
    }
  };

  Piechart_PieRenderer.prototype.paintBackArrow = function(event) {
    var depth, g, heightProportion, ihh, ihw, img, invsq2, phs, topPie, widthProportion, x, y, zoom;
    if (!(!event["export"] && this.scene.pies.length > 1)) {
      return;
    }
    img = this.scene.settings.getAssetImage(this.scene.settings.advanced.backImage);
    if (!(img && img.width)) {
      return;
    }
    topPie = this.scene.pies[this.scene.pies.length - 1];
    invsq2 = 0.707106781186547;
    x = topPie.x;
    y = topPie.y;
    depth = this.settings.pie.depth;
    y += (this.scene.pies.length - 1) * depth;
    ihw = img.width / 2;
    ihh = img.height / 2;
    phs = topPie.innerRadius * invsq2;
    widthProportion = Math.min(ihw, Math.max(phs, ihw / 2)) / ihw;
    heightProportion = Math.min(ihh, Math.max(phs, ihh / 2)) / ihh;
    zoom = Math.min(widthProportion, heightProportion);
    g = event.context;
    g.globalAlpha = 0.5;
    g.drawImage(img, x - ihw * zoom, y - ihh * zoom, ihw * 2 * zoom, ihh * 2 * zoom);
    return g.globalAlpha = 1;
  };

  Piechart_PieRenderer.prototype.paintPie = function(g, labelRenderer, pie) {
    var a0, a1, aR1, add, am, angle, angle1, angleDiff, backgroundStyle, end, h, icon, img, innerAngleLeft, innerAngleRight, insideTextStyle, isActive, m, mul, outerAngleLeft, outerAngleRight, pxToAngleR0, pxToAngleR1, r0, r1, rl, slice, sliceAngle, slicesToPaint, spacing, spacingAngleR0, spacingAngleR1, sr0, sr1, start, textStyle, w, x, xx, y, yy, _i, _j, _k, _l, _len, _len1, _len2, _len3, _ref, _ref1, _ref2, _results;
    spacing = this.settings.slice.margin;
    x = pie.x;
    y = pie.y;
    add = this.scene.currentInnerRadius;
    mul = this.scene.currentRadius - add;
    r0 = Math.max(pie.currentInnerRadius * mul + add, spacing / 2);
    r1 = pie.currentRadius * mul + add;
    start = pie.currentStartAngle;
    end = pie.currentEndAngle;
    angleDiff = end - start;
    angle1 = start + pie.scrollOffset * angleDiff;
    if (!(r1 > 0 && angleDiff > 0)) {
      return;
    }
    pxToAngleR0 = r0 > 0 ? 1 / r0 : 0;
    pxToAngleR1 = 1 / r1;
    spacingAngleR0 = spacing / 2 * pxToAngleR0;
    spacingAngleR1 = spacing / 2 * pxToAngleR1;
    slicesToPaint = [];
    _ref = pie.allSlices;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      slice = _ref[_i];
      sliceAngle = slice.currentFraction * angleDiff;
      if (!(sliceAngle > 0)) {
        continue;
      }
      angle = angle1;
      angle1 += sliceAngle;
      sr0 = r0 + slice.currentCutoutDistance;
      sr1 = r1 + slice.currentCutoutDistance;
      if (sliceAngle <= spacingAngleR1 * 4) {
        m = (angle + angle1) / 2;
        aR1 = sliceAngle / 4;
        outerAngleLeft = m - aR1;
        outerAngleRight = m + aR1;
      } else {
        outerAngleLeft = angle + spacingAngleR1;
        outerAngleRight = angle1 - spacingAngleR1;
      }
      innerAngleLeft = angle + spacingAngleR0;
      innerAngleRight = angle1 - spacingAngleR0;
      if (innerAngleLeft > innerAngleRight) {
        innerAngleLeft = innerAngleRight = (innerAngleLeft + innerAngleRight) / 2;
      }
      if (outerAngleRight < start || outerAngleLeft > end) {
        continue;
      }
      outerAngleLeft = Math.max(outerAngleLeft, start);
      outerAngleRight = Math.min(outerAngleRight, end);
      innerAngleLeft = Math.max(innerAngleLeft, start);
      innerAngleRight = Math.min(innerAngleRight, end);
      if (innerAngleLeft > innerAngleRight) {
        innerAngleLeft = innerAngleRight = (innerAngleLeft + innerAngleRight) / 2;
      }
      slice.renderParams = [sr0, sr1, outerAngleLeft, outerAngleRight, innerAngleLeft, innerAngleRight];
      slice.fillColor_b = slice.fillColor;
      slice.lineColor_b = slice.lineColor;
      slice.fillColor = slice.currentFillColor;
      slice.lineColor = slice.currentLineColor;
      slicesToPaint.push(slice);
    }
    x = pie.x;
    y = pie.y;
    this.renderer.paintPie(g, x, y, r0, r1, pie.currentStartAngle, pie.currentEndAngle, pie);
    this.renderer.paintSlices(g, x, y, slicesToPaint);
    if (pie === this.scene.peek()) {
      this.renderer.paintExpandableHilights(g, x, y, slicesToPaint);
    }
    for (_j = 0, _len1 = slicesToPaint.length; _j < _len1; _j++) {
      slice = slicesToPaint[_j];
      slice.fillColor = slice.fillColor_b;
      slice.lineColor = slice.lineColor_b;
    }
    if (!pie.removed) {
      Base_Graphics.clearShadow(g);
      _ref1 = pie.allSlices;
      for (_k = 0, _len2 = _ref1.length; _k < _len2; _k++) {
        slice = _ref1[_k];
        if (slice.currentIcon) {
          img = this.scene.settings.getAssetImage(slice.icon);
          if (img) {
            icon = slice.currentIcon;
            xx = x + icon.x;
            yy = y + icon.y;
            w = Math.min(img.width / 2, icon.hwidth);
            h = Math.min(img.height / 2, icon.hheight);
            g.drawImage(img, xx - w, yy - h, w * 2, h * 2);
          }
        }
      }
      textStyle = this.settings.labels.textStyle;
      insideTextStyle = this.settings.labels.insideTextStyle;
      backgroundStyle = this.settings.labels.backgroundStyle;
      angle1 = start + pie.scrollOffset * angleDiff;
      _ref2 = pie.allSlices;
      _results = [];
      for (_l = 0, _len3 = _ref2.length; _l < _len3; _l++) {
        slice = _ref2[_l];
        sliceAngle = slice.currentFraction * angleDiff;
        angle = angle1;
        angle1 = angle + sliceAngle;
        a0 = Math.max(angle, start);
        a1 = Math.min(angle1, end);
        am = (a0 + a1) / 2;
        isActive = slice === this.scene.hoverSlice;
        rl = r1 + slice.currentCutoutDistance;
        if (slice.currentInsideLabel && slice.currentInsideLabel.visible) {
          slice.currentInsideLabel.id = null;
          this.paintLabel(g, labelRenderer, x, y, rl, am, slice.currentInsideLabel, slice.insideLabelStyle, isActive);
        }
        if (slice.currentLabel && slice.currentLabel.visible) {
          slice.currentLabel.id = null;
          _results.push(this.paintLabel(g, labelRenderer, x, y, rl, am, slice.currentLabel, slice.labelStyle, isActive));
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    }
  };

  Piechart_PieRenderer.prototype.paintLabel = function(g, labelRenderer, x, y, r1, angleM, label, labelStyle, active) {
    var a, bottom, conStyle, cosa, da, hh, labelConfig, r15, r2, sina, t, top, touchAngle, width, ww, x0, x1, x1a, x2, x2p, xc, xx, y0, y1, y1a, y2, y2p, yc, yy;
    top = this.scene.y0 + 3;
    bottom = top + this.scene.height - 6;
    labelConfig = this.settings.labels;
    xx = label.x;
    yy = label.y;
    ww = label.hwidth;
    hh = label.hheight;
    r2 = r1 + labelConfig.connectorLength;
    if (xx + ww < 0) {
      x2 = xx + ww;
      y2 = yy;
    } else if (xx + ww >= 0) {
      x2 = xx - ww;
      y2 = yy;
    } else {
      x2 = xx;
      if (yy > 0) {
        y2 = yy - hh;
      } else {
        y2 = yy + hh;
      }
    }
    if (labelConfig.connectors && x2 * x2 + y2 * y2 > r1 * r1) {
      sina = Math.sin(angleM);
      cosa = Math.cos(angleM);
      g.beginPath();
      x0 = x + r1 * cosa;
      y0 = y + r1 * sina;
      g.moveTo(x0, y0);
      x1 = x + r2 * cosa;
      y1 = y + r2 * sina;
      y1 = Math.min(Math.max(y1, top), bottom);
      x2 += x;
      y2 += y;
      y2 = Math.min(Math.max(y2, top), bottom);
      r15 = (r1 + r2) / 2;
      t = Base_Geometry.rayIntersectsCircle(x2 - x, y2 - y, x0 - x2, y0 - y2, r1);
      a = Base_Geometry.lineTouchingCircle(x2 - x, y2 - y, x1 - x, y1 - y, r2);
      if (t < 0.9 && a) {
        xc = a[0], yc = a[1];
        touchAngle = Math.atan2(yc, xc);
        while (touchAngle - angleM > Math.PI) {
          touchAngle -= Math.PI * 2;
        }
        while (touchAngle - angleM < -Math.PI) {
          touchAngle += Math.PI * 2;
        }
        da = touchAngle - angleM;
        xc += x;
        yc += y;
        x1 = x + r15 * cosa;
        y1 = y + r15 * sina;
        y1 = Math.min(Math.max(y1, top), bottom);
        x1a = x + r15 * Math.cos(angleM + da * 0.2);
        y1a = y + r15 * Math.sin(angleM + da * 0.2);
        y1a = Math.min(Math.max(y1a, top), bottom);
        g.quadraticCurveTo(x1, y1, x1a, y1a);
        x2p = x + r2 * Math.cos(touchAngle);
        y2p = y + r2 * Math.sin(touchAngle);
        y2p = Math.min(Math.max(y2p, top), bottom);
        Base_Graphics.arcBetweenTwoPoints(g, x, y, r15, x1a, y1a, x2p, y2p);
        g.lineTo(x2, y2);
      } else {
        g.quadraticCurveTo(x1, y1, x2, y2);
      }
      conStyle = this.settings.slice.connectorStyle;
      width = conStyle.lineWidth;
      if (active) {
        conStyle.lineWidth += 2;
      }
      Base_Graphics.stroke(g, conStyle);
      conStyle.lineWidth = width;
    }
    labelRenderer.paintWithStyle(g, x + label.x, y + label.y, 1, label, labelStyle);
    return Base_Graphics.clearShadow(g);
  };

  return Piechart_PieRenderer;

})();
// Generated by CoffeeScript 1.8.0
var Piechart_PieBuilder;

Piechart_PieBuilder = (function() {
  "use strict";
  function Piechart_PieBuilder(chart) {
    this.chart = chart;
    this.scene = chart.scene;
    this.loading = false;
  }

  Piechart_PieBuilder.prototype.updatePie = function(pie) {
    var data, newSlices, numberOfSlices, others, previous, ready, _ref, _ref1;
    data = this.getPieData(pie);
    _ref = this.getForwardCount(pie.id, data, pie.offset), numberOfSlices = _ref[0], ready = _ref[1];
    pie.data = data;
    pie.loading = !ready;
    if (ready) {
      _ref1 = this.buildSlices(pie, pie.offset, numberOfSlices), newSlices = _ref1[0], others = _ref1[1], previous = _ref1[2];
      this.applyNewSlices(pie, newSlices, others, previous);
    }
    return ready;
  };

  Piechart_PieBuilder.prototype.scrollForward = function(pie, newOffset) {
    var data, newOthers, newPrevious, newSlices, newSlicesStartPos, numberOfSlices, ready, _ref, _ref1, _ref2;
    data = this.getPieData(pie);
    pie.data = data;
    ready = true;
    if (newOffset == null) {
      _ref = this.getForwardCount(pie.id, data, pie.offset), numberOfSlices = _ref[0], ready = _ref[1];
      newOffset = pie.offset + numberOfSlices;
    }
    if (ready) {
      _ref1 = this.getForwardCount(pie.id, data, newOffset), numberOfSlices = _ref1[0], ready = _ref1[1];
    }
    if (!ready) {
      pie.loading = true;
      return false;
    } else {
      _ref2 = this.buildSlices(pie, newOffset, numberOfSlices), newSlices = _ref2[0], newOthers = _ref2[1], newPrevious = _ref2[2];
      if (pie.othersSlice) {
        newSlicesStartPos = Math.min(newSlices.length, Math.max(0, (pie.offset + pie.count) - newOffset));
        this.fitSlicesInOrigin(pie.othersSlice, newSlices.slice(newSlicesStartPos), newOthers);
        if (!newOthers) {
          newOthers = pie.othersSlice;
          newOthers.fraction = 0;
          newOthers.currentFraction = 0;
          newOthers.removed = true;
        }
      }
      pie.offset = newOffset;
      this.applyNewSlices(pie, newSlices, newOthers, newPrevious);
      pie.loading = false;
      return true;
    }
  };

  Piechart_PieBuilder.prototype.scrollBackward = function(pie, newOffset) {
    var data, newOthers, newPrevious, newSlices, newSlicesEndPos, numberOfSlices, ready, _ref, _ref1, _ref2;
    data = this.getPieData(pie);
    pie.data = data;
    ready = true;
    if (newOffset == null) {
      _ref = this.getBackOffset(pie.id, data, pie.offset), newOffset = _ref[0], ready = _ref[1];
    }
    if (ready) {
      _ref1 = this.getForwardCount(pie.id, data, newOffset), numberOfSlices = _ref1[0], ready = _ref1[1];
    }
    if (!ready) {
      pie.loading = true;
      return false;
    } else {
      _ref2 = this.buildSlices(pie, newOffset, numberOfSlices), newSlices = _ref2[0], newOthers = _ref2[1], newPrevious = _ref2[2];
      if (pie.previousSlice) {
        newSlicesEndPos = Math.min(newSlices.length, Math.max(0, pie.offset - newOffset));
        this.fitSlicesInOrigin(pie.previousSlice, newSlices.slice(0, newSlicesEndPos), newPrevious);
        if (!newPrevious) {
          newPrevious = pie.previousSlice;
          newPrevious.fraction = 0;
          newPrevious.currentFraction = 0;
          newPrevious.removed = true;
        }
      }
      pie.offset = newOffset;
      this.applyNewSlices(pie, newSlices, newOthers, newPrevious);
      pie.loading = false;
      return true;
    }
  };

  Piechart_PieBuilder.prototype.fitSlicesInOrigin = function(origin, slices, extraSlice) {
    var compression, originFraction, slice, targetFraction, _i, _j, _len, _len1;
    originFraction = Math.max(1e-6, origin.currentFraction);
    targetFraction = 0;
    for (_i = 0, _len = slices.length; _i < _len; _i++) {
      slice = slices[_i];
      targetFraction += slice.fraction;
    }
    if (extraSlice) {
      targetFraction += extraSlice.fraction;
    }
    compression = originFraction / targetFraction;
    for (_j = 0, _len1 = slices.length; _j < _len1; _j++) {
      slice = slices[_j];
      slice.currentFraction = slice.fraction * compression;
      slice.currentFillColor = origin.currentFillColor;
      slice.currentLineColor = origin.currentLineColor;
    }
    if (extraSlice) {
      extraSlice.currentFraction = extraSlice.fraction * compression;
      extraSlice.currentFillColor = origin.currentFillColor;
      extraSlice.currentLineColor = origin.currentLineColor;
    }
  };

  Piechart_PieBuilder.prototype.getForwardCount = function(id, data, offset) {
    var count, dataEnd, dataStart, full, i, maxOthers, maxSlices, minSlice, othersRealFraction, othersS, othersSum, othersVisibleFraction, sliceFraction, slicesSum, val, _i, _ref;
    if (!data || (data.offset > offset) || (data.offset + data.values.length <= offset)) {
      if (!data || !data.done || data.offset > offset) {
        this.scene.mainData.requestPieData(id, offset);
        return [0, false];
      } else {
        return [0, true];
      }
    }
    dataStart = data.offset;
    dataEnd = dataStart + data.values.length;
    othersS = this.scene.settings.interaction.others;
    if (!othersS.enabled) {
      if (!data.done) {
        this.scene.mainData.requestMorePieData(id);
      }
      return [Math.max(dataEnd - offset, 0), data.done];
    }
    othersSum = data.afterFraction;
    for (i = _i = offset, _ref = dataEnd - 1; _i <= _ref; i = _i += 1) {
      othersSum += data.values[i - dataStart].fraction;
    }
    minSlice = othersS.minSliceFraction;
    maxOthers = othersS.maxOthersFraction;
    maxSlices = othersS.maxSlicesVisible;
    count = 0;
    slicesSum = 0;
    full = data.done;
    while (count + offset < dataEnd) {
      count++;
      val = data.values[offset + count - dataStart - 1].fraction;
      slicesSum += val;
      othersSum -= val;
      othersRealFraction = othersSum / (othersSum + slicesSum);
      othersVisibleFraction = Math.min(othersRealFraction, maxOthers);
      sliceFraction = val / slicesSum * (1 - othersVisibleFraction);
      if (count > maxSlices || sliceFraction < minSlice) {
        if (data.done && count + offset !== dataEnd) {
          count--;
        }
        full = true;
        break;
      }
    }
    if (!full) {
      this.scene.mainData.requestMorePieData(id);
    }
    return [count, full];
  };

  Piechart_PieBuilder.prototype.getBackOffset = function(id, data, othersOffset) {
    var count, dataEnd, dataStart, full, i, maxOthers, maxSlices, minSlice, othersFraction, othersS, othersSum, pos, slicesSum, smallestSliceFraction, smallestValue, val, _i, _ref;
    if (!data || (data.offset >= othersOffset) || (!data.done && data.offset + data.values.length < othersOffset)) {
      this.scene.mainData.requestPieData(id, Math.max(0, othersOffset - this.scene.mainData.dataSettings.itemsToLoad), this.scene.mainData.dataSettings.itemsToLoad);
      return [0, false];
    }
    if (data.done && othersOffset > data.offset + data.values.length) {
      othersOffset = data.offset + data.values.length;
    }
    if (othersOffset === 0) {
      return [0, true];
    }
    othersS = this.scene.settings.interaction.others;
    dataStart = data.offset;
    dataEnd = dataStart + data.values.length;
    othersSum = data.afterFraction;
    for (i = _i = othersOffset, _ref = dataEnd - 1; _i <= _ref; i = _i += 1) {
      othersSum += data.values[i - dataStart].fraction;
    }
    minSlice = othersS.minSliceFraction;
    maxOthers = othersS.maxOthersFraction;
    maxSlices = othersS.maxSlicesVisible;
    pos = othersOffset;
    smallestValue = data.values[othersOffset - dataStart - 1].fraction;
    slicesSum = 0;
    full = data.offset === 0;
    while (pos > data.offset) {
      pos--;
      count = othersOffset - pos;
      val = data.values[pos - dataStart].fraction;
      slicesSum += val;
      othersFraction = Math.min(othersSum / (othersSum + slicesSum), maxOthers);
      smallestSliceFraction = smallestValue / slicesSum * (1 - othersFraction);
      if (pos === 0 || count > maxSlices || smallestSliceFraction < minSlice) {
        if (pos !== 0) {
          pos++;
        }
        full = true;
        break;
      }
    }
    if (!full) {
      this.scene.mainData.requestLessPieData(id);
    }
    return [pos, full];
  };

  Piechart_PieBuilder.prototype.buildSlices = function(pie, offset, count) {
    var data, ff, fractionCompress, fractionInMin, i, minFraction, othersFraction, othersSettings, othersSlice, othersVal, prevMinSlices, prevValue, previousFraction, previousSlice, s, slice, slices, slicesFraction, slicesInMin, _i, _j, _k, _l, _len, _len1, _len2, _len3, _m, _n, _o, _ref, _ref1, _ref2, _ref3, _ref4;
    data = pie.data;
    if (!data) {
      throw "Internal error";
    }
    slicesFraction = 0;
    slices = [];
    for (i = _i = offset, _ref = offset + count - 1; _i <= _ref; i = _i += 1) {
      s = new Piechart_Slice(pie, i);
      s.data = data.values[i - data.offset];
      s.id = s.data.__id;
      slicesFraction += s.data.fraction;
      slices.push(s);
    }
    othersSettings = this.scene.settings.interaction.others;
    othersFraction = data.afterFraction;
    othersVal = data.afterSum;
    for (i = _j = _ref1 = offset + count, _ref2 = data.offset + data.values.length - 1; _j <= _ref2; i = _j += 1) {
      othersVal += data.values[i - data.offset].value;
      othersFraction += data.values[i - data.offset].fraction;
    }
    if (othersFraction > 0) {
      othersSlice = new Piechart_Slice(pie, Infinity);
      othersSlice.data = {
        value: othersVal,
        fraction: othersFraction,
        name: this.scene.settings.localization.othersLabel
      };
    } else {
      othersSlice = null;
    }
    previousSlice = null;
    previousFraction = 0;
    if (offset > 0) {
      prevValue = data.beforeSum;
      for (i = _k = _ref3 = data.offset, _ref4 = Math.min(offset, data.offset + data.values.length) - 1; _k <= _ref4; i = _k += 1) {
        prevValue += Math.abs(data.values[i - data.offset].value);
      }
      previousSlice = new Piechart_Slice(pie, -1);
      previousFraction = othersSettings.navigationFraction;
      previousSlice.data = {
        value: prevValue,
        name: this.scene.settings.localization.previousLabel
      };
      previousSlice.fraction = previousFraction;
    }
    fractionCompress = (1 - previousFraction) / (slicesFraction + othersFraction);
    othersFraction = othersFraction * fractionCompress;
    if (offset > 0 || othersFraction > othersSettings.maxOthersFraction) {
      othersFraction = Math.min(othersFraction, othersSettings.navigationFraction);
    }
    if (othersSlice) {
      othersSlice.fraction = othersFraction;
    }
    fractionCompress = (1 - previousFraction - othersFraction) / slicesFraction;
    slicesFraction = 1 - previousFraction - othersFraction;
    for (_l = 0, _len = slices.length; _l < _len; _l++) {
      slice = slices[_l];
      slice.fraction = slice.data.fraction * fractionCompress;
    }
    minFraction = this.scene.settings.slice.minFraction;
    if (minFraction > 0) {
      prevMinSlices = 0;
      while (true) {
        slicesInMin = 0;
        fractionInMin = 0;
        for (_m = 0, _len1 = slices.length; _m < _len1; _m++) {
          slice = slices[_m];
          if (slice.fraction <= minFraction) {
            slicesInMin += 1;
            fractionInMin += slice.fraction;
          }
        }
        if (slicesInMin === slices.length) {
          ff = slicesFraction / slices.length;
          for (_n = 0, _len2 = slices.length; _n < _len2; _n++) {
            slice = slices[_n];
            slice.fraction = ff;
          }
          break;
        } else {
          fractionCompress = (slicesFraction - (slicesInMin * minFraction)) / (slicesFraction - fractionInMin);
          for (_o = 0, _len3 = slices.length; _o < _len3; _o++) {
            slice = slices[_o];
            if (slice.fraction <= minFraction) {
              slice.fraction = minFraction;
            } else {
              slice.fraction = slice.fraction * fractionCompress;
            }
          }
          if (slicesInMin === prevMinSlices) {
            break;
          }
          prevMinSlices = slicesInMin;
        }
      }
    }
    return [slices, othersSlice, previousSlice];
  };

  Piechart_PieBuilder.prototype.applyNewSlices = function(pie, newSlices, others, previous) {
    var allSlices, i1, i2, oldSlices, s1, s2, slice, slices, wasEmpty, _i, _len, _ref;
    oldSlices = pie.slices;
    wasEmpty = oldSlices.length === 0;
    slices = [];
    allSlices = [];
    i1 = 0;
    i2 = 0;
    while (i1 < oldSlices.length || i2 < newSlices.length) {
      s1 = oldSlices[i1];
      s2 = newSlices[i2];
      if ((s1 != null) && (s2 != null) && s1.id === s2.id) {
        s1.removed = false;
        s1.fraction = s2.fraction;
        s1.data = s2.data;
        if (s2.currentFraction) {
          s1.currentFraction = s2.currentFraction;
          s1.animatorF = null;
        }
        slices.push(s1);
        allSlices.push(s1);
        i1++;
        i2++;
      } else if (!s2 || (s1 && s1.index < s2.index)) {
        s1.removed = true;
        s1.fraction = 0;
        allSlices.push(s1);
        i1++;
      } else {
        if (!s2.currentFraction && !wasEmpty) {
          s2.currentFraction = 0;
        }
        slices.push(s2);
        allSlices.push(s2);
        i2++;
      }
    }
    pie.total = pie.data ? pie.data.total : 0;
    pie.count = newSlices.length;
    pie.slices = slices;
    pie.allSlices = allSlices;
    if (others) {
      if (!pie.othersSlice) {
        if (!wasEmpty) {
          others.currentFraction = 0;
        }
        pie.othersSlice = others;
      } else {
        pie.othersSlice.removed = others.removed;
        pie.othersSlice.data = others.data;
        pie.othersSlice.fraction = others.fraction;
        pie.othersSlice.value = others.value;
        if (others.currentFraction != null) {
          pie.othersSlice.currentFraction = others.currentFraction;
          pie.othersSlice.animatorF = null;
        }
      }
      pie.allSlices.push(pie.othersSlice);
    } else if (pie.othersSlice) {
      pie.allSlices.push(pie.othersSlice);
      pie.othersSlice.removed = true;
      pie.othersSlice.fraction = 0;
    }
    if (previous) {
      if (!pie.previousSlice) {
        if (!wasEmpty) {
          previous.currentFraction = 0;
        }
        pie.previousSlice = previous;
      } else {
        pie.previousSlice.removed = previous.removed;
        pie.previousSlice.data = previous.data;
        pie.previousSlice.fraction = previous.fraction;
        pie.previousSlice.value = previous.value;
        if (previous.currentFraction != null) {
          pie.previousSlice.currentFraction = previous.currentFraction;
          pie.previousSlice.animatorF = null;
        }
      }
      pie.allSlices.unshift(pie.previousSlice);
    } else if (pie.previousSlice) {
      pie.previousSlice.removed = true;
      pie.previousSlice.fraction = 0;
      pie.allSlices.unshift(pie.previousSlice);
    }
    _ref = pie.allSlices;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      slice = _ref[_i];
      slice.value = slice.data.value;
    }
    return this.scene.updateOnPieChanged(pie);
  };

  Piechart_PieBuilder.prototype.getPieData = function(pie) {
    var data, sum, v, _i, _j, _len, _len1, _ref, _ref1;
    data = this.scene.mainData.getPieData(pie.id);
    if (!data) {
      return null;
    }
    sum = data.total;
    if (sum > 0) {
      _ref = data.values;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        v = _ref[_i];
        v.fraction = v.value / sum;
      }
    } else {
      sum = data.values.length;
      _ref1 = data.values;
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        v = _ref1[_j];
        v.fraction = 1 / sum;
      }
    }
    if (data.afterSum > 0) {
      data.afterFraction = data.afterSum / sum;
    } else {
      data.afterFraction = 0;
    }
    if (data.beforeSum > 0) {
      data.beforeFraction = data.beforeSum / sum;
    } else {
      data.beforeFraction = 0;
    }
    return data;
  };

  return Piechart_PieBuilder;

})();
// Generated by CoffeeScript 1.8.0
var Base_Bar_UserButton,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

Base_Bar_UserButton = (function(_super) {
  __extends(Base_Bar_UserButton, _super);

  function Base_Bar_UserButton(chart, options) {
    this.chart = chart;
    this.options = options;
    Base_Bar_UserButton.__super__.constructor.call(this, chart);
    this.createButton(options);
  }

  Base_Bar_UserButton.prototype.onClick = function(ev) {
    if (this.options.onClick) {
      this.options.onClick(ev, this.chart.api);
    }
    return Base_Helpers.stopPropagation(ev);
  };

  return Base_Bar_UserButton;

})(Base_Bar_Button);
// Generated by CoffeeScript 1.8.0
var Base_Bar_Dropdown,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

Base_Bar_Dropdown = (function(_super) {
  "use strict";
  __extends(Base_Bar_Dropdown, _super);

  function Base_Bar_Dropdown(chart, options) {
    this.options = options;
    Base_Bar_Dropdown.__super__.constructor.call(this, chart, options);
    this.items = [];
    this.listeners = [];
  }

  Base_Bar_Dropdown.prototype.buildDropdownList = function() {
    var item, _i, _len, _ref;
    this.items = [];
    this.listeners = [];
    _ref = this.options.items;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      item = _ref[_i];
      Base_Helpers.listen(item.domElement, "click", this.hideDropdown);
      this.items.push(item.domElement);
    }
    return this.items;
  };

  Base_Bar_Dropdown.prototype.onHideDropdown = function() {
    var ii, _i, _len, _ref;
    _ref = this.items;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      ii = _ref[_i];
      ii.parentNode.removeChild(ii);
      Base_Helpers.unlisten(ii, "click", this.hideDropdown);
    }
    this.items = [];
    return this.listeners = [];
  };

  return Base_Bar_Dropdown;

})(Base_Bar_DropdownBase);
// Generated by CoffeeScript 1.8.0
var Base_Bar_Combobox,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

Base_Bar_Combobox = (function(_super) {
  "use strict";
  __extends(Base_Bar_Combobox, _super);

  function Base_Bar_Combobox(chart, options) {
    this.options = options;
    Base_Bar_Combobox.__super__.constructor.call(this, chart, options);
  }

  Base_Bar_Combobox.prototype.onSelectionChange = function(item) {
    return item;
  };

  Base_Bar_Combobox.prototype.getItems = function() {
    return [];
  };

  Base_Bar_Combobox.prototype.buildDropdownList = function() {
    var a, item, items, li, _i, _len, _ref;
    items = [];
    _ref = this.getItems();
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      item = _ref[_i];
      li = Base_Helpers.createDom("li", null, null, null);
      a = Base_Helpers.createDom("a", null, item.name, li);
      if (item.selected) {
        a.className = "DVSL-bar-dropdown-active";
      }
      if (item.disabled) {
        a.className = "DVSL-bar-dropdown-disabled";
      } else {
        (function(_this) {
          return (function() {
            var ii;
            ii = item;
            return Base_Helpers.listen(a, "click", function() {
              return _this.userSelected(ii);
            });
          });
        })(this)();
      }
      items.push(li);
    }
    return items;
  };

  Base_Bar_Combobox.prototype.userSelected = function(item) {
    this.hideDropdown();
    this.setSelectedItem(item);
    return this.onSelectionChange(item);
  };

  Base_Bar_Combobox.prototype.setSelectedItem = function(item) {
    if (this.options.showLabels !== false) {
      return this.p.innerHTML = item.name || "";
    }
  };

  return Base_Bar_Combobox;

})(Base_Bar_DropdownBase);
// Generated by CoffeeScript 1.8.0
var Base_Bar_ToggleButton,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

Base_Bar_ToggleButton = (function(_super) {
  __extends(Base_Bar_ToggleButton, _super);

  function Base_Bar_ToggleButton(chart, options) {
    this.chart = chart;
    this.options = options;
    this.createButton(options);
    this.curState = false;
  }

  Base_Bar_ToggleButton.prototype.onSceneChange = function(changes) {
    var newState;
    newState = this.options.getChartState();
    if (newState !== this.curState) {
      this.curState = newState;
      if (this.curState && this.options.cssClassEnabled) {
        this.a.className = this.options.cssClassEnabled;
      } else {
        this.a.className = this.options.cssClass;
      }
      if (this.options.showLabels !== false) {
        if (this.curState && this.options.labelEnabled) {
          return this.p.innerHTML = this.options.labelEnabled;
        } else {
          return this.p.innerHTML = this.options.label;
        }
      }
    }
  };

  Base_Bar_ToggleButton.prototype.onClick = function(ev) {
    if (this.curState) {
      this.options.onDisable();
    } else {
      this.options.onEnable();
    }
    this.onSceneChange();
    return Base_Helpers.stopPropagation(ev);
  };

  return Base_Bar_ToggleButton;

})(Base_Bar_Button);
// Generated by CoffeeScript 1.8.0
var Netchart_Navigator,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

Netchart_Navigator = (function(_super) {
  __extends(Netchart_Navigator, _super);

  Netchart_Navigator.prototype.animationOrder = 100;

  Netchart_Navigator.prototype.paintOrder = 5;

  Netchart_Navigator.prototype.updateOrder = 1500;

  Netchart_Navigator.settings = {
    _doc: {
      doc: "Controls the dynamic layout appearance and interaction associated with initial and focal nodes.",
      type: "section"
    },
    mode: "showall",
    mode_doc: {
      doc: "Navigation mode.",
      type: "enum",
      values: {
        "manual": "show just the initial nodes. User expands nodes by clicking on them.",
        "showall": "show all nodes, load more nodes on the fly, use if you intend to show all network. Caution if the network is large this will bring down the chart.",
        "focusnodes": "show initial nodes and neighbor nodes up to focusNodeExpansionRadius links away."
      }
    },
    initialNodes: null,
    initialNodes_doc: {
      doc: "Initially visible nodes. Array of node identifiers.",
      type: "array",
      baseObject: "string"
    },
    focusNodeExpansionRadius: 2,
    focusNodeExpansionRadius_doc: {
      doc: "Link distance from focus nodes to show.",
      type: "integer",
      units: "expanding levels"
    },
    focusNodeTailExpansionRadius: 0.3,
    focusNodeTailExpansionRadius_doc: {
      doc: "Expansion radius of the oldest (end of the tail) focus node.",
      type: "float",
      units: "expanding factor"
    },
    focusAutoFadeout: true,
    focusAutoFadeout_doc: {
      doc: "Whether to limit the number of focus nodes to numberOfFocusNodes. If more nodes are focused, oldest are removed.",
      type: "bool"
    },
    numberOfFocusNodes: 3,
    numberOfFocusNodes_doc: {
      doc: "Maximal number of focus nodes. When more focus nodes are added, oldest nodes are removed.",
      type: "integer"
    },
    expandDelay: 400,
    expandDelay_doc: {
      doc: "Expand delay for multi-level expands. When adding a focus node it results in showing multiple levels on nodes. Each level is shown after a short delay.",
      type: "integer",
      units: "milliseconds"
    },
    expandOnClick: true,
    expandOnClick_doc: {
      doc: "Whether to expand node on click.",
      type: "bool"
    },
    autoZoomOnFocus: false,
    autoZoomOnFocus_doc: {
      doc: "Whether to auto zoom when a new focus node is added.",
      type: "bool"
    },
    nodeAutoExpandFilter: null
  };

  Netchart_Navigator.prototype.FocusNode = (function() {
    function _Class() {
      this.id = null;
      this.relevance = -1;
      this.initial = false;
      this.stopped = false;
      this.hidden = false;
      this.expanded = false;
      this.collapsed = false;
      this.actionId = 0;
    }

    return _Class;

  })();

  Netchart_Navigator.prototype.otherEnd = Netchart_Data.otherEnd;

  function Netchart_Navigator(chart) {
    this.chart = chart;
    this.layer = this.chart.layer;
    this.graph = this.chart.graph;
    this.scene = this.chart.scene;
    this.nodes = {};
    this.lastExpandTime = 0;
    this.nextId = 0;
    this.hasData = false;
  }

  Netchart_Navigator.prototype.clear = function(origin) {
    this.chart.events.notifySceneChanges({
      navigation: true
    });
    this.nodes = {};
    return this.chart.notifyChartUpdate(origin);
  };

  Netchart_Navigator.prototype.addAction = function(nodeId, params, origin) {
    var a;
    this.chart.events.notifySceneChanges({
      navigation: true
    });
    a = new this.FocusNode();
    a.id = nodeId;
    a.actionId = this.nextId;
    this.nextId += 1;
    Base_Helpers.extend(a, params);
    this.nodes[nodeId] = a;
    this.chart.notifyChartUpdate(origin);
    return a;
  };

  Netchart_Navigator.prototype.updateAction = function(nodeId, params, origin) {
    var a;
    this.chart.events.notifySceneChanges({
      navigation: true
    });
    a = this.nodes[nodeId];
    a.actionId = this.nextId;
    this.nextId += 1;
    Base_Helpers.extend(a, params);
    this.chart.notifyChartUpdate(origin);
    return a;
  };

  Netchart_Navigator.prototype.hideNode = function(nodeId, origin) {
    return this.addAction(nodeId, {
      hidden: true
    }, origin);
  };

  Netchart_Navigator.prototype.collapseNode = function(nodeId, origin) {
    return this.addAction(nodeId, {
      collapsed: true,
      expanded: false
    }, origin);
  };

  Netchart_Navigator.prototype.addFocusNode = function(nodeId, relevance, origin) {
    return this.addAction(nodeId, {
      relevance: relevance,
      initial: true
    }, origin);
  };

  Netchart_Navigator.prototype.expandNode = function(nodeId, origin) {
    if (this.nodes[nodeId] && this.nodes[nodeId].initial) {
      return this.updateAction(nodeId, {
        expanded: true
      }, origin);
    } else {
      return this.addAction(nodeId, {
        expanded: true
      }, origin);
    }
  };

  Netchart_Navigator.prototype.unexpandNode = function(nodeId, origin) {
    if (this.nodes[nodeId]) {
      return this.updateAction(nodeId, {
        initial: false
      }, origin);
    }
  };

  Netchart_Navigator.prototype.removeNode = function(nodeId) {
    return delete this.nodes[nodeId];
  };

  Netchart_Navigator.prototype.save = function() {
    return this.nodes;
  };

  Netchart_Navigator.prototype.restore = function(state) {
    var id, n, params;
    this.nodes = {};
    for (id in state) {
      params = state[id];
      n = new this.FocusNode();
      Base_Helpers.extend(n, params);
      this.nodes[id] = n;
      this.nextId = Math.max(n.actionId, this.nextId);
    }
    this.chart.events.notifySceneChanges({
      navigation: true
    });
    return this.chart.notifyChartUpdate("restore");
  };

  Netchart_Navigator.prototype.getInitialNodes = function() {
    var initialNodes;
    initialNodes = this.scene.settings.navigation.initialNodes;
    if (Base_Helpers.isString(initialNodes)) {
      initialNodes = [initialNodes];
    } else if (!Base_Helpers.isArray(initialNodes)) {
      initialNodes = [];
    }
    return initialNodes;
  };

  Netchart_Navigator.prototype.onNewDataObject = function() {
    var i, initialNodes, _i, _len, _results;
    this.hasData = false;
    if (this.scene.settings.navigation.mode === "showall") {
      initialNodes = this.getInitialNodes();
      if (initialNodes.length === 0) {
        return this.scene.loading = this.scene.mainData.requestAllNodes();
      } else {
        _results = [];
        for (_i = 0, _len = initialNodes.length; _i < _len; _i++) {
          i = initialNodes[_i];
          _results.push(this.scene.mainData.getNodeData(i));
        }
        return _results;
      }
    } else {
      return this.scene.loading = false;
    }
  };

  Netchart_Navigator.prototype.showInitialNodes = function() {
    var id, initialNodes, settings, _i, _j, _len, _len1;
    this.clear();
    settings = this.scene.settings.navigation;
    initialNodes = this.getInitialNodes();
    if (settings.mode === "focusnodes") {
      for (_i = 0, _len = initialNodes.length; _i < _len; _i++) {
        id = initialNodes[_i];
        this.addFocusNode(id, -1);
      }
    } else if (settings.mode === "manual") {
      for (_j = 0, _len1 = initialNodes.length; _j < _len1; _j++) {
        id = initialNodes[_j];
        this.addFocusNode(id, 1);
      }
    } else if (settings.mode === "showall" || true) {
      1;
    }
    return this.chart.notifyChartUpdate("init");
  };

  Netchart_Navigator.prototype.commitChanges = function(changes) {
    return this.onSceneChange({
      changes: changes
    });
  };

  Netchart_Navigator.prototype.onSceneChange = function(event) {
    var canCleanup, exp, expandUnfinished, expandedLinks, linksWithNewData, loadingNodes, nodesWithNewData, rel, visibleNodes, _ref;
    if (!(event.changes.navigation || event.changes.dataArrived || this.layer.hasTopologyChanges() || event.changes.settings || event.changes.filters || event.changes.data)) {
      return;
    }
    if (this.scene.settings.navigation.expandDelay && this.lastExpandTime > event.timeStamp - this.scene.settings.navigation.expandDelay && !event.changes.filters && this.hasData && !this.dataArrived) {
      this.chart.events.notifySceneChanges({
        navigation: true
      });
      return;
    }
    if (event.changes.dataArrived) {
      this.hasData = true;
      this.scene.loading = false;
    }
    this.resolveConflicts();
    _ref = this.computeRelevances(), rel = _ref[0], exp = _ref[1], expandedLinks = _ref[2], expandUnfinished = _ref[3], loadingNodes = _ref[4];
    visibleNodes = rel;
    if (!this.hasData) {
      return;
    }
    canCleanup = true;
    if (expandUnfinished && this.scene.settings.navigation.expandDelay) {
      canCleanup = false;
      this.lastExpandTime = event.timeStamp;
      this.chart.events.notifySceneChanges({
        navigation: true
      });
    }
    if (event.changes.dataArrived) {
      nodesWithNewData = event.changes.dataNodesIds;
      linksWithNewData = event.changes.dataLinksIds;
    } else {
      nodesWithNewData = {};
      linksWithNewData = {};
    }
    event.changes.newGraph = this.updateGraph(visibleNodes, expandedLinks, nodesWithNewData, linksWithNewData);
    this.applyRelevances(rel, exp, loadingNodes);
    if (canCleanup) {
      return this.cleanupInivisibleNodes();
    }
  };

  Netchart_Navigator.prototype.resolveConflicts = function() {
    var a, focusNodes, i, id, link, links, maxFocusNodes, nodeId, otherFocus, otherNodeId, _i, _len, _ref, _ref1, _results;
    _ref = this.nodes;
    for (nodeId in _ref) {
      a = _ref[nodeId];
      if (a.expanded) {
        links = this.scene.mainData.getNodeCollectedLinks(nodeId);
        for (_i = 0, _len = links.length; _i < _len; _i++) {
          link = links[_i];
          otherNodeId = this.otherEnd(link, nodeId);
          otherFocus = this.nodes[otherNodeId];
          if (otherFocus && otherFocus.actionId < a.actionId && otherFocus.hidden) {
            delete this.nodes[otherNodeId];
          }
        }
      }
    }
    if (this.scene.settings.navigation.mode === "focusnodes") {
      maxFocusNodes = this.scene.settings.navigation.numberOfFocusNodes;
      focusNodes = [];
      _ref1 = this.nodes;
      for (id in _ref1) {
        a = _ref1[id];
        if (a.initial) {
          focusNodes.push(a);
        }
      }
      focusNodes.sort(function(a, b) {
        return a.actionId - b.actionId;
      });
      i = 0;
      _results = [];
      while (focusNodes.length - i > maxFocusNodes) {
        focusNodes[i].initial = false;
        _results.push(i++);
      }
      return _results;
    }
  };

  Netchart_Navigator.prototype.cleanupInivisibleNodes = function() {
    var a, nodeId, _ref, _results;
    _ref = this.nodes;
    _results = [];
    for (nodeId in _ref) {
      a = _ref[nodeId];
      if (this.scene.settings.navigation.mode !== "focusnodes" && this.scene.mainData.isFilteredNode(nodeId)) {
        delete this.nodes[nodeId];
        continue;
      }
      if (!a.initial && !a.hidden && !this.graph.idToNode.hasOwnProperty(nodeId)) {
        delete this.nodes[nodeId];
        continue;
      } else {
        _results.push(void 0);
      }
    }
    return _results;
  };

  Netchart_Navigator.prototype.computeRelevances = function() {
    var a, autoExpandFilterFunc, cold, cooldown, data, dataNodes, expand, expandIncremental, expandUnfinished, expandedLinks, expandedNodes, expandedRelevances, focusNodes, graphNodes, id, linkData, links, loadingNodes, maxRelevance, minRelevance, mode, n1, n1rel, preloadNodeLinks, q1, queue, r, rel, _, _i, _j, _len, _len1, _ref, _ref1, _ref2, _ref3;
    this.changes = false;
    graphNodes = this.graph.idToNode;
    dataNodes = this.scene.mainData.nodes;
    preloadNodeLinks = this.scene.mainData.dataSettings.preloadNodeLinks;
    expandedRelevances = {};
    expandedNodes = {};
    expandedLinks = {};
    loadingNodes = {};
    queue = {};
    expandIncremental = !!this.scene.settings.navigation.expandDelay && mode === "focusnodes";
    expandUnfinished = false;
    autoExpandFilterFunc = this.scene.settings.navigation.nodeAutoExpandFilter;
    mode = this.scene.settings.navigation.mode;
    if (mode === "focusnodes") {
      focusNodes = [];
      _ref = this.nodes;
      for (id in _ref) {
        a = _ref[id];
        if (a.initial) {
          focusNodes.push(a);
        }
      }
      focusNodes.sort(function(a, b) {
        return b.actionId - a.actionId;
      });
      maxRelevance = 1 + parseFloat(this.scene.settings.navigation.focusNodeExpansionRadius);
      minRelevance = 1 + parseFloat(this.scene.settings.navigation.focusNodeTailExpansionRadius);
      cooldown = (maxRelevance - minRelevance) / Math.max(1, this.scene.settings.navigation.numberOfFocusNodes - 1);
      cold = 0;
      for (_i = 0, _len = focusNodes.length; _i < _len; _i++) {
        a = focusNodes[_i];
        id = a.id;
        r = a.relevance;
        if (r < 0) {
          r = maxRelevance;
        }
        r = Math.max(0, r - cold);
        cold += cooldown;
        expandedRelevances[id] = r;
        queue[id] = true;
      }
    } else if (mode === "manual") {
      focusNodes = [];
      _ref1 = this.nodes;
      for (id in _ref1) {
        a = _ref1[id];
        focusNodes.push(a);
      }
      focusNodes.sort(function(a, b) {
        return b.actionId - a.actionId;
      });
      _ref2 = this.nodes;
      for (id in _ref2) {
        a = _ref2[id];
        if (!a.collapsed) {
          queue[id] = true;
          expandedRelevances[id] = a.relevance;
        }
      }
      if (!Base_Helpers.hasProperties(queue) && focusNodes.length > 0) {
        queue[focusNodes[0].id] = true;
        expandedRelevances[focusNodes[0].id] = 1;
      }
    } else {
      _ref3 = this.scene.mainData.getNodes();
      for (id in _ref3) {
        data = _ref3[id];
        queue[id] = true;
        expandedRelevances[id] = 1.01;
      }
    }
    while (Base_Helpers.hasProperties(queue)) {
      q1 = {};
      for (id in queue) {
        _ = queue[id];
        rel = expandedRelevances[id];
        a = this.nodes[id];
        if (a) {
          if (a.hidden) {
            delete expandedRelevances[id];
            continue;
          }
          if (a.expanded && rel < 2) {
            rel = 2;
            expandedRelevances[id] = Math.max(1, expandedRelevances[id]);
          }
          expand = a.expanded || (rel > 1 && !a.collapsed) && !expandedNodes.hasOwnProperty(id);
        } else {
          expand = rel > 1;
        }
        if (!this.scene.mainData.getNodeData(id)) {
          this.scene.loading = true;
          delete expandedRelevances[id];
          continue;
        }
        if (!expand && autoExpandFilterFunc) {
          1;
        }
        if (expand && expandIncremental && !graphNodes.hasOwnProperty(id)) {
          if (dataNodes.hasOwnProperty(id)) {
            expandUnfinished = true;
          }
          expand = false;
        }
        if (!expandedNodes.hasOwnProperty(id)) {
          if (expand) {
            expandedNodes[id] = true;
            links = this.scene.mainData.getNodeLinks(id);
            if (!links) {
              loadingNodes[id] = true;
              links = this.scene.mainData.getNodeCollectedLinks(id);
            }
            expandedLinks[id] = links;
            n1rel = rel - 1;
            for (_j = 0, _len1 = links.length; _j < _len1; _j++) {
              linkData = links[_j];
              n1 = this.otherEnd(linkData, id);
              if (!expandedRelevances.hasOwnProperty(n1) || n1rel > expandedRelevances[n1]) {
                expandedRelevances[n1] = n1rel;
                q1[n1] = true;
              }
            }
          } else if (preloadNodeLinks) {
            links = this.scene.mainData.getNodeLinks(id);
            if (!links) {
              loadingNodes[id] = true;
              links = this.scene.mainData.getNodeCollectedLinks(id);
            }
            expandedLinks[id] = links;
          } else {
            expandedLinks[id] = this.scene.mainData.getNodeCollectedLinks(id);
          }
        }
      }
      queue = q1;
    }
    return [expandedRelevances, expandedNodes, expandedLinks, expandUnfinished, loadingNodes];
  };

  Netchart_Navigator.prototype.updateGraph = function(visibleNodes, expandedLinks, nodesWithNewData, linksWithNewData) {
    var isNewGraph;
    isNewGraph = this.graph.replaceGraph(visibleNodes, expandedLinks);
    this.graph.updateGraphWithNewData(nodesWithNewData, linksWithNewData);
    return isNewGraph;
  };

  Netchart_Navigator.prototype.applyRelevances = function(relevances, expanded, loading) {
    var actionNode, e, f, focusMode, l, lastFocusNode, lastFocusPos, link, linkId, node, nodeId, nodesInData, rel, rr, _ref, _results;
    nodesInData = this.scene.mainData.nodes;
    focusMode = this.scene.settings.navigation.mode === "focusnodes";
    lastFocusNode = null;
    lastFocusPos = 0;
    for (nodeId in relevances) {
      rel = relevances[nodeId];
      node = this.graph.idToNode[nodeId];
      if (node) {
        actionNode = this.nodes[nodeId];
        e = expanded.hasOwnProperty(nodeId);
        f = focusMode && actionNode && actionNode.initial;
        l = loading.hasOwnProperty(nodeId);
        if (e !== node.expanded || f !== node.focused || node.relevance !== rel || node.loading !== l) {
          node.expanded = e;
          node.focused = f;
          node.relevance = rel;
          node.loading = l;
          this.layer.touchNode(node);
        }
        if (f && (lastFocusNode === null || lastFocusPos < actionNode.actionId)) {
          lastFocusNode = node;
          lastFocusPos = actionNode.actionId;
        }
      }
    }
    this.scene.lastFocusNode = lastFocusNode;
    if (Base_Helpers.hasProperties(loading)) {
      this.scene.loading = true;
    }
    _ref = this.graph.idToLink;
    _results = [];
    for (linkId in _ref) {
      link = _ref[linkId];
      rr = Math.min(link.from.relevance, link.to.relevance);
      if (rr !== link.relevance) {
        link.relevance = rr;
        _results.push(this.layer.touchLink(link));
      } else {
        _results.push(void 0);
      }
    }
    return _results;
  };

  return Netchart_Navigator;

})(Base_ChartElement);
// Generated by CoffeeScript 1.8.0
var Netchart_Scene,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

Netchart_Scene = (function(_super) {
  __extends(Netchart_Scene, _super);

  function Netchart_Scene() {
    Netchart_Scene.__super__.constructor.call(this);
    this.autoZoomMode = false;
    this.layoutActive = true;
    this.lastFocusNode = null;
  }

  return Netchart_Scene;

})(Itemschart_Scene);
// Generated by CoffeeScript 1.8.0
var Netchart_Scrolling,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

Netchart_Scrolling = (function(_super) {
  __extends(Netchart_Scrolling, _super);

  Netchart_Scrolling.prototype.animationOrder = 800;

  Netchart_Scrolling.prototype.paintOrder = 15;

  Netchart_Scrolling.prototype.updateOrder = 1300;

  function Netchart_Scrolling(chart) {
    this.chart = chart;
    this.scene = chart.scene;
    this.events = chart.events;
    this.settings = this.scene.settings;
    this.pointer1 = null;
    this.pointer2 = null;
    this.x1 = 0;
    this.y1 = 0;
    this.x2 = 0;
    this.y2 = 0;
    this.centerX = 0;
    this.centerY = 0;
    this.centerDistance = 1;
    this.numPointers = 0;
  }

  Netchart_Scrolling.prototype.onWheel = function(event) {
    var zoomChange;
    if (!(this.scene.xyInChart(event.x, event.y) && this.scene.settings.interaction.zooming.wheel)) {
      return;
    }
    zoomChange = Math.pow(1 + this.scene.settings.interaction.zooming.sensitivity, event.wheely * 0.004);
    this.chart.autoZoom.manualZoom(zoomChange, event.x, event.y);
    event.consumed = true;
    return event.changes.position = true;
  };

  Netchart_Scrolling.prototype.previewPointerDown = function(event) {
    return this.numPointers += 1;
  };

  Netchart_Scrolling.prototype.previewPointerUp = function(event) {
    return this.numPointers -= 1;
  };

  Netchart_Scrolling.prototype.previewPointerCancel = function(event) {
    return this.numPointers -= 1;
  };

  Netchart_Scrolling.prototype.onPointerDown = function(event) {
    var dx, dy, len, _ref, _ref1, _ref2;
    if (this.pointer1 === null) {
      this.pointer1 = event.identifier;
      _ref = [event.x, event.y], this.x1 = _ref[0], this.y1 = _ref[1];
      if (this.settings.interaction.panning.enabled) {
        return event.consumed = true;
      } else if (this.settings.interaction.zooming.fingers) {
        return event.capture = true;
      }
    } else if (this.pointer2 === null && this.settings.interaction.zooming.fingers) {
      this.pointer2 = event.identifier;
      _ref1 = [event.x, event.y], this.x2 = _ref1[0], this.y2 = _ref1[1];
      _ref2 = this.scene.fromDisplay((this.x1 + this.x2) / 2, (this.y1 + this.y2) / 2), this.centerX = _ref2[0], this.centerY = _ref2[1];
      dx = this.x1 - this.x2;
      dy = this.y1 - this.y2;
      len = Math.sqrt(dx * dx + dy * dy);
      this.centerDistance = len / this.scene.zoom;
      return event.consumed = true;
    }
  };

  Netchart_Scrolling.prototype.onPointerDrag = function(event) {
    if (event.identifier === this.pointer1 && this.pointer2 === null) {
      if (this.settings.interaction.panning.enabled) {
        this.scene.centerX -= event.dx / this.scene.zoom;
        this.scene.centerY -= event.dy / this.scene.zoom;
        this.scene.autoZoomMode = false;
        event.changes.position = true;
        return event.consumed = true;
      } else {
        return event.capture = true;
      }
    } else if (event.identifier === this.pointer1 && this.settings.interaction.zooming.fingers) {
      this.twoFingerDrag(event.x, event.y, this.x2, this.y2);
      event.changes.position = true;
      return event.consumed = true;
    } else if (event.identifier === this.pointer2 && this.settings.interaction.zooming.fingers) {
      this.twoFingerDrag(this.x1, this.y1, event.x, event.y);
      event.changes.position = true;
      return event.consumed = true;
    }
  };

  Netchart_Scrolling.prototype.onPointerUp = function(event) {
    if (this.pointer2 === event.identifier) {
      return this.pointer2 = null;
    } else if (this.pointer1 === event.identifier) {
      if (this.pointer2 !== null) {
        this.pointer1 = this.pointer2;
        this.pointer2 = null;
        this.x1 = this.x2;
        return this.y1 = this.y2;
      } else {
        return this.pointer1 = null;
      }
    }
  };

  Netchart_Scrolling.prototype.onPointerCancel = function(event) {
    return this.onPointerUp(event);
  };

  Netchart_Scrolling.prototype.onDoubleClick = function(event) {
    var z;
    z = this.settings.interaction.zooming.doubleClickZoom;
    if (z && this.settings.interaction.zooming.zoomInOnDoubleClick) {
      this.chart.autoZoom.manualZoom(z, event.x, event.y);
      event.changes.position = true;
      return event.consumed = true;
    }
  };

  Netchart_Scrolling.prototype.twoFingerDrag = function(x1, y1, x2, y2) {
    var cx, cy, dz, newLen, sceneX, sceneY, sx1, sy1, _ref;
    sx1 = x2 - x1;
    sy1 = y2 - y1;
    newLen = Math.sqrt(sx1 * sx1 + sy1 * sy1) / this.scene.zoom;
    cx = (x2 + x1) / 2;
    cy = (y2 + y1) / 2;
    _ref = this.scene.fromDisplay(cx, cy), sceneX = _ref[0], sceneY = _ref[1];
    this.scene.centerX += this.centerX - sceneX;
    this.scene.centerY += this.centerY - sceneY;
    dz = newLen / this.centerDistance;
    this.chart.autoZoom.manualZoom(dz, cx, cy);
    this.x1 = x1;
    this.y1 = y1;
    this.x2 = x2;
    return this.y2 = y2;
  };

  return Netchart_Scrolling;

})(Base_ChartElement);
// Generated by CoffeeScript 1.8.0
var Netchart_Renderer,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

Netchart_Renderer = (function(_super) {
  "use strict";
  __extends(Netchart_Renderer, _super);

  Netchart_Renderer.prototype.animationOrder = 500;

  Netchart_Renderer.prototype.paintOrder = 35;

  Netchart_Renderer.prototype.updateOrder = 1800;

  Netchart_Renderer.prototype.scene = null;

  Netchart_Renderer.prototype.events = null;

  function Netchart_Renderer(chart) {
    this.chart = chart;
    this.scene = chart.scene;
    this.layer = this.chart.layer;
    this.events = chart.events;
  }

  Netchart_Renderer.prototype.doAnimations = function(event) {
    return this.layer.doAnimations(event);
  };

  Netchart_Renderer.prototype.paintScene = function(event) {
    Base_Graphics.pushClip(event.context, this.scene.x0, this.scene.y0, this.scene.width, this.scene.height);
    this.layer.setBounds(this.scene.x0, this.scene.y0, this.scene.x0 + this.scene.width, this.scene.y0 + this.scene.height);
    this.layer.paint(event);
    return Base_Graphics.popClip(event.context);
  };

  Netchart_Renderer.prototype.paintLinks = function(g, links, multiLinks, setup) {
    return this.layer.paintLinksImpl(g, links, multiLinks, setup);
  };

  Netchart_Renderer.prototype.paintNodes = function(g, nodes, setup, time) {
    return this.layer.paintNodesImpl(g, nodes, setup, time);
  };

  Netchart_Renderer.prototype.findObjectAt = function(displayX, displayY, tolerance) {
    return this.layer.findObjectAt(displayX, displayY, tolerance);
  };

  return Netchart_Renderer;

})(Base_ChartElement);
// Generated by CoffeeScript 1.8.0
var Netchart_Layers,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

Netchart_Layers = (function(_super) {
  __extends(Netchart_Layers, _super);

  Netchart_Layers.prototype.animationOrder = 900;

  Netchart_Layers.prototype.paintOrder = 50;

  Netchart_Layers.prototype.updateOrder = 600;

  Netchart_Layers.prototype.scene = null;

  Netchart_Layers.prototype.container = null;

  Netchart_Layers.prototype.background = null;

  Netchart_Layers.prototype.canvas = null;

  Netchart_Layers.prototype.outerBorder = null;

  Netchart_Layers.prototype.mouseTrackLayer = null;

  function Netchart_Layers(chart) {
    this.chart = chart;
    this.scene = this.chart.scene;
    this.container = Base_Helpers.createDom("div", "DVSL-container");
    this.container.style.position = "relative";
    this.container.style.width = "100%";
    this.container.style.height = "100%";
    this.background = Base_Helpers.createDom("div", "DVSL-background", null, this.container);
    this.setContainerStyle(this.background);
    this.canvas = Base_Helpers.createDom("canvas", "DVSL-canvas", null, this.container);
    this.setContainerStyle(this.canvas);
    this.outerBorder = Base_Helpers.createDom("div", "DVSL-border", null, this.container);
    this.setContainerStyle(this.outerBorder);
    this.resizerBar = Base_Helpers.createDom("div", "DVSL-resizer", null, this.container);
    this.mouseTrackLayer = Base_Helpers.createDom("div", null, null, this.container);
    this.setContainerStyle(this.mouseTrackLayer);
    this.updateSettings(this.scene.settings, "init");
  }

  Netchart_Layers.prototype.updateSettings = function(changes) {
    if (Base_Helpers.hasProp(changes, "advanced.themeCSSClass")) {
      if (this.curTheme != null) {
        Base_Helpers.removeClass(this.container, this.curTheme);
      }
      this.curTheme = this.scene.settings.advanced.themeCSSClass;
      return Base_Helpers.addClass(this.container, this.curTheme);
    }
  };

  Netchart_Layers.prototype.doAnimations = function(event) {
    var setHeight, setWidth;
    if (!event.changes.bounds) {
      return;
    }
    setWidth = this.scene.settings.width;
    setHeight = this.scene.settings.height;
    if (this.scene.chartWidth > this.scene.settings.container.clientWidth) {
      setWidth = this.scene.chartWidth;
    }
    if (this.scene.chartHeight > this.scene.settings.container.clientHeight) {
      setHeight = this.scene.chartHeight;
    }
    if (setWidth) {
      this.container.style.width = "" + setWidth + "px";
    }
    if (setHeight) {
      this.container.style.height = "" + setHeight + "px";
    }
    this.resizerBar.style.width = "" + this.scene.width + "px";
    return this.resizerBar.style.left = "" + this.scene.x0 + "px";
  };

  Netchart_Layers.prototype.setContainerStyle = function(c) {
    c.style.position = "absolute";
    c.style.left = "0px";
    c.style.right = "0px";
    c.style.top = "0px";
    return c.style.bottom = "0px";
  };

  return Netchart_Layers;

})(Base_ChartElement);
// Generated by CoffeeScript 1.8.0
var Netchart_AutoZoom,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

Netchart_AutoZoom = (function(_super) {
  __extends(Netchart_AutoZoom, _super);

  Netchart_AutoZoom.prototype.animationOrder = 700;

  Netchart_AutoZoom.prototype.paintOrder = 20;

  Netchart_AutoZoom.prototype.updateOrder = 2000;

  function Netchart_AutoZoom(chart) {
    this.chart = chart;
    this.scene = chart.scene;
    this.layer = chart.layer;
    this.events = chart.events;
    this.settings = this.scene.settings;
    this.animatorX = new Base_Animator(0, 0, this.settings.interaction.animation.scrollDuration, "=");
    this.animatorY = new Base_Animator(0, 0, this.settings.interaction.animation.scrollDuration, "=");
    this.animatorZ = new Base_Animator(0, 0, this.settings.interaction.animation.scrollDuration, "=");
    this.numPointers = 0;
    this.resetZoom = false;
  }

  Netchart_AutoZoom.prototype.setZoom = function(zoom, animate) {
    var newZoom, zoomFactor;
    if (animate == null) {
      animate = true;
    }
    zoomFactor = 1 + this.scene.settings.interaction.zooming.sensitivity;
    if (zoom === "auto") {
      this.scene.autoZoomMode = true;
      this.autoZoom(animate);
    } else if (zoom === "overview") {
      this.scene.autoZoomMode = "overview";
      this.autoZoom(animate);
    } else {
      if (zoom === "in") {
        newZoom = this.animatorZ.to * zoomFactor;
      } else if (zoom === "out") {
        newZoom = this.animatorZ.to / zoomFactor;
      } else if (Base_Helpers.isNumber(zoom)) {
        newZoom = parseFloat(zoom);
      } else {
        this.chart.error("Invalid zoom value: " + zoom);
        newZoom = this.animatorZ.to;
      }
      this.manualZoom(newZoom / this.scene.zoom, void 0, void 0, animate);
    }
    return this.chart.events.notifySceneChanges({
      position: true
    });
  };

  Netchart_AutoZoom.prototype.previewPointerDown = function() {
    return this.numPointers += 1;
  };

  Netchart_AutoZoom.prototype.previewPointerUp = function() {
    return this.numPointers -= 1;
  };

  Netchart_AutoZoom.prototype.previewPointerCancel = function() {
    return this.numPointers -= 1;
  };

  Netchart_AutoZoom.prototype.doAnimations = function(event) {
    var cx, cy, time, zz;
    if (Base_Helpers.hasProp(event, "changes.settingsChanges.interaction.zooming")) {
      this.scene.autoZoomMode = this.scene.settings.interaction.zooming.initialAutoZoom;
    }
    if (this.resetZoom || event.changes.newGraph) {
      this.resetZoom = false;
      return this.setZoom("overview", false);
    } else if (this.numPointers === 0 && this.layer.nodes().length > 0) {
      if (this.scene.autoZoomMode && this.autoZoom(true)) {
        event.changes.position = true;
      }
      time = event.timeStamp;
      cx = this.animatorX.get(time);
      cy = this.animatorY.get(time);
      zz = this.animatorZ.get(time);
      if (cx !== this.scene.centerX || cy !== this.scene.centerY || zz !== this.scene.zoom) {
        this.scene.centerX = cx;
        this.scene.centerY = cy;
        this.scene.zoom = zz;
        event.changes.position = true;
      }
      if (!(this.animatorX.finished(time)) || !(this.animatorY.finished(time)) || !(this.animatorZ.finished(time))) {
        return event.animating = true;
      }
    } else {
      this.animatorX.jump(this.scene.centerX);
      this.animatorY.jump(this.scene.centerY);
      return this.animatorZ.jump(this.scene.zoom);
    }
  };

  Netchart_AutoZoom.prototype.autoZoom = function(animate) {
    var autoZoomLowerTreshold, autoZoomTreshold, autoZoomUpperTreshold, changes, cx, cy, height, width, xDiff, yDiff, z, zoomDiff, _ref;
    changes = false;
    _ref = this.computeAutoZoom(this.scene.autoZoomMode === "overview"), cx = _ref[0], cy = _ref[1], z = _ref[2];
    autoZoomTreshold = 0.01;
    autoZoomUpperTreshold = 1 + autoZoomTreshold;
    autoZoomLowerTreshold = 1 - autoZoomTreshold;
    zoomDiff = this.animatorZ.to / z;
    if (zoomDiff > autoZoomUpperTreshold || zoomDiff < autoZoomLowerTreshold) {
      if (animate) {
        this.animatorZ.retargetColor(z);
      } else {
        this.animatorZ.jump(z);
        this.scene.zoom = z;
      }
      changes = true;
    }
    width = this.scene.width;
    xDiff = (this.animatorX.to - cx) * z / width;
    if (xDiff > autoZoomTreshold || xDiff < -autoZoomTreshold) {
      if (animate) {
        this.animatorX.retargetColor(cx);
      } else {
        this.animatorX.jump(cx);
        this.scene.centerX = cx;
      }
      changes = true;
    }
    height = this.scene.height;
    yDiff = (this.animatorY.to - cy) * z / height;
    if (yDiff > autoZoomTreshold || yDiff < -autoZoomTreshold) {
      if (animate) {
        this.animatorY.retargetColor(cy);
      } else {
        this.animatorY.jump(cy);
        this.scene.centerY = cy;
      }
      changes = true;
    }
    return changes;
  };

  Netchart_AutoZoom.prototype.getOnscreenBounds = function(zoomFraction) {
    var h, sx0, sx1, sy0, sy1, w;
    if (zoomFraction == null) {
      zoomFraction = 1;
    }
    w = this.scene.width * zoomFraction;
    h = this.scene.height * zoomFraction;
    sx0 = this.scene.settings.area.paddingLeft;
    sx1 = this.scene.settings.area.paddingRight;
    sy0 = this.scene.settings.area.paddingTop;
    sy1 = this.scene.settings.area.paddingBottom;
    if (sx0 <= 1) {
      sx0 = w * sx0;
    }
    if (sx1 <= 1) {
      sx1 = w * (1 - sx1);
    } else {
      sx1 = w - sx1;
    }
    if (sy0 <= 1) {
      sy0 = h * sy0;
    }
    if (sy1 <= 1) {
      sy1 = h * (1 - sy1);
    } else {
      sy1 = h - sy1;
    }
    return [sx0, sy0, sx1, sy1];
  };

  Netchart_AutoZoom.prototype.computeAutoZoom = function(showAll) {
    var centerXMax, centerXMin, centerYMax, centerYMin, cx, cy, extents, h, lastNode, newCx, newCy, nx0, nx1, ny0, ny1, nzoom, sx0, sx1, sy0, sy1, w, x0, x1, y0, y1, zoom, _ref, _ref1, _ref2;
    _ref = this.layer.getGraphBounds(), x0 = _ref[0], y0 = _ref[1], x1 = _ref[2], y1 = _ref[3];
    if (x0 === x1 && y0 === y1) {
      x0 = 0;
      x1 = 1;
      y0 = 0;
      y1 = 1;
    }
    w = this.scene.width * this.scene.settings.interaction.zooming.autoZoomSize;
    h = this.scene.height * this.scene.settings.interaction.zooming.autoZoomSize;
    _ref1 = this.getOnscreenBounds(this.scene.settings.interaction.zooming.autoZoomSize), sx0 = _ref1[0], sy0 = _ref1[1], sx1 = _ref1[2], sy1 = _ref1[3];
    zoom = Math.min((sx1 - sx0) / (x1 - x0), (sy1 - sy0) / (y1 - y0));
    extents = this.scene.settings.interaction.zooming.autoZoomExtent;
    lastNode = this.scene.lastClickedNode;
    zoom = Math.min(extents[1], zoom);
    if (showAll) {
      newCx = (x0 + x1) / 2 - w * (this.scene.settings.area.centerX - 0.5) / zoom;
      newCy = (y0 + y1) / 2 - h * (this.scene.settings.area.centerY - 0.5) / zoom;
    } else {
      zoom = Math.max(zoom, extents[0]);
      if (lastNode) {
        if (lastNode.expanded && lastNode.links.length > 1) {
          _ref2 = this.layer.getNodeNeighborsBounds(lastNode), nx0 = _ref2[0], ny0 = _ref2[1], nx1 = _ref2[2], ny1 = _ref2[3];
          nzoom = Math.min((sx1 - sx0) / (nx1 - nx0), (sy1 - sy0) / (ny1 - ny0));
          newCx = (nx0 + nx1) / 2;
          newCy = (ny0 + ny1) / 2;
          zoom = Math.min(nzoom, zoom);
        } else {
          newCx = lastNode.x;
          newCy = lastNode.y;
        }
      } else {
        newCx = this.scene.centerX;
        newCy = this.scene.centerY;
      }
    }
    centerXMin = x0 - (sx0 - w / 2) / zoom;
    centerXMax = x1 - (sx1 - w / 2) / zoom;
    centerYMin = y0 - (sy0 - h / 2) / zoom;
    centerYMax = y1 - (sy1 - h / 2) / zoom;
    cx = this.scene.centerX;
    cy = this.scene.centerY;
    if (showAll) {
      cx = Math.min(centerXMin, Math.max(centerXMax, newCx));
      cy = Math.min(centerYMin, Math.max(centerYMax, newCy));
    } else {
      if (cx < centerXMax && newCx > cx) {
        cx = Math.min(centerXMax, newCx);
      } else if (cx > centerXMin && newCx < cx) {
        cx = Math.max(centerXMin, newCx);
      }
      if (cy < centerYMax && newCy > cy) {
        cy = Math.min(centerYMax, newCy);
      } else if (cy > centerYMin && newCy < cy) {
        cy = Math.max(centerYMin, newCy);
      }
    }
    return [cx, cy, zoom * this.scene.settings.interaction.zooming.autoZoomSize];
  };

  Netchart_AutoZoom.prototype.manualZoom = function(zoomChange, displayX, displayY, animate) {
    var bounds, centerX, centerY, dx, dy, extents, fitZoom, n, newZoom, o, scx, scy, sx0, sx1, sy0, sy1, x0, x1, xx, y0, y1, yy, zoom, _i, _len, _ref, _ref1, _ref2, _ref3;
    if (animate == null) {
      animate = false;
    }
    extents = this.settings.interaction.zooming.zoomExtent;
    _ref = this.layer.getGraphBounds(), x0 = _ref[0], y0 = _ref[1], x1 = _ref[2], y1 = _ref[3];
    if (zoomChange > 1) {
      newZoom = Math.max(this.scene.zoom, Math.min(extents[1], this.scene.zoom * zoomChange));
    } else if (zoomChange < 1) {
      _ref1 = this.getOnscreenBounds(), sx0 = _ref1[0], sy0 = _ref1[1], sx1 = _ref1[2], sy1 = _ref1[3];
      fitZoom = Math.min((sx1 - sx0) / (x1 - x0), (sy1 - sy0) / (y1 - y0));
      newZoom = Math.min(this.scene.zoom, Math.max(Math.min(extents[0], fitZoom), this.scene.zoom * zoomChange));
    } else {
      newZoom = this.scene.zoom;
    }
    zoomChange = newZoom / this.scene.zoom;
    if (displayX !== void 0 && displayY !== void 0) {
      _ref2 = this.scene.fromDisplay(displayX, displayY), scx = _ref2[0], scy = _ref2[1];
    } else if (this.scene.selection.length > 0) {
      xx = 0;
      yy = 0;
      n = 0;
      _ref3 = this.scene.selection;
      for (_i = 0, _len = _ref3.length; _i < _len; _i++) {
        o = _ref3[_i];
        if (o.isNode) {
          xx += o.x;
          yy += o.y;
          n += 1;
        }
      }
      if (n > 0) {
        scx = xx / n;
        scy = yy / n;
      }
    }
    if (scx && scy) {
      centerX = (this.scene.centerX - scx) / zoomChange + scx;
      centerY = (this.scene.centerY - scy) / zoomChange + scy;
    } else {
      centerX = scx = this.scene.centerX;
      centerY = scy = this.scene.centerY;
    }
    zoom = this.scene.zoom * zoomChange;
    bounds = this.scene.getVisibleBounds();
    if (scx < x0 || scx > x1) {
      if (bounds.x0 > x0 && bounds.x1 > x1) {
        dx = Math.max(x1 - bounds.x1, x0 - bounds.x0);
      } else if (bounds.x1 < x1 && bounds.x0 < x0) {
        dx = Math.min(x1 - bounds.x1, x0 - bounds.x0);
      } else {
        dx = 0;
      }
      centerX += dx;
    }
    if (scy < y0 || scy > y1) {
      if (bounds.y0 > y0 && bounds.y1 > y1) {
        dy = Math.max(y1 - bounds.y1, y0 - bounds.y0);
      } else if (bounds.y1 < y1 && bounds.y0 < x0) {
        dy = Math.min(y1 - bounds.y1, y0 - bounds.y0);
      } else {
        dy = 0;
      }
      centerY += dy;
    }
    if (animate && zoom !== this.scene.zoom) {
      this.animatorZ.retargetColor(zoom);
    } else {
      this.animatorZ.jump(zoom);
      this.scene.zoom = zoom;
    }
    if (animate && (centerX !== this.scene.centerX || centerY !== this.scene.centerY)) {
      this.animatorX.retargetColor(centerX);
      this.animatorY.retargetColor(centerY);
    } else {
      this.scene.centerX = centerX;
      this.scene.centerY = centerY;
      this.animatorX.jump(centerX);
      this.animatorY.jump(centerY);
    }
    return this.scene.autoZoomMode = false;
  };

  return Netchart_AutoZoom;

})(Base_ChartElement);
// Generated by CoffeeScript 1.8.0
var Base_Export;

Base_Export = (function() {
  function Base_Export() {}

  Base_Export.exportToImage = function(chart, type, dimensions, transparent) {
    var canvas, canvasHeight, canvasWidth, chartHeight, chartWidth, context, mime, mime_map, scale, _ref;
    if (type == null) {
      type = "png";
    }
    if (transparent === void 0) {
      transparent = type === "png";
    }
    mime_map = {
      "png": "image/png",
      "jpeg": "image/jpeg"
    };
    mime = mime_map[type];
    _ref = Base_Export.exportToImageGetDimensions(chart, dimensions), canvasWidth = _ref[0], canvasHeight = _ref[1], scale = _ref[2], chartWidth = _ref[3], chartHeight = _ref[4];
    canvas = document.createElement("canvas");
    canvas.width = canvasWidth;
    canvas.height = canvasHeight;
    context = canvas.getContext("2d");
    if (!transparent) {
      context.fillStyle = "#fff";
      context.fillRect(0, 0, canvas.width, canvas.height);
    }
    chart.events.exportToContext(context, (canvasWidth - chartWidth * scale) / 2, (canvasHeight - chartHeight * scale) / 2, scale);
    return canvas.toDataURL(mime);
  };

  Base_Export.exportToPdf = function(chart, dimensions, transparent) {
    var a4, dh, doc, dpi, dw, h, o, out, p, ph, pw, s, scale, w;
    s = chart.events.exportToImageGetDimensions();
    p = [10, 10, 10, 10];
    a4 = [];
    pw = ph = 0;
    dw = dh = 0;
    dpi = 72;
    scale = 1;
    w = h = 0;
    if (s[0] >= s[1]) {
      a4 = [297, 210];
      o = "l";
    } else {
      a4 = [210, 297];
      o = "p";
    }
    pw = a4[0] / 25.4 * dpi;
    ph = a4[1] / 25.4 * dpi;
    scale = Math.min(ph / s[1], pw / s[0]);
    if (o === "l") {
      w = s[0] * scale / pw * a4[0] - p[1] - p[3];
      dw = (a4[0] - w - p[1] - p[3]) / 2;
      h = s[1] / s[0] * w;
      dh = (a4[1] - p[0] - p[2] - h) / 2;
    } else {
      h = s[1] * scale / ph * a4[1] - p[0] - p[2];
      dh = (a4[1] - h - p[0] - p[2]) / 2;
      w = s[0] / s[1] * h;
      dw = (a4[0] - p[1] - p[3] - w) / 2;
    }
    out = Base_Export.exportToImage(chart, "jpeg", {
      scaling: scale * 3
    }, transparent);
    doc = new jsPDF(o, "mm", "a4");
    doc.addImage(out, 'JPEG', p[3] + dw, p[0] + dh, w, h);
    return doc.output('datauristring');
  };

  Base_Export.exportAndStartDownload = function(chart, type, dimensions, transparent) {
    var doExport, mime, mime_map, out, payload;
    if (type == null) {
      type = "png";
    }
    if (dimensions == null) {
      dimensions = {};
    }
    mime_map = {
      "png": "image/png",
      "jpeg": "image/jpeg",
      "csv": "text/csv",
      "xls": "application/vnd.ms-excel"
    };
    mime = mime_map[type];
    if (type === "csv" || type === "xls") {
      payload = JSON.stringify(chart.exportVisibleData());
      this.proxyExport(chart, mime, payload, "json", {});
    }
    if (type === "png" || type === "jpeg") {
      out = Base_Export.exportToImage(chart, type, dimensions, transparent);
      return this.proxyExport(chart, mime, out, "base64", dimensions);
    } else if (type === "pdf") {
      doExport = (function(_this) {
        return function() {
          var pdf;
          pdf = Base_Export.exportToPdf(chart, dimensions, transparent);
          return _this.proxyExport(chart, "application/pdf", pdf, "base64", {});
        };
      })(this);
      if (!chart.assetsLoader.load(chart.settings.advanced.pdfExportAssets, doExport)) {
        return doExport();
      }
    } else {
      return chart.error("Unrecognized export type: " + type);
    }
  };

  Base_Export.exportToImageGetDimensions = function(chart, dimensions) {
    var chartHeight, chartWidth, height, pixelsPerMM, scale, width, _ref;
    _ref = chart.events.exportToImageGetDimensions(), chartWidth = _ref[0], chartHeight = _ref[1];
    width = parseFloat(dimensions.width);
    height = parseFloat(dimensions.height);
    if (width > 0 && height > 0) {
      scale = Math.min(width / chartWidth, height / chartHeight);
    } else if (width > 0) {
      scale = width / chartWidth;
      height = chartHeight * scale;
    } else if (height > 0) {
      scale = height / chartHeight;
      width = chartWidth * scale;
    } else {
      scale = dimensions.scaling > 0 ? parseFloat(dimensions.scaling) : 1;
      scale *= Math.max(chart.events.scaleX, chart.events.scaleY);
      width = chartWidth * scale;
      height = chartHeight * scale;
    }
    if (dimensions.unit === "mm") {
      if (dimensions.dpi > 0 && dimensions.width > 0 && dimensions.height > 0) {
        pixelsPerMM = parseFloat(dimensions.dpi) / 25.4;
        scale *= pixelsPerMM;
        width *= pixelsPerMM;
        height *= pixelsPerMM;
      } else {
        throw "Invalid export configuration. If unit = mm, dpi, width and height must be supplied";
      }
    }
    return [width, height, scale, chartWidth, chartHeight];
  };

  Base_Export.proxyExport = function(chart, type, data, encoding, dimensions) {
    var b, dpi, f, f1, f2, f3, f4;
    f = Base_Helpers.createDom("form");
    f.setAttribute("action", chart.settings.advanced.exportProxyURL);
    f.setAttribute("method", "POST");
    f.setAttribute("style", "display:none");
    f1 = Base_Helpers.createDom("input", null, null, f);
    f1.setAttribute("type", "hidden");
    f1.setAttribute("name", "type");
    f1.setAttribute("value", type);
    f2 = Base_Helpers.createDom("input", null, null, f);
    f2.setAttribute("type", "hidden");
    f2.setAttribute("name", "encoding");
    f2.setAttribute("value", encoding);
    f3 = Base_Helpers.createDom("input", null, null, f);
    f3.setAttribute("type", "hidden");
    f3.setAttribute("name", "data");
    f3.setAttribute("value", data);
    dpi = parseInt(dimensions.dpi);
    if (dpi > 0) {
      f4 = Base_Helpers.createDom("input", null, null, f);
      f4.setAttribute("type", "hidden");
      f4.setAttribute("name", "setdpi");
      f4.setAttribute("value", dpi);
    }
    b = document.getElementsByTagName("body")[0];
    b.appendChild(f);
    f.submit();
    return b.removeChild(f);
  };

  return Base_Export;

})();
// Generated by CoffeeScript 1.8.0
var Timechart_Scrolling,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

Timechart_Scrolling = (function(_super) {
  "use strict";
  __extends(Timechart_Scrolling, _super);

  Timechart_Scrolling.prototype.animationOrder = 600;

  Timechart_Scrolling.prototype.paintOrder = 10;

  Timechart_Scrolling.prototype.updateOrder = 1400;

  Timechart_Scrolling.settings = {
    _doc: {
      doc: "Scrolling settings.",
      type: "section"
    },
    limitMode: "snapBack",
    limitMode_doc: {
      doc: "Scrolling limit mode. The actual limits are stored in limitFrom and limitTo.",
      type: "enum",
      values: {
        "snapBack": "allow scrolling past the limit but scroll pack.",
        "block": "do not allow to scroll past the limit",
        "null": "no limit scroll"
      }
    },
    limitFrom: "oldestData",
    limitFrom_doc: {
      doc: "Limits scrolling in the left side.",
      type: "enum",
      values: {
        "timestamp": "limits to a specific timestamp in milliseconds",
        "oldestData": "limits to oldest timestamp in data",
        "null": "no limit"
      }
    },
    limitTo: "newestData",
    limitTo_doc: {
      doc: "Limits scrolling in the right side.",
      type: "enum",
      values: {
        "timestamp": "limits to a specific timestamp in milliseconds",
        "oldestData": "limits to oldest timestamp in data",
        "null": "no limit"
      }
    },
    overscrollProportion: 0
  };

  Timechart_Scrolling.prototype.animationUnit = null;

  Timechart_Scrolling.prototype.targetUnit = null;

  Timechart_Scrolling.prototype.dragStartBar0 = null;

  Timechart_Scrolling.prototype.dragStartBar1 = null;

  Timechart_Scrolling.prototype.dragStartUnit = null;

  function Timechart_Scrolling(chart) {
    Timechart_Scrolling.__super__.constructor.call(this, chart);
    this.s = new Timechart_TimeSetup(this.scene.settings);
  }

  Timechart_Scrolling.prototype.setTimeRangeSnap = function(from, to, origin, desiredUnit, animate, notifyOrigin, scroll, scale) {
    var anchor, period, unit, _ref;
    _ref = this.snap(from, to, origin, desiredUnit, scroll, scale), from = _ref[0], to = _ref[1], unit = _ref[2], period = _ref[3], anchor = _ref[4];
    return this.setTimeRange(from, to, unit, animate, notifyOrigin, anchor, period);
  };

  Timechart_Scrolling.prototype.computeDisplayPeriod = function(period, anchor, unitStr, dataFrom, dataTo) {
    var from, to, unit, _ref;
    _ref = this.s.tryComputeDisplayPeriod(period, anchor, unitStr, dataFrom, dataTo, this.scene, this.scene.getCurTime()), from = _ref[0], to = _ref[1], unit = _ref[2];
    if (from === null || to === null) {
      return [null, null, null];
    }
    return this.computeTimeRangeExtend(from, to, unit);
  };

  Timechart_Scrolling.prototype.computeTimeRangeExtend = function(from, to, unit) {

    /*
      For scaling - snaps both ends to full/partial block
     */
    var _ref;
    if (unit == null) {
      unit = this.s.computeDisplayUnit(this.scene.timeStart, this.scene.timeEnd, this.scene.displayUnit, from, to, this.scene);
    }
    from = unit.roundTimeDown(from);
    to = unit.roundTimeUp(to);
    if (to === from) {
      to = unit.add(to, 1);
    }
    _ref = this._preventOverscroll(from, to, unit, true), from = _ref[0], to = _ref[1];
    return [from, to, unit];
  };

  Timechart_Scrolling.prototype.computeDisplayUnit = function(from, to) {
    var oldEnd, oldStart, oldUnit;
    oldStart = this.dragStartFrom !== null ? this.dragStartFrom : this.scene.timeStart;
    oldEnd = this.dragStartTo !== null ? this.dragStartTo : this.scene.timeEnd;
    oldUnit = this.dragStartUnit ? this.dragStartUnit : this.scene.displayUnit;
    return this.s.computeDisplayUnit(oldStart, oldEnd, oldUnit, from, to, this.scene);
  };


  /*
    Just sets the specified time range (with optional animation).
   */

  Timechart_Scrolling.prototype.setTimeRange = function(from, to, unit, animate, notifyOrigin, anchor, period) {
    if (anchor == null) {
      anchor = null;
    }
    if (period == null) {
      period = null;
    }
    if (!(from < to || unit)) {
      return;
    }
    from = Math.round(from);
    to = Math.round(to);
    if ((unit == null) && from < to) {
      unit = this.computeDisplayUnit(from, to);
    }
    if (from !== this.getFrom() || to !== this.getTo() || !unit.isEqual(this.scene.displayUnit)) {
      this.scene.anchor = anchor;
      this.scene.period = period;
      this.targetUnit = unit;
      this.animationUnit = (unit == null) || (this.scene.displayUnit && unit.toString() !== this.scene.displayUnit.toString()) ? null : unit;
      this.goToPosition(from, to, animate);
      this.events.notifySceneChanges({
        time: true
      });
      if (notifyOrigin) {
        return this.chart.notifyTimeChanged(from, to, unit, notifyOrigin);
      }
    }
  };

  Timechart_Scrolling.prototype.zoomOut = function(displayPeriod, from, to, animate, notifyOrigin) {
    var origin, _ref;
    origin = (from + to) / 2;
    _ref = this.computeZoomOut(from, to, displayPeriod), from = _ref[0], to = _ref[1];
    return this.setTimeRangeSnap(from, to, origin, null, animate, notifyOrigin, false, true);
  };

  Timechart_Scrolling.prototype.zoomIn = function(unit, center, from, to, animate, notifyOrigin) {
    var _ref;
    if (center === null) {
      center = (from + to) / 2;
    }
    _ref = this.onZoomIn(from, to, center, 0.5), from = _ref[0], to = _ref[1];
    return this.setTimeRangeSnap(from, to, center, unit, animate, notifyOrigin, false, true);
  };

  Timechart_Scrolling.prototype.xyInArea = function(x, y) {
    return this.scene.xyInChart(x, y);
  };

  Timechart_Scrolling.prototype.xyToPosition = function(x, y) {
    return this.scene.xToTime(x);
  };

  Timechart_Scrolling.prototype.onZoomOut = function(from, to, origin, scale) {
    if (scale == null) {
      scale = null;
    }
    if (scale) {
      return Timechart_Scrolling.__super__.onZoomOut.call(this, from, to, origin, scale);
    } else {
      return this.computeZoomOut(from, to, null);
    }
  };

  Timechart_Scrolling.prototype.onZoomIn = function(from, to, center, scale) {
    var _ref;
    if (scale == null) {
      scale = null;
    }
    if (scale) {
      return Timechart_Scrolling.__super__.onZoomIn.call(this, from, to, center, scale);
    } else if (this.dragStartBar0) {
      from = this.dragStartBar0;
      to = this.dragStartBar1;
      if (to - from > this.scene.timeEnd - this.scene.timeStart) {
        _ref = this.scene.getClickBar(center), from = _ref[0], to = _ref[1];
      }
    }
    return [from, to];
  };

  Timechart_Scrolling.prototype.onScroll = function(from, to, direction) {
    return this.s.scroll(from, to, this.scene.displayUnit, direction, 1, "page");
  };

  Timechart_Scrolling.prototype.onGoHome = function(from, to) {
    var dataTo, dt;
    dataTo = this.scene.getDisplayLimits()[1];
    if (dataTo === null) {
      return [from, to];
    }
    this.scene.anchor = "newestData";
    dt = to - from;
    return [dataTo - dt, dataTo, dataTo];
  };

  Timechart_Scrolling.prototype.onStartDragging = function(oldFrom, oldTo, pos) {
    var _ref;
    this.animationUnit = null;
    this.scene.anchor = null;
    this.dragStartUnit = this.scene.displayUnit;
    return _ref = this.scene.getClickBar(pos), this.dragStartBar0 = _ref[0], this.dragStartBar1 = _ref[1], _ref;
  };

  Timechart_Scrolling.prototype.onSnapWhileDragging = function(from, to, origin, isScrolling, isScaling) {
    var unit, _ref, _ref1;
    this._minDisplayRange = this.scene.settings.area._minDisplayRange;
    _ref = this._preventOverscale(from, to, null, origin, false), from = _ref[0], to = _ref[1];
    unit = this.computeDisplayUnit(from, to);
    _ref1 = this._preventOverscroll(from, to, unit, false), from = _ref1[0], to = _ref1[1];
    this.events.notifySceneChanges({
      time: true
    });
    return [from, to];
  };

  Timechart_Scrolling.prototype.onSnapAfterDragging = function(from, to, origin, isScrolling, isScaling) {
    var anchor, period, unit, _ref, _ref1, _ref2;
    _ref = this.snap(from, to, origin, unit, isScrolling, isScaling), from = _ref[0], to = _ref[1], unit = _ref[2], period = _ref[3], anchor = _ref[4];
    this.targetUnit = unit;
    this.animationUnit = !isScaling || (unit && this.scene.displayUnit.isEqual(unit)) ? this.scene.displayUnit : null;
    this.scene.period = period;
    this.scene.anchor = anchor;
    _ref1 = [null, null], this.dragStartBar0 = _ref1[0], this.dragStartBar1 = _ref1[1];
    _ref2 = [null, null, null], this.dragStartFrom = _ref2[0], this.dragStartTo = _ref2[1], this.dragStartUnit = _ref2[2];
    this.events.notifySceneChanges({
      time: true
    });
    this.chart.notifyTimeChanged(from, to, unit, "user");
    return [from, to];
  };

  Timechart_Scrolling.prototype.onPositionChanged = function(from, to) {
    var unit;
    if (this.animationUnit != null) {
      unit = this.animationUnit;
    } else {
      unit = this.computeDisplayUnit(from, to);
    }
    this.scene.setTimeRange(from, to, unit);
    return this.events.notifySceneChanges({
      time: true
    });
  };

  Timechart_Scrolling.prototype.onAnimationDone = function(from, to) {
    var unit;
    if (this.targetUnit) {
      unit = this.targetUnit != null ? this.targetUnit : this.computeDisplayUnit(from, to);
      this.scene.setTimeRange(from, to, unit);
    }
    this.targetUnit = null;
    this.animationUnit = null;
    return this.chart.notifyAnimationDone();
  };

  Timechart_Scrolling.prototype.computeZoomOut = function(from, to, unit) {
    var p;
    if (unit == null) {
      p = this.s.getBiggerDisplayPeriod(this.scene.timeStart, this.scene.timeEnd);
      if (p != null) {
        unit = p.displayPeriod;
      }
    }
    if (unit == null) {
      return [from, to];
    }
    from = unit.roundTimeDown(from);
    to = unit.roundTimeUp(to);
    return [from, to];
  };


  /*
     Takes the time range and applies snapping rules from settings.
   */

  Timechart_Scrolling.prototype.snap = function(from, to, origin, desiredUnit, scroll, scale) {
    var anchor, dataFrom, dataTo, diff, fd, from0, isYears, numberOfUnits, period, range, snapMode, snapUnit, sp, td, to0, unit, _ref, _ref1, _ref2, _ref3;
    if (desiredUnit == null) {
      desiredUnit = null;
    }
    if ((this.scene.settings.interaction.scrolling.limitMode != null) && scale) {
      if (scale) {
        _ref = this._preventOverscale(from, to, desiredUnit, origin, true), from = _ref[0], to = _ref[1];
      }
    }
    if (desiredUnit) {
      unit = desiredUnit;
    } else if (!scale) {
      unit = this.scene.displayUnit;
    } else {
      unit = this.computeDisplayUnit(from, to);
    }
    if (scroll || scale) {
      diff = to - from;
      _ref1 = this._preventOverscroll(from, to, unit, false), from = _ref1[0], to = _ref1[1];
      _ref2 = this._preventOverscroll(from, to, unit, true), from = _ref2[0], to = _ref2[1];
      scale || (scale = to - from !== diff);
    }
    if (!desiredUnit && scale) {
      unit = this.computeDisplayUnit(from, to);
      return this.snap(from, to, origin, unit, scroll, scale);
    }
    from0 = from;
    to0 = to;
    period = scale ? null : this.scene.period;
    anchor = this.scene.anchor;
    snapMode = this.scene.settings.interaction.snapMode;
    if (snapMode) {
      isYears = this.scene.majorTimeUnit.unit === "y";
      if (snapMode === "displayUnit") {
        snapUnit = unit;
      } else if (snapMode === "multiperiod" || snapMode === "period") {
        range = to - from;
        _ref3 = this.scene.getDisplayLimits(), dataFrom = _ref3[0], dataTo = _ref3[1];
        if (dataFrom != null) {
          range = Math.min(range, dataTo - dataFrom);
        }
        sp = this.s.getClosestDisplayPeriod(range, this.scene.majorTimeUnit, snapMode === "multiperiod" || isYears);
        if (sp.displayUnit != null) {
          unit = sp.displayUnit;
        }
        snapUnit = sp.displayPeriod;
        period = sp.displayPeriod;
        anchor = sp.displayAnchor || anchor;
      }
      if (snapMode === "period" && !isYears) {
        from = snapUnit.roundTimeDown(origin);
        to = snapUnit.add(from, 1);
      } else {
        if (scale) {
          from = snapUnit.roundTimeRound(from);
          to = snapUnit.roundTimeRound(to);
        } else {
          numberOfUnits = Math.max(snapUnit.numberOfUnits(from, to), 1);
          fd = Math.abs(snapUnit.roundTimeRound(from) - from);
          td = Math.abs(snapUnit.roundTimeRound(to) - to);
          if (fd < td) {
            from = snapUnit.roundTimeRound(from);
            to = snapUnit.add(from, numberOfUnits);
          } else {
            to = snapUnit.roundTimeRound(to);
            from = snapUnit.sub(to, numberOfUnits);
          }
        }
      }
    } else {
      from = Math.round(from);
      to = Math.round(to);
    }
    return [from, to, unit, period, anchor];
  };

  Timechart_Scrolling.prototype._snapToAnchor = function(from, to, unit) {
    var direction, dt, time;
    if (this.scene.anchor === "now") {
      time = this.scene.getCurTime();
      direction = -1;
    } else if (this.scene.anchor === "newestData") {
      time = this.scene.mainData.dataTo;
      direction = -1;
    }
    if ((time != null) && direction === -1 && to > time) {
      dt = time - to;
      to = unit.roundTimeUp(to + dt);
      from = unit.roundTimeUp(from + dt);
    }
    return [from, to];
  };

  Timechart_Scrolling.prototype._preventOverscroll = function(from, to, unit, isFinal) {
    var dataFrom, dataTo, _ref;
    _ref = this.scene.getDisplayLimits(), dataFrom = _ref[0], dataTo = _ref[1];
    return this.s.preventOverscroll(unit, from, to, dataFrom, dataTo, this.scene.getCurTime(), isFinal);
  };

  Timechart_Scrolling.prototype._preventOverscale = function(from, to, unit, center, isFinal) {
    var dataFrom, dataTo, units, _ref;
    _ref = this.scene.getDisplayLimits(), dataFrom = _ref[0], dataTo = _ref[1];
    if (unit) {
      units = [unit];
    } else {
      unit = this.scene.displayUnit;
      units = this.scene.settings.area._displayUnitsParsed;
    }
    return this.s.preventOverscale(this.scene, units, center, from, to, unit, dataFrom, dataTo, this.scene.getCurTime(), isFinal);
  };

  return Timechart_Scrolling;

})(Linearchart_Scrolling);
// Generated by CoffeeScript 1.8.0
var Timechart_Selection,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

Timechart_Selection = (function(_super) {
  "use strict";
  __extends(Timechart_Selection, _super);

  Timechart_Selection.prototype.animationOrder = 500;

  Timechart_Selection.prototype.paintOrder = 15;

  Timechart_Selection.prototype.updateOrder = 1300;

  Timechart_Selection.settings = {
    _doc: {
      doc: "Configurable settings to select specific time period.",
      type: "section"
    },
    enabled: true,
    enabled_doc: {
      doc: "Enable/disable selection",
      type: "bool"
    },
    tolerance: 6,
    tolerance_doc: {
      doc: "Distance from selected object sides to move it.",
      type: "float",
      units: "pixels"
    }
  };

  function Timechart_Selection(chart) {
    this.chart = chart;
    this.scene = chart.scene;
    this.selectStart = null;
    this.selectingPointer = null;
    this.isSelecting = false;
    this.lastX = 0;
    this.lastY = 0;
    this.roundAround = false;
    this.selectionRemoved = false;
  }

  Timechart_Selection.prototype.onSceneChange = function(event) {
    if ((event.changes.time || event.changes.bounds) && (this.selectStart != null)) {
      event.x = this.lastX;
      event.y = this.lastY;
      event.identifier = this.selectingPointer;
      return this.onPointerDrag(event);
    }
  };

  Timechart_Selection.prototype.paintScene = function(event) {
    var g, h, labelRenderer, leftText, ll, rectangles, rightText, rl, textWidthLeft, textWidthRight, x0, x2, xL, xR, xSpace, y, y0, y2, ySpace;
    if (!(this.scene.selectionStart && this.scene.selectionEnd)) {
      return;
    }
    x0 = Math.round(this.scene.x0);
    x2 = Math.round(x0 + this.scene.width);
    y0 = Math.round(this.scene.y0);
    y2 = Math.round(y0 + this.scene.height + this.scene.bottomAxisSize);
    xL = Math.round(this.scene.timeToX(this.scene.selectionStart));
    xR = Math.round(this.scene.timeToX(this.scene.selectionEnd));
    h = this.scene.height + this.scene.bottomAxisSize;
    leftText = moment(this.scene.selectionStart).utc().format(this.scene.minorTimeFormat);
    rightText = moment(Math.max(this.scene.selectionStart, this.scene.selectionEnd - 1)).utc().format(this.scene.minorTimeFormat);
    g = event.context;
    Base_Graphics.pushClip(g, x0, y0, this.scene.width, h);
    Base_Graphics.rectStyle(g, this.scene.settings.area.style.selection);
    g.fillRect(xL, y0, xR - xL, h);
    g.beginPath();
    g.moveTo(xL, y0);
    g.lineTo(xL, y2);
    g.moveTo(xR, y0);
    g.lineTo(xR, y2);
    Base_Graphics.stroke(g, this.scene.settings.area.style.selection);
    labelRenderer = event.labelRenderer;
    textWidthLeft = g.measureText(leftText).width;
    textWidthRight = g.measureText(rightText).width;
    ll = new Base_Label();
    rl = new Base_Label();
    ll.text = leftText;
    rl.text = rightText;
    ll.textStyle = rl.textStyle = this.scene.settings.area.style.selectionLabel;
    ySpace = 10;
    xSpace = 5;
    rectangles = this.chart.toolbar ? this.chart.toolbar.getTopInsidePanelBoundingRectangles() : [];
    if (xL < x0) {
      xL = x0;
    }
    if (xR > x2) {
      xR = x2;
    }
    if (textWidthLeft + textWidthRight + 20 < xR - xL) {
      xL = xL + xSpace;
      xR = xR - textWidthRight - xSpace;
    } else {
      xL = xL - textWidthLeft - xSpace;
      xR = xR + xSpace;
    }
    y = this.testLabelOverlapWithToolbar(rectangles, xL, textWidthLeft) || y0;
    labelRenderer.paintWithStyle(g, xL + textWidthLeft / 2, y + ySpace, 1, ll, ll);
    y = this.testLabelOverlapWithToolbar(rectangles, xR, textWidthRight) || y0;
    labelRenderer.paintWithStyle(g, xR + textWidthRight / 2, y + ySpace, 1, rl, rl);
    return Base_Graphics.popClip(g);
  };

  Timechart_Selection.prototype.testLabelOverlapWithToolbar = function(toolbarRectangles, labelX, labelWidth) {
    var rect, _i, _len;
    for (_i = 0, _len = toolbarRectangles.length; _i < _len; _i++) {
      rect = toolbarRectangles[_i];
      if (rect.x0 > labelX + labelWidth || rect.x1 < labelX) {
        continue;
      }
      return rect.y1;
    }
    return null;
  };

  Timechart_Selection.prototype.onPointerMove = function(event) {
    var s0X, s1X;
    if (!this.scene.settings.interaction.selection.enabled) {
      return;
    }
    if (this.scene.xyInBottom(event.x, event.y)) {
      event.cursor = "text";
    }
    if (this.scene.selectionStart && this.scene.selectionEnd && this.scene.xyInChartOrBottom(event.x, event.y) && this.scene.timeStart < this.scene.timeEnd) {
      s0X = this.scene.timeToX(this.scene.selectionStart);
      s1X = this.scene.timeToX(this.scene.selectionEnd);
      if (Math.abs(s1X - event.x) <= this.scene.settings.interaction.selection.tolerance) {
        event.cursor = "e-resize";
        return event.consumed = true;
      } else if (Math.abs(s0X - event.x) <= this.scene.settings.interaction.selection.tolerance) {
        event.cursor = "w-resize";
        return event.consumed = true;
      }
    }
  };

  Timechart_Selection.prototype.onPointerDown = function(event) {
    var s0X, s1X, x0, x1;
    if ((!this.scene.xyInChartOrBottom(event.x, event.y)) || (this.selectingPointer != null) || (!this.scene.settings.interaction.selection.enabled)) {
      return;
    }
    this.selectionRemoved = false;
    this.lastX = event.x;
    this.lastY = event.y;
    if ((this.scene.selectionStart != null) || (this.scene.selectionEnd != null)) {
      x0 = this.scene.timeToX(this.scene.selectionStart);
      x1 = this.scene.timeToX(this.scene.selectionEnd);
      s0X = Math.abs(x0 - event.x);
      s1X = Math.abs(x1 - event.x);
      if (s0X < this.scene.settings.interaction.selection.tolerance && s0X <= s1X) {
        this.selectingPointer = event.identifier;
        this.selectStart = this.scene.selectionEnd;
        this.selectingPointer = event.identifier;
        event.consumed = true;
        this.roundAround = true;
        this.isSelecting = true;
        return;
      }
      if (s1X < this.scene.settings.interaction.selection.tolerance && s1X <= s0X) {
        this.selectStart = this.scene.selectionStart;
        this.selectingPointer = event.identifier;
        event.consumed = true;
        this.roundAround = true;
        this.isSelecting = true;
        return;
      }
    }
    if (this.scene.xyInBottom(event.x, event.y)) {
      this.selectingPointer = event.identifier;
      this.selectStart = this.scene.xToTime(event.x);
      event.capture = true;
      this.roundAround = true;
      if (event.x >= x0 && event.x <= x1) {
        return this.isSelecting = false;
      } else {
        if (this.scene.selectionStart != null) {
          this.selectionRemoved = true;
          this.scene.selectionStart = null;
          this.scene.selectionEnd = null;
          event.changes.selection = true;
        }
        return this.isSelecting = false;
      }
    }
  };

  Timechart_Selection.prototype.onPointerDrag = function(event) {
    var diff, filling, sign, startSnapped, t0, t1, time;
    if ((this.selectStart == null) || this.selectingPointer !== event.identifier) {
      return;
    }
    this.isSelecting = true;
    this.lastX = event.x;
    this.lastY = event.y;
    time = this.scene.xToTime(event.x);
    filling = Math.abs(this.selectStart - time);
    startSnapped = this.scene.snapTimeRound(this.selectStart);
    diff = startSnapped - this.selectStart;
    sign = Base_Helpers.sign(diff);
    startSnapped = this.selectStart + Math.min(diff * sign, filling * 0.9) * sign;
    if (this.selectStart < time) {
      t0 = startSnapped;
      t1 = time;
    } else {
      t0 = time;
      t1 = startSnapped;
    }
    this.scene.selectionStart = t0;
    this.scene.selectionEnd = t1;
    event.changes.selection = true;
    return event.consumed = true;
  };

  Timechart_Selection.prototype.onPointerUp = function(event) {
    var en, st, _ref;
    if ((this.selectStart == null) || this.selectingPointer !== event.identifier) {
      return;
    }
    if (this.isSelecting) {
      _ref = this.snapSelection(), st = _ref[0], en = _ref[1];
      if (st === en) {
        st = null;
        en = null;
      }
      this.scene.selectionStart = st;
      this.scene.selectionEnd = en;
      this.chart.notifySelectionChanged("user");
      event.changes.selection = true;
    }
    if (this.isSelecting || this.selectionRemoved) {
      event.consumed = true;
    }
    this.isSelecting = false;
    this.selectStart = null;
    return this.selectingPointer = null;
  };

  Timechart_Selection.prototype.onPointerCancel = function(event) {
    return this.onPointerUp(event);
  };

  Timechart_Selection.prototype.snapSelection = function() {
    var en, st;
    if (this.scene.selectionStart) {
      if (this.roundAround) {
        st = this.scene.snapTimeRound(this.scene.selectionStart);
        en = this.scene.snapTimeRound(this.scene.selectionEnd);
      } else {
        st = this.scene.snapTimeDown(this.scene.selectionStart);
        en = this.scene.snapTimeUp(this.scene.selectionEnd);
      }
    } else {
      st = null;
      en = null;
    }
    return [st, en];
  };

  return Timechart_Selection;

})(Base_ChartElement);
// Generated by CoffeeScript 1.8.0
var Timechart_Scene,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

Timechart_Scene = (function(_super) {
  "use strict";
  __extends(Timechart_Scene, _super);

  Timechart_Scene.prototype.settings = null;

  Timechart_Scene.prototype.timeStart = 0;

  Timechart_Scene.prototype.timeEnd = 0;

  Timechart_Scene.prototype.anchor = null;

  Timechart_Scene.prototype.period = null;

  Timechart_Scene.prototype.displayUnit = null;

  Timechart_Scene.prototype.data = {};

  Timechart_Scene.prototype.mainData = null;

  Timechart_Scene.prototype.selectionStart = null;

  Timechart_Scene.prototype.selectionEnd = null;

  Timechart_Scene.prototype.minorTimeFormat = null;

  Timechart_Scene.prototype.minorTimeUnit = null;

  Timechart_Scene.prototype.majorTimeFormat = null;

  Timechart_Scene.prototype.majorTimeUnit = null;

  Timechart_Scene.prototype.hoverFrom = null;

  Timechart_Scene.prototype.hoverTo = null;

  function Timechart_Scene(settings) {
    Timechart_Scene.__super__.constructor.call(this, settings);
  }

  Timechart_Scene.prototype.setTimeRange = function(minTime, maxTime, unit) {
    if (!unit) {
      Base_Helpers.error("Scene.setTimeRange: no display unit");
    }
    this.timeStart = minTime;
    this.timeEnd = maxTime;
    return this.displayUnit = unit;
  };

  Timechart_Scene.prototype.pixelsPerTime = function() {
    return this.width / (this.timeEnd - this.timeStart);
  };

  Timechart_Scene.prototype.getScale = function() {
    return (this.timeEnd - this.timeStart) / this.width;
  };

  Timechart_Scene.prototype.timeToX = function(time) {
    return this.x0 + this.width * (time - this.timeStart) / (this.timeEnd - this.timeStart);
  };

  Timechart_Scene.prototype.timeToXCoefs = function() {
    return [this.x0 - this.timeStart * this.width / (this.timeEnd - this.timeStart), this.width / (this.timeEnd - this.timeStart)];
  };

  Timechart_Scene.prototype.xToTime = function(x) {
    return this.timeStart + (this.timeEnd - this.timeStart) * (x - this.x0) / this.width;
  };

  Timechart_Scene.prototype.xToFraction = function(x) {
    return (x - this.x0) / this.width;
  };

  Timechart_Scene.prototype.dxToDtime = function(dx) {
    return dx / this.width * (this.timeEnd - this.timeStart);
  };

  Timechart_Scene.prototype.snapTimeDown = function(time) {
    return this.displayUnit.roundTimeDown(time);
  };

  Timechart_Scene.prototype.snapTimeUp = function(time) {
    return this.displayUnit.roundTimeUp(time);
  };

  Timechart_Scene.prototype.snapTimeRound = function(time) {
    return this.displayUnit.roundTimeRound(time);
  };

  Timechart_Scene.prototype.getDataLimits = function() {
    var from, to;
    from = this.mainData.dataLimitFrom;
    to = this.mainData.dataLimitTo;
    if (!((from != null) && (to != null))) {
      return [null, null];
    }
    if (this.displayUnit) {
      from = this.displayUnit.roundTimeDown(from);
      to = this.displayUnit.roundTimeUp(to);
    }
    return [from, to];
  };

  Timechart_Scene.prototype.getDisplayLimits = function() {
    var from, marker, to, _i, _len, _ref, _ref1;
    _ref = this.getDataLimits(), from = _ref[0], to = _ref[1];
    if (from === null) {
      return [null, null];
    }
    _ref1 = this.markers;
    for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
      marker = _ref1[_i];
      from = Math.min(from, marker.time);
      to = Math.max(to, marker.time);
    }
    return [from, to];
  };

  Timechart_Scene.prototype.getClickBar = function(time) {
    return [this.displayUnit.roundTimeDown(time), this.displayUnit.roundTimeUp(time + 1)];
  };

  Timechart_Scene.prototype.getCurTime = function() {
    return new Date().getTime() + this.settings.currentTime._computedTimeOffset;
  };

  return Timechart_Scene;

})(Linearchart_Scene);
// Generated by CoffeeScript 1.8.0
var Timechart_ClickNotifier,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

Timechart_ClickNotifier = (function(_super) {
  "use strict";
  __extends(Timechart_ClickNotifier, _super);

  Timechart_ClickNotifier.prototype.animationOrder = 600;

  Timechart_ClickNotifier.prototype.paintOrder = 20;

  Timechart_ClickNotifier.prototype.updateOrder = 1200;

  Timechart_ClickNotifier.prototype.chart = null;

  Timechart_ClickNotifier.prototype.scene = null;

  Timechart_ClickNotifier.prototype.pointer = null;

  function Timechart_ClickNotifier(chart) {
    this.chart = chart;
    this.scene = this.chart.scene;
  }

  Timechart_ClickNotifier.prototype.previewPointerMove = function(event) {
    this.pointer = null;
    return this.updateHover(event);
  };

  Timechart_ClickNotifier.prototype.onPointerOut = function(event) {
    this.scene.hoverSeriesItem = null;
    this.hoverEvent = null;
    event.changes.hover = true;
    return this.chart.notifyHoverChanged(event);
  };

  Timechart_ClickNotifier.prototype.previewPointerDown = function(event) {
    this.pointer = event.identifier;
    return this.updateHover(event);
  };

  Timechart_ClickNotifier.prototype.updateHover = function(event) {
    var g, hoverFrom, hoverSeriesItem, hoverTo, item, numBars, s, series, _i, _ref;
    g = this.getClickRange(event.x, event.y);
    hoverFrom = null;
    hoverTo = null;
    hoverSeriesItem = null;
    if (g) {
      hoverFrom = g[0], hoverTo = g[1], numBars = g[2];
      hoverSeriesItem = this.chart.renderer.hitTest(event.x, event.y);
    }
    if (this.chart.legend && !hoverSeriesItem) {
      item = this.chart.legend.findItemAt(event.x, event.y);
      series = this.scene.settings._computedSeries;
      for (s = _i = 0, _ref = series.length; _i < _ref; s = _i += 1) {
        if (item === series[s]) {
          hoverSeriesItem = {
            seriesIndex: s
          };
          event.cursor = "pointer";
        }
      }
    }
    if (hoverFrom !== this.scene.hoverFrom || hoverTo !== this.scene.hoverTo || (!hoverSeriesItem !== !this.scene.hoverSeriesItem) || (hoverSeriesItem && (hoverSeriesItem.seriesIndex !== this.scene.hoverSeriesItem.seriesIndex || hoverSeriesItem.x0 !== this.scene.hoverSeriesItem.x0))) {
      this.scene.hoverFrom = hoverFrom;
      this.scene.hoverTo = hoverTo;
      this.scene.hoverSeriesItem = hoverSeriesItem;
      event.changes.hover = true;
      return this.chart.notifyHoverChanged(event);
    }
  };

  Timechart_ClickNotifier.prototype.onClick = function(event) {
    var t;
    if (event.identifier === this.pointer) {
      if (this.scene.hoverFrom != null) {
        t = this.scene.xToTime(event.x);
        if ((this.scene.selectionStart != null) && (this.scene.selectionStart > t || this.scene.selectionEnd < t)) {
          this.scene.selectionStart = null;
          this.scene.selectionEnd = null;
          this.chart.notifySelectionChanged("user");
          event.changes.selection = true;
          return event.consumed = true;
        } else {
          this.buildClickEvent(event);
          this.chart.notifyClick(event);
          return event.consumed = true;
        }
      }
    }
  };

  Timechart_ClickNotifier.prototype.onRightClick = function(event) {
    var ue;
    if (this.scene.hoverFrom != null) {
      this.buildClickEvent(event);
      ue = this.chart.notifyRightClick(event);
      if (ue.defaultPrevented) {
        return event.consumed = true;
      }
    }
  };

  Timechart_ClickNotifier.prototype.onDoubleClick = function(event) {
    if (this.scene.hoverFrom != null) {
      this.buildClickEvent(event);
      this.chart.notifyDoubleClick(event);
      return event.consumed = true;
    }
  };


  /*
    Retrieves time range corresponding to click
   */

  Timechart_ClickNotifier.prototype.getClickRange = function(x, y) {
    var mt0, mt1, numBars, t0, t1, time, use1Bar;
    if (!this.scene.xyInChartOrBottom(x, y)) {
      return null;
    }
    time = this.scene.xToTime(x);
    if ((this.scene.selectionStart != null) && time >= this.scene.selectionStart && time < this.scene.selectionEnd) {
      t0 = this.scene.selectionStart;
      t1 = this.scene.selectionEnd;
      numBars = Math.max(2, this.scene.displayUnit.numberOfUnits(t0, t1));
    } else if (this.scene.displayUnit) {
      use1Bar = true;
      if (this.scene.majorTimeUnit != null) {
        mt0 = this.scene.majorTimeUnit.roundTimeDown(time);
        mt1 = this.scene.majorTimeUnit.roundTimeUp(time + 1);
        if (y > this.scene.y0 + this.scene.height && (mt0 > this.scene.timeStart || mt1 < this.scene.timeEnd)) {
          t0 = mt0;
          t1 = mt1;
          numBars = this.scene.displayUnit.numberOfUnits(t0, t1);
          use1Bar = false;
        }
      }
      if (use1Bar) {
        t0 = this.scene.displayUnit.roundTimeDown(time);
        t1 = this.scene.displayUnit.roundTimeUp(time + 1);
        numBars = 1;
      }
    } else {
      t0 = null;
      t1 = null;
      numBars = null;
    }
    return [t0, t1, numBars];
  };

  Timechart_ClickNotifier.prototype.buildClickEvent = function(event) {
    event.clickStart = this.scene.hoverFrom;
    event.clickEnd = this.scene.hoverTo;
    if (this.scene.hoverSeriesItem !== null) {
      event.clickSeries = this.scene.settings.series[this.scene.hoverSeriesItem.seriesIndex];
      return event.clickMarker = this.scene.hoverSeriesItem.isMarker;
    }
  };

  return Timechart_ClickNotifier;

})(Base_ChartElement);
// Generated by CoffeeScript 1.8.0
var Timechart_Navigator,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

Timechart_Navigator = (function(_super) {
  __extends(Timechart_Navigator, _super);

  function Timechart_Navigator(chart) {
    this.chart = chart;
    this.scene = chart.scene;
    this.settings = chart.settings;
    this.reinitializePeriod = true;
  }

  Timechart_Navigator.prototype.onSceneChange = function(event) {
    var ch;
    ch = event.changes;
    if (ch.settings && ch.settingsChanges.navigation) {
      this.reinitializePeriod = true;
    }
    if (this.reinitializePeriod) {
      return this.setupInitialDisplayPeriod();
    }
  };

  Timechart_Navigator.prototype.onNewDataObject = function() {
    return 1;
  };

  Timechart_Navigator.prototype.setupInitialDisplayPeriod = function() {
    var ianchor, iperiod, iunit;
    if (!this.scene.width) {
      return;
    }
    this.reinitializePeriod = false;
    ianchor = this.settings.navigation.initialDisplayAnchor;
    iperiod = this.settings.navigation.initialDisplayPeriod;
    iunit = this.settings.navigation.initialDisplayUnit;
    return this.computeDisplayPeriod(iperiod, ianchor, iunit, (function(_this) {
      return function(form, to, unit) {
        _this.scene.setMessage("impl", null);
        _this.scene.loading = false;
        if (_this.scene.displayUnit != null) {
          unit = _this.scene.displayUnit;
        }
        if (!_this.scene.timeStart && !_this.scene.timeEnd) {
          return _this.chart.scrolling.setTimeRange(form, to, unit, false, "init", ianchor, iperiod);
        }
      };
    })(this));
  };

  Timechart_Navigator.prototype.computeDisplayPeriod = function(periodStr, anchorStr, displayUnitStr, callback) {
    var dataLoaded, from, to, unit, _ref;
    _ref = this.chart.scrolling.computeDisplayPeriod(periodStr, anchorStr, displayUnitStr, this.scene.mainData.dataFrom, this.scene.mainData.dataTo), from = _ref[0], to = _ref[1], unit = _ref[2];
    if ((from != null) && (to != null) && unit) {
      if ((from != null) && (to != null)) {
        return callback(from, to, unit);
      }
    }
    if ((this.scene.mainData.dataSettings.dataFunction == null) && (this.scene.mainData.dataSettings.url == null) && (this.scene.mainData.dataSettings.urlByUnit == null) && (this.scene.mainData.dataSettings.preloaded == null)) {
      this.error("Cannot compute data dependant display period, no data given. DisplayPeriod = " + periodStr + ", DisplayAnchor = " + anchorStr);
      return;
    }
    dataLoaded = (function(_this) {
      return function(dataFrom, dataTo, dataUnit, oldFrom, oldTo, oldUnit) {
        var displayUnit, _ref1;
        if (_this.chart.removed) {
          return;
        }
        if (dataFrom === null || dataTo === null || (dataFrom === 0 && dataTo === 0 && _this.scene.mainData.noData)) {
          callback(oldFrom, oldTo, oldUnit);
          return;
        }
        _ref1 = _this.chart.scrolling.computeDisplayPeriod(periodStr, anchorStr, displayUnitStr, dataFrom, dataTo), from = _ref1[0], to = _ref1[1], displayUnit = _ref1[2];
        if (!((from != null) && (to != null))) {
          _this.error("Could not setup display time interval. Check your configuration.");
          return;
        }
        if (Timechart_TimeSetup.isSmallerOrEqualUnit(dataUnit, displayUnit.unit)) {
          return callback(from, to, displayUnit);
        } else {
          return _this.scene.mainData.determineDataLimits(displayUnit.unit, true, true, function(a, b, c) {
            return dataLoaded(a, b, c, dataFrom, dataTo, displayUnit);
          });
        }
      };
    })(this);
    return this.scene.mainData.determineDataLimits(null, true, true, (function(_this) {
      return function(a, b, c) {
        return dataLoaded(a, b, c, 0, 0, null);
      };
    })(this));
  };

  return Timechart_Navigator;

})(Base_ChartElement);
// Generated by CoffeeScript 1.8.0
var Base_Resizer,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

Base_Resizer = (function(_super) {
  __extends(Base_Resizer, _super);

  Base_Resizer.prototype.animationOrder = 2000;

  Base_Resizer.prototype.paintOrder = 65;

  Base_Resizer.prototype.updateOrder = 300;

  Base_Resizer.settings = {
    _doc: {
      doc_file: "base/settings/resizer.markdown",
      type: "section"
    },
    enabled: true,
    enabled_doc: {
      doc: "Enable/disable chart resizing.",
      type: "bool"
    },
    fixedAspect: false,
    fixedAspect_doc: {
      doc: "Whether to fix chart aspect ratio while resizing.",
      type: "bool"
    },
    visibilityDistance: 45,
    visibilityDistance_doc: {
      doc: "Max pointer distance from chart edge when resize handle appears.",
      type: "float",
      units: "pixels"
    },
    grabDistance: 10,
    grabDistance_doc: {
      doc: "Distance from chart edge that will be used for resizing.",
      type: "float",
      units: "pixels"
    }
  };

  function Base_Resizer(chart) {
    this.chart = chart;
    this.scene = this.chart.scene;
    this.options = this.scene.settings.interaction.resizing;
    this.layers = this.chart.layers;
    this.oh = 0;
    this.sy = 0;
    this.barVisible = false;
    this.resizing = false;
    this.aspect = null;
    if (this.layers.resizerBar) {
      this.chart.events.addContainer(this.layers.resizerBar);
    }
  }

  Base_Resizer.prototype.onSceneChange = function(ev) {
    if (!this.options.enabled) {
      return this.hideUI();
    }
  };

  Base_Resizer.prototype.onPointerOut = function(ev) {
    if (!this.options.enabled) {
      return;
    }
    return this.hideUI();
  };

  Base_Resizer.prototype.onPointerMove = function(ev) {
    var dy;
    if (!this.options.enabled) {
      return;
    }
    dy = this.scene.chartHeight - ev.y;
    if (dy < this.options.visibilityDistance) {
      if (!this.barVisible) {
        this.showUI();
      }
      if (dy < this.options.grabDistance) {
        ev.consumed = true;
        return ev.cursor = "ns-resize";
      }
    } else {
      if (this.barVisible) {
        return this.hideUI();
      }
    }
  };

  Base_Resizer.prototype.onPointerDown = function(ev) {
    var dy;
    if (!this.options.enabled) {
      return;
    }
    this.sy = ev.y;
    dy = this.scene.chartHeight - ev.y;
    this.resizing = dy < this.options.grabDistance && ev.y <= this.scene.chartHeight;
    if (this.resizing) {
      if (this.options.fixedAspect) {
        this.aspect = Math.max(1, this.chart.scene.chartWidth) / Math.max(1, this.chart.scene.chartHeight);
      } else {
        this.aspect = 0;
      }
      this.oh = this.scene.chartHeight;
      this.showUI();
      ev.cursor = "ns-resize";
      return ev.consumed = true;
    }
  };

  Base_Resizer.prototype.onDoubleClick = function(ev) {
    if (this.resizing) {
      return this.chart.setFullscreen(!this.chart.isFullscreen());
    }
  };

  Base_Resizer.prototype.onPointerDrag = function(ev) {
    if (!this.options.enabled) {
      return;
    }
    if (this.chart.isFullscreen()) {
      this.chart.setFullscreen(false);
      this.hideUI();
      return ev.consumed = true;
    } else if (this.resizing) {
      ev.consumed = true;
      this.wasMaximized = false;
      this.scene.settings.height = Math.min(this.scene.settings.maxHeight, Math.max(this.scene.settings.minHeight, this.oh + (ev.y - this.sy)));
      if (this.aspect) {
        this.scene.settings.width = this.scene.settings.height * this.aspect;
      }
      return this.chart.updateSize();
    }
  };

  Base_Resizer.prototype.showUI = function() {
    if (this.barVisible) {
      return;
    }
    this.barVisible = true;
    return Base_Helpers.fadeIn(this.layers.resizerBar);
  };

  Base_Resizer.prototype.hideUI = function() {
    if (!this.barVisible) {
      return;
    }
    this.barVisible = false;
    this.resizing = false;
    return Base_Helpers.fadeOut(this.layers.resizerBar);
  };

  return Base_Resizer;

})(Base_ChartElement);
// Generated by CoffeeScript 1.8.0
var Base_MessagesOverlay,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

Base_MessagesOverlay = (function(_super) {
  "use strict";
  __extends(Base_MessagesOverlay, _super);

  Base_MessagesOverlay.prototype.animationOrder = 2000;

  Base_MessagesOverlay.prototype.paintOrder = 70;

  Base_MessagesOverlay.prototype.updateOrder = 200;

  Base_MessagesOverlay.prototype.scene = null;

  Base_MessagesOverlay.prototype.loadingTime = null;

  function Base_MessagesOverlay(chart) {
    this.chart = chart;
    this.scene = chart.scene;
  }

  Base_MessagesOverlay.prototype.doAnimations = function(event) {
    if (this.scene.loading) {
      return event.animating = true;
    }
  };

  Base_MessagesOverlay.prototype.paintScene = function(event) {
    var a, arcStyle, g, grad, height, loading, msg, r, scene, w, width, x, y, yy;
    scene = this.scene;
    msg = this.scene.getMessage();
    loading = this.scene.loading;
    if (!loading) {
      this.loadingTime = null;
    }
    if (!((msg != null) || loading)) {
      return;
    }
    if (this.loadingTime == null) {
      this.loadingTime = event.timeStamp;
    }
    arcStyle = this.scene.settings.advanced.style.loadingArcStyle;
    g = event.context;
    if (arcStyle.location === "corner") {
      x = scene.x0 + scene.width;
      y = scene.y0;
    } else {
      x = scene.x0 + scene.width / 2;
      y = scene.y0 + scene.height / 2;
    }
    if (msg != null) {
      Base_Graphics.textStyle(g, this.scene.settings.advanced.style.messageTextStyle);
      g.textBaseline = "middle";
      g.textAlign = "center";
      height = Base_Graphics.getTextHeight(g, this.scene.settings.advanced.style.messageTextStyle.font);
      width = g.measureText(msg).width;
      if (arcStyle.location === "corner") {
        x -= width;
        y += height * 1.5;
      }
      if (this.scene.loading) {
        y -= height;
        yy = y + arcStyle.r + height;
      } else {
        yy = y;
      }
      g.fillText(msg, x, yy);
    }
    if (this.scene.loading) {
      r = arcStyle.r;
      w = arcStyle.lineWidth;
      if (!msg && arcStyle.location === "corner") {
        x -= (r + w) * 1.2;
        y += (r + w) * 1.2;
      }
      g.save();
      g.lineCap = 'round';
      g.lineWidth = w;
      a = (event.timeStamp - this.loadingTime) / 700 * Math.PI;
      grad = g.createLinearGradient(x + r * Math.cos(a + Math.PI), y + r * Math.sin(a + Math.PI), x + r * Math.cos(a), y + r * Math.sin(a));
      grad.addColorStop(0, arcStyle.lineColor);
      grad.addColorStop(1, "transparent");
      g.strokeStyle = grad;
      g.beginPath();
      g.arc(x, y, r, a, a + Math.PI);
      g.stroke();
      return g.restore();
    }
  };

  return Base_MessagesOverlay;

})(Base_ChartElement);
// Generated by CoffeeScript 1.8.0
var Base_Title,
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

Base_Title = (function(_super) {
  "use strict";
  __extends(Base_Title, _super);

  Base_Title.prototype.animationOrder = 2000;

  Base_Title.prototype.paintOrder = 55;

  Base_Title.prototype.updateOrder = 500;

  Base_Title.settings = {
    _doc: {
      doc: "The chart's main title.",
      type: "section"
    },
    enabled: true,
    enabled_doc: {
      doc: "Show/hide chart title",
      type: "bool"
    },
    enabledOnExport: true,
    enabledOnExport_doc: {
      doc: "Whether to display title on the exported image. Note that it does not affect chart.",
      type: "bool"
    },
    align: "center",
    align_doc: {
      doc: "Alignment of the title text.",
      type: "enum",
      values: ["center", "left", "right"]
    },
    margin: 25,
    margin_doc: {
      doc: "Margin around title text, in px.",
      type: "float",
      units: "pixels"
    },
    style: {
      _doc: {
        doc: "Title style",
        type: "object"
      },
      font: "20px Arial",
      fillColor: "#000"
    },
    text: "",
    text_doc: {
      doc: "Title text.",
      type: "string"
    }
  };

  function Base_Title(chart) {
    this.chart = chart;
    this.computePanelSize = __bind(this.computePanelSize, this);
    this.scene = chart.scene;
    this.settings = this.scene.settings.title;
    this.lines = [];
    this.lineSpacing = 0;
    this.panel = new Base_ChartPanel();
    this.panel.packingOrder = 10;
    this.panel.side = "top";
    this.panel.align = "fill";
    this.panel.visible = false;
    this.panel.computeSize = this.computePanelSize;
  }

  Base_Title.prototype.onSceneChange = function(event) {
    var ch;
    ch = event.changes;
    if (ch.settings && ch.settingsChanges.title) {
      return ch.bounds = true;
    }
  };

  Base_Title.prototype.getPanels = function(forExport) {
    var _base;
    this.panel.visible = forExport ? this.settings.enabledOnExport : this.settings.enabled;
    (_base = this.panel).visible && (_base.visible = !!this.settings.text);
    this.panel.margin = this.settings.margin;
    if (this.panel.visible) {
      if (forExport && !this.settings.enabled) {
        this.panel.location = "external";
      } else {
        this.panel.location = "outsideFill";
      }
      return [this.panel];
    } else {
      return [];
    }
  };

  Base_Title.prototype.computePanelSize = function(availableWidth, availableHeight, g) {
    var h, i, line, line1, line1Width, lineWidth, text, w, width, words, _i, _ref;
    this.lines = [];
    text = this.settings.text;
    g.save();
    Base_Graphics.textStyle(g, this.settings.style);
    w = g.measureText(text).width;
    h = Base_Graphics.getTextHeight(g, this.settings.style.font);
    this.lineSpacing = h * 1.15;
    if (w > availableWidth) {
      width = 0;
      words = text.split(" ");
      line = words[0];
      lineWidth = g.measureText(line).width;
      for (i = _i = 1, _ref = words.length - 1; _i <= _ref; i = _i += 1) {
        line1 = line + " " + words[i];
        line1Width = g.measureText(line1).width;
        if (line1Width <= availableWidth) {
          line = line1;
          lineWidth = line1Width;
        } else {
          this.lines.push(line);
          w = Math.max(w, lineWidth);
          line = words[i];
          lineWidth = g.measureText(line).width;
        }
      }
      this.lines.push(line);
      w = Math.max(width, lineWidth);
    } else {
      this.lines.push(text);
    }
    g.restore();
    h = (this.lines.length - 1) * this.lineSpacing + h;
    return [w, h];
  };

  Base_Title.prototype.paintScene = function(event) {
    var g, left, line, right, title, x, y, _i, _len, _ref, _results;
    if (!this.panel.visible) {
      return;
    }
    title = this.settings;
    g = event.context;
    left = this.panel.left;
    right = this.panel.right;
    y = this.panel.top;
    Base_Graphics.textStyle(g, title.style);
    g.textBaseline = "top";
    if (title.align === "left") {
      g.textAlign = "start";
      x = left;
    } else if (title.align === "right") {
      g.textAlign = "end";
      x = right;
    } else {
      g.textAlign = "center";
      x = (left + right) / 2;
    }
    _ref = this.lines;
    _results = [];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      line = _ref[_i];
      g.fillText(line, x, y);
      _results.push(y += this.lineSpacing);
    }
    return _results;
  };

  return Base_Title;

})(Base_ChartElement);
// Generated by CoffeeScript 1.8.0
var Base_Legend, Base_Legend_Entry,
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

Base_Legend_Entry = (function() {
  function Base_Legend_Entry() {
    this.data = null;
    this.label = null;
    this.markerStyle = {};
    this.textColor = null;
  }

  return Base_Legend_Entry;

})();

Base_Legend = (function(_super) {
  "use strict";
  __extends(Base_Legend, _super);

  Base_Legend.prototype.animationOrder = 300;

  Base_Legend.settings = {
    _doc: {
      doc: "",
      type: "section"
    },
    enabled: false,
    enabled_doc: {
      doc: "Show/hide chart legend.",
      type: "bool"
    },
    width: null,
    width_doc: {
      doc: "Maximum width of the legend. If null, all available horizontal space of chart will be consumed to set as much entries as possible. It coincides with the chart width if legend panel side is on a top or bottom.",
      type: "float",
      units: "pixels"
    },
    height: null,
    height_doc: {
      doc: "Maximum height of the legend. If null, all available vertical space of chart will be consumed to set as much entries as possible. It coincides with the chart height if legend panel side is on a left or right.",
      type: "float",
      units: "pixels"
    },
    numberOfRows: null,
    numberOfRows_doc: {
      doc: "Max number of rows. Use in conjunction with side parameter under the legend panel that should be set as bottom or top in order to arrange entries by rows.",
      type: "integer",
      units: "rows"
    },
    numberOfColumns: null,
    numberOfColumns_doc: {
      doc: "Max number of columns. Use in conjunction with side parameter under the legend panel should be right or left in order to arrange entries by columns.",
      type: "integer",
      units: "columns"
    },
    margin: 1,
    margin_doc: {
      doc: "Margin around each legend entry.",
      type: "float",
      units: "pixels"
    },
    padding: 5,
    padding_doc: {
      doc: "Padding around each entry text and marker.",
      type: "float",
      units: "pixels"
    },
    maxLineSymbols: 15,
    maxLineSymbols_doc: {
      doc: "Max number of symbols used in one line of text that applies to any legend entry.",
      type: "integer",
      units: "symbols"
    },
    lineSpacing: 0.2,
    lineSpacing_doc: {
      doc: "Vertical space between the lines of text.",
      type: "float",
      units: "scale"
    },
    text: {
      _doc: {
        doc: "Text settings displaying in legend entries.",
        type: "object",
        baseObject: Base_Label.styleSettings
      },
      font: "12px Arial",
      fillColor: "#000"
    },
    marker: {
      _doc: {
        doc: "",
        type: "object"
      },
      size: 20,
      size_doc: {
        doc: "Marker size.",
        type: "float",
        units: "pixels"
      },
      alignment: "left",
      alignment_doc: {
        doc: "Marker position relative to text",
        type: "enum",
        values: ["left", "right"]
      },
      lineColor: "#fff",
      lineColor_doc: {
        doc: "Line color around marker shape",
        type: "color"
      }
    },
    equalizeRowsColumns: true,
    equalizeRowsColumns_doc: {
      doc: "Whether to order entries to get possibly equal number of items into columns or rows. If false, once the row or column is full of entries, the next element will be first in the new row or column/rows.",
      type: "bool"
    },
    panel: {
      _doc: {
        doc: "Legend enclosing panel settings.",
        type: "object",
        baseObject: Base_ChartPanel.styleSettings
      },
      margin: 1,
      padding: 0,
      align: "fill",
      side: "left"
    },
    advanced: {
      _doc: {
        doc: "Settings to configure the legend marker appearance if disabled series corresponded.",
        type: "section"
      },
      selectedBackground: "rgba(208,233,255,0.3)",
      selectedBackground_doc: {
        doc: "Background color for selected legend entry.",
        type: "color"
      },
      selectedBorder: "rgba(208,233,255,0.3)",
      selectedBorder_doc: {
        doc: "Border color for selected legend entry.",
        type: "color"
      },
      disabledSeries: {
        _doc: {
          doc: "Style for legend entry in case when disabled series presented.",
          type: "object"
        },
        fillColor: "rgba(191,187,185,0.3)",
        lineColor: "rgba(64,62,62,0.3)",
        textColor: "rgba(64,62,62,0.3)"
      }
    }
  };

  function Base_Legend(chart) {
    this.chart = chart;
    this.computePanelSize = __bind(this.computePanelSize, this);
    this.scene = chart.scene;
    this.settings = this.scene.settings.legend;
    this.panel = new Base_ChartPanel();
    this.panel.packingOrder = 50;
    this.panel.location = "outside";
    this.panel.computeSize = this.computePanelSize;
    this.entries = [];
    this.hoverObject = null;
    this.selectedObjects = [];
    this.entryWidth = 0;
    this.entryHeight = 0;
    this.textHeight = 0;
    this.columns = null;
    this.rows = null;
    this.contentWidth = 0;
    this.contentHeight = 0;
    this.baseTextColor = null;
    this.markerSize = 0;
    this.drawingEntries = 0;
    this.orientation = this.settings.panel.side === "left" || this.settings.panel.side === "right" ? "vertical" : "horizontal";
    this.lastInsensitive = false;
  }

  Base_Legend.prototype.onSceneChange = function(event) {
    var ch;
    ch = event.changes;
    if (ch.settings && ch.settingsChanges.legend) {
      ch.bounds = true;
      if (!this.settings.enabled) {
        this.entries = [];
      }
      return this.labelStyle = {
        textStyle: this.settings.text,
        align: "left",
        lineSpacing: this.settings.lineSpacing,
        padding: 0
      };
    }
  };


  /*
    data is array of {label, data, fillColor, lineColor}
   */

  Base_Legend.prototype.setItems = function(data) {
    var entry, i, label, _i, _len, _results;
    if (!this.settings.enabled) {
      return;
    }
    this.entries = [];
    _results = [];
    for (_i = 0, _len = data.length; _i < _len; _i++) {
      i = data[_i];
      entry = new Base_Legend_Entry();
      entry.data = i.data;
      label = entry.label = new Base_Label();
      label.text = i.label;
      label.align = "left";
      entry.textColor = i.textColor;
      _results.push(this.entries.push(entry));
    }
    return _results;
  };

  Base_Legend.prototype.getPanels = function() {
    var r;
    Base_Helpers.extend(this.panel, this.settings.panel);
    r = this.settings.enabled ? [this.panel] : [];
    return r;
  };

  Base_Legend.prototype.computePanelSize = function(availableWidth, availableHeight, g, labelRenderer) {
    var calcColumns, calcRows, contAproxH, contAproxW, e, h, maxHeight, numberOfColumns, numberOfRows, pad, space, spaceE, textWidth, w, _i, _len, _ref;
    if (this.entries.length === 0) {
      return [0, 0];
    }
    Base_Graphics.textStyleNoShadow(g, this.labelStyle.textStyle);
    this.lastInsensitive = false;
    textWidth = this.labelStyle.maxWidth = g.measureText("M").width * this.settings.maxLineSymbols;
    maxHeight = 0;
    numberOfRows = this.settings.numberOfRows;
    numberOfColumns = this.settings.numberOfColumns;
    spaceE = 2 * (this.settings.margin + this.settings.padding);
    space = 2 * (this.settings.panel.margin + this.settings.panel.padding);
    _ref = this.entries;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      e = _ref[_i];
      labelRenderer.measure(g, e.label, this.labelStyle);
      maxHeight = Math.max(maxHeight, e.label.hheight * 2);
    }
    this.textHeight = this.entries[0].label.lineHeight;
    this.markerSize = this.settings.marker.size || this.textHeight;
    maxHeight = Math.max(maxHeight, this.markerSize);
    this.entryHeight = Math.max(maxHeight, this.markerSize) + spaceE;
    this.entryWidth = textWidth + this.markerSize + this.settings.padding + spaceE;
    contAproxW = (this.settings.width != null ? Math.min(availableWidth, Math.max(this.settings.width, this.entryWidth) + space) : availableWidth) - space;
    contAproxH = (this.settings.height != null ? Math.min(availableHeight, Math.max(this.settings.height, this.entryHeight) + space) : availableHeight) - space;
    if (this.orientation === "vertical") {
      this.rows = Math.floor(contAproxH / this.entryHeight);
      calcColumns = Math.min(Math.ceil(this.entries.length / this.rows), Math.floor(contAproxW / this.entryWidth));
      this.columns = numberOfColumns != null ? Math.min(numberOfColumns, calcColumns) : calcColumns;
      this.drawingEntries = Math.min(Math.floor(contAproxH / this.entryHeight) * this.columns, this.entries.length);
      w = this.columns * this.entryWidth;
      if (this.drawingEntries > this.rows) {
        if (this.settings.equalizeRowsColumns) {
          this.rows = Math.ceil(this.drawingEntries / this.columns);
        }
        h = this.rows * this.entryHeight;
      } else {
        h = this.drawingEntries * this.entryHeight;
      }
    }
    if (this.orientation === "horizontal") {
      this.columns = Math.floor(contAproxW / this.entryWidth);
      calcRows = Math.min(Math.ceil(this.entries.length / this.columns), Math.floor(contAproxH / this.entryHeight));
      this.rows = numberOfRows != null ? Math.min(numberOfRows, calcRows) : calcRows;
      this.drawingEntries = Math.min(Math.floor(contAproxW / this.entryWidth) * this.rows, this.entries.length);
      h = this.rows * this.entryHeight;
      if (this.drawingEntries > this.columns) {
        if (this.settings.equalizeRowsColumns) {
          this.columns = Math.ceil(this.drawingEntries / this.rows);
        }
        w = this.columns * this.entryWidth;
      } else {
        w = this.drawingEntries * this.entryWidth;
      }
    }
    this.contentHeight = h;
    this.contentWidth = w;
    pad = this.settings.panel.padding;
    return [w + pad * 2, h + pad * 2];
  };

  Base_Legend.prototype.paintScene = function(event) {
    var alignToMarker, block, col, entr, entry, g, labelRenderer, left, marginE, paddingE, paddingP, top, whiteSpace, x, xmPos, xtPos, y, ymPos, ytPos, _i, _ref, _results;
    if (!((this.settings.enabled && this.entries.length !== 0) && this.drawingEntries !== 0)) {
      return null;
    }
    g = event.context;
    labelRenderer = event.labelRenderer;
    top = this.panel.top;
    left = this.panel.left;
    marginE = this.settings.margin;
    paddingE = this.settings.padding;
    paddingP = this.settings.panel.padding;
    entr = 0;
    col = 0;
    block = 0;
    Base_Graphics.textStyleNoShadow(g, this.settings.text);
    _results = [];
    for (entr = _i = 0, _ref = this.drawingEntries; 0 <= _ref ? _i < _ref : _i > _ref; entr = 0 <= _ref ? ++_i : --_i) {
      whiteSpace = paddingP + marginE;
      x = left + whiteSpace + col * this.entryWidth;
      y = top + whiteSpace + block * this.entryHeight;
      entry = this.entries[entr];
      entry.label.lineSpacing = this.settings.lineSpacing;
      if (this.settings.marker.alignment === "right") {
        xtPos = x + paddingE + entry.label.hwidth;
        xmPos = x + this.entryWidth - 2 * (marginE + paddingE) - this.markerSize / 2;
      } else {
        xtPos = x + this.markerSize + 2 * paddingE + entry.label.hwidth;
        xmPos = x + paddingE + this.markerSize / 2;
      }
      alignToMarker = entry.label.hheight > this.markerSize / 2 ? 0 : this.markerSize / 2 - this.textHeight / 2;
      ymPos = y + paddingE + this.markerSize / 2;
      ytPos = y + alignToMarker + paddingE + entry.label.hheight;
      if (this.drawingEntries < this.entries.length && entr + 1 === this.drawingEntries) {
        this.lastInsensitive = true;
        g.fillStyle = "#000";
        g.textAlign = "left";
        g.font = "bold 12px Arial";
        g.fillText(". . .", xtPos - entry.label.hwidth, ytPos);
        break;
      }
      if (entry.data === this.hoverObject || Base_Helpers.arrayContains(this.selectedObjects, entry.data)) {
        this.rect(g, x, y, this.settings.advanced.selectedBorder, this.settings.advanced.selectedBackground, this.entryWidth - 2 * marginE, this.entryHeight - 2 * marginE);
      }
      this.labelStyle.textStyle.fillColor = entry.textColor;
      labelRenderer.paintWithStyle(g, xtPos, ytPos, 1, entry.label, this.labelStyle);
      this.paintMarker(g, xmPos, ymPos, this.markerSize / 2, entry);
      entr += 1;
      if (this.orientation === "vertical") {
        block += 1;
        if (block === this.rows) {
          block = 0;
          col += 1;
        }
        if (col === this.columns) {
          break;
        } else {
          _results.push(void 0);
        }
      } else {
        col += 1;
        if (col === this.columns) {
          col = 0;
          block += 1;
        }
        if (block === this.rows) {
          break;
        } else {
          _results.push(void 0);
        }
      }
    }
    return _results;
  };

  Base_Legend.prototype.findItemAt = function(x, y) {
    var c, entriesInSet, focusEntry, left, pointerApart, r, top;
    if (!(this.entries.length > 0)) {
      return;
    }
    top = this.panel.top + this.settings.panel.padding;
    left = this.panel.left + this.settings.panel.padding;
    pointerApart = (x < left || x > left + this.contentWidth) || (y < top || y > top + this.contentHeight);
    if (pointerApart) {
      return null;
    }
    entriesInSet = this.orientation === "vertical" ? Math.abs(this.contentHeight / this.entryHeight) : Math.abs(this.contentWidth / this.entryWidth);
    if (this.orientation === "vertical") {
      c = Math.floor((x - left) / this.entryWidth);
      r = Math.floor((y - top) / this.entryHeight);
    } else {
      c = Math.floor((y - top) / this.entryHeight);
      r = Math.floor((x - left) / this.entryWidth);
    }
    focusEntry = Math.floor(entriesInSet * c + r);
    if (focusEntry > this.drawingEntries - 1) {
      return null;
    } else {
      if (this.lastInsensitive && focusEntry === this.drawingEntries - 1) {
        return null;
      }
      return this.entries[focusEntry].data;
    }
  };

  Base_Legend.prototype.rect = function(g, x, y, c, fc, w, h) {
    g.beginPath();
    g.rect(x, y, w, h);
    g.fillStyle = fc;
    g.fill();
    g.lineWidth = 0;
    g.strokeStyle = c;
    return g.stroke();
  };

  Base_Legend.prototype.paintMarker = function(context, markerXPos, markerYPos, markerHSize, entry) {
    return 1;
  };

  Base_Legend.prototype.shape = function(g, x, y, w, h, col) {
    if (col == null) {
      col = null;
    }
    g.lineWidth = 1;
    g.beginPath();
    g.rect(x, y, w, h);
    g.strokeStyle = col !== null ? col : "black";
    return g.stroke();
  };

  return Base_Legend;

})(Base_ChartElement);
// Generated by CoffeeScript 1.8.0
var Base_Credits,
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

Base_Credits = (function(_super) {
  "use strict";
  __extends(Base_Credits, _super);

  Base_Credits.prototype.animationOrder = 2000;

  Base_Credits.prototype.paintOrder = 60;

  Base_Credits.prototype.updateOrder = 400;

  Base_Credits.settings = {
    _doc: {
      doc_file: "base/settings/credits.markdown",
      type: "section"
    },
    enabled: false,
    enabled_doc: {
      doc: "Enable/disable chart credits. Note that it does not affect exported image.",
      type: "bool"
    },
    enabledOnExport: false,
    enabledOnExport_doc: {
      doc: "Whether to render credits on the exported image. Note that it does not affect chart.",
      type: "bool"
    },
    url: "http://zoomcharts.com",
    url_doc: {
      doc: "URL to open on click.",
      type: "url"
    },
    image: "builtin://logo",
    image_doc: {
      doc: "URL of credits image.",
      type: "imageUrl"
    },
    imageScaling: 0.5,
    imageScaling_doc: {
      doc: "Image scaling. Use to embed higher resolution images.",
      type: "float"
    },
    location: "outside",
    location_doc: {
      doc: "Credits location",
      type: "enum",
      values: ["inside", "outside"]
    }
  };

  function Base_Credits(chart, settings) {
    this.chart = chart;
    this.settings = settings;
    this.imageLoaded = __bind(this.imageLoaded, this);
    this.scene = this.chart.scene;
    if (this.settings.enabledOnExport || this.settings.enabled) {
      this.scene.settings.getAssetImage(this.settings.image, this.imageLoaded);
      if (this.settings.imageExport) {
        this.scene.settings.getAssetImage(this.settings.imageExport);
      }
    }
    this.panel = new Base_ChartPanel();
    this.panel.packingOrder = 0;
    this.panel.side = "bottom";
    this.panel.align = "right";
    this.panel.visible = false;
    this.panel.margin = 3;
  }

  Base_Credits.prototype.onSceneChange = function(event) {
    var ch;
    ch = event.changes;
    if (ch.settings && ch.settingsChanges.credits) {
      return ch.bounds = true;
    }
  };

  Base_Credits.prototype.getPanels = function(forExport) {
    var enabled, i;
    enabled = forExport ? this.settings.enabledOnExport : this.settings.enabled;
    if (enabled) {
      this.panel.location = "outside";
      if (this.settings.location === "outside") {
        this.panel.floating = false;
        if (forExport && !this.settings.enabled) {
          this.panel.location = "external";
        }
      } else {
        this.panel.floating = true;
      }
      i = this.scene.settings.getAssetImage(this.settings.image, this.imageLoaded);
      if (i) {
        this.panel.desiredWidth = i.width * this.settings.imageScaling;
        this.panel.desiredHeight = i.height * this.settings.imageScaling;
        this.panel.visible = true;
        return [this.panel];
      }
    }
    this.panel.visible = false;
    return [];
  };

  Base_Credits.prototype.paintScene = function(event) {
    var ei, i;
    if (!this.panel.visible) {
      return;
    }
    i = this.scene.settings.getAssetImage(this.settings.image);
    ei = this.settings.imageExport ? this.scene.settings.getAssetImage(this.settings.imageExport) : i;
    if (event["export"]) {
      i = ei;
    }
    if (i) {
      return event.context.drawImage(i, 0, 0, i.width, i.height, this.panel.left, this.panel.top, this.panel.right - this.panel.left, this.panel.bottom - this.panel.top);
    }
  };

  Base_Credits.prototype.onPointerMove = function(event) {
    var x, y;
    x = event.x;
    y = event.y;
    if (this.panel.visible && x >= this.panel.left && y >= this.panel.top && x <= this.panel.right && y <= this.panel.bottom && this.settings.url) {
      return event.cursor = "pointer";
    }
  };

  Base_Credits.prototype.onClick = function(event) {
    var x, y;
    x = event.x;
    y = event.y;
    if (this.panel.visible && x >= this.panel.left && y >= this.panel.top && x <= this.panel.right && y <= this.panel.bottom && this.settings.url) {
      Base_Helpers.openUrl(this.settings.url);
      return event.consumed = true;
    }
  };

  Base_Credits.prototype.imageLoaded = function(image) {
    return this.chart.updateSize(true);
  };

  return Base_Credits;

})(Base_ChartElement);
// Generated by CoffeeScript 1.8.0
var Piechart_Selection,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

Piechart_Selection = (function(_super) {
  __extends(Piechart_Selection, _super);

  Piechart_Selection.prototype.animationOrder = 400;

  Piechart_Selection.prototype.paintOrder = 10;

  Piechart_Selection.prototype.updateOrder = 1200;

  Piechart_Selection.prototype.scene = null;

  Piechart_Selection.prototype.events = null;

  Piechart_Selection.prototype.currentSlice = null;

  Piechart_Selection.prototype.currentLabel = null;

  Piechart_Selection.prototype.currentPie = null;

  Piechart_Selection.prototype.draggedLabelSlice = null;

  Piechart_Selection.prototype.draggedLabel = null;

  Piechart_Selection.prototype.hoverEvent = null;

  function Piechart_Selection(chart) {
    this.chart = chart;
    this.scene = chart.scene;
    this.events = chart.events;
    this.dragPointers = {};
  }

  Piechart_Selection.prototype.doAnimations = function(event) {
    if (this.hoverEvent) {
      return this.onPointerMove(this.hoverEvent);
    }
  };

  Piechart_Selection.prototype.previewPointerDrag = function(event) {
    return this.hoverEvent = event;
  };

  Piechart_Selection.prototype.onPointerMove = function(event) {
    this.hoverEvent = event;
    return this.updateCurrentObject(event);
  };

  Piechart_Selection.prototype.onPointerOut = function(event) {
    this.switchCurrentSlice(null, null, event);
    return this.hoverEvent = null;
  };

  Piechart_Selection.prototype.onPointerDown = function(event) {
    var _ref;
    this.updateCurrentObject(event);
    if (this.currentSlice || this.currentPie) {
      event.consumed = true;
    }
    _ref = this.scene.findLabelAt(event.x, event.y, this.scene.settings.interaction.selection.tolerance), this.draggedLabelSlice = _ref[0], this.draggedLabel = _ref[1];
    if (this.draggedLabel && this.scene.settings.interaction.dragging.enabled) {
      return event.consumed = true;
    } else {
      this.draggedLabel = null;
      return this.draggedLabelSlice = null;
    }
  };

  Piechart_Selection.prototype.onPointerUp = function(event) {
    if (this.draggedLabel) {
      this.draggedLabel = null;
      return event.consumed = true;
    }
  };

  Piechart_Selection.prototype.onPointerCancel = function(event) {
    return this.onPointerUp(event);
  };

  Piechart_Selection.prototype.onPointerDrag = function(event) {
    var label;
    if (this.draggedLabel) {
      label = this.draggedLabel;
      label.userPlaced = true;
      label.x += event.dx;
      label.y += event.dy;
      event.consumed = true;
      return event.changes.pie = true;
    }
  };

  Piechart_Selection.prototype.onClick = function(event) {
    var userEvent;
    this.onPointerMove(event);
    this.fillClickParams(event);
    userEvent = this.chart.notifyClick(event);
    if (this.currentSlice || this.currentPie) {
      event.consumed = true;
    }
    if (!userEvent.defaultPrevented) {
      return this.updateSelection(event, event.slice, false);
    }
  };

  Piechart_Selection.prototype.onRightClick = function(event) {
    var userEvent;
    this.onPointerMove(event);
    this.fillClickParams(event);
    if (this.currentSlice || this.currentPie) {
      event.consumed = true;
    }
    userEvent = this.chart.notifyRightClick(event);
    if (userEvent.defaultPrevented) {
      return event.consumed = true;
    }
  };

  Piechart_Selection.prototype.onDoubleClick = function(event) {
    this.onPointerMove(event);
    this.fillClickParams(event);
    this.chart.notifyDoubleClick(event);
    return event.consumed = true;
  };

  Piechart_Selection.prototype.fillClickParams = function(event) {
    var n, p;
    n = this.scene.findSliceAt(event.x, event.y, this.scene.settings.interaction.selection.tolerance);
    p = this.scene.findPieAt(event.x, event.y, this.scene.settings.interaction.selection.tolerance);
    event.clickPie = n ? n.pie : p;
    if (n) {
      return event.cursor = "pointer";
    }
  };

  Piechart_Selection.prototype.updateSelection = function(event, target, softDeselect) {
    var shift, toggle;
    if (!this.scene.settings.interaction.selection.enabled) {
      return;
    }
    shift = event.shiftKey;
    toggle = this.scene.settings.interaction.mode === "toggle" || event.ctrlKey;
    if (target) {
      if (shift || (softDeselect && target.selected) || (toggle && !target.selected)) {
        if (!target.selected) {
          this.scene.selection.push(target);
          target.selected = true;
          return this.setSelection(this.scene.selection, this.scene.selectionIds, true);
        }
      } else if (toggle && target.selected) {
        Base_Helpers.removeFromArray(this.scene.selection, target);
        target.selected = false;
        return this.setSelection(this.scene.selection, this.scene.selectionIds, true);
      } else if (!target.selected || this.scene.selection.length > 1) {
        return this.setSelection([target]);
      } else {
        return this.setSelection([]);
      }
    } else {
      if (!shift && !toggle) {
        return this.setSelection([]);
      }
    }
  };

  Piechart_Selection.prototype.switchCurrentSlice = function(obj, label, event) {
    if (obj === this.currentSlice && label === this.currentLabel) {
      return;
    }
    event.changes.current = true;
    if (this.scene.hoverSlice) {
      this.scene.hoverSlice.active = false;
    }
    if (this.scene.hoverPie) {
      this.scene.hoverPie.active = false;
    }
    this.scene.hoverSlice = obj;
    this.scene.hoverPie = null;
    this.scene.hoverLabel = label;
    this.currentSlice = obj;
    this.currentLabel = label;
    this.currentPie = null;
    if (this.currentSlice) {
      this.scene.hoverSlice.active = true;
      event.hoverSlice = this.currentSlice;
    }
    this.events.notifySceneChanges({
      pie: true
    });
    return this.chart.notifyHoverChanged(event);
  };

  Piechart_Selection.prototype.switchCurrentPie = function(obj, event) {
    if (obj === this.currentPie) {
      return;
    }
    event.changes.current = true;
    if (this.scene.hoverSlice) {
      this.scene.hoverSlice.active = false;
    }
    if (this.scene.hoverPie) {
      this.scene.hoverPie.active = false;
    }
    this.scene.hoverPie = obj;
    this.scene.hoverSlice = null;
    this.currentSlice = null;
    this.currentPie = obj;
    if (this.currentPie) {
      this.scene.hoverPie.active = true;
      event.hoverPie = this.currentPie;
    }
    this.events.notifySceneChanges({
      pie: true
    });
    return this.chart.notifyHoverChanged(event);
  };

  Piechart_Selection.prototype.onSceneChange = function(event) {
    if (event.changes.pie) {
      if (this.updateSelectionIds()) {
        this.events.notifySceneChanges({
          selection: true
        });
        return this.chart.notifySelectionChanged("");
      }
    }
  };

  Piechart_Selection.prototype.updateSelectionIds = function() {
    var id, pie, slice, slicesToSelect, _i, _j, _k, _l, _len, _len1, _len2, _len3, _ref, _ref1, _ref2;
    slicesToSelect = [];
    _ref = this.scene.selectionIds;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      id = _ref[_i];
      _ref1 = this.scene.pies;
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        pie = _ref1[_j];
        if (pie.background) {
          continue;
        }
        _ref2 = pie.slices;
        for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
          slice = _ref2[_k];
          if (slice.id === id) {
            slicesToSelect.push(slice);
            break;
          }
        }
      }
    }
    if (slicesToSelect.length > 0) {
      for (_l = 0, _len3 = slicesToSelect.length; _l < _len3; _l++) {
        slice = slicesToSelect[_l];
        if (!slice.selected) {
          slice.selected = true;
          this.scene.selection.push(slice);
        }
        Base_Helpers.removeFromArray(this.scene.selectionIds, slice.id);
      }
    }
    return slicesToSelect.length > 0;
  };

  Piechart_Selection.prototype.setSelection = function(selection, selectionIds, alreadyChanged, origin) {
    var changedIds, hasChanges, s, _i, _j, _len, _len1, _ref;
    if (selectionIds == null) {
      selectionIds = [];
    }
    if (alreadyChanged == null) {
      alreadyChanged = false;
    }
    if (origin == null) {
      origin = "user";
    }
    this.scene.selectionIds = selectionIds;
    if (alreadyChanged) {
      hasChanges = true;
    } else {
      _ref = this.scene.selection;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        s = _ref[_i];
        if (!Base_Helpers.arrayContains(selection, s)) {
          s.selected = false;
          hasChanges = true;
        }
      }
      for (_j = 0, _len1 = selection.length; _j < _len1; _j++) {
        s = selection[_j];
        if (!s.selected) {
          s.selected = true;
          hasChanges = true;
        }
      }
      this.scene.selection = selection;
    }
    changedIds = this.updateSelectionIds();
    hasChanges || (hasChanges = changedIds);
    if (hasChanges) {
      this.events.notifySceneChanges({
        selection: true
      });
      return this.chart.notifySelectionChanged(origin);
    }
  };

  Piechart_Selection.prototype.updateCurrentObject = function(event) {
    var label, pie, slice;
    slice = this.findSliceAt(event.x, event.y);
    label = this.scene.findLabelAt(event.x, event.y, this.scene.settings.interaction.selection.tolerance);
    label = label ? label[1] : null;
    if (slice) {
      event.cursor = "pointer";
    }
    this.switchCurrentSlice(slice, label, event);
    pie = this.scene.findPieAt(event.x, event.y, this.scene.settings.interaction.selection.tolerance);
    if (pie && pie.background && !slice) {
      event.cursor = "pointer";
      return this.switchCurrentPie(pie, event);
    } else {
      return this.switchCurrentPie(null, event);
    }
  };

  Piechart_Selection.prototype.findSliceAt = function(x, y) {
    var slice;
    slice = this.scene.findSliceAt(x, y, this.scene.settings.interaction.selection.tolerance);
    if (!slice && this.chart.legend) {
      slice = this.chart.legend.findItemAt(x, y);
    }
    return slice;
  };

  return Piechart_Selection;

})(Base_ChartElement);
// Generated by CoffeeScript 1.8.0
var Piechart_Styles,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

Piechart_Styles = (function(_super) {
  __extends(Piechart_Styles, _super);

  Piechart_Styles.prototype.animationOrder = 100;

  Piechart_Styles.prototype.paintOrder = 25;

  Piechart_Styles.prototype.updateOrder = 900;

  function Piechart_Styles(chart) {
    this.chart = chart;
    this.scene = chart.scene;
  }

  Piechart_Styles.prototype.onSceneChange = function(event) {
    var pie, slice, slice_ind, _i, _len, _ref, _results;
    if (!(event.changes.settings || event.changes.pie || event.changes.selection || event.changes.style)) {
      return;
    }
    this.insideLabelBase = this.scene.settings.slice.insideLabelStyle;
    this.labelBase = this.scene.settings.slice.labelStyle;
    _ref = this.scene.pies;
    _results = [];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      pie = _ref[_i];
      this.updatePie(pie);
      this.computePieColors(pie);
      _results.push((function() {
        var _j, _len1, _ref1, _results1;
        _ref1 = pie.allSlices;
        _results1 = [];
        for (slice_ind = _j = 0, _len1 = _ref1.length; _j < _len1; slice_ind = ++_j) {
          slice = _ref1[slice_ind];
          _results1.push(this.updateSlice(slice, slice_ind));
        }
        return _results1;
      }).call(this));
    }
    return _results;
  };

  Piechart_Styles.prototype.updatePie = function(pie) {
    Base_Helpers.extend(pie, this.scene.settings.pie.style);
    if (pie.slices.length === 0) {
      Base_Helpers.extend(pie, this.scene.settings.pie.noDataStyle);
    }
    if (pie.background) {
      Base_Helpers.extend(pie, this.scene.settings.pie.backgroundStyle);
    }
    if (this.scene.hoverPie === pie) {
      Base_Helpers.extend(pie, this.scene.settings.pie.backgroundHoveredStyle);
    }
    if (this.scene.settings.pie.styleFunction) {
      return this.scene.settings.pie.styleFunction(pie);
    }
  };

  Piechart_Styles.prototype.computePieColors = function(pie) {
    var c0, c1, col, colorCount, colorMode, colors, cp, i, pos, round, slice, sliceCount, _i, _j, _k, _l, _len, _len1, _len2, _len3, _ref, _ref1, _ref2, _ref3, _results, _results1, _results2;
    colors = pie.sliceColors;
    colorMode = pie.colorDistribution;
    sliceCount = 0;
    _ref = pie.slices;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      slice = _ref[_i];
      if (!slice.removed) {
        sliceCount += 1;
      }
    }
    if (sliceCount === 1) {
      pie.slices[0].fillColor = colors[0];
      return;
    }
    if (colors.length === 1) {
      col = colors[0];
      colors = [col, Base_Graphics.blendColors(col, "#fff", 0.8)];
    }
    colorCount = colors.length;
    if (colorMode === "gradient") {
      pos = 0;
      _ref1 = pie.slices;
      _results = [];
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        slice = _ref1[_j];
        if (slice.removed) {
          continue;
        }
        c0 = colors[(pos * (colorCount - 1)) | 0];
        c1 = colors[(pos * (colorCount - 1) + 1) | 0];
        cp = pos * (colorCount - 1);
        cp = cp - Math.floor(cp);
        col = Base_Graphics.blendColors(c0, c1, cp);
        slice.fillColor = col;
        _results.push(pos += 1 / (sliceCount - 0.9));
      }
      return _results;
    } else if (colorMode === "gradientProportional") {
      pos = 0;
      _ref2 = pie.slices;
      _results1 = [];
      for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
        slice = _ref2[_k];
        if (slice.removed) {
          continue;
        }
        c0 = colors[(pos * (colorCount - 1)) | 0];
        c1 = colors[(pos * (colorCount - 1) + 1) | 0];
        cp = pos * (colorCount - 1);
        cp = cp - Math.floor(cp);
        col = Base_Graphics.blendColors(c0, c1, cp);
        slice.fillColor = col;
        _results1.push(pos += slice.fraction);
      }
      return _results1;
    } else {
      _ref3 = pie.slices;
      _results2 = [];
      for (i = _l = 0, _len3 = _ref3.length; _l < _len3; i = ++_l) {
        slice = _ref3[i];
        if (slice.removed) {
          continue;
        }
        col = colors[i % colorCount];
        round = (i / colorCount) | 0;
        if (round === 1) {
          col = Base_Graphics.deriveColor(col, 1.5, 1);
        } else if (round >= 2) {
          col = Base_Graphics.deriveColor(col, 0.5, 1);
        }
        _results2.push(slice.fillColor = col);
      }
      return _results2;
    }
  };

  Piechart_Styles.prototype.updateSlice = function(slice, index) {
    var brightness, l, pie, styleFunc, targetFillColor, targetLineColor;
    pie = slice.pie;
    styleFunc = this.scene.settings.slice.styleFunction;
    if (slice.removed) {
      return;
    }
    slice.labelStyle = this.labelBase;
    slice.insideLabelStyle = this.insideLabelBase;
    slice.expandable = this.scene.mainData.canExpand(slice.id);
    Base_Helpers.extend(slice, this.scene.settings.slice.style);
    if (slice === pie.othersSlice) {
      Base_Helpers.extend(slice, this.scene.settings.slice.othersStyle);
    }
    if (slice === pie.previousSlice) {
      Base_Helpers.extend(slice, this.scene.settings.slice.previousStyle);
    }
    if (pie.total > 0) {
      slice.percent = slice.value / pie.total * 100;
    } else {
      slice.percent = 0;
    }
    if (!styleFunc) {
      slice.label = "" + (slice.percent.toFixed(1)) + "%";
      if (!slice.percent) {
        debugger;
      }
      if (slice.data.name) {
        slice.label = slice.data.name + " " + slice.label;
      }
    }
    if (slice.selected) {
      Base_Helpers.extend(slice, this.scene.settings.slice.selectedStyle);
    }
    if (this.scene.hoverSlice === slice) {
      Base_Helpers.extend(slice, this.scene.settings.slice.hoverStyle);
    }
    if (slice.data.style) {
      Base_Helpers.extend(slice, slice.data.style);
    }
    if (styleFunc) {
      styleFunc(slice, slice.data);
      if (slice.label && !Base_Helpers.isString(slice.label)) {
        slice.label = "" + slice.label;
      }
      if (slice.insideLabel && !Base_Helpers.isString(slice.insideLabel)) {
        slice.insideLabel = "" + slice.insideLabel;
      }
    }
    if (pie.background) {
      if (pie.activeSliceId !== slice.id) {
        Base_Helpers.extend(slice, this.scene.settings.slice.backgroundStyle);
        if (index % 2 === 1) {
          slice.fillColor = slice.fillColor2;
        }
      } else {
        Base_Helpers.extend(slice, this.scene.settings.slice.backgroundActiveStyle);
      }
    }
    if (slice.fillColor) {
      targetFillColor = slice.fillColor;
    } else {
      targetFillColor = "rgba(255,255,255,0)";
    }
    if (slice.lineColor) {
      targetLineColor = slice.lineColor;
    } else if (slice.lineBrightness) {
      targetLineColor = Base_Graphics.deriveColor(targetFillColor, slice.lineBrightness, 1);
    } else {
      targetLineColor = "rgba(255,255,255,0)";
    }
    brightness = slice.brightness * pie.brightness;
    if (brightness !== 1) {
      targetFillColor = Base_Graphics.deriveColor(targetFillColor, brightness, 1);
      targetLineColor = Base_Graphics.deriveColor(targetLineColor, brightness, 1);
      if (targetFillColor.indexOf("rgba(255,255,255") !== -1 && targetLineColor.indexOf("rgba(255,255,255") !== -1) {
        targetLineColor = "rgba(200,200,200,1.000)";
      }
    }
    if (slice.labelStyle !== this.labelBase) {
      l = Base_Helpers.realClone(this.labelBase);
      Base_Helpers.extendDeep(l, slice.labelStyle);
      slice.labelStyle = l;
    }
    if (slice.insideLabelStyle !== this.insideLabelBase) {
      l = Base_Helpers.realClone(this.insideLabelBase);
      Base_Helpers.extendDeep(l, slice.insideLabelStyle);
      slice.insideLabelStyle = l;
    }
    if (pie.removed && pie.parentSlice) {
      slice.targetFillColor = pie.parentSlice.targetFillColor;
      return slice.targetLineColor = pie.parentSlice.targetLineColor;
    } else {
      slice.targetFillColor = Base_Graphics.normalizeColor(targetFillColor);
      return slice.targetLineColor = Base_Graphics.normalizeColor(targetLineColor);
    }
  };

  return Piechart_Styles;

})(Base_ChartElement);
// Generated by CoffeeScript 1.8.0
var Piechart_Layers,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

Piechart_Layers = (function(_super) {
  __extends(Piechart_Layers, _super);

  Piechart_Layers.prototype.animationOrder = 500;

  Piechart_Layers.prototype.paintOrder = 35;

  Piechart_Layers.prototype.updateOrder = 600;

  Piechart_Layers.prototype.scene = null;

  Piechart_Layers.prototype.container = null;

  Piechart_Layers.prototype.background = null;

  Piechart_Layers.prototype.canvas = null;

  Piechart_Layers.prototype.outerBorder = null;

  Piechart_Layers.prototype.mouseTrackLayer = null;

  Piechart_Layers.prototype.backgroundImage = null;

  function Piechart_Layers(chart) {
    this.chart = chart;
    this.scene = chart.scene;
    this.container = Base_Helpers.createDom("div", "DVSL-container");
    this.container.style.position = "relative";
    this.container.style.width = "100%";
    this.container.style.height = "100%";
    this.background = Base_Helpers.createDom("div", "DVSL-background", null, this.container);
    this.setContainerStyle(this.background);
    this.backgroundImage = Base_Helpers.createDom("div", "DVSL-PC-background-image", null, this.container);
    this.backgroundImage.style.position = "absolute";
    this.backgroundImage.style.overflow = "hidden";
    this.canvas = Base_Helpers.createDom("canvas", "DVSL-canvas", null, this.container);
    this.setContainerStyle(this.canvas);
    this.outerBorder = Base_Helpers.createDom("div", "DVSL-border", null, this.container);
    this.setContainerStyle(this.outerBorder);
    this.resizerBar = Base_Helpers.createDom("div", "DVSL-resizer", null, this.container);
    this.mouseTrackLayer = Base_Helpers.createDom("div", null, null, this.container);
    this.setContainerStyle(this.mouseTrackLayer);
    this.updateSettings(this.scene.settings, "init");
  }

  Piechart_Layers.prototype.updateSettings = function(changes) {
    var image;
    if (Base_Helpers.hasProp(changes, "area.style.image")) {
      image = changes.area.style.image;
      if (image) {
        this.backgroundImage.style.backgroundImage = "url(" + image + ")";
      } else {
        this.backgroundImage.style.backgroundImage = "";
      }
    }
    if (Base_Helpers.hasProp(changes, "advanced.themeCSSClass")) {
      if (this.curTheme != null) {
        Base_Helpers.removeClass(this.container, this.curTheme);
      }
      this.curTheme = this.scene.settings.advanced.themeCSSClass;
      return Base_Helpers.addClass(this.container, this.curTheme);
    }
  };

  Piechart_Layers.prototype.doAnimations = function(event) {
    var r, setHeight, setWidth, x, y;
    if (event.changes.bounds) {
      setWidth = this.scene.settings.width;
      setHeight = this.scene.settings.height;
      if (this.scene.chartWidth > this.scene.settings.container.clientWidth && this.container && this.container.style.display !== "") {
        setWidth = this.scene.chartWidth;
      }
      if (this.scene.chartHeight > this.scene.settings.container.clientHeight && this.container && this.container.style.display !== "") {
        setHeight = this.scene.chartHeight;
      }
      if (setWidth) {
        this.container.style.width = "" + setWidth + "px";
      }
      if (setHeight) {
        this.container.style.height = "" + setHeight + "px";
      }
      this.resizerBar.style.width = "" + this.scene.width + "px";
      this.resizerBar.style.left = "" + this.scene.x0 + "px";
    }
    if (event.changes.position && this.scene.settings.area.style.image && this.scene.pies.length > 0) {
      r = this.scene.currentInnerRadius - this.scene.settings.pie.margin;
      x = this.scene.pies[0].x;
      y = this.scene.pies[0].y;
      this.backgroundImage.style.left = x - r + "px";
      this.backgroundImage.style.top = y - r + "px";
      this.backgroundImage.style.width = r * 2 + "px";
      return this.backgroundImage.style.height = r * 2 + "px";
    }
  };

  Piechart_Layers.prototype.setContainerStyle = function(c) {
    c.style.position = "absolute";
    c.style.left = "0px";
    c.style.right = "0px";
    c.style.top = "0px";
    return c.style.bottom = "0px";
  };

  return Piechart_Layers;

})(Base_ChartElement);
// Generated by CoffeeScript 1.8.0
var Piechart_Scrolling,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

Piechart_Scrolling = (function(_super) {
  __extends(Piechart_Scrolling, _super);

  Piechart_Scrolling.prototype.animationOrder = 200;

  Piechart_Scrolling.prototype.paintOrder = 5;

  Piechart_Scrolling.prototype.updateOrder = 1300;

  function Piechart_Scrolling(chart, view) {
    this.chart = chart;
    this.view = view;
    this.scene = chart.scene;
    this.events = chart.events;
    this.pie = null;
    this.slice = null;
    this.fraction = null;
    this.offset = null;
  }

  Piechart_Scrolling.prototype.doAnimations = function(event) {};

  Piechart_Scrolling.prototype.onPointerDown = function(event) {
    this.pie = this.scene.view.findPieAt(event.x, event.y, this.scene.settings.interaction.selection.tolerance);
    this.slice = this.scene.view.findSliceAt(event.x, event.y, this.scene.settings.interaction.selection.tolerance);
    if (this.slice) {
      this.pie = this.slice.pie;
    }
    return this.mode = null;
  };

  Piechart_Scrolling.prototype.onPointerDrag = function(event) {
    var dfraction, doffset, newDist, _ref;
    if (!(this.pie || this.slice)) {
      return;
    }
    if (this.mode === null) {
      if (this.pie && this.scene.settings.interaction.scrolling.enabled) {
        this.mode = "scroll";
      } else if (this.slice && this.scene.settings.interaction.dragging.enabled) {
        this.mode = "drag";
      }
    }
    _ref = this.scene.view.getMovement(this.pie, event), dfraction = _ref[0], doffset = _ref[1];
    if (this.mode === "scroll") {
      this.pie.scrollOffset += dfraction;
      this.updatePieScrolling(this.pie);
      event.consumed = true;
      return event.changes.pie = true;
    } else if (this.mode === "drag") {
      this.slice.userPlaced = true;
      newDist = this.slice.currentCutoutDistance + doffset;
      if (newDist < 0) {
        this.slice.currentCutoutDistance = 0;
        this.slice.userPlaced = false;
      } else {
        this.slice.currentCutoutDistance = newDist;
        this.slice.userPlaced = true;
      }
      event.consumed = true;
      return event.changes.pie = true;
    }
  };

  Piechart_Scrolling.prototype.onPointerUp = function(event) {
    if (this.mode === "scroll") {
      this.updatePieAfterScroll(this.pie);
      event.consumed = true;
    } else if (this.mode === "drag") {
      event.consumed = true;
    }
    this.pie = null;
    this.slice = null;
    return this.mode = null;
  };

  Piechart_Scrolling.prototype.onPointerCancel = function(event) {
    return this.onPointerUp(event);
  };

  Piechart_Scrolling.prototype.updatePieScrolling = function(pie) {
    var offsetIncrement, pieUpdate, remainingOffset, scrollIncrement;
    pieUpdate = false;
    if (pie.scrollOffset < 0) {
      remainingOffset = pie.scrollOffset;
      offsetIncrement = 0;
      scrollIncrement = 0;
      while (pie.slices.length > offsetIncrement + 1 && pie.slices[offsetIncrement].fraction < -(pie.scrollOffset + scrollIncrement)) {
        offsetIncrement += 1;
        scrollIncrement += pie.slices[scrollIncrement].fraction;
      }
      pie.offset += offsetIncrement;
      pie.scrollOffset += scrollIncrement;
      pieUpdate = true;
    } else if (pie.scrollOffset > 0) {
      if (pie.offset === 0) {
        pie.scrollOffset = 0;
      }
    }
    if (pieUpdate) {
      return this.scene.view.updatePie(this.pie);
    }
  };

  Piechart_Scrolling.prototype.updatePieAfterScroll = function(pie) {
    return 1;
  };

  return Piechart_Scrolling;

})(Base_ChartElement);
// Generated by CoffeeScript 1.8.0
var Piechart_Navigator,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

Piechart_Navigator = (function(_super) {
  "use strict";
  __extends(Piechart_Navigator, _super);

  Piechart_Navigator.prototype.animationOrder = 250;

  Piechart_Navigator.prototype.paintOrder = 30;

  Piechart_Navigator.prototype.updateOrder = 650;

  function Piechart_Navigator(chart) {
    this.chart = chart;
    this.scene = chart.scene;
    this.events = chart.events;
  }

  Piechart_Navigator.prototype.onNewDataObject = function() {
    return 1;
  };

  Piechart_Navigator.prototype.setPie = function(id, offset, origin) {
    var changes, pie;
    if (!Base_Helpers.isArray(id)) {
      id = [id];
    }
    this.scene.pendingAction = null;
    changes = 0;
    while (this.scene.length() > id.length) {
      this.scene.pop();
      changes++;
    }
    while (this.scene.length() > 0 && this.scene.peek().id !== id[this.scene.length() - 1]) {
      this.scene.pop();
      changes++;
    }
    while (this.scene.length() < id.length) {
      pie = new Piechart_Pie();
      pie.id = id[this.scene.length()];
      pie.offset = this.scene.length() + 1 === id.length ? offset : 0;
      this.scene.push(pie);
      this.scene.view.updatePie(pie);
      changes++;
    }
    pie = this.scene.peek();
    if (pie.offset !== offset) {
      this.scroll(pie, offset);
      changes++;
    } else {
      if (changes && pie) {
        this.scene.view.updatePie(pie);
      }
    }
    if (changes) {
      this.chart.notifyChartUpdate(origin);
      return this.events.notifySceneChanges({
        pie: true
      });
    }
  };

  Piechart_Navigator.prototype.getPie = function() {
    var pie, _i, _len, _ref, _results;
    _ref = this.scene.stack;
    _results = [];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      pie = _ref[_i];
      _results.push(pie.id);
    }
    return _results;
  };

  Piechart_Navigator.prototype.getPieOffset = function() {
    return this.scene.peek().offset;
  };

  Piechart_Navigator.prototype.goBack = function(origin) {
    if (!(this.scene.length() > 1)) {
      return;
    }
    this.scene.pop();
    this.scene.pendingAction = null;
    return this.updateAndNotifyCurrent(origin);
  };

  Piechart_Navigator.prototype.goCenter = function(origin) {
    var pie;
    pie = this.scene.peek();
    if (pie.offset > 0 && this.scene.settings.interaction.others.centerGoesToPrevious) {
      return this.goPrevious(pie, origin);
    } else if (this.scene.length() > 1) {
      this.scene.pop();
      this.scene.pendingAction = null;
      return this.updateAndNotifyCurrent(origin);
    }
  };

  Piechart_Navigator.prototype.drillDown = function(pieId, origin) {
    var pie;
    this.scene.pendingAction = null;
    pie = new Piechart_Pie();
    pie.id = pieId;
    pie.offset = 0;
    this.scene.push(pie);
    return this.updateAndNotifyCurrent(origin);
  };

  Piechart_Navigator.prototype.goOthers = function(pie, origin) {
    var ready;
    if (!pie.othersStack) {
      pie.othersStack = [];
    }
    pie.othersStack.push(pie.offset);
    ready = this.scene.view.scrollForward(pie, pie.offset + pie.count);
    if (!ready) {
      this.scene.pendingAction = "forward";
      this.scene.pendingOffset = null;
    }
    this.events.notifySceneChanges({
      pie: true
    });
    return this.chart.notifyChartUpdate(origin);
  };

  Piechart_Navigator.prototype.goPrevious = function(pie, origin) {
    var ready;
    if (!(pie.offset > 0)) {
      return;
    }
    ready = this.scene.view.scrollBackward(pie);
    if (!ready) {
      this.scene.pendingAction = "back";
      this.scene.pendingOffset = null;
    }
    this.chart.notifyChartUpdate(origin);
    return this.events.notifySceneChanges({
      pie: true
    });
  };

  Piechart_Navigator.prototype.scroll = function(pie, offset) {
    var ready;
    ready = true;
    if (pie.offset > offset) {
      ready = this.scene.view.scrollBackward(pie, offset);
      if (!ready) {
        this.scene.pendingAction = "back";
        return this.scene.pendingOffset = offset;
      }
    } else if (pie.offset < offset) {
      ready = this.scene.view.scrollForward(pie, offset);
      if (!ready) {
        this.scene.pendingAction = "forward";
        return this.scene.pendingOffset = offset;
      }
    }
  };

  Piechart_Navigator.prototype.updateAndNotifyCurrent = function(origin) {
    var pie;
    pie = this.scene.peek();
    this.scene.view.updatePie(pie);
    this.chart.notifyChartUpdate(origin);
    return this.events.notifySceneChanges({
      pie: true
    });
  };

  Piechart_Navigator.prototype.expandSlice = function(slice, origin) {
    var id, pie;
    pie = slice.pie;
    if (pie === this.scene.peek()) {
      if (slice === pie.othersSlice) {
        this.chart.setSelection([]);
        this.goOthers(pie, origin);
        return true;
      } else if (slice === pie.previousSlice) {
        this.chart.setSelection([]);
        this.goPrevious(pie, origin);
        return true;
      } else {
        id = slice.id;
        if (slice.expandable && this.scene.mainData.canExpand(id)) {
          this.chart.setSelection([]);
          this.drillDown(id, origin);
          return true;
        }
      }
    } else {
      this.chart.setSelection([]);
      this.goBack(origin);
      return true;
    }
    return false;
  };

  Piechart_Navigator.prototype.onSceneChange = function(event) {
    var activePie, activePieReady, ids, pie, ready, _i, _j, _len, _len1, _ref, _ref1;
    activePieReady = false;
    activePie = this.scene.peek();
    if (event.changes.dataArrived) {
      ids = event.changes.dataArrivedIds;
      _ref = this.scene.pies;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        pie = _ref[_i];
        if (ids.hasOwnProperty(pie.id)) {
          if (pie === activePie) {
            if (this.scene.pendingAction === "forward") {
              ready = this.scene.view.scrollForward(pie, this.scene.pendingOffset);
            } else if (this.scene.pendingAction === "back") {
              ready = this.scene.view.scrollBackward(pie, this.scene.pendingOffset);
            } else {
              ready = this.scene.view.updatePie(pie);
            }
            if (ready) {
              this.scene.pendingAction = null;
              this.scene.pendingOffset = null;
            }
            activePieReady = ready;
          } else {
            this.scene.view.updatePie(pie);
          }
          event.changes.pie = true;
        }
      }
    }
    if (event.changes.data) {
      _ref1 = this.scene.stack;
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        pie = _ref1[_j];
        if (!pie.data || pie === activePie || event.changes.dataDeep) {
          if (pie === activePie) {
            if (this.scene.pendingAction === "forward") {
              ready = this.scene.view.scrollForward(pie, this.scene.pendingOffset);
            } else if (this.scene.pendingAction === "back") {
              ready = this.scene.view.scrollBackward(pie, this.scene.pendingOffset);
            } else {
              ready = this.scene.view.updatePie(pie);
            }
            if (ready) {
              this.scene.pendingAction = null;
              this.scene.pendingOffset = null;
            }
            activePieReady = ready;
          } else {
            this.scene.view.updatePie(pie);
          }
          event.changes.pie = true;
        }
      }
    }
    if (activePieReady) {
      return this.chart.notifyChartUpdate("data", true);
    }
  };

  return Piechart_Navigator;

})(Base_ChartElement);
// Generated by CoffeeScript 1.8.0
var Piechart_InfoPopup,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

Piechart_InfoPopup = (function(_super) {
  __extends(Piechart_InfoPopup, _super);

  Piechart_InfoPopup.prototype.animationOrder = 500;

  Piechart_InfoPopup.prototype.paintOrder = 15;

  Piechart_InfoPopup.prototype.updateOrder = 1100;

  function Piechart_InfoPopup(chart) {
    this.chart = chart;
    this.scene = chart.scene;
    this.options = this.scene.settings;
    this.events = chart.events;
    this.currentSlice = null;
    this.x = null;
    this.y = null;
    this.popup = new Base_InfoPopup(chart);
  }

  Piechart_InfoPopup.prototype.previewPointerMove = function(event) {
    return this.onMove(event.x, event.y);
  };

  Piechart_InfoPopup.prototype.doAnimations = function(event) {
    if (this.x !== null && this.y !== null) {
      return this.onMove(this.x, this.y);
    }
  };

  Piechart_InfoPopup.prototype.previewPointerDown = function(event) {
    this.x = this.y = null;
    return this.setCurrentObject(0, 0, null);
  };

  Piechart_InfoPopup.prototype.previewPointerDrag = function(event) {
    this.x = this.y = null;
    return this.setCurrentObject(0, 0, null);
  };

  Piechart_InfoPopup.prototype.onPointerOut = function(event) {
    this.x = this.y = null;
    return this.setCurrentObject(0, 0, null);
  };

  Piechart_InfoPopup.prototype.onMove = function(x, y) {
    var pie, slice;
    this.x = x;
    this.y = y;
    if (!this.options.info.enabled) {
      return;
    }
    slice = this.scene.findSliceAt(x, y, this.scene.settings.interaction.selection.tolerance);
    pie = this.scene.findPieAt(x, y, this.scene.settings.interaction.selection.tolerance);
    if (pie && !slice) {
      slice = pie.getActiveSlice();
    }
    return this.setCurrentObject(x, y, slice);
  };

  Piechart_InfoPopup.prototype.setCurrentObject = function(x, y, obj) {
    var contents;
    if (!obj) {
      this.currentSlice = null;
      return this.popup.hide();
    } else {
      if (obj !== this.currentSlice) {
        contents = this.buildContents(obj);
        this.popup.show(x, x, y, contents);
      } else {
        this.popup.updateXY(x, x, y);
      }
      return this.currentSlice = obj;
    }
  };

  Piechart_InfoPopup.prototype.buildContents = function(slice) {
    var callback;
    if (this.options.info.contentsFunction) {
      callback = (function(_this) {
        return function(contents) {
          if (slice === _this.currentSlice) {
            return _this.popup.updateContents(contents);
          }
        };
      })(this);
      return this.options.info.contentsFunction.call(this.scene.api, slice.data, slice, callback);
    } else {
      return slice.label;
    }
  };

  return Piechart_InfoPopup;

})(Base_ChartElement);
// Generated by CoffeeScript 1.8.0
var Piechart_PieView,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

Piechart_PieView = (function(_super) {
  __extends(Piechart_PieView, _super);

  Piechart_PieView.prototype.animationOrder = 500;

  Piechart_PieView.prototype.paintOrder = 30;

  Piechart_PieView.prototype.updateOrder = 700;

  function Piechart_PieView(chart) {
    this.chart = chart;
    this.scene = this.chart.scene;
    this.renderer = new Piechart_PieRenderer(chart);
    this.animator = new Piechart_Animations(chart);
    this.layout = new Piechart_PieLayout(chart, this);
    this.builder = new Piechart_PieBuilder(chart);
  }

  Piechart_PieView.prototype.updatePie = function(pie) {
    return this.builder.updatePie(pie);
  };

  Piechart_PieView.prototype.scrollForward = function(pie, offset) {
    return this.builder.scrollForward(pie, offset);
  };

  Piechart_PieView.prototype.scrollBackward = function(pie, offset) {
    return this.builder.scrollBackward(pie, offset);
  };

  Piechart_PieView.prototype.onSceneChange = function(event) {
    return this.renderer.onSceneChange(event);
  };

  Piechart_PieView.prototype.doAnimations = function(event) {
    var changedPies, pie, pieChanges, _i, _len;
    if (event.changes.settings || event.changes.pie || event.changes.bounds) {
      pieChanges = false;
      pie = this.scene.peek();
      if (pie != null) {
        pieChanges = this.layout.placeStack(pie, event.context);
      }
    }
    changedPies = this.animator.doAnimations(event);
    for (_i = 0, _len = changedPies.length; _i < _len; _i++) {
      pie = changedPies[_i];
      this.layout.placeLabels(pie, event.context);
    }
    if (pieChanges || changedPies) {
      return event.changes.position = true;
    }
  };

  Piechart_PieView.prototype.paintScene = function(event) {
    return this.renderer.paintScene(event);
  };

  Piechart_PieView.prototype.getMovement = function(pie, event) {
    var a0, a1, d0, d1, dd, df, x0, x1, y0, y1;
    x0 = event.x - event.dx - pie.x;
    y0 = event.y - event.dy - pie.y;
    x1 = event.x - pie.x;
    y1 = event.y - pie.y;
    a0 = Math.atan2(y0, x0);
    a1 = Math.atan2(y1, x1);
    if (a0 - a1 > Math.PI) {
      a1 += Math.PI * 2;
    }
    if (a1 - a0 > Math.PI) {
      a0 += Math.PI * 2;
    }
    df = (a1 - a0) / (pie.currentEndAngle - pie.currentStartAngle);
    d0 = Math.sqrt(x0 * x0 + y0 * y0);
    d1 = Math.sqrt(x1 * x1 + y1 * y1);
    dd = d1 - d0;
    return [df, dd];
  };

  Piechart_PieView.prototype.findPieAt = function(px, py, tolerance) {
    var add, distSq, dx, dy, i, mul, pie, r0, r1, r1sq, x, xx, y, _i, _ref;
    add = this.scene.currentInnerRadius;
    mul = this.scene.currentRadius - add;
    for (i = _i = _ref = this.scene.pies.length - 1; _i >= 0; i = _i += -1) {
      pie = this.scene.pies[i];
      x = pie.x;
      y = pie.y;
      r0 = pie.currentInnerRadius * mul + add;
      r1 = pie.currentRadius * mul + add;
      xx = Math.max(0, r0 - tolerance);
      xx = r1 + tolerance;
      r1sq = xx * xx;
      dx = px - x;
      dy = py - y;
      distSq = dx * dx + dy * dy;
      if (pie.background) {
        if (distSq <= r1sq) {
          return pie;
        }
      }
    }
    return null;
  };

  Piechart_PieView.prototype.findSliceAt = function(px, py, tolerance) {
    var a1, ad, add, cosa0, cosa1, dist, distSq, dp1, dp2, dx, dy, i, mul, pie, r0, r0sq, r1, r1sq, selectionDistance, sina0, sina1, slice, x, xx, y, _i, _j, _len, _ref, _ref1;
    add = this.scene.currentInnerRadius;
    mul = this.scene.currentRadius - add;
    selectionDistance = this.scene.settings.interaction.selection.cutoutDistance;
    for (i = _i = _ref = this.scene.pies.length - 1; _i >= 0; i = _i += -1) {
      pie = this.scene.pies[i];
      if (pie.background) {
        continue;
      }
      x = pie.x;
      y = pie.y;
      r0 = pie.currentInnerRadius * mul + add;
      r1 = pie.currentRadius * mul + add;
      xx = Math.max(0, r0 - tolerance);
      r0sq = xx * xx;
      xx = r1 + tolerance + selectionDistance;
      r1sq = xx * xx;
      dx = px - x;
      dy = py - y;
      distSq = dx * dx + dy * dy;
      if (distSq < r0sq || distSq > r1sq) {
        continue;
      }
      dist = Math.sqrt(distSq);
      dx /= dist;
      dy /= dist;
      a1 = pie.currentStartAngle;
      ad = pie.currentEndAngle - a1;
      a1 += ad * pie.scrollOffset;
      cosa1 = Math.cos(a1);
      sina1 = Math.sin(a1);
      _ref1 = pie.allSlices;
      for (_j = 0, _len = _ref1.length; _j < _len; _j++) {
        slice = _ref1[_j];
        cosa0 = cosa1;
        sina0 = sina1;
        a1 += ad * slice.currentFraction;
        cosa1 = Math.cos(a1);
        sina1 = Math.sin(a1);
        if (dist >= r0 + slice.cutoutDistance && dist <= r1 + slice.cutoutDistance) {
          dp1 = sina0 * dx - cosa0 * dy;
          dp2 = sina1 * dx - cosa1 * dy;
          if (dp1 < 0 && dp2 > 0) {
            return slice;
          }
          if (Math.abs(ad * slice.currentFraction) > Math.PI) {
            if ((dp1 < 0 && dp2 < 0) || (dp1 > 0 && dp2 > 0)) {
              return slice;
            }
          }
        }
      }
    }
    return this.findLabelAt(px, py, tolerance)[0];
  };

  Piechart_PieView.prototype.findLabelAt = function(px, py, tolerance) {
    var i, l, pie, slice, x, y, _i, _j, _len, _ref, _ref1;
    for (i = _i = _ref = this.scene.pies.length - 1; _i >= 0; i = _i += -1) {
      pie = this.scene.pies[i];
      x = px - pie.x;
      y = py - pie.y;
      _ref1 = pie.allSlices;
      for (_j = 0, _len = _ref1.length; _j < _len; _j++) {
        slice = _ref1[_j];
        if (slice.currentLabel) {
          l = slice.currentLabel;
          if (l.visible && l.x - l.hwidth <= x && l.x + l.hwidth >= x && l.y - l.hheight <= y && l.y + l.hheight >= y) {
            return [slice, l];
          }
        }
        if (slice.currentInsideLabel) {
          l = slice.currentInsideLabel;
          if (l.visible && l.x - l.hwidth <= x && l.x + l.hwidth >= x && l.y - l.hheight <= y && l.y + l.hheight >= y) {
            return [slice, l];
          }
        }
      }
    }
    return [null, null];
  };

  return Piechart_PieView;

})(Piechart_View);
// Generated by CoffeeScript 1.8.0
var Facetchart_FacetAxis;

Facetchart_FacetAxis = (function() {
  Facetchart_FacetAxis.settings = {
    _doc: {
      doc: "Chart x-axis line rendered at the bottom horizontally to display group names under each bar.",
      type: "section"
    },
    enabled: true,
    enabled_doc: {
      doc: "Show/hide facet axis.",
      type: "bool"
    },
    size: 40,
    size_doc: {
      doc: "Height of the x axis.",
      type: "float",
      units: "pixels"
    },
    defaultUnitWidth: 50,
    defaultUnitWidth_doc: {
      doc: "Default width of one item. Used to calculate initial view.",
      type: "float",
      units: "pixels"
    },
    maxUnitWidth: 400,
    maxUnitWidth_doc: {
      doc: "Maximum width of one item.",
      type: "float",
      units: "pixels"
    },
    labels: {
      _doc: {
        doc: "Facet axis name settings.",
        type: "object",
        baseObject: Base_Label.styleSettings
      },
      enabled: true,
      angle: 0,
      lineSpacing: 0.2,
      interLabelSpacing: 0.6,
      textStyle: {
        fillColor: "#000000",
        font: "12px Arial"
      },
      margin: 4,
      padding: 0
    }
  };

  function Facetchart_FacetAxis(chart, facet) {
    this.chart = chart;
    this.facet = facet;
    this.scene = this.chart.scene;
    this.options = this.scene.settings.facetAxis;
    this.currentItemWidth = 1;
    this.currentItemHeight = 1;
    this.panel = new Base_ChartPanel();
    this.panel.side = "bottom";
    this.panel.packingOrder = 100;
  }

  Facetchart_FacetAxis.prototype.getPanel = function() {
    if (this.options.enabled && this.options.size > 0) {
      this.panel.desiredHeight = this.options.size;
      this.panel.visible = true;
      this.scene.bottomAxisSize = this.options.size;
    } else {
      this.panel.desiredHeight = 0;
      this.panel.visible = false;
      this.scene.bottomAxisSize = 0;
    }
    return this.panel;
  };

  Facetchart_FacetAxis.prototype.paint = function(event, boundsLeft, boundsWidth, xes) {
    var boundsRight, c0, c1, g, i, item, itemHeight, itemWidth, label, labelRenderer, rebuildLabels, top, x0, _i, _len, _ref, _results;
    if (!(xes.length > 1 && this.panel.visible)) {
      return;
    }
    g = event.context;
    labelRenderer = event.labelRenderer;
    boundsRight = boundsLeft + boundsWidth;
    itemWidth = xes[1] - xes[0];
    top = this.panel.top;
    itemHeight = this.panel.bottom - this.panel.top;
    if (this.options.labels.enabled) {
      rebuildLabels = false;
      if (Math.abs(1 - this.currentItemWidth / itemWidth) > 0.01 || Math.abs(1 - this.currentItemHeight / itemHeight) > 0.01) {
        this.currentItemWidth = itemWidth;
        this.currentItemHeight = itemHeight;
        rebuildLabels = true;
      }
      if (event.changes.settings) {
        rebuildLabels = true;
      }
      this.layout = new Base_LabelLayoutBase(g, this.options.labels);
      _ref = this.facet.items;
      _results = [];
      for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
        item = _ref[i];
        x0 = xes[i];
        if (item.label) {
          if (item.currentLabel === null || rebuildLabels || item.currentLabel.text !== item.label) {
            label = this.buildLabel(item.label, itemWidth, itemHeight);
            item.currentLabel = label;
          } else {
            label = item.currentLabel;
          }
          c0 = Math.max(x0 + 1, boundsLeft);
          c1 = Math.min(x0 + itemWidth - 2, boundsRight);
          Base_Graphics.pushClip(g, c0, top, c1 - c0, itemHeight);
          labelRenderer.paintWithStyle(g, x0 + label.x, top + label.y, 1, label, this.options.labels);
          _results.push(Base_Graphics.popClip(g));
        } else {
          _results.push(item.currentLabel = null);
        }
      }
      return _results;
    }
  };

  Facetchart_FacetAxis.prototype.buildLabel = function(text, availableWidth, availableHeight) {
    var align, angle, cosa, label, locationFromHeight, middleX, prop, sina;
    label = new Base_Label();
    label.text = text;
    angle = label.angle = this.layout.angle;
    align = this.options.labels.align;
    if (align) {
      label.align = align;
    } else if (angle > 0) {
      align = label.align = "left";
    } else if (angle < 0) {
      align = label.align = "right";
    } else {
      align = label.align = "center";
    }
    middleX = availableWidth / 2;
    sina = Math.sin(angle);
    cosa = Math.cos(angle);
    locationFromHeight = function(halfHeight) {
      var centerX, centerY, heightR, rotatedHeight, width;
      rotatedHeight = halfHeight * cosa;
      if (sina !== 0) {
        heightR = availableHeight - 2 * halfHeight * cosa;
        width = Math.max(0, heightR / Math.abs(sina));
      } else {
        if (halfHeight * 2 <= availableHeight) {
          width = availableWidth;
        } else {
          width = 0;
        }
      }
      if (angle > 0) {
        centerX = middleX + width / 2 * cosa;
        centerY = halfHeight * cosa + width / 2 * sina;
      } else if (angle < 0) {
        centerX = middleX - width / 2 * cosa;
        centerY = halfHeight * cosa - width / 2 * sina;
      } else {
        centerX = middleX;
        centerY = halfHeight;
      }
      return [centerX, centerY, cosa, sina, width];
    };
    prop = this.layout.fitLabelInRect(label, align, align, locationFromHeight);
    return label;
  };

  return Facetchart_FacetAxis;

})();
// Generated by CoffeeScript 1.8.0
var Facetchart_Selection,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

Facetchart_Selection = (function(_super) {
  __extends(Facetchart_Selection, _super);

  Facetchart_Selection.prototype.animationOrder = 2000;

  Facetchart_Selection.prototype.paintOrder = 15;

  Facetchart_Selection.prototype.updateOrder = 1000;

  Facetchart_Selection.settings = {
    _doc: {
      doc: "Configurable settings for select option.",
      type: "section"
    },
    enabled: true,
    enabled_doc: {
      doc: "Enable/disable selection",
      type: "bool"
    },
    tolerance: 2,
    tolerance_doc: {
      doc: "Selection distance tolerance.",
      type: "float",
      units: "pixels"
    }
  };

  Facetchart_Selection.prototype.scene = null;

  Facetchart_Selection.prototype.events = null;

  Facetchart_Selection.prototype.currentItem = null;

  Facetchart_Selection.prototype.currentFacet = null;

  Facetchart_Selection.prototype.draggedLabelItem = null;

  Facetchart_Selection.prototype.draggedLabel = null;

  Facetchart_Selection.prototype.hoverEvent = null;

  function Facetchart_Selection(chart) {
    this.chart = chart;
    this.scene = chart.scene;
    this.events = chart.events;
    this.dragPointers = {};
  }

  Facetchart_Selection.prototype.doAnimations = function(event) {
    if (this.hoverEvent) {
      return this.onPointerMove(this.hoverEvent);
    }
  };

  Facetchart_Selection.prototype.previewPointerDrag = function(event) {
    return this.hoverEvent = event;
  };

  Facetchart_Selection.prototype.onPointerMove = function(event) {
    var hoverItem, item, legendItem, s, series, _i, _ref;
    this.hoverEvent = event;
    item = this.scene.findItemAt(event.x, event.y, this.scene.settings.interaction.selection.tolerance);
    if (item) {
      event.cursor = "pointer";
    }
    hoverItem = this.chart.renderer.hitTest(event.x, event.y);
    if ((!hoverItem) && this.chart.legend) {
      legendItem = this.chart.legend.findItemAt(event.x, event.y);
      if (legendItem) {
        series = this.scene.settings._computedSeries;
        for (s = _i = 0, _ref = series.length; _i < _ref; s = _i += 1) {
          if (legendItem === series[s]) {
            hoverItem = {
              seriesIndex: s
            };
            event.cursor = "pointer";
          }
        }
      }
    }
    if ((!hoverItem !== !this.scene.hoverSeriesItem) || (hoverItem && (hoverItem.seriesIndex !== this.scene.hoverSeriesItem.seriesIndex || hoverItem.x0 !== this.scene.hoverSeriesItem.x0))) {
      this.scene.hoverSeriesItem = hoverItem;
      event.changes.hover = true;
    }
    return this.switchcurrentItem(item, event);
  };

  Facetchart_Selection.prototype.onPointerOut = function(event) {
    this.hoverEvent = this.scene.hoverSeriesItem = null;
    this.events.notifySceneChanges({
      selection: true
    });
    return this.switchcurrentItem(null, event);
  };

  Facetchart_Selection.prototype.onPointerDown = function(event) {
    var _ref;
    this.onPointerMove(event);
    _ref = this.scene.findLabelAt(event.x, event.y, this.scene.settings.interaction.selection.tolerance), this.draggedLabelItem = _ref[0], this.draggedLabel = _ref[1];
    if (this.draggedLabel) {
      return event.consumed = true;
    }
  };

  Facetchart_Selection.prototype.onPointerUp = function(event) {
    if (this.draggedLabel) {
      this.draggedLabel = null;
      return event.consumed = true;
    }
  };

  Facetchart_Selection.prototype.onPointerCancel = function(event) {
    if (this.draggedLabel) {
      return this.draggedLabel = null;
    }
  };

  Facetchart_Selection.prototype.onPointerDrag = function(event) {
    var label;
    if (this.draggedLabel) {
      label = this.draggedLabel;
      label.userPlaced = true;
      label.x += event.dx;
      label.y += event.dy;
      event.consumed = true;
      return event.changes.label = true;
    }
  };

  Facetchart_Selection.prototype.onClick = function(event) {
    var n, userEvent;
    n = this.scene.findItemAt(event.x, event.y, this.scene.settings.interaction.selection.tolerance);
    event.clickItem = n;
    event.clickFacet = n ? n.facet : null;
    event.consumed = true;
    if (n) {
      event.cursor = "pointer";
    }
    userEvent = this.chart.notifyClick(event);
    if (!userEvent.defaultPrevented) {
      return this.updateSelection(event, n, false);
    }
  };

  Facetchart_Selection.prototype.onRightClick = function(event) {
    var n, userEvent;
    n = this.scene.findItemAt(event.x, event.y, this.scene.settings.interaction.selection.tolerance);
    event.clickItem = n;
    event.clickFacet = n ? n.facet : null;
    userEvent = this.chart.notifyRightClick(event);
    if (n) {
      event.cursor = "pointer";
    }
    if (userEvent.defaultPrevented) {
      return event.consumed = true;
    }
  };

  Facetchart_Selection.prototype.onDoubleClick = function(event) {
    var n;
    n = this.scene.findItemAt(event.x, event.y, this.scene.settings.interaction.selection.tolerance);
    event.clickItem = n;
    if (n) {
      event.cursor = "pointer";
    }
    this.chart.notifyDoubleClick(event);
    return event.consumed = true;
  };

  Facetchart_Selection.prototype.updateSelection = function(event, target, softDeselect) {
    if (!this.scene.settings.interaction.selection.enabled) {
      return;
    }
    if (!event.shiftKey && (!target || target.selected)) {
      return this.setSelection([]);
    } else if (target && event.shiftKey || (softDeselect && target.selected)) {
      if (!target.selected) {
        this.scene.selection.push(target);
        target.selected = true;
        return this.setSelection(this.scene.selection, this.scene.selectionIds, true);
      }
    } else if (target) {
      return this.setSelection([target]);
    }
  };

  Facetchart_Selection.prototype.switchcurrentItem = function(obj, event) {
    if (obj === this.currentItem) {
      return;
    }
    event.changes.current = true;
    if (this.scene.hoverItem) {
      this.scene.hoverItem.active = false;
    }
    this.scene.hoverItem = obj;
    this.currentItem = obj;
    this.currentFacet = null;
    if (this.currentItem) {
      this.scene.hoverItem.active = true;
      event.hoverItem = this.currentItem;
    }
    this.events.notifySceneChanges({
      items: true
    });
    return this.chart.notifyHoverChanged(event);
  };

  Facetchart_Selection.prototype.onSceneChange = function(event) {
    if (event.changes.items) {
      if (this.updateSelectionIds()) {
        this.events.notifySceneChanges({
          selection: true
        });
        return this.chart.notifySelectionChanged(null);
      }
    }
  };

  Facetchart_Selection.prototype.updateSelectionIds = function() {
    var facet, id, item, itemsToSelect, _i, _j, _k, _l, _len, _len1, _len2, _len3, _ref, _ref1, _ref2;
    itemsToSelect = [];
    _ref = this.scene.selectionIds;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      id = _ref[_i];
      _ref1 = this.scene.activeFacet;
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        facet = _ref1[_j];
        _ref2 = facet.items;
        for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
          item = _ref2[_k];
          if (item.id === id) {
            itemsToSelect.push(item);
            break;
          }
        }
      }
    }
    if (itemsToSelect.length > 0) {
      for (_l = 0, _len3 = itemsToSelect.length; _l < _len3; _l++) {
        item = itemsToSelect[_l];
        if (!item.selected) {
          item.selected = true;
          this.scene.selection.push(item);
        }
        Base_Helpers.removeFromArray(this.scene.selectionIds, item.id);
      }
    }
    return itemsToSelect.length > 0;
  };

  Facetchart_Selection.prototype.setSelection = function(selection, selectionIds, alreadyChanged, origin) {
    var changedIds, hasChanges, s, _i, _j, _len, _len1, _ref;
    if (selectionIds == null) {
      selectionIds = [];
    }
    if (alreadyChanged == null) {
      alreadyChanged = false;
    }
    if (origin == null) {
      origin = "user";
    }
    this.scene.selectionIds = selectionIds;
    if (alreadyChanged) {
      hasChanges = true;
    } else {
      _ref = this.scene.selection;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        s = _ref[_i];
        if (!Base_Helpers.arrayContains(selection, s)) {
          s.selected = false;
          hasChanges = true;
        }
      }
      for (_j = 0, _len1 = selection.length; _j < _len1; _j++) {
        s = selection[_j];
        if (!s.selected) {
          s.selected = true;
          hasChanges = true;
        }
      }
      this.scene.selection = selection;
    }
    changedIds = this.updateSelectionIds();
    hasChanges || (hasChanges = changedIds);
    if (hasChanges) {
      this.events.notifySceneChanges({
        selection: true
      });
      return this.chart.notifySelectionChanged(origin);
    }
  };

  return Facetchart_Selection;

})(Base_ChartElement);
// Generated by CoffeeScript 1.8.0
var Facetchart_Facet, Facetchart_Item, Facetchart_ItemValue, Facetchart_Scene,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

Facetchart_Facet = (function() {
  function Facetchart_Facet() {
    this.id = null;
    this.data = null;
    this.items = [];
    this.parentItem = null;
    this.activeItemId = null;
    this.offset = 0;
    this.count = 0;
    this.totalCount = 0;
    this.from = 0;
    this.to = 0;
    this.left = 0;
    this.right = 1;
    this.opacity = 1;
  }

  Facetchart_Facet.prototype.getActiveItem = function() {
    var item, _i, _len, _ref;
    if (!this.activeItemId) {
      return null;
    }
    _ref = this.items;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      item = _ref[_i];
      if (item.id === this.activeItemId) {
        return item;
      }
    }
    return null;
  };

  return Facetchart_Facet;

})();

Facetchart_Item = (function() {
  function Facetchart_Item(facet, id, index, data) {
    this.facet = facet;
    this.id = id;
    this.index = index;
    this.data = data;
    this.expandable = true;
    this.selected = false;
    this.active = false;
    this.url = null;
    this.values = [];
    this.innerFacet = null;
    this.label = null;
    this.currentLabel = null;
  }

  return Facetchart_Item;

})();

Facetchart_ItemValue = (function() {
  Facetchart_ItemValue.prototype.value = 0;

  Facetchart_ItemValue.prototype.fillColor = null;

  Facetchart_ItemValue.prototype.lineColor = null;

  Facetchart_ItemValue.prototype.lineWidth = 1;

  Facetchart_ItemValue.prototype.label = null;

  Facetchart_ItemValue.prototype.previewContents = false;

  Facetchart_ItemValue.prototype.previewData = null;

  function Facetchart_ItemValue(facet, id, index, data) {
    this.facet = facet;
    this.id = id;
    this.index = index;
    this.data = data;
  }

  Facetchart_ItemValue.prototype.currentLabel = null;

  return Facetchart_ItemValue;

})();

Facetchart_Scene = (function(_super) {
  "use strict";
  __extends(Facetchart_Scene, _super);

  function Facetchart_Scene(settings) {
    Facetchart_Scene.__super__.constructor.call(this, settings);
    this.data = null;
    this.stack = [];
    this.selection = [];
    this.selectionIds = [];
    this.activeFacet = null;
    this.hoverItem = null;
  }

  Facetchart_Scene.prototype.xToPosition = function(x) {
    var f, left, pos, right;
    f = this.activeFacet;
    left = this.x0 + f.left * this.width;
    right = this.x0 + f.right * this.width;
    pos = f.from + (x - left) / (right - left) * (f.to - f.from);
    return pos;
  };

  Facetchart_Scene.prototype.positionToX = function(t) {
    var f, left, right;
    f = this.activeFacet;
    left = this.x0 + f.left * this.width;
    right = this.x0 + f.right * this.width;
    return left + (t - f.from) * (right - left) / (f.to - f.from);
  };

  Facetchart_Scene.prototype.timeToX = function(t) {
    return this.positionToX(t);
  };

  Facetchart_Scene.prototype.xToTime = function(x) {
    return this.xToPosition(x);
  };

  Facetchart_Scene.prototype.length = function() {
    return this.stack.length;
  };

  Facetchart_Scene.prototype.peek = function() {
    if (this.stack.length === 0) {
      return null;
    }
    return this.stack[this.stack.length - 1];
  };

  Facetchart_Scene.prototype.push = function(facet, originItem) {
    var a0, a1, item, parent, _i, _len, _ref, _ref1;
    parent = this.peek();
    if (parent && !originItem) {
      _ref = parent.items;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        item = _ref[_i];
        if (item.data.__id === facet.id) {
          originItem = item;
          break;
        }
      }
    }
    if (originItem) {
      facet.parentItem = originItem;
      originItem.innerFacet = facet;
      _ref1 = this.getItemPlacement(originItem), a0 = _ref1[0], a1 = _ref1[1];
      facet.left = a0;
      facet.right = a1;
      parent.activeItemId = originItem.id;
    } else if (parent) {
      parent.activeItemId = null;
    }
    this.stack.push(facet);
    return this.activeFacet = facet;
  };

  Facetchart_Scene.prototype.pop = function() {
    var f;
    if (this.stack.length > 0) {
      f = this.stack.pop();
      if (f.parentItem) {
        f.parentItem.facet.activeItemId = null;
      }
    }
    if (this.stack.length > 0) {
      this.activeFacet = this.peek();
    } else {
      this.activeFacet = null;
    }
    return this.activeFacet;
  };

  Facetchart_Scene.prototype.getParent = function(pie) {
    var p, parent, _i, _len, _ref;
    parent = null;
    _ref = this.stack;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      p = _ref[_i];
      if (p === pie) {
        return parent;
      }
      parent = p;
    }
    return null;
  };

  Facetchart_Scene.prototype.getChild = function(pie) {
    var p, parent, _i, _len, _ref;
    parent = null;
    _ref = this.stack;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      p = _ref[_i];
      if (parent === pie) {
        return p;
      }
      parent = p;
    }
    return null;
  };

  Facetchart_Scene.prototype.updateLinks = function(facet) {
    var child, item, parent, _i, _j, _len, _len1, _ref, _ref1, _results;
    parent = this.getParent(facet);
    child = this.getChild(facet);
    if (parent && !facet.parentItem) {
      _ref = parent.items;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        item = _ref[_i];
        if (item.id === facet.id) {
          facet.parentItem = item;
          parent.activeItemId = item.id;
          break;
        }
      }
    }
    if (child && !child.parentItem) {
      _ref1 = facet.items;
      _results = [];
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        item = _ref1[_j];
        if (item.id === child.id) {
          child.parentItem = item;
          facet.activeItemId = item.id;
          break;
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    }
  };

  Facetchart_Scene.prototype.getItemPlacement = function(item) {
    var a0, da, facet, i, p0, p1;
    facet = item.facet;
    i = item.index;
    da = facet.to - facet.from;
    a0 = facet.from;
    p0 = (i - a0) / da;
    p1 = (i - a0 + 1) / da;
    return [facet.left + p0 * (facet.right - facet.left), facet.left + p1 * (facet.right - facet.left)];
  };

  Facetchart_Scene.prototype.getFacetPlacementFromItem = function(item, iLeft, iRight) {
    var A0, A1, facet, i0, i1, left, right;
    facet = item.facet;
    i0 = item.index;
    i1 = i0 + 1;
    A0 = (i0 - facet.from) / (facet.to - facet.from);
    A1 = (i1 - facet.from) / (facet.to - facet.from);
    left = iLeft - A0 * (iLeft - iRight) / (A0 - A1);
    right = left + (iLeft - iRight) / (A0 - A1);
    return [left, right];
  };

  Facetchart_Scene.prototype.findFacetAt = function(x, y) {
    return null;
  };

  Facetchart_Scene.prototype.findItemAt = function(x, y) {
    var f, pos;
    f = this.activeFacet;
    if (!(this.xyInChart(x, y) && f)) {
      return null;
    }
    pos = Math.floor(this.xToPosition(x));
    if (pos >= f.offset && pos < f.offset + f.count) {
      return f.items[pos - f.offset];
    }
    return null;
  };

  Facetchart_Scene.prototype.findLabelAt = function(x, y) {
    return [null, null];
  };

  return Facetchart_Scene;

})(Linearchart_Scene);
// Generated by CoffeeScript 1.8.0
var Facetchart_Scrolling,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

Facetchart_Scrolling = (function(_super) {
  "use strict";
  __extends(Facetchart_Scrolling, _super);

  Facetchart_Scrolling.prototype.animationOrder = 100;

  Facetchart_Scrolling.prototype.paintOrder = 10;

  Facetchart_Scrolling.prototype.updateOrder = 1100;

  function Facetchart_Scrolling(chart) {
    Facetchart_Scrolling.__super__.constructor.call(this, chart);
    this.facet = null;
    this.animatingFacet = null;
    this.leftAnimator = null;
    this.rightAnimator = null;
    this.activePieReady = false;
  }

  Facetchart_Scrolling.prototype.setState = function(id, offset, count, origin) {
    var changes, facet, from, pieId, to;
    if (!Base_Helpers.isArray(id)) {
      id = [id];
    }
    if (id.length === 0) {
      this.chart.error("setPie - array needs at least one item.");
      return;
    }
    changes = 0;
    while (this.scene.length() > id.length) {
      this.scene.pop();
      changes++;
    }
    while (this.scene.length() > 0 && this.scene.peek().id !== id[this.scene.length() - 1]) {
      this.scene.pop();
      changes++;
    }
    while (this.scene.length() < id.length) {
      pieId = id[this.scene.length()];
      this.drillDown(pieId, null);
      changes++;
    }
    facet = this.scene.peek();
    this.facet = facet;
    if (changes) {
      this.goToPositionDragging(facet.from, facet.to);
    }
    if (facet.offset !== offset || (count && facet.count !== count)) {
      from = offset;
      if (count > 0) {
        to = from + count;
      } else {
        to = offset + facet.count;
      }
      if (changes) {
        this.goToPositionDragging(from, to);
        this.animateFillChart();
      } else {
        this.goToPosition(from, to, true);
      }
    } else if (changes) {
      this.animateFillChart();
    }
    this.chart.notifyChartUpdate(origin);
    if (changes) {
      return this.events.notifySceneChanges({
        navigation: true
      });
    }
  };

  Facetchart_Scrolling.prototype.getState = function() {
    var pie;
    return [
      (function() {
        var _i, _len, _ref, _results;
        _ref = this.scene.stack;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          pie = _ref[_i];
          _results.push(pie.id);
        }
        return _results;
      }).call(this), this.scene.peek().offset, this.scene.peek().count
    ];
  };

  Facetchart_Scrolling.prototype.goUp = function(origin) {
    var f;
    if (this.scene.length() > 1) {
      this.scene.pop();
      this.facet = f = this.scene.peek();
      this.goToPositionDragging(f.from, f.to);
      this.animateFillChart();
      this.events.notifySceneChanges({
        navigation: true
      });
      return this.updateAndNotifyCurrent(origin);
    } else {
      return this.goToPosition(0, this.getMaxItems(), true);
    }
  };

  Facetchart_Scrolling.prototype.getMaxItems = function() {
    var m;
    m = this.scene.width / this.scene.settings.facetAxis.defaultUnitWidth;
    if (this.facet.data.totalCount) {
      m = Math.min(m, this.facet.data.totalCount);
    }
    return m;
  };

  Facetchart_Scrolling.prototype.drillDown = function(pieId, origin) {
    var f;
    this.stopAnimations();
    f = new Facetchart_Facet();
    f.id = pieId;
    this.scene.push(f);
    this.chart.builder.updateFacet(f);
    this.facet = f;
    this.currentFrom = f.from;
    this.currentTo = f.to;
    this.animateFillChart();
    this.events.notifySceneChanges({
      navigation: true
    });
    return this.updateAndNotifyCurrent(origin);
  };

  Facetchart_Scrolling.prototype.updateAndNotifyCurrent = function(origin) {
    this.chart.builder.updateFacet(this.facet);
    return this.chart.notifyChartUpdate(origin);
  };

  Facetchart_Scrolling.prototype.onSceneChange = function(event) {
    var f, facet, ids, pie, _i, _j, _k, _len, _len1, _len2, _ref, _ref1, _ref2;
    f = this.facet;
    if (event.changes.settings && event.changes.settingsChanges.series) {
      event.changes.items = true;
      _ref = this.scene.stack;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        facet = _ref[_i];
        this.chart.builder.rebuildValues(facet);
      }
    }
    if (event.changes.dataArrived || event.changes.data) {
      this.activePieReady = false;
      if (event.changes.dataArrived) {
        ids = event.changes.dataArrivedIds;
        _ref1 = this.scene.stack;
        for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
          pie = _ref1[_j];
          if (ids.hasOwnProperty(pie.id)) {
            this.chart.builder.updateFacet(pie, event);
            event.changes.items = true;
            this.activePieReady || (this.activePieReady = pie === f && !pie.loading);
          }
        }
      }
      if (event.changes.data) {
        _ref2 = this.scene.stack;
        for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
          facet = _ref2[_k];
          if (!facet.data || facet === f || event.changes.dataDeep) {
            facet.rebuild = true;
            this.chart.builder.updateFacet(facet, event);
            event.changes.items = true;
            this.activePieReady || (this.activePieReady = facet === f && !facet.loading);
          }
        }
      }
    }
    if (this.activePieReady && this.scene.width > 0) {
      this.activePieReady = false;
      if (this.currentFrom === this.currentTo && f.from < f.to) {
        this.currentFrom = f.from;
        this.currentTo = f.to;
        this.animateFillChart();
      }
      return this.chart.notifyChartUpdate(null);
    }
  };

  Facetchart_Scrolling.prototype.doAnimations = function(event) {
    var done, f, opacity, visiblePerc, _i, _len, _ref;
    f = this.facet;
    if (this.animatingFacet) {
      f.left = this.leftAnimator.get(event.timeStamp);
      f.right = this.rightAnimator.get(event.timeStamp);
      f.opacity = this.opacityAnimator.get(event.timeStamp);
      done = this.leftAnimator.finished(event.timeStamp) || this.rightAnimator.finished(event.timeStamp);
      if (done) {
        this.animatingFacet = null;
        this.leftAnimator = null;
        this.rightAnimator = null;
        this.opacityAnimator = null;
      }
      this.events.notifySceneChanges({
        position: true
      });
      event.animating = true;
    } else {
      visiblePerc = f.right - f.left;
      opacity = Math.min(1, Math.abs(visiblePerc));
      f.opacity = 1;
    }
    this.layoutFacets();
    _ref = this.scene.stack;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      f = _ref[_i];
      this.chart.builder.updateFacet(f);
    }
    return Facetchart_Scrolling.__super__.doAnimations.call(this, event);
  };

  Facetchart_Scrolling.prototype.xyInArea = function(x, y) {
    return this.scene.xyInChartOrBottom(x, y);
  };

  Facetchart_Scrolling.prototype.xyToPosition = function(x, y) {
    return this.scene.xToPosition(x);
  };

  Facetchart_Scrolling.prototype.onZoomOut = function(from, to, origin, scale) {
    if (scale == null) {
      scale = null;
    }
    return Facetchart_Scrolling.__super__.onZoomOut.call(this, from, to, origin, scale);
  };

  Facetchart_Scrolling.prototype.onZoomIn = function(from, to, center, scale) {
    if (scale == null) {
      scale = null;
    }
    return Facetchart_Scrolling.__super__.onZoomIn.call(this, from, to, center, scale);
  };

  Facetchart_Scrolling.prototype.onScroll = function(from, to, direction) {
    return Facetchart_Scrolling.__super__.onScroll.call(this, from, to, direction);
  };

  Facetchart_Scrolling.prototype.onGoHome = function(from, to) {
    return [0, to - from, 0];
  };

  Facetchart_Scrolling.prototype.onStartDragging = function(oldFrom, oldTo, pos) {
    return this.stopAnim();
  };

  Facetchart_Scrolling.prototype.onSnapWhileDragging = function(from, to, origin, isScrolling, isScaling) {
    var cnt, dcenter, diff, fr, left, margin, right, t, total, visibleDiff;
    diff = to - from;
    dcenter = ((from + to) - (this.dragStartFrom + this.dragStartTo)) / 2;
    left = 0;
    right = 1;
    total = this.facet.totalCount;
    if (this.dragStartFrom <= 0 && dcenter < 0) {
      if (this.scene.stack.length > 1) {
        left = Math.min(0.19, -dcenter / diff / 3);
        right = 1 - left * 4;
        from = this.dragStartFrom;
        to = this.dragStartTo;
      } else {
        visibleDiff = diff * Math.pow(3, -dcenter / diff);
        margin = -dcenter / 5;
        if (total > 0) {
          visibleDiff = Math.min(total, visibleDiff);
        }
        from = -margin;
        to = visibleDiff + margin;
      }
    } else if (from < 0) {
      fr = Math.max(-diff, from / 2);
      from = fr;
      to = fr + diff;
    } else if (total > 0 && to > total) {
      cnt = total;
      t = cnt + Math.min(diff, (to - cnt) / 2);
      from = t - diff;
      to = t;
    }
    if (from < 0) {
      left -= from * (right - left) / (to - from);
      from = 0;
    }
    this.facet.left = left;
    this.facet.right = right;
    return [from, to];
  };

  Facetchart_Scrolling.prototype.onSnapAfterDragging = function(from, to, origin, isScrolling, isScaling) {
    var _ref;
    if (this.shouldZoomOut()) {
      this.goUp("user");
      return null;
    } else {
      _ref = this.snap(from, to, origin, isScrolling, isScaling), from = _ref[0], to = _ref[1];
      this.animateFillChart();
      this.chart.notifyChartUpdate("user");
      return [from, to];
    }
  };

  Facetchart_Scrolling.prototype.shouldZoomOut = function() {
    return (this.facet.right - this.facet.left < 0.5) && this.scene.stack.length > 1 && this.dragStartFrom === 0;
  };

  Facetchart_Scrolling.prototype.onPositionChanged = function(from, to) {
    var f;
    f = this.facet;
    f.from = from;
    f.to = to;
    this.chart.builder.updateFacet(f);
    return this.events.notifySceneChanges({
      position: true
    });
  };

  Facetchart_Scrolling.prototype.onAnimationDone = function(from, to) {
    this.chart.notifyChartUpdate(null);
    return this.chart.notifyAnimationDone();
  };


  /*
     Takes the time range and applies snapping rules from settings.
   */

  Facetchart_Scrolling.prototype.snap = function(from, to, origin, scroll, scale) {
    var curItemSize, itemSize, newFrom;
    curItemSize = this.scene.width / (to - from);
    itemSize = Math.min(this.scene.settings.facetAxis.maxUnitWidth, curItemSize);
    if (this.facet.totalCount > 0) {
      itemSize = Math.max(itemSize, this.scene.width / this.facet.totalCount);
    }
    scale = curItemSize / itemSize;
    from = origin + (from - origin) * scale;
    to = origin + (to - origin) * scale;
    from = Math.round(from);
    to = Math.round(to);
    if (from < 0) {
      to -= from;
      from = 0;
    } else if (this.facet.totalCount > 0 && to > this.facet.totalCount) {
      newFrom = Math.max(0, this.facet.totalCount - (to - from));
      to = to - from + newFrom;
      from = newFrom;
    }
    return [from, to];
  };

  Facetchart_Scrolling.prototype.animateFillChart = function() {
    if (this.facet.left !== 0 || this.facet.right !== 1 || this.animatingFacet !== this.facet) {
      this.animatingFacet = this.facet;
      this.leftAnimator = new Base_Animator(this.facet.left, 0, this.scene.settings.interaction.animation.scrollDuration, "<>");
      this.rightAnimator = new Base_Animator(this.facet.right, 1, this.scene.settings.interaction.animation.scrollDuration, "<>");
      this.opacityAnimator = new Base_Animator(this.facet.opacity, 1, this.scene.settings.interaction.animation.scrollDuration, "<>");
      return this.events.notifySceneChanges({
        animating: true
      });
    }
  };

  Facetchart_Scrolling.prototype.stopAnim = function() {
    this.animatingFacet = null;
    this.leftAnimator = null;
    return this.rightAnimator = null;
  };

  Facetchart_Scrolling.prototype.layoutFacets = function() {
    var f, i, opacity, parent, _i, _ref, _ref1;
    f = this.facet;
    if (f.left > 0 || f.right < 1) {
      opacity = 0.5;
    } else {
      opacity = 0;
    }
    for (i = _i = _ref = this.scene.stack.length - 2; _i >= 0; i = _i += -1) {
      parent = this.scene.stack[i];
      if (f.parentItem) {
        _ref1 = this.scene.getFacetPlacementFromItem(f.parentItem, f.left, f.right), parent.left = _ref1[0], parent.right = _ref1[1];
      }
      parent.opacity = opacity;
      opacity = parent.left > 0 || parent.right < 1 ? 0.2 : 0;
      f = parent;
    }
    if (this.shouldZoomOut()) {
      this.facet.opacity = 0.5;
      return this.facet.parentItem.facet.opacity = 1;
    } else {
      return this.facet.opacity = 1;
    }
  };

  return Facetchart_Scrolling;

})(Linearchart_Scrolling);
// Generated by CoffeeScript 1.8.0
var Facetchart_Builder;

Facetchart_Builder = (function() {
  "use strict";
  function Facetchart_Builder(chart) {
    this.chart = chart;
    this.scene = chart.scene;
    this.loading = false;
  }

  Facetchart_Builder.prototype.updateFacet = function(facet, event) {
    var changes, curToOffset, data, dataSource, fromData, fromOffset, i, itemsToShow, maxSliceCount, minSliceCount, newItems, pieIds, toData, toOffset, _i, _j, _ref, _ref1;
    dataSource = this.chart.getData("default");
    data = dataSource.getPieData(facet.id);
    facet.data = data;
    if (!data) {
      facet.loading = true;
      dataSource.requestPieData(facet.id, Math.floor(facet.from));
      return;
    }
    changes = false;
    if (this.scene.width && (!(facet.from < facet.to) || facet.rebuild)) {
      facet.rebuild = false;
      minSliceCount = Math.max(1, Math.floor(this.scene.width / this.scene.settings.facetAxis.maxUnitWidth));
      maxSliceCount = Math.max(1, Math.floor(this.scene.width / this.scene.settings.facetAxis.defaultUnitWidth));
      if (data.totalCount) {
        itemsToShow = Math.min(data.totalCount, maxSliceCount);
      } else {
        itemsToShow = maxSliceCount;
      }
      facet.offset = Math.floor(facet.from);
      facet.count = 0;
      facet.to = facet.from + Math.round(itemsToShow);
      facet.items = [];
    }
    if (data.totalCount) {
      facet.totalCount = data.totalCount;
    }
    fromOffset = Math.max(0, Math.floor(facet.from));
    toOffset = Math.ceil(facet.to);
    toData = data.values.length + data.offset;
    fromData = data.offset;
    facet.loading = false;
    if (fromData > fromOffset) {
      fromOffset = fromData;
      dataSource.requestLessPieData(facet.id);
      facet.loading = true;
    }
    if (toData < toOffset) {
      toOffset = toData;
      if (!data.done) {
        dataSource.requestMorePieData(facet.id);
        facet.loading = true;
      }
    }
    curToOffset = facet.offset + facet.items.length;
    if (toOffset < facet.offset || fromOffset > curToOffset) {
      facet.offset = fromOffset;
      facet.items = [];
      curToOffset = fromOffset;
    }
    if (fromOffset > facet.offset) {
      facet.items = facet.items.slice(fromOffset - facet.offset);
      facet.offset = fromOffset;
    } else if (fromOffset < facet.offset) {
      newItems = [];
      for (i = _i = fromOffset, _ref = facet.offset - 1; _i <= _ref; i = _i += 1) {
        newItems.push(this.buildItem(facet, data, i));
      }
      facet.items = newItems.concat(facet.items);
      facet.offset = fromOffset;
      changes = true;
    }
    if (toOffset < curToOffset) {
      facet.items = facet.items.slice(0, toOffset - facet.offset);
    } else if (toOffset > curToOffset) {
      for (i = _j = curToOffset, _ref1 = toOffset - 1; _j <= _ref1; i = _j += 1) {
        facet.items.push(this.buildItem(facet, data, i));
      }
      changes = true;
    }
    facet.count = facet.items.length;
    if (changes) {
      if (event) {
        event.changes.items = true;
        if (!event.changes.changedItems) {
          event.changes.changedItems = {};
        }
        event.changes.changedItems[facet.id] = true;
      } else {
        pieIds = [];
        pieIds[facet.id] = true;
        this.chart.events.notifySceneChanges({
          items: true,
          changedItems: pieIds
        });
      }
    }
    return this.scene.updateLinks(facet);
  };

  Facetchart_Builder.prototype.rebuildValues = function(facet) {
    var item, _i, _len, _ref, _results;
    _ref = facet.items;
    _results = [];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      item = _ref[_i];
      _results.push(this.updateItem(item));
    }
    return _results;
  };

  Facetchart_Builder.prototype.buildItem = function(facet, data, index) {
    var item;
    data = data.values[index - data.offset];
    item = new Facetchart_Item(facet, data.__id, index, data);
    this.updateItem(item);
    return item;
  };

  Facetchart_Builder.prototype.updateItem = function(item) {
    var series, value, values, _i, _len, _ref;
    values = [];
    _ref = this.scene.settings._computedSeries;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      series = _ref[_i];
      value = new Facetchart_ItemValue(item.facet, item.id, item.index, item.data);
      if (item.data) {
        value.value = this.getSeriesValue(item.data, series);
      } else {
        value.value = null;
      }
      values.push(value);
    }
    return item.values = values;
  };

  Facetchart_Builder.prototype.getSeriesValue = function(data, series) {
    var field, func;
    func = series.data.valueFunction;
    if (func) {
      return parseFloat(func(data));
    } else {
      field = series.data.field || "value";
      return parseFloat(data[field]);
    }
  };

  Facetchart_Builder.prototype.buildPreviewData = function(item, series) {
    var data, i, id, pvd, sceneData, sum, v, val, _i, _j, _len, _len1, _ref;
    id = item.id;
    sceneData = this.scene.mainData;
    data = sceneData.getPieData(id);
    pvd = null;
    if (!data) {
      if (item.expandable && sceneData.canExpand(id)) {
        sceneData.requestPieData(item.id, 0);
      }
    } else if (data.offset > 0) {
      sceneData.requestLessPieData(item.id, 0, data.offset);
    } else {
      pvd = [];
      sum = 0;
      _ref = data.values;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        val = _ref[_i];
        v = this.getSeriesValue(val, series);
        pvd.push(v);
        sum += v;
      }
      if (sum > 0) {
        sum = 1 / sum;
        for (i = _j = 0, _len1 = pvd.length; _j < _len1; i = ++_j) {
          val = pvd[i];
          pvd[i] = val * sum;
        }
      } else {
        pvd = null;
      }
    }
    return pvd;
  };

  return Facetchart_Builder;

})();
// Generated by CoffeeScript 1.8.0
var Facetchart_Styles,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

Facetchart_Styles = (function(_super) {
  __extends(Facetchart_Styles, _super);

  Facetchart_Styles.prototype.animationOrder = 200;

  Facetchart_Styles.prototype.paintOrder = 20;

  Facetchart_Styles.prototype.updateOrder = 900;

  function Facetchart_Styles(chart) {
    this.chart = chart;
    this.scene = chart.scene;
  }

  Facetchart_Styles.prototype.doAnimations = function(event) {
    var facet, _results;
    if (!(event.changes.settings || event.changes.items || event.changes.selection || event.changes.navigation)) {
      return;
    }
    facet = this.scene.activeFacet;
    if (!facet) {
      return;
    }
    this.computeFacetStyleRec(facet);
    _results = [];
    while (facet && facet.parentItem) {
      facet = facet.parentItem.facet;
      _results.push(this.computeFacetStyleRec(facet));
    }
    return _results;
  };

  Facetchart_Styles.prototype.computeFacetStyleRec = function(facet) {
    var i, item, _i, _len, _ref, _results;
    this.computeFacetStyle(facet);
    _ref = facet.items;
    _results = [];
    for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
      item = _ref[i];
      this.computeItemStyle(facet, item);
      if (item.innerFacet) {
        _results.push(this.computeFacetStyleRec(item.innerFacet));
      } else {
        _results.push(void 0);
      }
    }
    return _results;
  };

  Facetchart_Styles.prototype.computeFacetStyle = function(facet) {
    return 1;
  };

  Facetchart_Styles.prototype.computeItemStyle = function(facet, item, i) {
    var s, series, value, _i, _j, _k, _len, _len1, _len2, _ref, _ref1, _ref2, _results;
    series = this.scene.settings._computedSeries;
    Base_Helpers.extend(item, this.scene.settings.items.style);
    if (item.data.style) {
      Base_Helpers.extend(item, item.data.style);
    }
    if (item.id === item.facet.activeItemId) {
      _ref = item.values;
      for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
        value = _ref[i];
        value.fillColor = null;
        value.lineColor = null;
      }
    } else {
      _ref1 = item.values;
      for (i = _j = 0, _len1 = _ref1.length; _j < _len1; i = ++_j) {
        value = _ref1[i];
        Base_Helpers.extend(value, series[i].style);
      }
    }
    if (this.scene.settings.items.styleFunction) {
      this.scene.settings.items.styleFunction(item, item.data);
      if (item.label && !Base_Helpers.isString(item.label)) {
        item.label = "" + item.label;
      }
    } else {
      if (item.data.name) {
        item.label = item.data.name;
      }
    }
    if (item.id !== item.facet.activeItemId) {
      _ref2 = item.values;
      _results = [];
      for (i = _k = 0, _len2 = _ref2.length; _k < _len2; i = ++_k) {
        value = _ref2[i];
        s = series[i];
        if (s.styleFunction) {
          s.styleFunction(value, item.data);
        }
        if (value.previewContents) {
          _results.push(value.previewData = this.chart.builder.buildPreviewData(item, s));
        } else {
          _results.push(value.previewData = null);
        }
      }
      return _results;
    } else {
      return value.previewData = null;
    }
  };

  return Facetchart_Styles;

})(Base_ChartElement);
// Generated by CoffeeScript 1.8.0
var Itemschart_ItemsStyle;

Itemschart_ItemsStyle = (function() {
  Itemschart_ItemsStyle.settings = {
    nodeRules: {},
    nodeRules_doc: {
      doc: "An object defining one or more functions used to calculate node rendering style. See see::examples/style/round-image-nodes.html::round image nodes:: example.",
      type: "object"
    },
    linkRules: {},
    linkRules_doc: {
      doc: "An object defining one or more functions used to calculate node rendering style. Structure: { 'rule1':function1(nodeObj), 'rule2':function2(nodeObj) } The functions are executed in lexicographic order whenever node data or links change. Each function can modify the nodeObj to add specific style elements.",
      type: "object"
    },
    nodeClasses: [],
    nodeClasses_doc: {
      doc: "The class rules to apply individual style for node subset. Use known CSS class definition practice. Define one or more classes by specifying name and style and apply those by node definition. If multiple classes applied separate them with space and class rules will cascade in order of class definition.",
      type: "array",
      baseObject: {
        _doc: {
          doc: "Class definition object to apply on node subset",
          type: "object"
        },
        name: null,
        name_doc: {
          doc: "Class name.",
          type: "string"
        },
        style: {},
        style_doc: {
          doc: "Style attributes.",
          type: "object",
          baseObject: Itemschart_Node.styleSettings
        }
      }
    },
    linkClasses: [],
    linkClasses_doc: {
      doc: "The class rules to apply individual style for link subset. Use known CSS class definition practice. Define one or more classes by specifying name and style and apply those by node definition. If multiple classes applied separate them with space and class rules will cascade in order of class definition.",
      type: "array",
      baseObject: {
        _doc: {
          doc: "Class definition object to apply on node subset",
          type: "object"
        },
        name: null,
        name_doc: {
          doc: "Class name.",
          type: "string"
        },
        style: {},
        style_doc: {
          doc: "Style attributes.",
          type: "object",
          baseObject: Itemschart_Link.styleSettings
        }
      }
    },
    node: {
      _doc: {
        doc: "Default node style.",
        type: "object",
        baseObject: Itemschart_Node.styleSettings
      },
      fillColor: "#c7dae0",
      lineColor: null,
      lineWidth: null,
      radius: 30,
      shadowColor: null,
      lineDash: null
    },
    link: {
      _doc: {
        doc: "Default link style.",
        type: "object",
        baseObject: Itemschart_Link.prototype.styleSettings
      },
      fillColor: "#333",
      shadowColor: null,
      fromDecoration: null,
      toDecoration: null,
      label: null,
      radius: 1,
      length: 1,
      strength: 1,
      lineDash: null,
      toPieValue: 0,
      toPieColor: null
    },
    item: {
      _doc: {
        doc: "Items are small UI elements that provide extra information. Items are attached to nodes or links and can display a label, image or both.",
        type: "object",
        baseObject: Base_Label.styleSettings
      },
      align: "center",
      aspectRatio: 4,
      borderRadius: 1000,
      textStyle: {
        fillColor: "black",
        font: "12px Arial"
      },
      backgroundStyle: {
        fillColor: "rgba(255,255,255,0.7)"
      }
    },
    linkLabel: {
      _doc: {
        doc: "Link text style.",
        type: "object",
        baseObject: Base_Label.styleSettings
      },
      scaleWithZoom: true,
      scaleWithZoom_doc: {
        doc: "Whether to apply the scale if zoom changes. If false, the link size never changes.",
        type: "bool"
      },
      scaleWithSize: false,
      scaleWithSize_doc: {
        doc: "Whether to apply different scale according to initial size of the link.",
        type: "bool"
      },
      padding: 0,
      margin: 0,
      align: "center",
      aspectRatio: 4,
      borderRadius: 1000,
      textStyle: {
        fillColor: "black",
        font: "12px Arial"
      },
      backgroundStyle: {
        fillColor: "#FFF",
        lineColor: "gray"
      }
    },
    nodeLabel: {
      _doc: {
        doc: "Node label style.",
        type: "object",
        baseObject: Base_Label.styleSettings
      },
      scaleWithZoom: false,
      scaleWithZoom_doc: {
        doc: "Whether to apply the scale if zoom changes. If false, the node label size never changes.",
        type: "bool"
      },
      scaleWithSize: true,
      scaleWithSize_doc: {
        doc: "Whether to apply different scale according to initial size of the link",
        type: "bool"
      },
      align: "center",
      aspectRatio: 4,
      borderRadius: 1000,
      padding: 0,
      textStyle: {
        fillColor: "black",
        font: "12px Arial"
      },
      backgroundStyle: {
        fillColor: "rgba(255,255,255,0.7)"
      }
    },
    nodeLocked: {
      _doc: {
        doc: "Additional style to apply when a node position is locked.",
        type: "object",
        baseObject: Itemschart_Node.styleSettings
      }
    },
    nodeExpanded: {
      _doc: {
        doc: "Additional style to apply when node is expanded.",
        type: "object",
        baseObject: Itemschart_Node.styleSettings
      }
    },
    nodeFocused: {
      _doc: {
        doc: "Additional style to apply when node is focused.",
        type: "object",
        baseObject: Itemschart_Node.styleSettings
      },
      fillColor: "#09c"
    },
    nodeNotLoaded: {
      _doc: {
        doc: "Additional style to apply when node data is not yet loaded.",
        type: "object",
        baseObject: Itemschart_Node.styleSettings
      },
      fillColor: "#fff"
    },
    nodeHovered: {
      _doc: {
        doc: "Additional style to apply when a node is hovered.",
        type: "object",
        baseObject: Itemschart_Node.styleSettings
      },
      shadowOffsetX: 0,
      shadowOffsetY: 0,
      shadowBlur: 12,
      shadowColor: "blue"
    },
    linkHovered: {
      _doc: {
        doc: "Additional style to apply when a link is hovered.",
        type: "object",
        baseObject: Itemschart_Link.prototype.styleSettings
      },
      shadowOffsetX: 0,
      shadowOffsetY: 0,
      shadowBlur: 12,
      shadowColor: "blue"
    },
    removedColor: "#EEE",
    removedColor_doc: {
      doc: "Color for fade out animation of removed objects.",
      type: "color"
    },
    nodeBackground: {},
    nodeBackground_doc: {
      doc: "",
      type: "object",
      hide: true
    },
    nodeDetailMinZoom: 0.2,
    nodeDetailMinZoom_doc: {
      doc: "Node details like labels, items, images are not rendered if chart zoom is below this value.",
      type: "float",
      unit: "zoom factor"
    },
    nodeDetailMinSize: 5,
    nodeDetailMinSize_doc: {
      doc: "Node details like labels, items, images are hidden if node width in pixels is below this value.",
      type: "float",
      unit: "pixels"
    },
    linkDetailMinZoom: 0.5,
    linkDetailMinZoom_doc: {
      doc: "Link details like labels, items are not rendered if chart zoom is below this value.",
      type: "float",
      unit: "zoom factor"
    },
    linkDetailMinSize: 12,
    linkDetailMinSize_doc: {
      doc: "Link details like labels, items are hidden if link width in pixels is below this value.",
      type: "float",
      unit: "pixels"
    },
    linkDecorationScale: 4,
    linkDecorationScale_doc: {
      doc: "Link decoration size calculated as a product of the link radius and scale factor. The value lower than linkDecorationMinSize will take no effect.",
      type: "float",
      unit: "scale"
    },
    linkDecorationMinSize: 4,
    linkDecorationMinSize_doc: {
      doc: "Link decorations are not painted if link is shorter than this.",
      type: "float",
      units: "pixels"
    },
    nodeLabelScaleBase: 30,
    nodeLabelScaleBase_doc: {
      doc: "Base node size of node label that scales with node size.",
      type: "float",
      units: "pixels"
    },
    linkLabelScaleBase: 1,
    linkLabelScaleBase_doc: {
      doc: "Base node size of link label that scales with link size.",
      type: "float",
      units: "pixels"
    },
    scaleObjectsWithZoom: true,
    scaleObjectsWithZoom_doc: {
      doc: "Whether to set actual node radius zoom-dependent instead of always fixed.",
      type: "bool"
    }
  };

  function Itemschart_ItemsStyle(styleSettings) {
    this.styleSettings = styleSettings;
    this.time = null;
    this.nodeClasses = Base_Helpers.arrayToMap(this.styleSettings.nodeClasses, 'className');
    this.linkClasses = Base_Helpers.arrayToMap(this.styleSettings.linkClasses, 'className');
    this.nodeRules = this.sortRules(this.styleSettings.nodeRules);
    this.linkRules = this.sortRules(this.styleSettings.linkRules);
    this.itemBase = this.styleSettings.item;
    this.nodeLabelBase = this.styleSettings.nodeLabel;
    this.linkLabelBase = this.styleSettings.linkLabel;
  }

  Itemschart_ItemsStyle.prototype.updateItems = function(event, layer, isIncremental) {
    var id, link, links, node, nodes, _i, _j, _len, _len1, _ref, _ref1, _results;
    this.isIncremental = isIncremental != null ? isIncremental : false;
    this.linksUpdated = {};
    if (event.changes.style) {
      this.isIncremental = false;
      _ref = layer.nodes();
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        node = _ref[_i];
        layer.touchNode(node);
      }
      _ref1 = layer.links();
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        link = _ref1[_j];
        layer.touchLink(link);
      }
    }
    nodes = layer.modifiedNodes;
    links = layer.modifiedLinks;
    for (id in nodes) {
      node = nodes[id];
      this.updateNode(node);
    }
    if (links) {
      for (id in links) {
        link = links[id];
        this.updateLink(link);
        this.linksUpdated[link.id] = true;
      }
      if (isIncremental) {
        _results = [];
        for (id in nodes) {
          node = nodes[id];
          _results.push((function() {
            var _k, _len2, _ref2, _results1;
            _ref2 = node.links;
            _results1 = [];
            for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
              link = _ref2[_k];
              if (!this.linksUpdated[link.id]) {
                this.updateLink(link);
                _results1.push(this.linksUpdated[link.id] = true);
              } else {
                _results1.push(void 0);
              }
            }
            return _results1;
          }).call(this));
        }
        return _results;
      }
    }
  };

  Itemschart_ItemsStyle.prototype.postprocessItems = function(obj) {
    var currentItems, i, item, _i, _len, _ref, _results;
    currentItems = obj.currentItems;
    _ref = obj.items;
    _results = [];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      item = _ref[_i];
      i = new Base_Label(this.itemBase);
      Base_Helpers.extendCopy(i, item);
      i.data = item;
      if (i.text != null) {
        i.text = i.text.toString();
      }
      _results.push(currentItems.push(i));
    }
    return _results;
  };

  Itemschart_ItemsStyle.prototype.sortRules = function(rules) {
    var name, names, _;
    names = (function() {
      var _results;
      _results = [];
      for (name in rules) {
        _ = rules[name];
        _results.push(name);
      }
      return _results;
    })();
    names.sort();
    return (function() {
      var _i, _len, _results;
      _results = [];
      for (_i = 0, _len = names.length; _i < _len; _i++) {
        name = names[_i];
        _results.push(rules[name]);
      }
      return _results;
    })();
  };

  Itemschart_ItemsStyle.prototype.updateNode = function(node) {
    var active, cl, l, sequence, style, _i, _len;
    style = this.styleSettings;
    active = node.hovered;
    if (!node.radius) {
      node.radius = 10;
    }
    node.label = null;
    Base_Helpers.extend(node, style.node);
    node.labelStyle = this.nodeLabelBase;
    if (node.userLock) {
      Base_Helpers.extend(node, style.nodeLocked);
    }
    if (node.expanded) {
      Base_Helpers.extend(node, style.nodeExpanded);
    }
    if (node.focused) {
      Base_Helpers.extend(node, style.nodeFocused);
    }
    if (node.background) {
      Base_Helpers.extend(node, style.nodeBackground);
    }
    if (!node.data.loaded) {
      Base_Helpers.extend(node, style.nodeNotLoaded);
    }
    if (node.data) {
      if (node.data.error != null) {
        node.label = node.data.error;
        node.fillColor = "red";
      }
      if (node.data.type) {
        node.display = node.data.type;
      }
      if (node.data.style) {
        Base_Helpers.extend(node, node.data.style);
      }
      this.applyStyleRules(node, this.nodeRules);
      if (node.data.className) {
        sequence = this.getClassSequence(node.data.className, this.nodeClasses);
        for (_i = 0, _len = sequence.length; _i < _len; _i++) {
          cl = sequence[_i];
          Base_Helpers.extend(node, this.styleSettings.nodeClasses[cl].style);
        }
      }
      if (node.labelStyle !== this.nodeLabelBase) {
        l = Base_Helpers.realClone(this.nodeLabelBase);
        Base_Helpers.extendDeep(l, node.labelStyle);
        node.labelStyle = l;
      }
    }
    if (node.removed) {
      node.fillColor = this.styleSettings.removedColor;
    }
    if (active) {
      Base_Helpers.extend(node, style.nodeHovered);
    }
    return true;
  };

  Itemschart_ItemsStyle.prototype.updateLink = function(link) {
    var active, cl, l, sequence, _i, _len;
    Base_Helpers.extend(link, this.styleSettings.link);
    link.label = null;
    link.labelStyle = this.linkLabelBase;
    link.radius = 1;
    active = link.hovered || link.from.hovered || link.to.hovered;
    if (link.data.style) {
      Base_Helpers.extend(link, link.data.style);
    }
    this.applyStyleRules(link, this.linkRules);
    if (link.data.className) {
      sequence = this.getClassSequence(link.data.className, this.linkClasses);
      for (_i = 0, _len = sequence.length; _i < _len; _i++) {
        cl = sequence[_i];
        Base_Helpers.extend(link, this.styleSettings.linkClasses[cl].style);
      }
    }
    if (link.labelStyle !== this.linkLabelBase) {
      l = Base_Helpers.realClone(this.linkLabelBase);
      Base_Helpers.extendDeep(l, link.labelStyle);
      link.labelStyle = l;
    }
    if (active) {
      Base_Helpers.extend(link, this.styleSettings.linkHovered);
      if (link.from.hovered) {
        link.toPieColor = link.fillColor;
      }
    }
    if (link.removed) {
      return link.fillColor = this.styleSettings.removedColor;
    }
  };

  Itemschart_ItemsStyle.prototype.applyStyleRules = function(obj, rules) {
    var func, _i, _len, _results;
    _results = [];
    for (_i = 0, _len = rules.length; _i < _len; _i++) {
      func = rules[_i];
      _results.push(func(obj));
    }
    return _results;
  };

  Itemschart_ItemsStyle.prototype.getClassSequence = function(classes, map) {
    var c, classIndexes, result, _i, _len;
    classes = classes.replace(/^\s+|\s+$/g, "").split(/\s+/g);
    classIndexes = [];
    for (_i = 0, _len = classes.length; _i < _len; _i++) {
      c = classes[_i];
      result = map[c];
      if (result != null) {
        classIndexes.push(result.index);
      } else {
        this.chart.error("class " + c + " undefined");
      }
    }
    return classIndexes.sort(function(a, b) {
      return a - b;
    });
  };

  return Itemschart_ItemsStyle;

})();
// Generated by CoffeeScript 1.8.0
var Base_Toolbar, Base_ToolbarPanel, ToolbarItemNames,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

ToolbarItemNames = {};

Base_Toolbar = (function(_super) {
  "use strict";
  __extends(Base_Toolbar, _super);

  Base_Toolbar.prototype.animationOrder = 2000;

  Base_Toolbar.itemSettings = {
    _doc: {
      doc: "Toolbar item settings",
      type: "object"
    },
    location: "outside",
    location_doc: {
      doc: "Item location",
      type: "enum",
      values: {
        "inside": "Inside chart area",
        "outside": "Outside of chart area"
      }
    },
    side: "top",
    side_doc: {
      doc: "Item side.",
      type: "enum",
      values: ["left", "right", "top", "bottom"]
    },
    align: "right",
    align_doc: {
      doc: "Item align.",
      type: "enum",
      values: ["left", "right", "top", "bottom"]
    },
    showLabel: void 0,
    showLabel_doc: {
      doc: "Whether to show button label.",
      typeL: "bool"
    },
    item: null,
    item_doc: {
      doc: "Built in toolbar item name.",
      type: "enum",
      values: {
        "back": "Back button used in all charts",
        "displayPeriod": "Display period dropdown used in time chart",
        "displayUnit": "Display unit dropdown used in time chart",
        "export": "Export dropdown list used in all charts except net chart",
        "fit": "Fit to scrren button used in net chart",
        "freeze": "Freeze chart used in net chart",
        "fullScreen": "Togggle fullscreen mode used in net chart",
        "logScale": "Log scale button used in time chart and facet chart",
        "rearrange": "Rearrange elements in net chart",
        "zoomOut": "Zoom out button used in facet chart, time chart and pie chart",
        "zoomControl": "Zoom control to manage zoom used in net chart"
      }
    },
    itemConstructor: null,
    label: null,
    label_doc: {
      doc: "Item label",
      type: "string"
    },
    title: null,
    title_doc: {
      doc: "Item title, shown on hover.",
      type: "string"
    },
    image: null,
    image_doc: {
      doc: "Item image, URL to image.",
      type: "imageUrl"
    },
    onClick: null,
    onClick_doc: {
      doc: "Function to execute on item click.",
      parameters: {},
      returns: "",
      type: "function"
    },
    cssClass: null,
    cssClass_doc: {
      doc: "CSS class name.",
      type: "string"
    }
  };

  Base_Toolbar.settings = {
    _doc: {
      doc: "Adjustable settings to manage default and custom toolbar items, as well as toolbar overall appearance.",
      type: "section"
    },
    enabled: false,
    enabled_doc: {
      doc: "Show/hide toolbar.",
      type: "bool"
    },
    location: "inside",
    location_doc: {
      doc: "Toolbar location inside chart.",
      type: "enum",
      values: {
        "inside": "Inside chart area",
        "outside": "Outside of chart area"
      }
    },
    side: "top",
    side_doc: {
      doc: "Toolbar placement side. Note that it can be overridden for individual items using item.side.",
      type: "enum",
      values: ["left", "right", "top", "bottom"]
    },
    align: "right",
    align_doc: {
      doc: "Toolbar align. Note that it can be overridden for individual items using item.align. Also Use 'top' or 'bottom' sides in conjunction with 'left', 'right' align or use 'left', 'right' sides with 'top', 'bottom'.",
      type: "enum",
      values: ["left", "right", "top", "bottom"]
    },
    showLabels: true,
    showLabels_doc: {
      doc: "Whether to show or hide labels next to toolbar items by default. Note that it can be overridden for individual items using item.showLabels.",
      type: "bool"
    },
    cssClass: "DVSL-bar-infobar",
    cssClass_doc: {
      doc: "CSS class name for the toolbar HTML panel.",
      type: "string"
    },
    items: [],
    items_doc: {
      doc: "A list of toolbar items. Use it to completely override the items in toolbar.",
      type: "array",
      baseObject: Base_Toolbar.itemSettings
    },
    extraItems: [],
    extraItems_doc: {
      doc: "A list of user defined items to show in toolbar.",
      type: "array",
      baseObject: Base_Toolbar.itemSettings
    },
    back: true,
    back_doc: {
      doc: "Whether to show back button in toolbar.",
      type: "bool"
    },
    "export": true,
    export_doc: {
      doc: "Whether to show export dropdown in toolbar.",
      type: "bool"
    },
    zoomOut: false,
    zoomOut_doc: {
      doc: "Whether to show the zoom out button.",
      type: "bool"
    }
  };

  function Base_Toolbar(chart, options) {
    this.chart = chart;
    this.options = options;
    this.scene = this.chart.scene;
    this.panels = {};
    this.panelList = [];
    this.items = [];
    this.hideLabels = false;
    this.itemBuilders = {};
    this.addItems();
    this.chart.events.addElement(this);
    this.chart.events.notifySceneChanges({
      bounds: true
    });
  }

  Base_Toolbar.prototype.rebuildItems = function() {
    this.removeItems();
    return this.addItems();
  };

  Base_Toolbar.prototype.addItems = function() {
    var item, _i, _j, _len, _len1, _ref, _ref1, _results;
    if (this.options.enabled) {
      _ref = this.options.items;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        item = _ref[_i];
        this.addItem(item);
      }
      _ref1 = this.options.extraItems;
      _results = [];
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        item = _ref1[_j];
        _results.push(this.addItem(item));
      }
      return _results;
    }
  };

  Base_Toolbar.prototype.removeItems = function() {
    var item, panel, _i, _j, _len, _len1, _ref, _ref1;
    _ref = this.items;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      item = _ref[_i];
      item.remove();
    }
    _ref1 = this.panelList;
    for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
      panel = _ref1[_j];
      panel.clear();
    }
    return this.items = [];
  };

  Base_Toolbar.prototype.remove = function() {
    var panel, _i, _len, _ref;
    this.removeItems();
    _ref = this.panelList;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      panel = _ref[_i];
      panel.remove();
    }
    return this.chart.events.removeElement(this);
  };

  Base_Toolbar.prototype.addItem = function(itemOptions) {
    var align, item, location, name, panel, panelStr, side;
    if (Base_Helpers.isString(itemOptions)) {
      itemOptions = {
        item: itemOptions
      };
    } else {
      itemOptions = Base_Helpers.clone(itemOptions);
    }
    itemOptions.showLabels = (itemOptions.showLabels !== void 0 ? itemOptions.showLabels : this.options.showLabels) && !this.hideLabels;
    if (Base_Helpers.isString(itemOptions.item)) {
      name = itemOptions.item || itemOptions;
      if (this.options.hasOwnProperty(name) && this.options[name] === false) {
        return;
      }
      if (ToolbarItemNames.hasOwnProperty(name)) {
        item = ToolbarItemNames[name](this.chart, itemOptions);
      } else {
        this.chart.error("Toolbar item name '" + name + "' not recognized.");
        return;
      }
    } else if (itemOptions.itemConstructor) {
      item = new itemOptions.itemConstructor(this.chart, itemOptions);
    } else {
      item = new Base_Bar_UserButton(this.chart, itemOptions);
    }
    location = itemOptions.location || this.options.location;
    side = itemOptions.side || this.options.side;
    align = itemOptions.align || this.options.align;
    panelStr = location + side;
    if (!this.panels.hasOwnProperty(panelStr)) {
      panel = new Base_ToolbarPanel(this, location, side);
      this.panelList.push(panel);
      this.panels[panelStr] = panel;
    }
    panel = this.panels[panelStr];
    panel.addItem(item, align);
    return this.items.push(item);
  };

  Base_Toolbar.prototype.getPanels = function() {
    return this.panelList;
  };

  Base_Toolbar.prototype.onSceneChange = function(event) {
    var item, _i, _len, _ref, _results;
    _ref = this.items;
    _results = [];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      item = _ref[_i];
      _results.push(item.onSceneChange(event.changes));
    }
    return _results;
  };

  Base_Toolbar.prototype.doAnimations = function(event) {
    var item, _i, _len, _ref, _results;
    _ref = this.items;
    _results = [];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      item = _ref[_i];
      _results.push(item.doAnimations(event));
    }
    return _results;
  };

  Base_Toolbar.prototype.getTopInsidePanelBoundingRectangles = function() {
    var canvasRect, dx, dy, panel, rect, result, _i, _len, _ref;
    canvasRect = this.chart.events.canvas.getBoundingClientRect();
    dx = canvasRect.left;
    dy = canvasRect.top;
    result = [];
    _ref = this.panelList;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      panel = _ref[_i];
      if (panel.location !== "inside" || panel.side !== "top") {
        continue;
      }
      rect = panel.left.getBoundingClientRect();
      if (rect.height > 0 || rect.width > 0) {
        result.push(new Base_Rect(rect.left - dx, rect.top - dy, rect.right - dx, rect.bottom - dy));
      }
      rect = panel.right.getBoundingClientRect();
      if (rect.height > 0 || rect.width > 0) {
        result.push(new Base_Rect(rect.left - dx, rect.top - dy, rect.right - dx, rect.bottom - dy));
      }
    }
    return result;
  };

  Base_Toolbar.prototype.previewGlobalPointerDown = function(event) {
    var item, _i, _len, _ref, _results;
    _ref = this.items;
    _results = [];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      item = _ref[_i];
      if (item.previewPointerDown) {
        _results.push(item.previewPointerDown(event));
      } else {
        _results.push(void 0);
      }
    }
    return _results;
  };

  return Base_Toolbar;

})(Base_ChartElement);

Base_ToolbarPanel = (function(_super) {
  __extends(Base_ToolbarPanel, _super);

  function Base_ToolbarPanel(toolbar, location, side) {
    this.toolbar = toolbar;
    this.location = location;
    this.side = side;
    this.packingOrder = location === "inside" ? 1000 : -1;
    this.container = this.toolbar.chart.layers.container;
    this.floating = false;
    this.align = "fill";
    if (this.side === "top") {
      this.vertical = false;
      this.left = Base_Helpers.createDom("ul", "DVSL-bar-left DVSL-bar-top DVSL-bar-horizontal", null, this.container);
      this.right = Base_Helpers.createDom("ul", "DVSL-bar-right DVSL-bar-top DVSL-bar-horizontal", null, this.container);
    } else if (this.side === "bottom") {
      this.vertical = false;
      this.left = Base_Helpers.createDom("ul", "DVSL-bar-left DVSL-bar-bottom DVSL-bar-horizontal", null, this.container);
      this.right = Base_Helpers.createDom("ul", "DVSL-bar-right DVSL-bar-bottom DVSL-bar-horizontal", null, this.container);
    } else if (this.side === "left") {
      this.vertical = true;
      this.left = Base_Helpers.createDom("ul", "DVSL-bar-left DVSL-bar-top DVSL-bar-vertical", null, this.container);
      this.right = Base_Helpers.createDom("ul", "DVSL-bar-left DVSL-bar-bottom DVSL-bar-vertical", null, this.container);
    } else if (this.side === "right") {
      this.vertical = true;
      this.left = Base_Helpers.createDom("ul", "DVSL-bar-right DVSL-bar-top DVSL-bar-vertical", null, this.container);
      this.right = Base_Helpers.createDom("ul", "DVSL-bar-right DVSL-bar-bottom DVSL-bar-vertical", null, this.container);
    } else {
      this.chart.error("Unrecognized side: '" + this.side + "'");
    }
    this.left.style.visibility = "hidden";
    this.right.style.visibility = "hidden";
  }

  Base_ToolbarPanel.prototype.addItem = function(item, align) {
    if (align === "left" || align === "top") {
      return this.left.appendChild(item.domElement);
    } else if (align === "right" || align === "bottom") {
      return this.right.appendChild(item.domElement);
    } else {
      return this.chart.error("Unrecognized align: '" + align + "'");
    }
  };

  Base_ToolbarPanel.prototype.clear = function() {
    var c, _results;
    while (c = this.left.firstChild) {
      this.left.removeChild(c);
    }
    _results = [];
    while (c = this.right.firstChild) {
      _results.push(this.right.removeChild(c));
    }
    return _results;
  };

  Base_ToolbarPanel.prototype.computeSize = function(availableWidth, availableHeight, context) {
    var hideLabels;
    if (!this.vertical) {
      if (!this.toolbar.hideLabels) {
        this.contentWidthWithLabels = this.left.offsetWidth + this.right.offsetWidth;
      }
      hideLabels = this.contentWidthWithLabels > availableWidth;
      if (hideLabels !== this.toolbar.hideLabels) {
        this.toolbar.hideLabels = hideLabels;
        this.toolbar.rebuildItems();
      }
    }
    if (this.vertical) {
      return [Math.max(this.left.offsetWidth, this.right.offsetWidth), 0];
    } else {
      return [0, Math.max(this.left.offsetHeight, this.right.offsetHeight)];
    }
  };

  Base_ToolbarPanel.prototype.placePanel = function(left, top, right, bottom) {
    if (this.vertical) {
      this.left.style.width = (right - left) + "px";
      this.right.style.width = (right - left) + "px";
      this.left.style.top = top + "px";
      this.right.style.bottom = (this.toolbar.scene.chartHeight - bottom) + "px";
      if (this.side === "left") {
        this.left.style.left = left + "px";
        this.right.style.left = left + "px";
      } else {
        this.left.style.right = (this.toolbar.scene.chartWidth - right) + "px";
        this.right.style.right = (this.toolbar.scene.chartWidth - right) + "px";
      }
    } else {
      this.left.style.left = left + "px";
      this.left.style.height = (bottom - top) + "px";
      this.right.style.right = (this.toolbar.scene.chartWidth - right) + "px";
      this.right.style.height = (bottom - top) + "px";
      if (this.side === "top") {
        this.left.style.top = top + "px";
        this.right.style.top = top + "px";
      } else {
        this.left.style.bottom = (this.toolbar.scene.chartHeight - bottom) + "px";
        this.right.style.bottom = (this.toolbar.scene.chartHeight - bottom) + "px";
      }
    }
    this.left.style.visibility = "visible";
    return this.right.style.visibility = "visible";
  };

  Base_ToolbarPanel.prototype.remove = function() {
    this.container.removeChild(this.left);
    return this.container.removeChild(this.right);
  };

  return Base_ToolbarPanel;

})(Base_ChartPanel);
// Generated by CoffeeScript 1.8.0
ToolbarItemNames["fullscreen"] = function(chart, options) {
  return new Base_Bar_ToggleButton(chart, {
    label: chart.settings.localization.toolbar.fullscreenButton,
    title: chart.settings.localization.toolbar.fullscreenTitle,
    cssClass: "DVSL-bar-btn-fullscreen",
    cssClassEnabled: "DVSL-bar-btn-fullscreen-active",
    showLabels: options.showLabels,
    onEnable: function() {
      return chart.setFullscreen(true);
    },
    onDisable: function() {
      return chart.setFullscreen(false);
    },
    getChartState: function() {
      return chart.isFullscreen();
    }
  });
};
// Generated by CoffeeScript 1.8.0
ToolbarItemNames["back"] = function(chart, options) {
  return new Base_Bar_UserButton(chart, {
    label: chart.settings.localization.toolbar.backButton,
    cssClass: "DVSL-bar-btn-back",
    title: chart.settings.localization.toolbar.backTitle,
    showLabels: options.showLabels,
    onClick: (function(_this) {
      return function() {
        return chart.back(true, "user");
      };
    })(this)
  });
};
// Generated by CoffeeScript 1.8.0
var Netchart_Bar_ZoomControl,
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

Netchart_Bar_ZoomControl = (function(_super) {
  __extends(Netchart_Bar_ZoomControl, _super);

  function Netchart_Bar_ZoomControl(chart, options) {
    var cont, nav, zoom;
    this.chart = chart;
    this.options = options;
    this.zoomMove = __bind(this.zoomMove, this);
    this.zoomDown = __bind(this.zoomDown, this);
    this.scene = chart.scene;
    this.events = chart.events;
    this.scrolling = this.chart.scrolling;
    cont = Base_Helpers.createDom("li", null, null, null);
    zoom = Base_Helpers.createDom("span", "DVSL-NC-zoom", null, cont);
    this.handle = Base_Helpers.createDom("em", null, null, zoom);
    nav = Base_Helpers.createDom("nav", null, null, this.cont);
    this.mouse = new Base_MouseEvents(cont, this.scene.settings.advanced.pointer);
    this.mouse.listen("drag", this.zoomMove);
    this.mouse.listen("down", this.zoomDown);
    this.domElement = cont;
  }

  Netchart_Bar_ZoomControl.prototype.zoomDown = function(event) {
    if (event.y < 100) {
      return this.zoomMove(event);
    }
  };

  Netchart_Bar_ZoomControl.prototype.zoomMove = function(event) {
    var newZoom, pos;
    pos = event.y - 10;
    pos = Math.max(0, Math.min(80, pos));
    this.handle.style.top = "" + pos + "px";
    newZoom = this.getZoomValue(pos / 80);
    this.chart.autoZoom.manualZoom(newZoom / this.scene.zoom);
    this.events.notifySceneChanges({
      position: true
    });
    return event.consumed = true;
  };

  Netchart_Bar_ZoomControl.prototype.getSliderPosition = function() {
    var max, min, zoom, _ref;
    _ref = this.scene.settings.interaction.zooming.zoomExtent, min = _ref[0], max = _ref[1];
    zoom = Math.log(Math.max(min, Math.min(max, this.scene.zoom)));
    min = Math.log(min);
    max = Math.log(max);
    return 1 - (zoom - min) / (max - min);
  };

  Netchart_Bar_ZoomControl.prototype.getZoomValue = function(pos) {
    var max, min, prop, _ref;
    _ref = this.scene.settings.interaction.zooming.zoomExtent, min = _ref[0], max = _ref[1];
    min = Math.log(min);
    max = Math.log(max);
    prop = (1 - pos) * (max - min) + min;
    return Math.exp(prop);
  };

  Netchart_Bar_ZoomControl.prototype.doAnimations = function(event) {
    var value;
    value = this.getSliderPosition();
    return this.handle.style.top = "" + (80 * value) + "px";
  };

  Netchart_Bar_ZoomControl.prototype.remove = function() {
    return this.mouse.remove();
  };

  return Netchart_Bar_ZoomControl;

})(Base_Bar_Item);

ToolbarItemNames["zoomcontrol"] = function(chart, options) {
  return new Netchart_Bar_ZoomControl(chart, options);
};
// Generated by CoffeeScript 1.8.0
var Itemschart_InfoPopup,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

Itemschart_InfoPopup = (function(_super) {
  __extends(Itemschart_InfoPopup, _super);

  Itemschart_InfoPopup.prototype.animationOrder = 800;

  Itemschart_InfoPopup.prototype.paintOrder = 45;

  Itemschart_InfoPopup.prototype.updateOrder = 2000;

  function Itemschart_InfoPopup(chart) {
    this.chart = chart;
    this.scene = chart.scene;
    this.options = this.scene.settings;
    this.item = null;
    this.x = null;
    this.y = null;
    this.popup = new Base_InfoPopup(chart);
  }

  Itemschart_InfoPopup.prototype.previewPointerMove = function(event) {
    return this.onMove(event.x, event.y);
  };

  Itemschart_InfoPopup.prototype.doAnimations = function(event) {
    if (this.x !== null && this.y !== null) {
      return this.onMove(this.x, this.y);
    }
  };

  Itemschart_InfoPopup.prototype.previewPointerDown = function(event) {
    this.x = this.y = null;
    return this.setCurrentObject(0, 0, null);
  };

  Itemschart_InfoPopup.prototype.previewPointerDrag = function(event) {
    this.x = this.y = null;
    return this.setCurrentObject(0, 0, null);
  };

  Itemschart_InfoPopup.prototype.onPointerOut = function(event) {
    this.x = this.y = null;
    return this.setCurrentObject(0, 0, null);
  };

  Itemschart_InfoPopup.prototype.onMove = function(x, y) {
    var item;
    this.x = x;
    this.y = y;
    if (!this.options.info.enabled) {
      return;
    }
    item = this.scene.hoverNode ? this.scene.hoverNode : this.scene.hoverLink;
    return this.setCurrentObject(x, y, item);
  };

  Itemschart_InfoPopup.prototype.setCurrentObject = function(x, y, item) {
    var contents;
    if (!item) {
      this.item = null;
      return this.popup.hide();
    } else {
      if (item !== this.item) {
        contents = this.buildContents(item);
        this.popup.show(x, x, y, contents);
      } else {
        this.popup.updateXY(x, x, y);
      }
      return this.item = item;
    }
  };

  Itemschart_InfoPopup.prototype.buildContents = function(item) {
    var callback, func;
    func = null;
    if (item instanceof Itemschart_Node) {
      func = this.options.info.nodeContentsFunction;
    } else if (item instanceof Itemschart_Link) {
      func = this.options.info.linkContentsFunction;
    }
    if (func) {
      callback = (function(_this) {
        return function(contents) {
          if (item === _this.item) {
            return _this.popup.updateContents(contents);
          }
        };
      })(this);
      return func.call(this.scene.api, item.data, item, callback);
    } else {
      return item.label;
    }
  };

  return Itemschart_InfoPopup;

})(Base_ChartElement);
// Generated by CoffeeScript 1.8.0
var Itemschart_NodesLayer,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

Itemschart_NodesLayer = (function(_super) {
  "use strict";
  var hitNode;

  __extends(Itemschart_NodesLayer, _super);

  function Itemschart_NodesLayer(scene, layerSettings, useFadeout) {
    this.scene = scene;
    this.layerSettings = layerSettings;
    this.useFadeout = useFadeout;
    Itemschart_NodesLayer.__super__.constructor.call(this, this.scene, this.layerSettings);
    this.style = this.layerSettings.style;
    this.scaleObjectsWithZoom = this.style.scaleObjectsWithZoom;
    this.imageCache = {};
    this.imageLoading = {};
    this.multilinks = {};
    this.labelRenderer = null;
    this.event = null;

    /*
      Layer functions
     */
  }

  Itemschart_NodesLayer.prototype.createStyleUpdater = function(style) {
    return new Itemschart_NodesStyle(style, this.useFadeout);
  };

  Itemschart_NodesLayer.prototype.doAnimations = function(event) {
    this.updateStyle(event);
    return this.animateSize(event);
  };

  Itemschart_NodesLayer.prototype.updateStyle = function(event) {
    var incremental;
    incremental = !event.changes.newGraph;
    return this.styleUpdater.updateItems(event, this, incremental);
  };

  Itemschart_NodesLayer.prototype.animateSize = function(event) {
    var animating, dt, fadeProp, fadeTime, finishProp, instant, l, link, linksToRemove, n, node, nodesToRemove, time, _i, _j, _k, _l, _len, _len1, _len2, _len3, _len4, _len5, _m, _n, _ref, _ref1, _ref2, _ref3;
    time = event.timeStamp;
    instant = event.changes.newGraph;
    dt = event.dtime;
    animating = false;
    fadeTime = this.style.fadeTime;
    instant || (instant = !(fadeTime > 0) || dt > fadeTime);
    nodesToRemove = [];
    linksToRemove = [];
    if (instant) {
      _ref = this.nodes();
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        node = _ref[_i];
        if (node.removed) {
          nodesToRemove.push(node);
        } else if (node.targetHWidth !== node.hWidth) {
          node.added = false;
          node.hHeight = node.targetHHeight;
          node.hWidth = node.targetHWidth;
        }
      }
      _ref1 = this.links();
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        link = _ref1[_j];
        if (link.removed) {
          linksToRemove.push(link);
        } else if (link.targetRadius !== link.currentRadius) {
          link.added = false;
          link.currentRadius = link.targetRadius;
        }
      }
    } else {
      fadeProp = fadeTime > 0 ? Math.max(0, Math.pow(0.2, dt / fadeTime)) : 0;
      finishProp = 0.01;
      _ref2 = this.nodes();
      for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
        node = _ref2[_k];
        if (node.added === true) {
          node.added = time;
        }
        if (node.added + fadeTime < time) {
          node.added = false;
        }
        if (node.removed === true) {
          node.removed = time;
        }
        if (node.removed) {
          animating = true;
          node.hHeight = node.hHeight * fadeProp;
          node.hWidth = node.hWidth * fadeProp;
          if (node.removed + fadeTime < time) {
            nodesToRemove.push(node);
          }
        } else if (node.targetHWidth !== node.hWidth) {
          animating = true;
          node.hHeight = node.hHeight * fadeProp + node.targetHHeight * (1 - fadeProp);
          node.hWidth = node.hWidth * fadeProp + node.targetHWidth * (1 - fadeProp);
          if (Math.abs(node.hHeight - node.targetHHeight) < finishProp * node.targetHHeight) {
            node.hHeight = node.targetHHeight;
            node.hWidth = node.targetHWidth;
          }
        }
      }
      _ref3 = this.links();
      for (_l = 0, _len3 = _ref3.length; _l < _len3; _l++) {
        link = _ref3[_l];
        if (link.added === true) {
          link.added = time;
        }
        if (link.added + fadeTime < time) {
          link.added = false;
        }
        if (link.removed === true) {
          link.removed = time;
        }
        if (link.removed) {
          animating = true;
          link.currentRadius = link.currentRadius * fadeProp;
          if (link.removed + fadeTime < time) {
            linksToRemove.push(link);
          }
        } else if (link.targetRadius !== link.currentRadius) {
          animating = true;
          link.currentRadius = link.currentRadius * fadeProp + link.targetRadius * (1 - fadeProp);
          if (Math.abs(link.currentRadius - link.targetRadius) < finishProp * link.targetRadius) {
            link.currentRadius = link.targetRadius;
          }
        }
      }
    }
    for (_m = 0, _len4 = linksToRemove.length; _m < _len4; _m++) {
      l = linksToRemove[_m];
      this.deleteLink(l);
    }
    for (_n = 0, _len5 = nodesToRemove.length; _n < _len5; _n++) {
      n = nodesToRemove[_n];
      this.deleteNode(n);
    }
    if (animating) {
      event.changes.position = true;
      return event.animating = true;
    }
  };

  Itemschart_NodesLayer.prototype.paintPrepare = function(event) {
    this.computeNodeRenderRadii();
    return this.multilinks = this.updateMultilinks();
  };

  Itemschart_NodesLayer.prototype.paintSelection = function(event, selectedNodes, selectedLinks) {
    var cons, ddx, ddy, dx, dy, g, invLen, n1, n2, obj, ofx, ofy, prop, r, selStyle, txa, txm, tya, tym, w, x, x0, x0s, x0w, x1, x1s, x1w, xx, y, y0, y0s, y0w, y1, y1s, y1w, zoom, _i, _j, _len, _len1, _ref;
    _ref = this.getGeometry(), txm = _ref[0], txa = _ref[1], tym = _ref[2], tya = _ref[3], zoom = _ref[4], x0s = _ref[5], x1s = _ref[6], y0s = _ref[7], y1s = _ref[8], x0w = _ref[9], y0w = _ref[10], x1w = _ref[11], y1w = _ref[12];
    g = event.context;
    selStyle = this.style.selection;
    prop = selStyle.sizeProportional;
    cons = selStyle.sizeConstant;
    g.beginPath();
    for (_i = 0, _len = selectedNodes.length; _i < _len; _i++) {
      obj = selectedNodes[_i];
      r = obj.renderHheight * (1 + prop) + cons;
      w = obj.renderHwidth - obj.renderHheight + r;
      x = obj.x * txm + txa;
      y = obj.y * tym + tya;
      xx = x + w - r;
      g.moveTo(xx, y - r);
      g.arc(xx, y, r, -Math.PI / 2, Math.PI / 2, false);
      xx = x - w + r;
      g.lineTo(xx, y + r);
      g.arc(xx, y, r, Math.PI / 2, -Math.PI / 2, false);
      g.closePath();
    }
    for (_j = 0, _len1 = selectedLinks.length; _j < _len1; _j++) {
      obj = selectedLinks[_j];
      r = (obj.currentRadius * (1 + prop) + cons) * zoom;
      n1 = obj.from;
      n2 = obj.to;
      x0 = n1.x * txm + txa;
      y0 = n1.y * tym + tya;
      x1 = n2.x * txm + txa;
      y1 = n2.y * tym + tya;
      dx = x0 - x1;
      dy = y0 - y1;
      invLen = 1 / Math.sqrt(dx * dx + dy * dy);
      ddx = dx * invLen;
      ddy = dy * invLen;
      if (obj.currentCenterOffset !== 0) {
        ofx = ddy * obj.currentCenterOffset * zoom;
        ofy = -ddx * obj.currentCenterOffset * zoom;
        x0 += ofx;
        y0 += ofy;
        x1 += ofx;
        y1 += ofy;
      }
      ddx *= r;
      ddy *= r;
      g.moveTo(x0 + ddy, y0 - ddx);
      g.lineTo(x0 - ddy, y0 + ddx);
      g.lineTo(x1 - ddy, y1 + ddx);
      g.lineTo(x1 + ddy, y1 - ddx);
      g.closePath();
    }
    return Base_Graphics.paint(g, selStyle);
  };

  Itemschart_NodesLayer.prototype.paintLinks = function(event, links) {
    var geometry;
    this.labelRenderer = event.labelRenderer;
    geometry = this.getGeometry();
    return this.paintLinksImpl(event.context, links, this.multilinks, {
      geometry: geometry,
      paintDetails: geometry[4] > this.style.linkDetailMinZoom
    });
  };

  Itemschart_NodesLayer.prototype.paintNodes = function(event, nodes) {
    var geometry;
    this.labelRenderer = event.labelRenderer;
    this.event = event;
    geometry = this.getGeometry();
    event.animating |= this.paintNodesImpl(event.context, nodes, {
      geometry: geometry,
      paintDetails: geometry[4] > this.style.nodeDetailMinZoom
    }, event.timeStamp);
    return this.event = null;
  };

  Itemschart_NodesLayer.prototype.updateMultilinks = function() {
    var l, link, links, multiId, multiLinks, _i, _len;
    if (!this.hasTopologyChanges()) {
      return this.multilinks;
    }
    links = this.links();
    multiLinks = {};
    for (_i = 0, _len = links.length; _i < _len; _i++) {
      link = links[_i];
      multiId = link.multiId;
      if (!multiLinks.hasOwnProperty(multiId)) {
        multiLinks[multiId] = link;
      } else {
        l = multiLinks[multiId];
        if (Base_Helpers.isArray(l)) {
          l.push(link);
        } else {
          multiLinks[multiId] = [multiLinks[multiId], link];
        }
      }
    }
    return multiLinks;
  };


  /* internal functions
   */

  Itemschart_NodesLayer.prototype.getNodeImage = function(style) {
    var crop, doRounding, imageId, imageUrl, tint;
    if (!style.image) {
      return null;
    }
    tint = style.tintImage && style.fillColor;
    crop = style.imageCropping;
    imageId = style.image;
    imageUrl = imageId;
    if (tint) {
      imageId += "##" + style.fillColor;
    }
    if (this.imageCache[imageId] != null) {
      return this.imageCache[imageId];
    } else if (this.imageLoading[imageId]) {
      return false;
    } else {
      doRounding = (function(_this) {
        return function(image) {
          if (crop) {
            image = Base_Graphics.cropImageToCircle(image, crop);
          }
          if (tint) {
            image = Base_Graphics.applyColorToImage(image, style.fillColor, false);
          }
          _this.imageCache[imageId] = image;
          delete _this.imageLoading[imageId];
          if (_this.event) {
            return _this.event.changes.repaint = true;
          }
        };
      })(this);
      this.imageLoading[imageId] = true;
      this.scene.settings.getAssetImage(imageUrl, doRounding);
      return false;
    }
  };

  Itemschart_NodesLayer.prototype.computeNodeRenderRadii = function() {
    var node, r, w, z0, _i, _len, _ref, _results;
    z0 = this.getGeometry()[4];
    _ref = this.nodes();
    _results = [];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      node = _ref[_i];
      r = node.hHeight * z0;
      w = node.hWidth * z0;
      if (node.lineWidth) {
        r += node.lineWidth / 2;
        w += node.lineWidth / 2;
      }
      node.renderHheight = r;
      _results.push(node.renderHwidth = w);
    }
    return _results;
  };

  Itemschart_NodesLayer.prototype.paintLinksImpl = function(g, links, multiLinks, setup) {
    var active, count, dA, dashLen, ddx, ddy, decorationMinSize, decorationScale, decorationSize, dsLen, dsLenpx, dx, dy, i, invlen, invzoom, j, l0, l1, len, lenSq, link, linkDetailMinSizeSq, linkLabelScaleBase, linkSpacing, ml, multiId, np, offset, paintItems, paintLinkDetails, pieInner, pieOuter, pieSizeConst, pieSizeProp, pieSpacing, r, r0, r1, styleSettings, t0, t1, tc, txa, txm, tya, tym, w0, w1, width, x0, x0a, x0b, x0s, x0w, x1, x1s, x1w, y0, y0a, y0b, y0s, y0w, y1, y1s, y1w, zoom, zs, zz, _i, _j, _k, _l, _len, _m, _ref, _ref1, _ref2, _ref3, _ref4;
    _ref = setup.geometry, txm = _ref[0], txa = _ref[1], tym = _ref[2], tya = _ref[3], zoom = _ref[4], x0s = _ref[5], x1s = _ref[6], y0s = _ref[7], y1s = _ref[8], x0w = _ref[9], y0w = _ref[10], x1w = _ref[11], y1w = _ref[12];
    invzoom = 1 / zoom;
    g.textAlign = "center";
    g.textBaseline = "middle";
    styleSettings = this.style;
    linkDetailMinSizeSq = styleSettings.linkDetailMinSize * styleSettings.linkDetailMinSize;
    paintLinkDetails = setup.paintDetails;
    linkSpacing = styleSettings.multilinkSpacing * zoom;
    decorationScale = styleSettings.linkDecorationScale;
    decorationMinSize = styleSettings.linkDecorationMinSize;
    linkLabelScaleBase = styleSettings.linkLabelScaleBase;
    pieSpacing = 2;
    pieSizeConst = 5;
    pieSizeProp = 0.1;
    for (_i = 0, _len = links.length; _i < _len; _i++) {
      link = links[_i];
      x0 = link.from.x;
      y0 = link.from.y;
      x1 = link.to.x;
      y1 = link.to.y;
      if (Math.max(x0, x1) < x0w || Math.min(x0, x1) > x1w || Math.max(y0, y1) < y0w || Math.min(y0, y1) > y1w) {
        continue;
      }
      x0 = x0 * txm + txa;
      y0 = y0 * tym + tya;
      x1 = x1 * txm + txa;
      y1 = y1 * tym + tya;
      dx = x1 - x0;
      dy = y1 - y0;
      lenSq = dx * dx + dy * dy;
      r = Math.max(0.25, link.currentRadius * zoom * 0.5);
      active = link.hovered || link.from.hovered || link.to.hovered;
      paintItems = active || (paintLinkDetails && lenSq > linkDetailMinSizeSq);
      if (lenSq > 25) {
        r0 = link.from.renderHheight;
        r1 = link.to.renderHheight;
        w0 = link.from.renderHwidth;
        w1 = link.to.renderHwidth;
        len = Math.sqrt(lenSq);
        if (link.toPieValue > 0) {
          pieInner = r1 + pieSpacing;
          pieOuter = pieInner + pieSizeConst + pieSizeProp * r1;
          this.paintLinkPie(g, x1, y1, pieInner, pieOuter, link.toPie0, link.toPie1, link.toPieColor);
          r1 = pieOuter;
        }
        if (len < r0 + r1) {
          continue;
        }
        invlen = 1 / len;
        ddx = dx * invlen;
        ddy = dy * invlen;
        t0 = Base_Geometry.distanceToBalloon(r0, w0, ddx, ddy);
        t1 = Base_Geometry.distanceToBalloon(r1, w1, ddx, ddy);
        if (len <= t0 + t1) {
          continue;
        }
        decorationSize = Math.min((len - t0 - t1) / 4, Math.max(decorationMinSize, r * decorationScale));
        if (link.fromDecoration) {
          t0 += decorationSize;
        }
        if (link.toDecoration) {
          t1 += decorationSize;
        }
        x0 += ddx * t0;
        y0 += ddy * t0;
        x1 -= ddx * t1;
        y1 -= ddy * t1;
        dx = x1 - x0;
        dy = y1 - y0;
        len = len - t0 - t1;
        invlen = 1 / len;
        multiId = link.multiId;
        ml = multiLinks[multiId];
        if (Base_Helpers.isArray(ml)) {
          count = ml.length;
          width = Math.min(linkSpacing * (count - 1), r0 * 1.5, r1 * 1.5);
          offset = width * (Base_Helpers.indexOf(ml, link) - (count - 1) / 2) / (count - 1);
          if (link.from.id > link.to.id) {
            offset = -offset;
          }
          link.currentCenterOffset = offset * invzoom;
          x0 -= ddy * offset;
          x1 -= ddy * offset;
          y0 += ddx * offset;
          y1 += ddx * offset;
        } else {
          link.currentCenterOffset = 0;
        }
        g.beginPath();
        if (link.fromDecoration) {
          this.paintLinkDecoration(g, x0, y0, ddx, ddy, decorationSize, link.fromDecoration, link.fillColor);
        }
        if (link.toDecoration) {
          this.paintLinkDecoration(g, x1, y1, -ddx, -ddy, decorationSize, link.toDecoration, link.fillColor);
        }
        if (link.lineDash) {
          x0a = x0 + ddy * r;
          y0a = y0 - ddx * r;
          x0b = x0 - ddy * r;
          y0b = y0 + ddx * r;
          if (link.lineDash.length > 0) {
            dA = link.lineDash;
            dsLen = dA.length;
            dsLenpx = dA.reduce(function(a, b) {
              return a + b;
            }) * zoom;
            np = 0;
            for (i = _j = 0, _ref1 = len / dsLenpx; _j <= _ref1; i = _j += 1) {
              for (j = _k = 0, _ref2 = dsLen - 1; _k <= _ref2; j = _k += 2) {
                l0 = (i * dsLenpx) + np;
                if (l0 > len - r) {
                  break;
                }
                tc = l0 + dA[j] * zoom;
                l1 = tc >= len - r ? len - r : tc;
                g.moveTo(x0a + l0 * ddx, y0a + l0 * ddy);
                g.lineTo(x0b + l0 * ddx, y0b + l0 * ddy);
                g.lineTo(x0b + l1 * ddx, y0b + l1 * ddy);
                g.lineTo(x0a + l1 * ddx, y0a + l1 * ddy);
                g.closePath();
                np += zoom * (dA[j] + dA[j + 1]);
              }
              np = 0;
            }
          } else {
            dashLen = Math.max(5, 3 * r);
            for (i = _l = 0, _ref3 = len / dashLen; _l <= _ref3; i = _l += 2) {
              l0 = i * dashLen;
              l1 = Math.min((i + 1) * dashLen, len);
              g.moveTo(x0a + l0 * ddx, y0a + l0 * ddy);
              g.lineTo(x0b + l0 * ddx, y0b + l0 * ddy);
              g.lineTo(x0b + l1 * ddx, y0b + l1 * ddy);
              g.lineTo(x0a + l1 * ddx, y0a + l1 * ddy);
              g.closePath();
            }
          }
        } else {
          g.moveTo(x0 + ddy * r, y0 - ddx * r);
          g.lineTo(x0 - ddy * r, y0 + ddx * r);
          g.lineTo(x1 - ddy * r, y1 + ddx * r);
          g.lineTo(x1 + ddy * r, y1 - ddx * r);
          g.closePath();
        }
        Base_Graphics.fill(g, link);
        if (paintItems && link.currentItems && !link.removed) {
          if (active) {
            zz = Math.max(1, zoom);
            zs = Math.max(1, r / linkLabelScaleBase);
          } else {
            zz = zoom;
            zs = r / linkLabelScaleBase;
          }
          this.paintLinkItems(g, zz, zs, x0, y0, ddx, ddy, len, r, link.currentItems);
        }
      } else if (link.fillColor) {
        g.beginPath();
        g.lineWidth = Math.max(0.1, r * 2);
        g.strokeStyle = link.fillColor;
        if (link.dashed) {
          len = Math.sqrt(lenSq);
          invlen = 1 / len;
          ddx = dx * invlen;
          ddy = dy * invlen;
          dashLen = Math.max(5, r * 3);
          for (i = _m = 0, _ref4 = len / dashLen; _m <= _ref4; i = _m += 2) {
            l0 = i * dashLen;
            l1 = Math.min((i + 1) * dashLen, len);
            g.moveTo(x0 + l0 * ddx, y0 + l0 * ddy);
            g.lineTo(x0 + l1 * ddx, y0 + l1 * ddy);
          }
        } else {
          g.moveTo(x0, y0);
          g.lineTo(x1, y1);
        }
        g.stroke();
      }
    }
    return false;
  };

  Itemschart_NodesLayer.prototype.paintNodesImpl = function(g, nodes, setup, time) {
    var PI2, a, a1, animating, bh, bw, display, displayAsText, hiddenLinksStyle, hlinks, ih, im, imSize, invzoom, iw, ix0, iy0, label, labelHHeight, labelHWidth, leftOffset, lineHeight, node, nodeDetailMinSizeSq, nodeLabelScaleBase, oldLine, opacity, otherRad, paintDetails, paintNodeDetails, r, rad, removedColor, roundText, s, scale, strokeContext, style, txa, txm, tya, tym, w, x, x0, x0s, x0w, x1s, x1w, xx, y, y0, y0s, y0w, y1s, y1w, zoom, zs, zz, _i, _j, _len, _len1, _ref;
    PI2 = Math.PI * 2;
    animating = false;
    _ref = setup.geometry, txm = _ref[0], txa = _ref[1], tym = _ref[2], tya = _ref[3], zoom = _ref[4], x0s = _ref[5], x1s = _ref[6], y0s = _ref[7], y1s = _ref[8], x0w = _ref[9], y0w = _ref[10], x1w = _ref[11], y1w = _ref[12];
    invzoom = 1 / txm;
    paintNodeDetails = setup.paintDetails;
    nodeDetailMinSizeSq = this.style.nodeDetailMinSize * this.style.nodeDetailMinSize * invzoom * invzoom;
    hiddenLinksStyle = this.style.hiddenLinks;
    nodeLabelScaleBase = this.style.nodeLabelScaleBase;
    g.textAlign = "center";
    g.textBaseline = "middle";
    Base_Graphics.textStyle(g, this.style.nodeLabel);
    removedColor = this.style.removedColor;
    for (_i = 0, _len = nodes.length; _i < _len; _i++) {
      node = nodes[_i];
      if (!node.data) {
        continue;
      }
      x = node.x;
      y = node.y;
      r = node.hHeight;
      w = node.hWidth;
      if (x + w < x0w || x - w > x1w || y + r < y0w || y - r > y1w) {
        continue;
      }
      x = x * txm + txa;
      y = y * tym + tya;
      r *= zoom;
      w *= zoom;
      display = node.display;
      opacity = node.opacity;
      bw = node.bRight - node.bLeft;
      bh = node.bBottom - node.bTop;
      paintDetails = paintNodeDetails && bw * bh > nodeDetailMinSizeSq || node.hovered;
      if (opacity < 1) {
        g.globalAlpha = opacity;
      }
      if (paintDetails && !node.removed) {
        hlinks = node.dataLinksFiltered.length - node.links.length;
        if (hlinks > 0) {
          if (node.relevance < 1) {
            oldLine = hiddenLinksStyle.lineColor;
            hiddenLinksStyle.lineColor = Base_Graphics.blendColors(removedColor, oldLine, node.relevance);
            this.paintHiddenLinks(g, node, x, y, r, w, hlinks, hiddenLinksStyle, hiddenLinksStyle.size * zoom);
            hiddenLinksStyle.lineColor = oldLine;
          } else {
            this.paintHiddenLinks(g, node, x, y, r, w, hlinks, hiddenLinksStyle, hiddenLinksStyle.size * zoom);
          }
        }
      }
      strokeContext = Base_Graphics.beginStrokeAndFill(g, node);
      if (r !== w) {
        xx = x + w - r;
        strokeContext.moveTo(xx, y - r);
        strokeContext.arc(xx, y, r, -Math.PI / 2, Math.PI / 2, false);
        xx = x - w + r;
        strokeContext.lineTo(xx, y + r);
        strokeContext.arc(xx, y, r, Math.PI * 0.5, Math.PI * 1.5, false);
        strokeContext.closePath();
      } else {
        strokeContext.moveTo(x + r, y);
        strokeContext.arc(x, y, r, 0, PI2);
      }
      Base_Graphics.endStrokeAndFill(g, strokeContext, node);
      if (paintDetails) {
        im = this.getNodeImage(node);
        label = node.currentLabel;
        roundText = display === "roundtext";
        displayAsText = roundText || display === "text";
        if (!displayAsText || !label) {
          if (im) {
            if (node.imageSlicing) {
              s = node.imageSlicing;
              ix0 = s[0];
              iy0 = s[1];
              iw = s[2];
              ih = s[3];
            } else {
              ix0 = 0;
              iy0 = 0;
              iw = im.width;
              ih = im.height;
            }
            Base_Graphics.drawImageInSquare(g, im, ix0, iy0, iw, ih, x - w + r, y, r);
          }
        } else if (displayAsText && (label != null) && r > 2) {
          this.labelRenderer.measure(g, label);
          labelHWidth = label.hwidth;
          labelHHeight = label.hheight;
          lineHeight = label.lineHeight;
          leftOffset = 0;
          if (roundText) {
            rad = Math.sqrt(labelHWidth * labelHWidth + labelHHeight * labelHHeight);
            if (im != null) {
              xx = lineHeight + 2 * labelHWidth;
              otherRad = (xx * xx + labelHHeight * labelHHeight) / 2 / xx;
              if (otherRad > rad) {
                leftOffset = otherRad - rad;
                rad = otherRad;
              }
            }
            scale = r / rad;
            leftOffset *= scale;
          } else {
            scale = r / labelHHeight;
          }
          if (im) {
            if (roundText) {
              imSize = lineHeight * scale;
            } else {
              leftOffset = r;
              imSize = r * 2;
            }
            x0 = x - w;
            y0 = y - imSize / 2;
            if (node.imageSlicing) {
              s = node.imageSlicing;
              g.drawImage(im, s[0], s[1], s[2], s[3], x0, y0, imSize, imSize);
            } else {
              g.drawImage(im, 0, 0, im.width, im.height, x0, y0, imSize, imSize);
            }
          }
          this.labelRenderer.paintWithStyle(g, x + leftOffset, y, scale, label, label);
          Base_Graphics.clearShadow(g);
        }
        if (!node.removed) {
          if (node.hovered) {
            zz = Math.max(1, zoom);
            zs = Math.min(r, nodeLabelScaleBase);
          } else {
            zz = zoom;
            zs = nodeLabelScaleBase;
          }
          this.paintNodeDetails(node, x, y, w, r, zz, zs, this.event, node.display !== "text" && node.display !== "roundtext");
        }
      }
      if (opacity < 1) {
        g.globalAlpha = 1;
      }
    }
    if (this.scene.settings.advanced.perNodeLoadingIndicator) {
      style = this.scene.settings.advanced.style.loadingArcStyle;
      g.save();
      g.lineCap = 'round';
      g.lineWidth = style.lineWidth;
      g.strokeStyle = style.lineColor;
      a = time / 1400;
      a = (a - Math.floor(a)) * (Math.PI * 2);
      a1 = a + Math.PI / 2;
      for (_j = 0, _len1 = nodes.length; _j < _len1; _j++) {
        node = nodes[_j];
        if (node.loading || this.getNodeImage(node) === false) {
          x = node.x * txm + txa;
          y = node.y * tym + tya;
          r = node.renderHheight;
          if (x - r < x0s || x + r > x1s || y - r < y0s || y + r > y1s) {
            continue;
          }
          animating = true;
          g.beginPath();
          g.arc(x, y, r, a, a1);
          g.stroke();
        }
      }
      g.restore();
    }
    return animating;
  };

  Itemschart_NodesLayer.prototype.paintLinkDecoration = function(g, x, y, dx, dy, size, decoration, color) {
    g.fillStyle = color;
    if (decoration === "circle") {
      g.moveTo(x + size, y);
      return g.arc(x, y, size, 0, Math.PI * 2, true);
    } else if (decoration === "arrow") {
      g.moveTo(x - dx * size, y - dy * size);
      g.lineTo(x + dx * size - dy * size, y + dy * size + dx * size);
      return g.lineTo(x + dx * size + dy * size, y + dy * size - dx * size);
    }
  };

  Itemschart_NodesLayer.prototype.paintLinkPie = function(g, x, y, innerRadius, outerRadius, a0, a1, color) {
    var r, w;
    r = (innerRadius + outerRadius) / 2;
    w = outerRadius - innerRadius;
    g.beginPath();
    g.arc(x, y, r, a0, a1);
    return Base_Graphics.paint(g, {
      lineColor: color,
      lineWidth: w
    });
  };

  Itemschart_NodesLayer.prototype.paintLinkItems = function(g, zoom, size, x, y, dx, dy, linkLength, linkRadius, items) {
    var fx, fy, item, ix, iy, lx, ly, scale, xx, yy, _i, _len;
    for (_i = 0, _len = items.length; _i < _len; _i++) {
      item = items[_i];
      fx = item.x || 0;
      fy = item.y || 0;
      ix = item.px || 0;
      iy = item.py || 0;
      lx = item.lx || 0;
      ly = item.ly || 0;
      ix = linkLength * (ix + 1) * 0.5 + lx;
      iy = iy * linkRadius + ly;
      xx = x + dx * ix - dy * iy + fx;
      yy = y + dy * ix + dx * iy + fy;
      scale = 0;
      if (item.scaleWithSize) {
        scale = size;
      } else if (item.scaleWithZoom) {
        scale = zoom;
      } else {
        scale = 1;
      }
      this.labelRenderer.paint(g, xx, yy, scale, item);
    }
  };

  Itemschart_NodesLayer.prototype.paintHiddenLinks = function(g, node, x, y, r, w, count, style, size) {
    var PI2, da, ddx, ddx1, ddy, i, invlen, link, sidePr, sinkPr, t0, xc, xt, xx, yc, yt, yy, _i, _j, _len, _ref;
    PI2 = Math.PI * 2;
    sidePr = size * 0.73 / r;
    sinkPr = (r - size * 0.1) / r;
    if (node.links.length > 0) {
      xx = 0;
      yy = 0;
      _ref = node.links;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        link = _ref[_i];
        xx += link.otherEnd(node).x;
        yy += link.otherEnd(node).y;
      }
      xx = node.x - xx / node.links.length;
      yy = node.y - yy / node.links.length;
      invlen = 1 / Math.sqrt(xx * xx + yy * yy);
      ddx = xx * invlen;
      ddy = yy * invlen;
    } else {
      ddx = 1;
      ddy = 0;
    }
    da = PI2 / count / 3;
    xt = Math.cos(-da * (count - 1) / 2);
    yt = Math.sin(-da * (count - 1) / 2);
    ddx1 = ddx * xt - ddy * yt;
    yc = ddx * yt + ddy * xt;
    xc = ddx1;
    xt = Math.cos(da);
    yt = Math.sin(da);
    g.beginPath();
    for (i = _j = 1; _j <= count; i = _j += 1) {
      t0 = Base_Geometry.distanceToBalloon(r, w, xc, yc);
      g.moveTo(x + xc * t0, y + yc * t0);
      g.lineTo(x + xc * (t0 + size), y + yc * (t0 + size));
      ddx1 = xc * xt - yc * yt;
      yc = xc * yt + yc * xt;
      xc = ddx1;
    }
    g.strokeStyle = style.lineColor;
    g.lineWidth = style.lineWidth;
    return g.stroke();
  };

  hitNode = function(n, x, y, invzoom, prevBest) {
    var distanceSq, dr, insideSq, nx, ny, r, toleranceSq, w, _ref;
    r = n.renderHheight * invzoom;
    w = n.renderHwidth * invzoom;
    nx = n.x;
    ny = n.y;
    if (r < w) {
      dr = w - r;
      _ref = Base_Geometry.closestPointToLine(nx - dr, ny, nx + dr, ny, x, y), nx = _ref[0], ny = _ref[1];
    }
    distanceSq = (x - nx) * (x - nx) + (y - ny) * (y - ny);
    toleranceSq = (r + prevBest) * (r + prevBest);
    if (distanceSq < toleranceSq) {
      insideSq = r * r;
      if (distanceSq < insideSq) {
        return 0;
      } else {
        return Math.sqrt(distanceSq) - r;
      }
    }
    return prevBest;
  };

  Itemschart_NodesLayer.prototype.findObjectAt = function(displayX, displayY, tolerance) {
    var best, cx, cy, distanceSq, i, invzoom, l, min, n, newDist, nodes, r, toleranceSq, x, x0, x1, y, y0, y1, _i, _j, _len, _ref, _ref1, _ref2, _ref3, _ref4;
    _ref = this.scene.fromDisplay(displayX, displayY), x = _ref[0], y = _ref[1];
    invzoom = 1 / this.scene.zoom;
    min = tolerance * invzoom;
    best = null;
    if (((_ref1 = this.scene.hoverNode) != null ? _ref1.layer : void 0) === this) {
      n = this.scene.hoverNode;
      newDist = hitNode(n, x, y, invzoom, min);
      if (newDist <= 0) {
        return n;
      }
    }
    nodes = this.nodes();
    for (i = _i = _ref2 = nodes.length - 1; _i >= 0; i = _i += -1) {
      n = nodes[i];
      if (!n.removed) {
        newDist = hitNode(n, x, y, invzoom, min);
        if (newDist === 0) {
          return n;
        } else if (newDist < min) {
          min = newDist;
          best = n;
        }
      }
    }
    _ref3 = this.links();
    for (_j = 0, _len = _ref3.length; _j < _len; _j++) {
      l = _ref3[_j];
      if (l.removed) {
        continue;
      }
      r = l.targetRadius;
      x0 = l.from.x;
      y0 = l.from.y;
      x1 = l.to.x;
      y1 = l.to.y;
      _ref4 = Base_Geometry.closestPointToLine(x0, y0, x1, y1, x, y), cx = _ref4[0], cy = _ref4[1];
      distanceSq = (x - cx) * (x - cx) + (y - cy) * (y - cy);
      toleranceSq = (r + min) * (r + min);
      if (distanceSq < toleranceSq) {
        min = Math.sqrt(distanceSq) - r;
        best = l;
      }
    }
    return best;
  };

  Itemschart_NodesLayer.prototype.getGraphBounds = function() {
    var node, nodes, x, x0, x1, y, y0, y1, z, _i, _len;
    nodes = this.nodes();
    if (nodes.length === 0) {
      return [0, 0, 0, 0];
    }
    x0 = Infinity;
    x1 = -Infinity;
    y0 = Infinity;
    y1 = -Infinity;
    z = this.scene.zoom;
    for (_i = 0, _len = nodes.length; _i < _len; _i++) {
      node = nodes[_i];
      if (node.removed) {
        continue;
      }
      x = node.x;
      y = node.y;
      x0 = Math.min(x0, node.bLeft + x);
      x1 = Math.max(x1, node.bRight + x);
      y0 = Math.min(y0, node.bTop + y);
      y1 = Math.max(y1, node.bBottom + y);
    }
    return [x0, y0, x1, y1];
  };

  Itemschart_NodesLayer.prototype.getNodeNeighborsBounds = function(cnode) {
    var link, node, nodes, x, x0, x1, y, y0, y1, z, _i, _len, _ref;
    nodes = this.nodes();
    if (nodes.length === 0) {
      return [0, 0, 0, 0];
    }
    x0 = Infinity;
    x1 = -Infinity;
    y0 = Infinity;
    y1 = -Infinity;
    z = this.scene.zoom;
    node = cnode;
    x = node.x;
    y = node.y;
    x0 = Math.min(x0, node.bLeft + x);
    x1 = Math.max(x1, node.bRight + x);
    y0 = Math.min(y0, node.bTop + y);
    y1 = Math.max(y1, node.bBottom + y);
    _ref = cnode.links;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      link = _ref[_i];
      node = link.otherEnd(cnode);
      if (node.removed) {
        continue;
      }
      x = node.x;
      y = node.y;
      x0 = Math.min(x0, node.bLeft + x);
      x1 = Math.max(x1, node.bRight + x);
      y0 = Math.min(y0, node.bTop + y);
      y1 = Math.max(y1, node.bBottom + y);
    }
    return [x0, y0, x1, y1];
  };

  return Itemschart_NodesLayer;

})(ItemsChart_ItemsLayer);
// Generated by CoffeeScript 1.8.0
var Linearchart_Legend,
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

Linearchart_Legend = (function(_super) {
  "use strict";
  __extends(Linearchart_Legend, _super);

  Linearchart_Legend.prototype.paintOrder = 75;

  Linearchart_Legend.prototype.updateOrder = 100;

  Linearchart_Legend.settings = {
    _doc: {
      doc: "The chart legend by additional interactivity to change the visibility of series it corresponds.",
      type: "section"
    },
    marker_doc: {
      doc: "Visual element of legend entry with appropriate style to a series type and visibility",
      type: "section"
    },
    panel: {
      side: "bottom",
      align: "left",
      packingOrder: 95
    }
  };

  function Linearchart_Legend(chart) {
    this.chart = chart;
    this.onClick = __bind(this.onClick, this);
    Linearchart_Legend.__super__.constructor.call(this, chart);
  }

  Linearchart_Legend.prototype.onSceneChange = function(event) {
    var ch;
    Linearchart_Legend.__super__.onSceneChange.call(this, event);
    ch = event.changes;
    if (ch.settings) {
      this.updateSettings(ch.settingsChanges);
      if (Base_Helpers.hasProp(ch, "settingsChanges._computedSeries")) {
        this.rebuildItems();
        return ch.bounds = true;
      }
    }
  };

  Linearchart_Legend.prototype.updateSettings = function(changes) {
    if (Base_Helpers.hasProp(changes, "legend.text.fillColor")) {
      return this.baseTextColor = this.settings.text.fillColor;
    }
  };

  Linearchart_Legend.prototype.doAnimations = function() {
    if (this.scene.hoverSeriesItem) {
      return this.hoverObject = this.scene.settings._computedSeries[this.scene.hoverSeriesItem.seriesIndex];
    } else {
      return this.hoverObject = null;
    }
  };

  Linearchart_Legend.prototype.paintMarker = function(context, cx, cy, radius, item) {
    var centers, disabledSeries, pos, px1, px2, px3, py1, py2, py3, r, renderer, segments, series, seriesCopy, size, yStack, zeroY;
    size = this.settings.marker.size;
    series = item.data;
    px1 = cx - size / 2;
    px2 = cx;
    px3 = cx + size / 2;
    py1 = size / 2.1;
    py2 = size / 2;
    py3 = (size * 3) / 4;
    context.beginPath();
    zeroY = cy + size / 2;
    seriesCopy = {};
    seriesCopy = Base_Helpers.realClone(series);
    if (!series.enabled) {
      disabledSeries = this.settings.advanced.disabledSeries;
      seriesCopy.style.fillColor = !series.style.fillColor ? null : disabledSeries.fillColor;
      seriesCopy.style.lineColor = disabledSeries.lineColor;
    }
    if (seriesCopy.type === "line") {
      yStack = [py1, py2, py3];
      centers = [px1, px2, px3];
      segments = [centers, [zeroY - py1, zeroY - py2, zeroY - py3]];
      seriesCopy.style.marker.width *= .8;
      pos = zeroY - py2;
      renderer = new Linearchart_Renderer_Line([seriesCopy]);
      renderer.paintLines(context, [seriesCopy], [
        {
          segments: segments
        }
      ], [null], yStack, zeroY);
      return renderer.paintMarkers(context, seriesCopy, [px2], [py2], [pos]);
    } else {
      yStack = [size, size];
      r = size / 2;
      centers = [cx];
      renderer = new Linearchart_Renderer_Columns(this.scene, [seriesCopy]);
      return renderer.paintStack(context, centers, [r], [yStack], [null], zeroY);
    }
  };

  Linearchart_Legend.prototype.rebuildItems = function() {
    var disabledSeries, fillColor, items, series, seriesArray, textColor, _i, _len;
    items = [];
    seriesArray = this.scene.settings._computedSeries;
    disabledSeries = this.settings.advanced.disabledSeries;
    for (_i = 0, _len = seriesArray.length; _i < _len; _i++) {
      series = seriesArray[_i];
      fillColor = series.enabled ? series.style.fillColor : disabledSeries.fillColor;
      textColor = series.enabled ? this.baseTextColor : disabledSeries.textColor;
      items.push({
        fillColor: fillColor,
        textColor: textColor,
        label: series.name,
        data: series
      });
    }
    return this.setItems(items);
  };

  Linearchart_Legend.prototype.onClick = function(e) {
    var clickObject, item, s, series, _i, _ref;
    clickObject = this.findItemAt(e.x, e.y);
    if (clickObject) {
      series = this.scene.settings._computedSeries;
      for (s = _i = 0, _ref = series.length; _i < _ref; s = _i += 1) {
        item = series[s];
        if (item === clickObject) {
          item.enabled = !item.enabled;
          this.chart.events.notifySceneChanges({
            settings: true,
            settingsChanges: {
              _computedSeries: {}
            }
          });
        }
      }
      return e.preventDefault();
    }
  };

  return Linearchart_Legend;

})(Base_Legend);
// Generated by CoffeeScript 1.8.0
ToolbarItemNames["zoomOut"] = function(chart, options) {
  return new Base_Bar_UserButton(chart, {
    label: chart.settings.localization.toolbar.zoomoutButton,
    cssClass: "DVSL-bar-btn-zoomout",
    title: chart.settings.localization.toolbar.zoomoutTitle,
    showLabels: options.showLabels,
    onClick: (function(_this) {
      return function() {
        return chart.zoomOut(null, true, "user");
      };
    })(this)
  });
};
// Generated by CoffeeScript 1.8.0
var Linearchart_Bar_LinLogButton,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

Linearchart_Bar_LinLogButton = (function(_super) {
  __extends(Linearchart_Bar_LinLogButton, _super);

  function Linearchart_Bar_LinLogButton(chart, options) {
    this.chart = chart;
    this.options = options;
    Linearchart_Bar_LinLogButton.__super__.constructor.call(this, chart);
    this.linClass = "DVSL-bar-btn-lin";
    this.logClass = "DVSL-bar-btn-log";
    options.cssClass = this.linClass;
    options.title = this.chart.settings.localization.toolbar.linLogTitle;
    options.label = this.chart.settings.localization.toolbar.linButton;
    this.createButton(options);
    this.logScale = false;
  }

  Linearchart_Bar_LinLogButton.prototype.onClick = function(event) {
    return this.chart.setLogScale(!this.chart.scene.settings.valueAxisDefault.logScale, "user");
  };

  Linearchart_Bar_LinLogButton.prototype.onSceneChange = function(changes) {
    if (changes.toolbar || (changes.settings && this.chart.scene.settings.valueAxisDefault.logScale !== this.logScale)) {
      this.logScale = this.chart.scene.settings.valueAxisDefault.logScale;
      if (this.logScale) {
        Base_Helpers.removeClass(this.a, this.linClass);
        Base_Helpers.addClass(this.a, this.logClass);
        if (this.options.showLabels) {
          return this.p.innerHTML = this.chart.settings.localization.toolbar.logButton;
        }
      } else {
        Base_Helpers.removeClass(this.a, this.logClass);
        Base_Helpers.addClass(this.a, this.linClass);
        if (this.options.showLabels) {
          return this.p.innerHTML = this.chart.settings.localization.toolbar.linButton;
        }
      }
    }
  };

  return Linearchart_Bar_LinLogButton;

})(Base_Bar_Button);

ToolbarItemNames["logScale"] = function(chart, options) {
  return new Linearchart_Bar_LinLogButton(chart, options);
};
// Generated by CoffeeScript 1.8.0
var Timechart_Bar_DisplayPeriodDropdown,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

Timechart_Bar_DisplayPeriodDropdown = (function(_super) {
  __extends(Timechart_Bar_DisplayPeriodDropdown, _super);

  function Timechart_Bar_DisplayPeriodDropdown(chart, options) {
    this.chart = chart;
    this.custom = {
      name: chart.settings.localization.toolbar.customPeriod
    };
    options = {
      cssClass: "DVSL-bar-btn-month",
      title: this.chart.settings.localization.toolbar.periodDropdownTitle,
      name: "",
      showLabels: options.showLabels
    };
    Timechart_Bar_DisplayPeriodDropdown.__super__.constructor.call(this, chart, options);
    this.updateSelectedItem();
  }

  Timechart_Bar_DisplayPeriodDropdown.prototype.onSelectionChange = function(item) {
    return this.chart.setDisplayPeriod(item.displayPeriod, item.displayAnchor, item.displayUnit, true, "user");
  };

  Timechart_Bar_DisplayPeriodDropdown.prototype.onSceneChange = function(changes) {
    var _ref, _ref1;
    if (((_ref = changes.settingsChanges) != null ? _ref.area : void 0) || ((_ref1 = changes.settingsChanges) != null ? _ref1.toolbar : void 0) || changes.time || changes.toolbar) {
      return this.updateSelectedItem();
    }
  };

  Timechart_Bar_DisplayPeriodDropdown.prototype.updateSelectedItem = function() {
    var item, _i, _len, _ref;
    _ref = this.chart.settings.toolbar.periods;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      item = _ref[_i];
      if (this.chart.isThisDisplayPeriod(item.displayPeriod, item.displayAnchor)) {
        this.setSelectedItem(item);
        return;
      }
    }
    return this.setSelectedItem(this.custom);
  };

  Timechart_Bar_DisplayPeriodDropdown.prototype.getItems = function() {
    var minUnit, p, period, r, unit, _i, _len, _ref;
    r = [];
    minUnit = this.chart.settings.area._minUnit;
    _ref = this.chart.settings.toolbar.periods;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      p = _ref[_i];
      period = Base_TimeStep.parse(p.displayPeriod);
      unit = Base_TimeStep.parse(p.displayUnit);
      if ((unit && unit.isSmaller(minUnit)) || (period && period.isSmallerOrEqual(minUnit))) {
        continue;
      }
      p.selected = this.chart.isThisDisplayPeriod(p.displayPeriod, p.displayAnchor);
      r.push(p);
    }
    return r;
  };

  return Timechart_Bar_DisplayPeriodDropdown;

})(Base_Bar_Combobox);

ToolbarItemNames["displayPeriod"] = function(chart, options) {
  return new Timechart_Bar_DisplayPeriodDropdown(chart, options);
};
// Generated by CoffeeScript 1.8.0
var Timechart_Bar_DisplayUnitDropdown,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

Timechart_Bar_DisplayUnitDropdown = (function(_super) {
  __extends(Timechart_Bar_DisplayUnitDropdown, _super);

  function Timechart_Bar_DisplayUnitDropdown(chart, options) {
    this.chart = chart;
    options = {
      cssClass: "DVSL-bar-btn-bars",
      title: this.chart.settings.localization.toolbar.unitDropdownTitle,
      name: "",
      showLabels: options.showLabels
    };
    Timechart_Bar_DisplayUnitDropdown.__super__.constructor.call(this, chart, options);
    this.updateSelectedItem();
  }

  Timechart_Bar_DisplayUnitDropdown.prototype.onSelectionChange = function(item) {
    return this.chart.setDisplayUnit(item.value, true, true, "user");
  };

  Timechart_Bar_DisplayUnitDropdown.prototype.onSceneChange = function(changes) {
    var _ref;
    if (((_ref = changes.settingsChanges) != null ? _ref.area : void 0) || changes.time || changes.toolbar) {
      return this.updateSelectedItem();
    }
  };

  Timechart_Bar_DisplayUnitDropdown.prototype.updateSelectedItem = function() {
    var item, unit, _i, _len, _ref;
    unit = this.chart.displayUnit;
    if (!unit) {
      return;
    }
    _ref = this.chart.settings.area._displayUnitsParsed;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      item = _ref[_i];
      if (item.isEqual(unit)) {
        this.setSelectedItem(item);
        return;
      }
    }
    return this.setSelectedItem({
      name: unit.name,
      value: unit
    });
  };

  Timechart_Bar_DisplayUnitDropdown.prototype.getItems = function() {
    var items, minSelectableUnit, sceneUnit, unit, _i, _len, _ref;
    items = [];
    sceneUnit = this.chart.scene.displayUnit;
    minSelectableUnit = this.chart.getMinSelectableUnit();
    _ref = this.chart.settings.area._displayUnitsParsed;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      unit = _ref[_i];
      items.push({
        name: unit.name,
        value: unit,
        disabled: unit.approxTime() < minSelectableUnit.approxTime(),
        selected: unit.isEqual(sceneUnit)
      });
    }
    return items;
  };

  return Timechart_Bar_DisplayUnitDropdown;

})(Base_Bar_Combobox);

ToolbarItemNames["displayUnit"] = function(chart, options) {
  return new Timechart_Bar_DisplayUnitDropdown(chart, options);
};
// Generated by CoffeeScript 1.8.0
var Timechart_TimeSlicer;

Timechart_TimeSlicer = (function() {
  Timechart_TimeSlicer.prototype.scene = null;

  Timechart_TimeSlicer.prototype.step = null;

  Timechart_TimeSlicer.prototype.uniform = false;

  Timechart_TimeSlicer.prototype.currentFrom = 0;

  Timechart_TimeSlicer.prototype.currentTo = 0;

  Timechart_TimeSlicer.prototype.fromBar = null;

  Timechart_TimeSlicer.prototype.toBar = null;

  Timechart_TimeSlicer.prototype.fromIndex = 0;

  Timechart_TimeSlicer.prototype.toIndex = 0;

  Timechart_TimeSlicer.prototype.times = [];

  Timechart_TimeSlicer.prototype.xes = [];

  Timechart_TimeSlicer.prototype.oldMul = 0;

  Timechart_TimeSlicer.prototype.oldAdd = 0;

  Timechart_TimeSlicer.prototype.arrays = [];

  Timechart_TimeSlicer.prototype.extraArrays = [];

  Timechart_TimeSlicer.prototype.bufExpandSize = 100;

  Timechart_TimeSlicer.prototype.extraSteps = 2;

  Timechart_TimeSlicer.prototype.uniformTolerance = 0;

  Timechart_TimeSlicer.prototype.approxExtraTime = 0;

  function Timechart_TimeSlicer(scene, step, arrays, from, to, uniform, extraSteps) {
    this.scene = scene;
    this.step = step;
    if (arrays == null) {
      arrays = [];
    }
    this.uniform = uniform != null ? uniform : true;
    this.extraSteps = extraSteps != null ? extraSteps : 2;
    from = from || this.scene.timeStart;
    to = to || this.scene.timeEnd;
    this.extraArrays = arrays.slice(0);
    this.arrays = arrays.slice(0);
    this.arrays.push("xes");
    this.arrays.push("times");
    this.uniformTolerance = Math.min(1, this.step.count - 2);
    this.approxExtraTime = this.extraSteps * step.approxTime();
    this.init(from - this.approxExtraTime, to + this.approxExtraTime);
  }

  Timechart_TimeSlicer.prototype._getOrigin = function(from) {
    var t0, unitsToAdd;
    if (this.step.count === 1 || this.uniform) {
      return this.step.roundTimeDown(from);
    }
    t0 = this.step.getBigger().roundTimeDown(from);
    unitsToAdd = this.step.numberOfUnits(t0, from);
    return this.step.add(t0, unitsToAdd);
  };

  Timechart_TimeSlicer.prototype._add = function(m) {
    var date, dim;
    if (this.uniform || this.step.count === 1 || this.step.unit !== "d") {
      return m.add(this.step.count, this.step.unit);
    } else {
      dim = m.daysInMonth();
      date = m.date();
      if (date + this.step.count * 2 > dim + 1 + this.uniformTolerance) {
        return m.add(dim - date + 1, "d");
      } else {
        return m.add(this.step.count, this.step.unit);
      }
    }
  };

  Timechart_TimeSlicer.prototype._sub = function(m) {
    var date, dim, targetDay;
    if (this.uniform || this.step.count === 1 || this.step.unit !== "d") {
      return m.subtract(this.step.count, this.step.unit);
    } else {
      date = m.date();
      if (date <= this.step.count) {
        m.subtract(1, "M");
        dim = m.daysInMonth() - 1;
        targetDay = dim + 1 - this.step.count + this.uniformTolerance;
        return m.date(1 + targetDay - ((targetDay % this.step.count) | 0));
      } else {
        return m.subtract(this.step.count, this.step.unit);
      }
    }
  };

  Timechart_TimeSlicer.prototype.init = function(from, to) {
    var a, arr, t, x, _i, _j, _len, _len1, _ref, _ref1, _results;
    _ref = this.arrays;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      a = _ref[_i];
      this[a] = [];
    }
    if (from >= to) {
      this.fromIndex = 0;
      this.toIndex = 0;
      this.fromBar = null;
      this.toBar = null;
      return;
    }
    this.fromBar = moment(this._getOrigin(from)).utc();
    this.fromIndex = 0;
    t = moment(this.fromBar).utc();
    this.times.push(t.valueOf());
    while (t.valueOf() < to) {
      this._add(t);
      this.times.push(t.valueOf());
    }
    this.toIndex = this.times.length;
    this.toBar = t;
    this.currentFrom = from;
    this.currentTo = to;
    this.xes = (function() {
      var _j, _len1, _ref1, _results;
      _ref1 = this.times;
      _results = [];
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        t = _ref1[_j];
        _results.push(this.scene.timeToX(t));
      }
      return _results;
    }).call(this);
    _ref1 = this.extraArrays;
    _results = [];
    for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
      arr = _ref1[_j];
      x = [];
      x.length = this.times.length;
      _results.push(this[arr] = x);
    }
    return _results;
  };

  Timechart_TimeSlicer.prototype.makeMiniSlice = function(time) {
    var m, t0, t1, tadd, tmul, x0, x1, _ref;
    _ref = this.scene.timeToXCoefs(), tadd = _ref[0], tmul = _ref[1];
    m = moment(this._getOrigin(time)).utc();
    t0 = m.valueOf();
    x0 = tadd + t0 * tmul;
    this._add(m);
    t1 = m.valueOf();
    x1 = tadd + t1 * tmul;
    return [t0, x0, t1, x1];
  };

  Timechart_TimeSlicer.prototype.update = function(from, to) {
    var a, arr, count, dfrom, ds, dto, l, newAfter, newBefore, offset, remove, t, tadd, tmul, _i, _j, _k, _l, _len, _len1, _len2, _len3, _ref, _ref1, _ref2, _ref3, _ref4;
    if (from == null) {
      from = this.scene.timeStart;
    }
    if (to == null) {
      to = this.scene.timeEnd;
    }

    /*
      Returns [offset, newBefore, newAfter].
      Data needs to be shifted by offset.
      Values [fromIndex..newBefore) and [newAfter..toIndex) are
      new and need updating.
     */
    from -= this.approxExtraTime;
    to += this.approxExtraTime;
    if (from === this.currentFrom && to === this.currentTo) {
      this.updateXes(this.fromIndex, this.toIndex);
      return [0, this.fromIndex, this.toIndex];
    }
    if (this.fromBar === null || from > this.toBar.valueOf() || to < this.fromBar.valueOf()) {
      this.init(from, to);
      return [0, this.toIndex, this.toIndex];
    }
    offset = 0;
    newBefore = this.fromIndex;
    newAfter = this.toIndex;
    _ref = this.scene.timeToXCoefs(), tadd = _ref[0], tmul = _ref[1];
    dfrom = this.fromBar.valueOf() - from;
    if (dfrom > 0) {
      count = ((dfrom / this.step.approxTime()) | 0) + 2;
      if (this.fromIndex < count) {
        a = [];
        a.length = count + this.bufExpandSize;
        _ref1 = this.arrays;
        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
          arr = _ref1[_i];
          this[arr] = a.concat(this[arr]);
        }
        offset + a.length;
        newBefore += a.length;
        newAfter += a.length;
        this.fromIndex += a.length;
        this.toIndex += a.length;
      }
      t = this.fromBar.valueOf();
      while (t > from) {
        this._sub(this.fromBar);
        this.fromIndex -= 1;
        t = this.fromBar.valueOf();
        this.times[this.fromIndex] = t;
        this.xes[this.fromIndex] = tadd + t * tmul;
      }
    }
    dto = to - this.toBar.valueOf();
    if (dto > 0) {
      count = ((dto / this.step.approxTime()) | 0) + 2;
      if (this.times.length < this.toIndex + count) {
        l = this.toIndex + count + this.bufExpandSize;
        _ref2 = this.arrays;
        for (_j = 0, _len1 = _ref2.length; _j < _len1; _j++) {
          arr = _ref2[_j];
          this[arr].length = l;
        }
      }
      t = this.toBar.valueOf();
      while (t < to) {
        this._add(this.toBar);
        t = this.toBar.valueOf();
        this.times[this.toIndex] = t;
        this.xes[this.toIndex] = tadd + t * tmul;
        this.toIndex += 1;
      }
    }
    this._add(this.fromBar);
    while (this.fromBar.valueOf() < from) {
      this.fromIndex += 1;
      this._add(this.fromBar);
    }
    this._sub(this.fromBar);
    this._sub(this.toBar);
    while (this.toBar.valueOf() >= to) {
      this.toIndex -= 1;
      this._sub(this.toBar);
    }
    this._add(this.toBar);
    ds = this.toIndex - this.fromIndex + this.bufExpandSize;
    if (this.fromIndex > ds) {
      remove = this.fromIndex - this.bufExpandSize;
      _ref3 = this.arrays;
      for (_k = 0, _len2 = _ref3.length; _k < _len2; _k++) {
        arr = _ref3[_k];
        this[arr].splice(0, remove);
      }
      offset -= remove;
      newBefore -= remove;
      newAfter -= remove;
      this.fromIndex -= remove;
      this.toIndex -= remove;
    }
    if (this.toIndex < this.times.length - ds) {
      _ref4 = this.arrays;
      for (_l = 0, _len3 = _ref4.length; _l < _len3; _l++) {
        arr = _ref4[_l];
        this[arr].length = this.toIndex + this.bufExpandSize;
      }
    }
    this.updateXes(newBefore, newAfter);
    this.currentFrom = from;
    this.currentTo = to;
    return [offset, newBefore, newAfter];
  };

  Timechart_TimeSlicer.prototype.updateXes = function(newBefore, newAfter) {
    var i, tadd, tmul, _i, _ref, _ref1, _results;
    _ref = this.scene.timeToXCoefs(), tadd = _ref[0], tmul = _ref[1];
    if (this.oldAdd !== tadd || this.oldMul !== tmul) {
      this.oldAdd = tadd;
      this.oldMul = tmul;
      _results = [];
      for (i = _i = newBefore, _ref1 = newAfter - 1; _i <= _ref1; i = _i += 1) {
        _results.push(this.xes[i] = tadd + this.times[i] * tmul);
      }
      return _results;
    }
  };

  return Timechart_TimeSlicer;

})();
// Generated by CoffeeScript 1.8.0
var Linearchart_InfoPopup,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

Linearchart_InfoPopup = (function(_super) {
  "use strict";
  __extends(Linearchart_InfoPopup, _super);

  Linearchart_InfoPopup.prototype.animationOrder = 10;

  Linearchart_InfoPopup.prototype.t0 = 0;

  Linearchart_InfoPopup.prototype.t1 = 0;

  Linearchart_InfoPopup.prototype.object = null;

  Linearchart_InfoPopup.prototype.popup = null;

  Linearchart_InfoPopup.prototype.visible = false;

  Linearchart_InfoPopup.prototype.activePointer = null;

  Linearchart_InfoPopup.prototype.pointerX = 0;

  Linearchart_InfoPopup.prototype.pointerY = 0;

  Linearchart_InfoPopup.prototype.getPopupAreaMouseMoved = function(x, y) {
    return null;
  };

  Linearchart_InfoPopup.prototype.buildHeader = function(t0, t1) {
    return "";
  };

  Linearchart_InfoPopup.prototype.popupHidden = function(event) {
    return null;
  };

  function Linearchart_InfoPopup(chart) {
    this.chart = chart;
    this.container = chart.layers.container;
    this.scene = chart.scene;
    this.events = chart.events;
    this.popup = new Base_InfoPopup(this.chart);
  }

  Linearchart_InfoPopup.prototype.show = function(event) {
    if (!this.scene.settings.info.enabled) {
      return;
    }
    this.pointerX = event.x;
    this.pointerY = event.y;
    return this.updatePopup(event);
  };

  Linearchart_InfoPopup.prototype.previewPointerMove = function(event) {
    if (!(this.scene.settings.info.enabled && (this.activePointer === null || (this.activePointer = event.identifier)))) {
      return;
    }
    this.pointerX = event.x;
    this.pointerY = event.y;
    return this.updatePopup(event);
  };

  Linearchart_InfoPopup.prototype.previewPointerDrag = function(event) {
    if (!(this.scene.settings.info.enabled && (this.activePointer === null || this.activePointer === event.identifier))) {
      return;
    }
    this.activePointer = event.identifier;
    this.pointerX = event.x;
    return this.pointerY = event.y;
  };

  Linearchart_InfoPopup.prototype.previewPointerCancel = function(event) {
    if (this.activePointer !== null && this.activePointer === event.identifier) {
      return this.activePointer = null;
    }
  };

  Linearchart_InfoPopup.prototype.previewPointerUp = function(event) {
    if (this.activePointer !== null && this.activePointer === event.identifier) {
      return this.activePointer = null;
    }
  };

  Linearchart_InfoPopup.prototype.previewPointerOut = function(event) {
    if ((this.activePointer !== null && this.activePointer !== event.identifier) || event.touch) {
      return;
    }
    this.activePointer = null;
    this.pointerX = null;
    this.pointerY = null;
    if (!Base_Helpers.isParentOf(this.popup, event.target)) {
      return this.hideInfoPopup(event);
    }
  };

  Linearchart_InfoPopup.prototype.previewPointerDown = function(event) {
    if (this.activePointer !== null) {
      return;
    }
    this.activePointer = event.identifier;
    if (event.touch) {
      return this.previewPointerMove(event);
    } else {
      return this.hideInfoPopup(event);
    }
  };

  Linearchart_InfoPopup.prototype.updatePopup = function(event) {
    var contents, g, obj, t0, t1;
    if (!this.pointerX && !this.pointerY) {
      this.hideInfoPopup(event);
      return;
    }
    g = this.getPopupMouseMoved(this.pointerX, this.pointerY, this.t0, this.t1, this.object, this.contents);
    if (g) {
      t0 = g[0], t1 = g[1], obj = g[2], contents = g[3];
      return this.showInfoPopup(t0, t1, obj, contents, event);
    } else {
      return this.hideInfoPopup(event);
    }
  };

  Linearchart_InfoPopup.prototype.showInfoPopup = function(t0, t1, object, contents, event) {
    var y;
    if (this.popup.visible && t0 === this.t0 && t1 === this.t1 && object === this.object) {
      return;
    }
    this.t0 = t0;
    this.t1 = t1;
    this.object = object;
    this.contents = contents;
    this.scene.setHighlight("infoRange", t0, t1, this.scene.settings.info.style.highlight);
    y = this.scene.y0;
    this.popup.show(this.scene.timeToX(this.t0), this.scene.timeToX(this.t1), y, contents);
    event.changes.infoLabel = true;
    return event.changes.highlight = true;
  };

  Linearchart_InfoPopup.prototype.hideInfoPopup = function(event) {
    if (!this.popup.visible) {
      return;
    }
    this.popupHidden(event);
    this.popup.hide();
    this.t0 = 0;
    this.t1 = 0;
    this.scene.removeHighlight("infoRange");
    event.changes.infoLabel = true;
    return event.changes.highlight = true;
  };

  Linearchart_InfoPopup.prototype.paintScene = function(event) {
    if (this.popup.visible) {
      return this.updateXY();
    }
  };

  Linearchart_InfoPopup.prototype.updateXY = function() {
    var y;
    y = this.scene.y0;
    return this.popup.updateXY(this.scene.timeToX(this.t0), this.scene.timeToX(this.t1), y);
  };

  Linearchart_InfoPopup.prototype.getPopupMouseMoved = function(x, y, prevT0, prevT1, prevObj, prevContents) {
    var content, g, scope, scopeT0, scopeT1, seriesInd, seriesObj, stack, t0, t1;
    if (!(!this.scene.displayUnit || this.scene.xyInChartOrBottom(x, y))) {
      return null;
    }
    g = this.getPopupAreaMouseMoved(x, y);
    if (!g) {
      return null;
    }
    t0 = g[0], t1 = g[1];
    stack = null;
    seriesInd = null;
    seriesObj = this.scene.hoverSeriesItem;
    scope = this.scene.settings.info.advanced.scope;
    scopeT0 = t0;
    scopeT1 = t1;
    if (seriesObj != null) {
      seriesInd = seriesObj.seriesIndex;
      if ((scope === "stack" || scope === "value") || (scope === "auto" && (seriesInd != null))) {
        scopeT0 = this.scene.xToTime(seriesObj.x0);
        scopeT1 = this.scene.xToTime(seriesObj.x1);
      }
      stack = seriesObj.stack;
    }
    if (scopeT0 == null) {
      return null;
    }
    if (scopeT0 === prevT0 && scopeT1 === prevT1 && seriesInd === prevObj) {
      return [prevT0, prevT1, prevObj, prevContents];
    }
    content = this.buildContent(t0, t1, seriesInd, stack);
    return [scopeT0, scopeT1, seriesInd, content];
  };

  Linearchart_InfoPopup.prototype.buildContent = function(t0, t1, activeSeriesInd, activeStack) {
    var header, info, seriesObj, valueHtml;
    header = this.buildHeader(t0, t1);
    info = this.chart.renderer.exportData(t0, t1);
    if (this.scene.settings.info.advanced.contentsFunction) {
      seriesObj = null;
      if (activeSeriesInd !== null && this.scene.settings.series.length > activeSeriesInd) {
        seriesObj = this.scene.settings.series[activeSeriesInd];
      }
      valueHtml = this.scene.settings.info.advanced.contentsFunction.call(this.chart.api, info, seriesObj);
    } else {
      valueHtml = this.buildValues(info, activeSeriesInd, activeStack);
    }
    return header + valueHtml;
  };

  Linearchart_InfoPopup.prototype.buildValues = function(info, selectedSeriesIndex, selectedStack) {

    /*
     *this method will build actual list, based on the info aggregated from the
     *series
     */
    var color, group, hasHovered, hoveredOnly, noDataStr, out, param, scope, selected, series, stackOnly, valueFormattingFunction, _i, _j, _k, _l, _len, _len1, _ref, _ref1, _ref2;
    noDataStr = this.scene.settings.localization.noDataLabel;
    valueFormattingFunction = this.scene.settings.info.valueFormatterFunction;
    scope = this.scene.settings.info.advanced.showOnlyHoveredSeries ? this.scene.settings.info.advanced.scope : null;
    stackOnly = (selectedStack && (scope === "stack" || scope === "value")) || (scope === "auto" && (selectedSeriesIndex != null));
    hoveredOnly = scope === "value";
    out = "";
    for (_i = 0, _len = info.length; _i < _len; _i++) {
      group = info[_i];
      if (stackOnly) {
        hasHovered = false;
        _ref = group.data;
        for (_j = _ref.length - 1; _j >= 0; _j += -1) {
          series = _ref[_j];
          if (!series.config.showInLegend || (!series.values && !this.chart.scene.settings.info.showNoData)) {
            continue;
          }
          hasHovered |= (selectedSeriesIndex !== null && series.config === this.scene.settings._computedSeries[selectedSeriesIndex]) || (selectedStack === group.stack);
        }
        if (!hasHovered) {
          continue;
        }
      }
      if (group.name && group.data.length > 1) {
        out += "<h3>" + group.name + "</h3>";
      }
      out += "<table cellspacing=\"0\">";
      _ref1 = group.data;
      for (_k = _ref1.length - 1; _k >= 0; _k += -1) {
        series = _ref1[_k];
        selected = selectedSeriesIndex !== null && series.config === this.scene.settings._computedSeries[selectedSeriesIndex];
        if (!series.config.showInLegend || (!series.values && !this.chart.scene.settings.info.showNoData)) {
          continue;
        }
        if (hoveredOnly && !selected) {
          continue;
        }
        out += "<tr><td";
        color = series.config.style.lineColor || series.config.style.fillColor;
        if (color) {
          out += " style=\"color: " + color + "\"";
        }
        out += ">";
        if (selected) {
          out += "<div class='DVSL-info-selected' style='background-color: " + color + "'></div>";
        }
        out += "" + (series.name || group.name);
        out += "</td><td>";
        if (valueFormattingFunction) {
          out += valueFormattingFunction.call(this.chart.api, series.values, series.config);
        } else if (!series.values) {
          out += noDataStr;
        } else if (series.values.count > 1 && this.scene.settings.info.aggregations && this.scene.settings.info.aggregations.length > 0) {
          _ref2 = this.scene.settings.info.aggregations;
          for (_l = 0, _len1 = _ref2.length; _l < _len1; _l++) {
            param = _ref2[_l];
            out += "" + Base_Helpers.numberFormat(series.values[param]) + ("&nbsp;(" + param + ")");
          }
        } else {
          out += Base_Helpers.numberFormat(series.values.sum);
        }
        out += "</td></tr>";
      }
      out += "</table>";
    }
    return out;
  };

  return Linearchart_InfoPopup;

})(Base_ChartElement);
// Generated by CoffeeScript 1.8.0
var Base_Bar_ExportDropdown,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

Base_Bar_ExportDropdown = (function(_super) {
  __extends(Base_Bar_ExportDropdown, _super);

  function Base_Bar_ExportDropdown(chart, options) {
    var items, loc;
    this.chart = chart;
    loc = this.chart.settings.localization.toolbar;
    items = [
      new Base_Bar_UserButton(chart, {
        label: loc.exportJpeg,
        onClick: function() {
          return Base_Export.exportAndStartDownload(chart, "jpeg", {
            scaling: 1
          });
        }
      }), new Base_Bar_UserButton(chart, {
        label: loc.exportPNG,
        onClick: function() {
          return Base_Export.exportAndStartDownload(chart, "png", {
            scaling: 3
          });
        }
      }), new Base_Bar_UserButton(chart, {
        label: loc.exportPDF,
        onClick: function() {
          return Base_Export.exportAndStartDownload(chart, "pdf");
        }
      })
    ];
    if (window.JSON && chart.exportVisibleData) {
      items.push(new Base_Bar_UserButton(chart, {
        label: loc.exportCSV,
        onClick: function() {
          return Base_Export.exportAndStartDownload(chart, "csv");
        }
      }));
      items.push(new Base_Bar_UserButton(chart, {
        label: loc.exportXLS,
        onClick: function() {
          return Base_Export.exportAndStartDownload(chart, "xls");
        }
      }));
    }
    options = {
      showLabels: options.showLabels,
      title: loc.exportTitle,
      label: loc.exportButton,
      cssClass: "DVSL-bar-btn-export",
      items: items
    };
    Base_Bar_ExportDropdown.__super__.constructor.call(this, chart, options);
  }

  return Base_Bar_ExportDropdown;

})(Base_Bar_Dropdown);

ToolbarItemNames["export"] = function(chart, options) {
  return new Base_Bar_ExportDropdown(chart, options);
};
// Generated by CoffeeScript 1.8.0
var Base_Api;

Base_Api = (function() {
  function Base_Api() {}

  Base_Api.themes = {};

  Base_Api.prototype.customize = function(name) {

    /*
      Applies one of predefined customizations from @themes
     */
    var themes;
    themes = this.constructor.themes;
    if (!(themes && themes.hasOwnProperty(name))) {
      throw "No customization named " + name;
    }
    return this.updateSettings(themes[name]);
  };

  Base_Api.prototype.saveState = function() {
    return this._impl.save();
  };

  Base_Api.prototype.restoreState = function(state, animate) {
    if (animate == null) {
      animate = false;
    }
    return this._impl.restore(state, animate);
  };

  Base_Api.prototype.fullscreen = function(isFullscreen) {
    if (isFullscreen === true) {
      this._impl.setFullscreen(true);
    } else if (isFullscreen === false) {
      this._impl.setFullscreen(false);
    }
    return this._impl.isFullscreen();
  };

  Base_Api.prototype.updateSettings = function(changes) {
    if (changes == null) {
      changes = {};
    }

    /*
      Change settings, can pass the same settings as in constructor.
      Only pass the settings you need changed.
     */
    this._impl.updateSettings(changes, "api");
    return this;
  };

  Base_Api.prototype.updateFilters = function() {
    return this._impl.updateFilters();
  };

  Base_Api.prototype.updateStyle = function() {
    return this._impl.updateStyle();
  };

  Base_Api.prototype.on = function(name, listener) {

    /*
     Adds event listener.
     Supported event types: "timeChange", "selectionChange, "click", "doubleClick".
     Consult doc for event types in specific SDK
     */
    return this._impl.on(name, listener);
  };

  Base_Api.prototype.off = function(name, listener) {
    return this._impl.off(name, listener);
  };

  Base_Api.prototype.updateSize = function() {

    /*
      Call when the container size has been changed to update the chart.
     */
    this._impl.updateSize(true);
    return this;
  };

  Base_Api.prototype.reloadData = function() {

    /*
      Clears data cache and loads new data. The time range is preserved.
     */
    return this._impl.reloadData();
  };

  Base_Api.prototype.addData = function(data, sourceId) {
    if (sourceId == null) {
      sourceId = "default";
    }

    /*
      Adds specific data and updates the chart.
     */
    return this._impl.addData(data, sourceId);
  };

  Base_Api.prototype.removeData = function(data, sourceId) {
    if (sourceId == null) {
      sourceId = "default";
    }

    /*
      Removes data and updates the chart.
     */
    return this._impl.removeData(data, sourceId);
  };

  Base_Api.prototype.replaceData = function(data, sourceId) {
    if (sourceId == null) {
      sourceId = "default";
    }

    /*
      Removes data and updates the chart.
     */
    return this._impl.replaceData(data, sourceId);
  };

  Base_Api.prototype.remove = function() {

    /*
      Removes chart from DOM. Is automatically called when you create a new Chart with the same container.
     */
    return this._impl.remove();
  };

  Base_Api.prototype.saveAsImage = function(type, dimensions, transparent) {
    return this.exportImageAsString(type, dimensions, transparent);
  };

  Base_Api.prototype.exportGetDimensions = function(dimensions) {
    return this.exportImageGetDimensions(dimensions);
  };

  Base_Api.prototype.exportImageAsString = function(type, dimensions, transparent) {

    /*
     * returns data uri string
     * supported types:
     *   png|jpeg
     * dimensions is object, that supports:
     *   dpi: int
     *   unit: mm|px
     *   width:
     *   height:
     *   scaling
     */
    return Base_Export.exportToImage(this._impl, type, dimensions, transparent);
  };

  Base_Api.prototype.exportImageGetDimensions = function(dimensions) {
    return Base_Export.exportToImageGetDimensions(this._impl, dimensions);
  };

  Base_Api.prototype["export"] = function(type, dimensions, transparent) {
    return Base_Export.exportAndStartDownload(this._impl, type, dimensions, transparent);
  };

  Base_Api.prototype.addSubchartContainer = function(container) {
    return this._impl.layers.mouseTrackLayer.appendChild(container);
  };

  Base_Api.prototype.paintNow = function(force) {
    if (force == null) {
      force = false;
    }
    this._impl.events.paintNow(force);
    return this;
  };

  Base_Api.prototype.hideMenu = function() {
    this._impl.hideMenu();
    return this;
  };

  Base_Api.prototype.back = function() {
    this._impl.back();
    return this;
  };

  Base_Api.prototype.home = function() {
    return this._impl.goHome();
  };

  Base_Api.prototype.clearHistory = function() {
    this._impl.clearHistory();
    return this;
  };

  Base_Api.prototype.closePopup = function() {
    this._impl.log("closePopup is deprecated, use hideMenu");
    this.hideMenu();
    return this;
  };

  Base_Api.prototype.profiler = function() {
    return this._impl.events.profiler;
  };

  Base_Api.prototype.measureFps = function(iters, callback) {
    this._impl.deprecated();
    return this.profiler().measureFps(iters, callback);
  };

  return Base_Api;

})();
// Generated by CoffeeScript 1.8.0
var Netchart_Legend,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

Netchart_Legend = (function(_super) {
  "use strict";
  __extends(Netchart_Legend, _super);

  Netchart_Legend.prototype.paintOrder = 51;

  Netchart_Legend.prototype.updateOrder = 100;

  Netchart_Legend.settings = {
    _doc: {
      doc: "The chart legend representing classes attached to nodes or links. Note that it's a current grouping alternative.",
      type: "section"
    },
    panel: {
      side: "bottom",
      align: "left"
    },
    marker: {
      _doc: {
        doc: "Visual element of legend entry with appropriate style to a class it corresponds.",
        type: "object"
      },
      size: 30
    },
    padding: 15
  };

  function Netchart_Legend(chart) {
    this.chart = chart;
    Netchart_Legend.__super__.constructor.call(this, chart);
    this.classes = [];
    this.renderer = chart.renderer;
  }

  Netchart_Legend.prototype.onSceneChange = function(event) {
    var ch;
    Netchart_Legend.__super__.onSceneChange.call(this, event);
    ch = event.changes;
    if (ch.settings) {
      this.updateSettings(ch.settingsChanges);
      if (ch.settingsChanges.legend) {
        this.rebuildItems();
        return ch.bounds = true;
      }
    }
  };

  Netchart_Legend.prototype.updateSettings = function(changes) {
    var baseLStyle, baseNStyle, linkClass, mergedStyle, nodeClass, style, _i, _j, _len, _len1, _ref, _ref1;
    if (Base_Helpers.hasProp(changes, "style.nodeClasses") || Base_Helpers.hasProp(changes, "style.linkClasses")) {
      style = this.scene.settings.style;
      baseNStyle = Base_Helpers.extend({}, style.node);
      baseLStyle = Base_Helpers.extend({}, style.link);
      _ref = style.nodeClasses;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        nodeClass = _ref[_i];
        mergedStyle = Base_Helpers.clone(baseNStyle);
        this.classes.push({
          className: nodeClass.className,
          itemType: "node",
          style: Base_Helpers.extend(mergedStyle, nodeClass.style)
        });
      }
      _ref1 = style.linkClasses;
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        linkClass = _ref1[_j];
        mergedStyle = Base_Helpers.clone(baseLStyle);
        this.classes.push({
          className: nodeClass.className,
          itemType: "link",
          style: Base_Helpers.extend(mergedStyle, linkClass.style)
        });
      }
    }
    if (Base_Helpers.hasProp(changes, "legend.text.fillColor")) {
      return this.baseTextColor = this.settings.text.fillColor;
    }
  };

  Netchart_Legend.prototype.doAnimations = function() {
    return 1;
  };

  Netchart_Legend.prototype.paintMarker = function(context, cx, cy, radius, item) {
    var id, setup;
    setup = {};
    if (item.data instanceof Itemschart_Node) {
      setup.geometry = this.getGeometry(cx, cy, .6);
      setup.paintDetails = false;
      return this.renderer.paintNodes(context, [item.data], setup, 0);
    } else if (item.data instanceof Itemschart_Link) {
      setup.geometry = this.getGeometry(cx, cy, 1);
      setup.paintDetails = true;
      id = item.multiId;
      return this.renderer.paintLinks(context, [item.data], {
        id: item
      }, setup);
    }
  };

  Netchart_Legend.prototype.rebuildItems = function() {
    var cl, halfSize, item, items, v, _ref;
    items = [];
    halfSize = this.settings.marker.size / 2;
    _ref = this.classes;
    for (v in _ref) {
      if (!__hasProp.call(_ref, v)) continue;
      cl = this.classes[v];
      item = cl.itemType === "node" ? new Itemschart_Node(null, null) : new Itemschart_Link(null, null);
      if (item instanceof Itemschart_Node) {
        item.data = {};
        item.hHeight = halfSize;
        item.hWidth = halfSize;
        item.renderHheight = halfSize;
        item.renderHwidth = halfSize;
      } else {
        item.from = {
          x: -halfSize * 2,
          y: 0,
          renderHheight: halfSize,
          renderHwidth: halfSize
        };
        item.to = {
          x: halfSize + halfSize / 2,
          y: 0,
          renderHheight: halfSize,
          renderHwidth: halfSize
        };
      }
      item = Base_Helpers.extend(item, cl.style);
      items.push({
        textColor: this.baseTextColor,
        label: cl.className,
        data: item
      });
    }
    return this.setItems(items);
  };

  Netchart_Legend.prototype.getGeometry = function(xc, yc, zoom) {
    var halfSize, txa, txm, tya, tym, x0s, x0w, x1s, x1w, y0s, y0w, y1s, y1w;
    halfSize = this.settings.marker.size;
    x0w = -halfSize;
    x1w = halfSize;
    y0w = -halfSize;
    y1w = halfSize;
    txm = zoom;
    tym = zoom;
    txa = xc;
    tya = yc;
    x0s = xc - halfSize;
    x1s = xc + halfSize;
    y0s = yc - halfSize;
    y1s = yc + halfSize;
    return [txm, txa, tym, tya, zoom, x0s, x1s, y0s, y1s, x0w, y0w, x1w, y1w];
  };

  Netchart_Legend.prototype.onClick = function() {
    return 1;
  };

  return Netchart_Legend;

})(Base_Legend);
// Generated by CoffeeScript 1.8.0
var Netchart_Layout,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

Netchart_Layout = (function(_super) {
  __extends(Netchart_Layout, _super);

  Netchart_Layout.prototype.animationOrder = 600;

  Netchart_Layout.prototype.paintOrder = 10;

  Netchart_Layout.prototype.updateOrder = 1600;

  Netchart_Layout.settings = {
    _doc: {
      doc: "Adjustable settings to get desired net chart layout style and animation while and before interacting.",
      type: "section"
    },
    mode: "dynamic",
    mode_doc: {
      doc: "Layout mode.",
      type: "enum",
      values: {
        "dynamic": "incrementally update whole network when user moves nodes",
        "radial": "Position graph nodes in concentric rings, starting form initial node.",
        "static": "other nodes stay fixed while user moves nodes."
      }
    },
    nodeSpacing: 16,
    nodeSpacing_doc: {
      doc: "Desired distance between nodes.",
      type: "integer",
      units: "pixels"
    },
    incrementalLayoutMaxTime: 300,
    incrementalLayoutMaxTime_doc: {
      doc: "Maximum time to wait for incremental layout to be completed. Note that bigger value will get nicer placement on network updates at the cost of longer delay.",
      type: "integer",
      units: "milliseconds"
    },
    initialLayoutMaxTime: 2000,
    initialLayoutMaxTime_doc: {
      doc: "Maximum time to wait for initial layout to be completed. Note that bigger value will get nicer placement of big networks at the cost of long initial delay.",
      type: "integer",
      units: "milliseconds"
    },
    layoutFreezeTimeout: 10000,
    layoutFreezeTimeout_doc: {
      doc: "Dynamic layout is stopped after user is inactive for this time.",
      type: "integer",
      units: "milliseconds"
    },
    layoutFreezeMinTimeout: 1500,
    layoutFreezeMaxTimeout_doc: {
      doc: "Dynamic layout can be stopped faster if no more movement is detected.",
      type: "integer",
      units: "milliseconds"
    },
    aspectRatio: false,
    aspectRatio_doc: {
      doc: "Whether to fit network in aspect ratio of chart viewport. Useful for small networks that always fit in chart and are not intended to be zoomed in / out.",
      type: "bool"
    },
    globalLayoutOnChanges: true,
    globalLayoutOnChanges_doc: {
      doc: "Whether to perform global layout on network changes. Use it for better node placement at the cost of chart slowdown on network changes.",
      type: "bool"
    },
    advanced: {
      _doc: {
        doc: "Advanced chart settings. Be advised that they are subject to change, backwards compatibility is not guaranteed.",
        type: "section"
      },
      adaptiveFreezeTreshold: 1.2
    }
  };

  function Netchart_Layout(chart) {
    this.chart = chart;
    this.scene = chart.scene;
    this.settings = this.scene.settings.layout;
    this.layer = this.chart.layer;
    this.idleSince = null;
    this.noMovementSince = null;
    this.random = new Base_Random(1);
    this.springs = new Netchart_Layout_TimedSpringEmbedder(this.random);
    this.layoutMovement = 0;
  }

  Netchart_Layout.prototype.onSceneChange = function(event) {
    var _ref;
    if (((_ref = event.settingsChanges) != null ? _ref.layout : void 0) || this.layer.hasTopologyChanges() || event.changes.navigation) {
      return this.updateBackgroundLinks();
    }
  };

  Netchart_Layout.prototype.doAnimations = function(event) {
    var aliveProportion, dt, dynamicLayout, idleTime, idleTimeout, majorChanges, newNodes, newPos, noMovementTime, noMovementTimeout, styleChanges, timeout, topologyChanges, _ref;
    idleTimeout = this.settings.layoutFreezeTimeout;
    noMovementTimeout = this.settings.layoutFreezeMinTimeout;
    topologyChanges = this.layer.hasTopologyChanges();
    styleChanges = this.layer.hasStyleChanges();
    dt = event.dtime;
    if (this.idleSince === null || event.animating || topologyChanges || event.changes.coordinates || event.changes.layout || event.changes.bounds) {
      this.idleSince = event.timeStamp;
      this.noMovementSince = null;
    }
    newPos = false;
    if (this.settings.mode === "radial") {
      this.layoutMovement = this.doLayout(event.timeStamp, dt * aliveProportion, topologyChanges | event.changes.layout, styleChanges, newNodes, 0, false, false);
      newPos = true;
    } else {
      newNodes = {};
      majorChanges = false;
      dynamicLayout = this.settings.mode === "dynamic";
      if (topologyChanges) {
        this.random = new Base_Random(1);
        _ref = this.placeNewNodes(), newNodes = _ref[0], majorChanges = _ref[1];
        newPos = true;
        aliveProportion = 1;
      } else if (dynamicLayout) {
        aliveProportion = 1;
        idleTime = event.timeStamp - this.idleSince;
        if (this.layoutMovement < this.settings.advanced.adaptiveFreezeTreshold) {
          if (this.noMovementSince) {
            noMovementTime = event.timeStamp - this.noMovementSince;
            aliveProportion = Math.min((noMovementTimeout - noMovementTime) / noMovementTimeout, aliveProportion);
          } else {
            this.noMovementSince = event.timeStamp;
          }
        }
        aliveProportion = Math.min((idleTimeout - idleTime) / noMovementTimeout, aliveProportion);
      }
      if (aliveProportion > 0) {
        timeout = majorChanges ? this.settings.initialLayoutMaxTime : this.settings.incrementalLayoutMaxTime;
        this.layoutMovement = this.doLayout(event.timeStamp, dt * aliveProportion, topologyChanges | event.changes.layout, styleChanges, newNodes, timeout, majorChanges, dynamicLayout);
        event.animating = true;
        newPos = true;
      }
    }
    if (newPos) {
      this.placePies();
      return event.changes.position = true;
    }
  };

  Netchart_Layout.prototype.resetLayout = function() {
    var n, newNodes, _i, _len, _ref;
    this.random = new Base_Random(1);
    this.springs.random = this.random;
    newNodes = {};
    _ref = this.layer.nodes();
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      n = _ref[_i];
      newNodes[n.id] = n;
      n.x = 0;
      n.y = 0;
      n.userLock = false;
    }
    this.doLayout(this.idleSince || new Date().getTime(), 1, true, true, newNodes, 10000, true);
    return this.idleSince = null;
  };

  Netchart_Layout.prototype.placeNewNodes = function() {
    var count, cx, cy, dx, dy, iln, len, link, majorChanges, n, neighbor, neighborCount, newNodes, nn, node, nx, ny, randomness, _i, _j, _k, _l, _len, _len1, _len2, _len3, _ref, _ref1, _ref2, _ref3;
    newNodes = {};
    majorChanges = false;
    _ref = this.layer.nodes();
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      n = _ref[_i];
      if (n.x === null || n.y === null) {
        newNodes[n.id] = true;
      }
    }
    _ref1 = this.layer.nodes();
    for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
      n = _ref1[_j];
      randomness = 1;
      if (newNodes.hasOwnProperty(n.id)) {
        neighborCount = 0;
        cx = 0;
        cy = 0;
        randomness = 1;
        _ref2 = n.links;
        for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
          link = _ref2[_k];
          nn = link.otherEnd(n);
          if (!newNodes.hasOwnProperty(nn.id)) {
            neighbor = nn;
            cx += nn.x;
            cy += nn.y;
            neighborCount += 1;
          }
        }
        if (neighborCount > 1) {
          nx = cx / neighborCount;
          ny = cy / neighborCount;
          randomness = 0.5;
        } else if (neighborCount === 1) {
          count = 0;
          dx = 0;
          dy = 0;
          _ref3 = neighbor.links;
          for (_l = 0, _len3 = _ref3.length; _l < _len3; _l++) {
            link = _ref3[_l];
            node = link.otherEnd(neighbor);
            if (node === n || newNodes.hasOwnProperty(node.id)) {
              continue;
            }
            dx += node.x - neighbor.x;
            dy += node.y - neighbor.y;
            count += 1;
          }
          if (count > 0) {
            len = Math.sqrt(dx * dx + dy * dy);
            if (len > 0) {
              iln = 1 / (len * count);
              dx *= iln;
              dy *= iln;
              nx = neighbor.x - dx * neighbor.hHeight * 1.2;
              ny = neighbor.y - dy * neighbor.hHeight * 1.2;
              randomness = 0.2;
            } else {
              nx = neighbor.x;
              ny = neighbor.y;
            }
          } else {
            majorChanges = true;
            nx = neighbor.x;
            ny = neighbor.y;
          }
        } else {
          majorChanges = true;
          nx = 0;
          ny = 0;
        }
        n.x = nx + (this.random.get() - 0.5) * randomness * (n.hHeight + 1);
        n.y = ny + (this.random.get() - 0.5) * randomness * (n.hHeight + 1);
      }
    }
    return [newNodes, majorChanges];
  };

  Netchart_Layout.prototype.placePies = function() {
    var PI2, angle, link, mul, node, offCenter, offset, pieLinks, sum, _i, _j, _k, _l, _len, _len1, _len2, _len3, _ref, _ref1, _results;
    PI2 = Math.PI * 2;
    pieLinks = [];
    _ref = this.layer.nodes();
    _results = [];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      node = _ref[_i];
      sum = 0;
      _ref1 = node.links;
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        link = _ref1[_j];
        if (link.to === node && link.toPieValue > 0) {
          sum += link.toPieValue;
          pieLinks.push(link);
          link._angle = Math.atan2(link.to.y - link.from.y, link.to.x - link.from.x);
        }
      }
      if (sum > 0) {
        pieLinks.sort(function(a, b) {
          return a._angle - b._angle;
        });
        mul = PI2 / sum;
        angle = 0;
        offset = 0;
        for (_k = 0, _len2 = pieLinks.length; _k < _len2; _k++) {
          link = pieLinks[_k];
          link.toPie0 = angle;
          angle += link.toPieValue * mul;
          link.toPie1 = angle;
          offCenter = link._angle - (link.toPie0 + link.toPie1) / 2;
          if (offCenter < 0) {
            offCenter += Math.PI * 2;
          }
          offset += offCenter;
        }
        offset /= pieLinks.length;
        offset -= Math.PI;
        for (_l = 0, _len3 = pieLinks.length; _l < _len3; _l++) {
          link = pieLinks[_l];
          link.toPie0 += offset;
          link.toPie1 += offset;
        }
        _results.push(pieLinks = []);
      } else {
        _results.push(void 0);
      }
    }
    return _results;
  };

  Netchart_Layout.prototype.doLayout = function(time, dt, topologyChanges, styleChanges, newNodes, timeout, reset, incremental) {
    if (reset == null) {
      reset = false;
    }
    if (incremental == null) {
      incremental = true;
    }
    if (this.settings.mode === "radial") {
      return this.doRadialLayout(time, dt, topologyChanges, styleChanges, newNodes, timeout, reset, incremental);
    } else {
      return this.doForceLayout(time, dt, topologyChanges, styleChanges, newNodes, timeout, reset, incremental);
    }
  };

  Netchart_Layout.prototype.updateBackgroundLinks = function() {
    var isBg, l, link, links, mainLinks, nodes, startNode, _i, _j, _len, _len1, _results, _results1;
    links = this.layer.links();
    nodes = this.layer.nodes();
    if (this.settings.mode === "radial") {
      if (this.scene.lastFocusNode) {
        startNode = this.scene.lastFocusNode;
      } else {
        startNode = nodes[0];
      }
      if (startNode) {
        l = new RadialLayout();
        mainLinks = l.getMainLinks(startNode);
      } else {
        mainLinks = {};
      }
      _results = [];
      for (_i = 0, _len = links.length; _i < _len; _i++) {
        link = links[_i];
        isBg = !mainLinks.hasOwnProperty(link.id);
        if (link.background !== isBg) {
          link.background = isBg;
          _results.push(this.layer.touchLink(link));
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    } else {
      _results1 = [];
      for (_j = 0, _len1 = links.length; _j < _len1; _j++) {
        link = links[_j];
        if (link.background) {
          link.background = false;
          _results1.push(this.layer.touchLink(link));
        } else {
          _results1.push(void 0);
        }
      }
      return _results1;
    }
  };

  Netchart_Layout.prototype.doRadialLayout = function(time, dt, topologyChanges, styleChanges, newNodes, timeout, reset, incremental) {
    var fadeTime, l, links, n, nodes, startNode, _i, _len;
    if (reset == null) {
      reset = false;
    }
    if (incremental == null) {
      incremental = true;
    }
    nodes = this.layer.nodes();
    links = this.layer.links();
    fadeTime = this.scene.settings.style.fadeTime;
    for (_i = 0, _len = nodes.length; _i < _len; _i++) {
      n = nodes[_i];
      n.locked = n.userLock || n.locks > 0;
      if (n.added) {
        n.visibility = (time - n.added) / fadeTime;
      } else if (n.removed) {
        n.visibility = 1 - (time - n.removed) / fadeTime;
      } else {
        n.visibility = 1;
      }
    }
    if (this.scene.lastFocusNode) {
      startNode = this.scene.lastFocusNode;
    } else {
      startNode = nodes[0];
    }
    if (startNode) {
      l = new RadialLayout();
      l.setParams(0, 0, this.settings.nodeSpacing, -Math.PI * 0.5, Math.PI * 1.5);
      l.layoutGraph(startNode);
    }
    return 0;
  };

  Netchart_Layout.prototype.doForceLayout = function(time, dt, topologyChanges, styleChanges, newNodes, timeout, reset, incremental) {
    var appearingNodes, aspect, degreeModifier, effectiveAspect, fadeTime, hasLockedNodes, hasOtherConnections, l, length, ml, mlid, multilinks, n, nodeSpacing, nodes, realLinks, s1, strength, visibility, _i, _j, _k, _l, _len, _len1, _len2, _len3, _ref;
    fadeTime = this.scene.settings.style.fadeTime;
    aspect = (this.scene.width + 1) / (this.scene.height + 1);
    if (!(aspect > 0)) {
      aspect = null;
    }
    effectiveAspect = this.scene.settings.layout.aspectRatio ? aspect : null;
    nodeSpacing = this.settings.nodeSpacing;
    degreeModifier = 1;
    nodes = this.layer.nodes();
    appearingNodes = false;
    hasLockedNodes = false;
    for (_i = 0, _len = nodes.length; _i < _len; _i++) {
      n = nodes[_i];
      n.locked = n.userLock || n.locks > 0;
      hasLockedNodes || (hasLockedNodes = n.locked);
      appearingNodes || (appearingNodes = n.added || n.removed);
      if (n.added) {
        n.visibility = 1 - 0.8 * (time - n.added) / fadeTime;
      } else if (n.removed) {
        n.visibility = 0.2 + 0.8 * (time - n.removed) / fadeTime;
      } else {
        n.visibility = 1;
      }
    }
    multilinks = {};
    realLinks = [];
    _ref = this.layer.links();
    for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
      l = _ref[_j];
      mlid = l.multiId;
      strength = l.targetStrength;
      length = l.targetLength;
      visibility = 1;
      if (l.removed || l.added) {
        hasOtherConnections = l.from.links.length > 1 && l.to.links.length > 1;
        if (hasOtherConnections || l.removed) {
          s1 = 0.2;
        } else {
          s1 = strength;
        }
        if (l.removed) {
          visibility = 1 - (time - l.removed) / fadeTime;
        }
        if (l.added) {
          visibility = (time - l.added) / fadeTime;
          length = 0.2 + (length - 0.2) * visibility;
        }
        strength = strength * visibility + s1 * (1 - visibility);
      }
      if (!multilinks.hasOwnProperty(mlid)) {
        ml = {
          from: l.from,
          to: l.to,
          strength: strength,
          length: length,
          visibility: visibility,
          direction: l.direction
        };
        multilinks[mlid] = ml;
        realLinks.push(ml);
      } else {
        ml = multilinks[mlid];
        ml.strength = Math.max(strength, ml.strength);
        ml.length = Math.max(length, ml.length);
        ml.visibility = Math.max(visibility, ml.visibility);
      }
    }
    this.springs.updateParams(nodeSpacing, degreeModifier, effectiveAspect);
    if (reset || Base_Helpers.hasProperties(newNodes)) {
      for (_k = 0, _len2 = nodes.length; _k < _len2; _k++) {
        n = nodes[_k];
        n.locked || (n.locked = !newNodes.hasOwnProperty(n.id));
      }
      this.springs.updateGraph(nodes, realLinks, topologyChanges);
      if (reset || this.scene.settings.layout.globalLayoutOnChanges) {
        this.springs.updateParams(nodeSpacing, degreeModifier, aspect);
        this.springs.globalLayout(nodes, timeout, reset && (!hasLockedNodes));
        this.springs.updateParams(nodeSpacing, degreeModifier, effectiveAspect);
      } else {
        this.springs.timedLayout(nodes, dt * 0.001);
      }
    }
    if (incremental || appearingNodes) {
      if (!incremental) {
        for (_l = 0, _len3 = nodes.length; _l < _len3; _l++) {
          n = nodes[_l];
          n.locked || (n.locked = !n.removed && !n.added);
        }
      }
      this.springs.updateGraph(nodes, realLinks, topologyChanges);
      this.springs.timedLayout(nodes, dt * 0.001);
    }
    return this.springs.stability;
  };

  return Netchart_Layout;

})(Base_ChartElement);
// Generated by CoffeeScript 1.8.0
var Netchart_Toolbar;

ToolbarItemNames["rearrange"] = function(chart, options) {
  return new Base_Bar_UserButton(chart, {
    label: chart.settings.localization.toolbar.rearrangeButton,
    cssClass: "DVSL-bar-btn-rearrange",
    title: chart.settings.localization.toolbar.rearrangeTitle,
    showLabels: options.showLabels,
    onClick: (function(_this) {
      return function() {
        return chart.resetLayout();
      };
    })(this)
  });
};

ToolbarItemNames["freeze"] = function(chart, options) {
  return new Base_Bar_ToggleButton(chart, {
    label: chart.settings.localization.toolbar.freezeButton,
    cssClass: "DVSL-bar-btn-lock-all",
    cssClassEnabled: "DVSL-bar-btn-lock-all-active",
    title: chart.settings.localization.toolbar.freezeTitle,
    titleActive: chart.settings.localization.toolbar.unfreezeTitle,
    showLabels: options.showLabels,
    getChartState: function() {
      return chart.scene.settings.layout.mode === "static";
    },
    onEnable: function() {
      chart.scene.settings.layout.mode = "static";
      return chart.events.notifySceneChanges({
        layout: true
      });
    },
    onDisable: function() {
      chart.scene.settings.layout.mode = "dynamic";
      return chart.events.notifySceneChanges({
        layout: true
      });
    }
  });
};

ToolbarItemNames["fit"] = function(chart, options) {
  return new Base_Bar_ToggleButton(chart, {
    label: chart.settings.localization.toolbar.fitButton,
    cssClass: "DVSL-bar-btn-fit",
    cssClassEnabled: "DVSL-bar-btn-fit-active",
    title: chart.settings.localization.toolbar.fitTitle,
    showLabels: options.showLabels,
    getChartState: function() {
      return chart.scene.autoZoomMode === "overview";
    },
    onEnable: function() {
      return chart.autoZoom.setZoom("overview");
    },
    onDisable: function() {
      return chart.autoZoom.setZoom("auto");
    }
  });
};

Netchart_Toolbar = (function() {
  function Netchart_Toolbar() {}

  Netchart_Toolbar.settings = {
    enabled: true,
    side: "bottom",
    align: "left",
    showLabels: false,
    align: "left",
    items: [
      {
        item: "fit"
      }, {
        item: "rearrange"
      }, {
        item: "freeze"
      }, {
        item: "back"
      }, {
        item: "fullscreen"
      }, {
        item: "zoomcontrol",
        side: "left",
        align: "bottom"
      }
    ]
  };

  return Netchart_Toolbar;

})();
// Generated by CoffeeScript 1.8.0
var Timechart_TimeAxis,
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

Timechart_TimeAxis = (function(_super) {
  __extends(Timechart_TimeAxis, _super);

  Timechart_TimeAxis.prototype.animationOrder = 610;

  Timechart_TimeAxis.prototype.paintOrder = 30;

  Timechart_TimeAxis.prototype.updateOrder = 1000;

  Timechart_TimeAxis.settings = {
    _doc: {
      doc_file: "time-chart/settings/timeAxis.markdown",
      type: "section"
    },
    enabled: true,
    enabled_doc: {
      doc: "Shows/hides time axis.",
      type: "bool"
    },
    vgrid: true,
    vgrid_doc: {
      doc: "Whether to show vertical grid.",
      type: "bool"
    },
    minUnitWidth: 12,
    minUnitWidth_doc: {
      doc: "Minimum width of a displayed value, in px . If the width is smaller than this, Time Chart will switch to bigger time units (e.g. from minutes to hours).",
      type: "float"
    },
    maxUnitWidth: 200,
    maxUnitWidth_doc: {
      doc: "Maximal width of displayed cart value, in px. If the width is bigger than this, Time Chart will use a smaller time unit (e.g. switch from minutes to seconds).",
      type: "float"
    },
    showHolidays: true,
    showHolidays_doc: {
      doc: "Whether to show holidays in day view.",
      type: "bool"
    },
    miniTimeRuler: true,
    unitSizePolicy: "auto",
    unitSizePolicy_doc: {
      doc: "Display unit switching policy.",
      type: "enum",
      values: {
        "auto": " same as 'max'.",
        "min": "uses smallest unit that has size >= minUnitWidth.",
        "max": "uses largest unit that has size <= maxUnitWidth."
      }
    },
    style: {
      _doc: {
        doc: "Time axis style",
        type: "object"
      },
      showMinorTimeBalloons: false,
      showMinorTimeBalloons_doc: {
        doc: "Whether to display minor time labels as balloons instead of ruler style.",
        type: "bool"
      },
      showMajorTimeBalloons: true,
      showMajorTimeBalloons_doc: {
        doc: "Whether to show balloons around major time labels.",
        type: "bool"
      },
      minorTimeBalloonStyle: {
        _doc: {
          doc: "Style for minor time labels balloons.",
          type: "object"
        },
        fillColor: "#FFF"
      },
      majorTimeBalloonStyle: {
        _doc: {
          doc: "Style for major time labels balloons.",
          type: "object"
        },
        fillColor: "AAA"
      },
      minorTimeLabel: {
        _doc: {
          doc: "Style for minor time labels.",
          type: "object",
          baseObject: Base_Label.styleSettings
        },
        fillColor: "#000000",
        font: "12px Arial"
      },
      majorTimeLabel: {
        _doc: {
          doc: "Style for major time labels.",
          type: "object",
          baseObject: Base_Label.styleSettings
        },
        fillColor: "#FFF",
        font: "11px Arial"
      },
      dateLighten: {
        _doc: {
          doc: "Tint for lighter blocks of altering shades in time axis.",
          type: "object"
        },
        fillColor: "rgba(255,255,255,0.2)"
      },
      dateHolidays: {
        fillColor: "rgba(230,230,230,0.2)"
      },
      minorTimeRuler1: {
        _doc: {
          doc: "Ruler lines are composed of two vertical lines one pixel apart. This setting sets style for the first line.",
          type: "object"
        },
        lineColor: "rgba(0,0,0,0.2)"
      },
      minorTimeRuler2: {
        _doc: {
          doc: "Ruler lines are composed of two vertical lines one pixel apart. This setting sets style for the second line.",
          type: "object"
        },
        lineColor: "rgba(255,255,255,0.1)"
      },
      vgrid: {
        _doc: {
          doc: "Chart vertical grid settings",
          type: "object"
        },
        lineColor: "rgba(0,0,0,0.1)"
      }
    }
  };

  "use strict";

  function Timechart_TimeAxis(chart) {
    this.chart = chart;
    this.computeSize = __bind(this.computeSize, this);
    this.scene = this.chart.scene;
    this.tt = new Timechart_TimeSetup(this.scene);
    this.options = this.scene.settings.timeAxis;
    this.context = null;
    this.tt = null;
    this.curSceneScale = 0;
    this.minorFormat = null;
    this.majorFormat = null;
    this.minorTimeUnit = null;
    this.majorTimeUnit = null;
    this.minorLabelHeight = null;
    this.majorLabelHeight = null;
    this.minorLabelWidths = null;
    this.minorLabelBallonWidths = null;
    this.majorLabelWidths = null;
    this.fullLabelWidths = null;
    this.multiYearWidth = null;
    this.majorSlices = null;
    this.minorSlices = null;
    this.panel = new Base_ChartPanel();
    this.panel.side = "bottom";
    this.panel.packingOrder = 100;
    this.panel.computeSize = this.computeSize;
  }

  Timechart_TimeAxis.prototype.computeSize = function(availableWidth, availableHeight, g, labelRenderer) {
    var height, unit, w, widestTime, _i, _j, _len, _len1, _ref, _ref1;
    if (!this.options.enabled) {
      this.scene.bottomAxisSize = 0;
      return [availableWidth, 0];
    }
    widestTime = moment(218342562955000).utc();
    g.save();
    Base_Graphics.textStyle(g, this.options.style.minorTimeLabel);
    this.minorLabelHeight = Base_Graphics.getTextHeight(g, this.options.style.minorTimeLabel.font) * 0.8;
    this.minorLabelWidths = {};
    this.minorLabelBallonWidths = {};
    _ref = Base_TimeStep.knownUnits;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      unit = _ref[_i];
      w = g.measureText(widestTime.format(this.scene.settings.localization.timeAxisDates.minorLabelTimeFormats[unit])).width;
      this.minorLabelWidths[unit] = w;
      this.minorLabelBallonWidths[unit] = w + this.minorLabelHeight;
    }
    Base_Graphics.textStyle(g, this.options.style.majorTimeLabel);
    this.majorLabelHeight = Base_Graphics.getTextHeight(g, this.options.style.majorTimeLabel.font) * 0.8;
    this.majorLabelWidths = {};
    this.fullLabelWidths = {};
    _ref1 = Base_TimeStep.knownUnits;
    for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
      unit = _ref1[_j];
      this.majorLabelWidths[unit] = g.measureText(widestTime.format(this.scene.settings.localization.timeAxisDates.majorLabelTimeFormats[unit])).width + this.majorLabelHeight;
      this.fullLabelWidths[unit] = g.measureText(widestTime.format(this.scene.settings.localization.timeAxisDates.majorLabelFullTimeFormats[unit])).width + this.majorLabelHeight;
    }
    this.multiYearWidth = g.measureText("8888 - 8888").width + this.majorLabelHeight;
    g.restore();
    height = Math.round(Math.min((this.minorLabelHeight + this.majorLabelHeight) * 2.3913043, availableHeight));
    this.scene.bottomAxisSize = height;
    return [availableWidth, height];
  };

  Timechart_TimeAxis.prototype.onSceneChange = function(event) {
    if (event.changes.settings && event.changes.settingsChanges.timeAxis) {
      return event.changes.bounds = true;
    }
  };

  Timechart_TimeAxis.prototype.getPanels = function() {
    return this.panel;
  };

  Timechart_TimeAxis.prototype.multiples = {
    s: [1, 2, 5, 15, 30],
    m: [1, 2, 5, 15, 30],
    h: [1, 3, 6, 12, 24],
    d: [1, 2, 5, 10],
    w: [1, 5, 10, 20],
    M: [1, 3, 6],
    y: [1, 10, 100, 1000]
  };


  /*
    Called whenever time scale cahanges
   */

  Timechart_TimeAxis.prototype.getMajorLabelWidth = function(step, minorStep) {
    if (step.unit === "y" && step.count > 1) {
      return this.multiYearWidth;
    } else if (minorStep) {
      return this.majorLabelWidths[step.unit];
    } else {
      return this.fullLabelWidths[step.unit];
    }
  };

  Timechart_TimeAxis.prototype.computeLabels = function(displayUnit) {
    var baseUnit, chartDt, m, majorUnit, minorUnit, nextUnit, s, _i, _len, _ref;
    s = new Timechart_TimeSetup(this.scene.settings);
    chartDt = this.scene.timeEnd - this.scene.timeStart;
    nextUnit = s.toBiggerDisplayPeriod(displayUnit);
    if (nextUnit != null) {
      baseUnit = new Base_TimeStep("s", 1);
      majorUnit = nextUnit.isSmaller(baseUnit) ? baseUnit : nextUnit;
      minorUnit = this.computeMinorUnit(majorUnit);
      nextUnit = s.toBiggerDisplayPeriod(majorUnit);
      while (nextUnit && (nextUnit.approxTime() <= chartDt * 0.5 || majorUnit.approxTime() < this.scene.dxToDtime(this.getMajorLabelWidth(majorUnit, minorUnit)))) {
        majorUnit = nextUnit;
        minorUnit = this.computeMinorUnit(majorUnit);
        nextUnit = s.toBiggerDisplayPeriod(nextUnit);
      }
    }
    if (nextUnit == null) {
      majorUnit = displayUnit.unit === "y" ? displayUnit : new Base_TimeStep("y", 1);
      _ref = this.multiples["y"];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        m = _ref[_i];
        majorUnit = new Base_TimeStep("y", m);
        minorUnit = this.computeMinorUnit(majorUnit);
        if (majorUnit.approxTime() > this.scene.dxToDtime(this.getMajorLabelWidth(majorUnit, minorUnit))) {
          break;
        }
      }
    }
    return [minorUnit, majorUnit];
  };

  Timechart_TimeAxis.prototype.computeMinorUnit = function(majorUnit) {
    var m, minorUnit, unit, unit2, unitDt, unitSpacing, _i, _len, _ref;
    unit = this.scene.displayUnit.clone();
    unit2 = new Base_TimeStep(Base_TimeStep.toSmallerUnit[majorUnit.unit], 1);
    if (unit2.unit && unit2.isBigger(unit)) {
      unit = unit2;
    }
    unitDt = unit.approxTime();
    minorUnit = null;
    unitSpacing = this.scene.dxToDtime(this.minorLabelWidths[unit.unit]) * 1.5;
    _ref = this.multiples[unit.unit];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      m = _ref[_i];
      if (m < unit.count) {
        m = unit.count;
      }
      unit.count = m;
      unitDt = unit.approxTime();
      if (unitSpacing <= unitDt) {
        minorUnit = unit;
        break;
      }
    }
    if (minorUnit && minorUnit.isEqual(majorUnit)) {
      minorUnit = null;
    }
    return minorUnit;
  };

  Timechart_TimeAxis.prototype.doAnimations = function(event) {
    var majorStep, minorStep, sceneScale, _ref;
    if (!((this.scene.displayUnit != null) && this.options.enabled && (this.scene.timeStart < this.scene.timeEnd))) {
      return;
    }
    sceneScale = this.scene.getScale();
    if (!(Math.abs(1 - this.curSceneScale / sceneScale) < 0.001)) {
      this.curSceneScale = sceneScale;
      _ref = this.computeLabels(this.scene.displayUnit), minorStep = _ref[0], majorStep = _ref[1];
      if (minorStep != null) {
        this.minorFormat = this.scene.settings.localization.timeAxisDates.minorLabelTimeFormats[minorStep.unit];
        this.majorFormat = this.scene.settings.localization.timeAxisDates.majorLabelTimeFormats[majorStep.unit];
      } else {
        this.minorFormat = null;
        this.majorFormat = this.scene.settings.localization.timeAxisDates.majorLabelFullTimeFormats[majorStep.unit];
      }
      this.minorTimeUnit = minorStep;
      this.majorTimeUnit = majorStep;
      if (this.majorSlices === null || majorStep.approxTime() !== this.majorSlices.step.approxTime()) {
        this.majorSlices = new Timechart_TimeSlicer(this.scene, majorStep);
      }
      if ((minorStep != null) && (this.minorSlices === null || minorStep.approxTime() !== this.minorSlices.step.approxTime())) {
        this.minorSlices = new Timechart_TimeSlicer(this.scene, minorStep, [], null, null, false);
      } else if (minorStep === null) {
        this.minorSlices = null;
      }
    }
    this.majorSlices.update();
    if (this.minorSlices) {
      this.minorSlices.update();
    }
    this.scene.minorTimeFormat = this.minorFormat;
    this.scene.minorTimeUnit = this.minorTimeUnit;
    this.scene.majorTimeFormat = this.majorFormat;
    return this.scene.majorTimeUnit = this.majorTimeUnit;
  };

  Timechart_TimeAxis.prototype.paintScene = function(event) {
    var align, barSlices, counter, dayInc, dayNo, fiMajor, fromIndex, g, gr, height, height0, holidayWeekdays, i, iMajor, isEven, isMultiYear, labelRenderer, lxtext, ly0, ly1, lytext, maI, maI0, maX, miI, miI0, miX, num, t, t1, text, textWidth, textX, textY, tiMajor, times, toIndex, tradd, trmul, tx0, tx1, ty0, ty1, value, x, x0, x1, xMajor, xa, xb, xes, xinc, y0, y00, y1, yMajor, _i, _j, _k, _l, _m, _n, _o, _p, _q, _r, _ref, _ref1, _ref10, _ref11, _ref12, _ref13, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7, _ref8, _ref9;
    if (!((this.scene.displayUnit != null) && this.options.enabled && (this.scene.timeStart < this.scene.timeEnd))) {
      return;
    }
    g = event.context;
    labelRenderer = event.labelRenderer;
    x0 = this.scene.x0;
    x1 = x0 + this.scene.width;
    y0 = this.panel.top + 1;
    y1 = this.panel.bottom;
    height = y1 - y0;
    y00 = this.scene.y0;
    height0 = this.scene.height;
    yMajor = y1 - this.majorLabelHeight * 1.8;
    Base_Graphics.pushClip(g, x0, y00, this.scene.width, height + height0);
    xes = this.majorSlices.xes;
    times = this.majorSlices.times;
    fromIndex = this.majorSlices.fromIndex;
    toIndex = this.majorSlices.toIndex;
    num = this.majorSlices.step.numberOfUnits(0, times[fromIndex]);
    isEven = (num | 0) % 2 === 0;
    g.beginPath();
    for (i = _i = fromIndex, _ref = toIndex - 2; _i <= _ref; i = _i += 1) {
      isEven = !isEven;
      if (isEven) {
        continue;
      }
      xa = (Math.max(xes[i], x0) | 0) + 1;
      xb = Math.min(xes[i + 1], x1) | 0;
      g.rect(xa, y0, xb - xa, height);
    }
    Base_Graphics.fill(g, this.scene.settings.timeAxis.style.dateLighten);
    if (this.options.showHolidays && this.minorSlices && (this.minorSlices.step.unit === "d" || this.minorSlices.step.unit === "h")) {
      _ref1 = this.scene.timeToXCoefs(), tradd = _ref1[0], trmul = _ref1[1];
      dayInc = 60 * 60 * 24 * 1000;
      t = this.scene.timeStart;
      t = Math.round(t - (t % dayInc));
      dayNo = moment(t).utc().isoWeekday();
      holidayWeekdays = this.scene.settings.localization.holidayWeekdays;
      g.beginPath();
      xa = t * trmul + tradd;
      while (xa <= x1) {
        xb = xa + trmul * dayInc;
        if (Base_Helpers.arrayContains(holidayWeekdays, dayNo)) {
          g.rect(xa, y00, xb - xa, Math.min(5, height) + height0);
        }
        dayNo = (dayNo % 7) + 1;
        xa = xb;
      }
      Base_Graphics.fill(g, this.scene.settings.timeAxis.style.dateHolidays);
    }
    if (this.options.vgrid) {
      gr = Base_Graphics.beginStrokeAndFill(g, this.options.style.vgrid);
      for (i = _j = _ref2 = fromIndex + 1, _ref3 = toIndex - 2; _j <= _ref3; i = _j += 1) {
        x = (xes[i] | 0) + 0.5;
        if (x >= x1) {
          break;
        }
        gr.moveTo(x, y00);
        gr.lineTo(x, y1);
      }
      Base_Graphics.endStrokeAndFill(g, gr, this.options.style.vgrid);
    }
    isMultiYear = this.majorSlices.step.unit === "y" && this.majorSlices.step.count > 1;
    textWidth = this.getMajorLabelWidth(this.majorSlices.step, this.minorFormat);
    if (!this.minorSlices || (this.majorSlices.step.unit !== this.minorSlices.step.unit)) {
      if (this.scene.settings.timeAxis.style.showMajorTimeBalloons) {
        g.beginPath();
        for (i = _k = fromIndex, _ref4 = toIndex - 2; _k <= _ref4; i = _k += 1) {
          tx0 = xes[i];
          tx1 = xes[i + 1];
          if (tx0 >= x1 || tx1 <= x0) {
            continue;
          }
          t = times[i];
          textX = (tx0 + tx1) / 2;
          if (tx0 < x0) {
            tx0 = x0;
            textX = Math.min((tx0 + tx1) / 2, tx1 - textWidth);
          }
          if (tx1 > x1) {
            tx1 = x1;
            textX = Math.max((tx0 + tx1) / 2, tx0 + textWidth);
          }
          Base_Graphics.strokeBalloon2(g, textX, yMajor + 1, textWidth, this.majorLabelHeight);
        }
        Base_Graphics.paint(g, this.scene.settings.timeAxis.style.majorTimeBalloonStyle);
      }
      for (i = _l = fromIndex, _ref5 = toIndex - 2; _l <= _ref5; i = _l += 1) {
        tx0 = xes[i];
        tx1 = xes[i + 1];
        if (tx0 >= x1 || tx1 <= x0) {
          continue;
        }
        t = times[i];
        if (isMultiYear) {
          t1 = times[i + 1];
          text = moment(t).utc().format(this.majorFormat) + " - " + moment(t1).utc().format(this.majorFormat);
        } else {
          text = moment(t).utc().format(this.majorFormat);
        }
        textX = (tx0 + tx1) / 2;
        if (tx0 < x0) {
          tx0 = x0;
          textX = Math.min((tx0 + tx1) / 2, tx1 - textWidth);
        }
        if (tx1 > x1) {
          tx1 = x1;
          textX = Math.max((tx0 + tx1) / 2, tx0 + textWidth);
        }
        value = new Base_Label();
        value.text = text;
        value.textStyle = this.scene.settings.timeAxis.style.majorTimeLabel;
        value.aspectRatio = 0;
        labelRenderer.paintWithStyle(g, textX, yMajor, 1, value, value);
      }
    }
    if (this.minorSlices) {
      times = this.minorSlices.times;
      xes = this.minorSlices.xes;
      fromIndex = this.minorSlices.fromIndex;
      toIndex = this.minorSlices.toIndex;
      textWidth = this.minorLabelWidths[this.minorSlices.step.unit];
      lytext = y0 + (this.minorLabelHeight * 0.4) | 0;
      ly0 = y0 - 1;
      ly1 = lytext + (this.minorLabelHeight * 1.6) | 0;
      if (this.scene.settings.timeAxis.style.showMinorTimeBalloons) {
        g.beginPath();
        textY = null;
        for (i = _m = fromIndex, _ref6 = toIndex - 1; _m <= _ref6; i = _m += 1) {
          x = xes[i];
          textY = Base_Graphics.strokeBalloon(g, x, y0 - 5, textWidth, this.minorLabelHeight);
        }
        Base_Graphics.paint(g, this.scene.settings.timeAxis.style.minorTimeBalloonStyle);
      } else {
        fiMajor = this.majorSlices.fromIndex;
        tiMajor = this.majorSlices.toIndex;
        xMajor = this.majorSlices.xes;
        g.beginPath();
        iMajor = fiMajor;
        for (i = _n = fromIndex, _ref7 = toIndex - 1; _n <= _ref7; i = _n += 1) {
          x = xes[i];
          while (x > xMajor[iMajor]) {
            iMajor += 1;
          }
          if (xMajor[iMajor] === x) {
            continue;
          }
          if (x >= x1) {
            break;
          }
          x = (x | 0) - 0.5;
          g.moveTo(x, ly0);
          g.lineTo(x, ly1);
        }
        Base_Graphics.stroke(g, this.scene.settings.timeAxis.style.minorTimeRuler1);
        g.beginPath();
        iMajor = fiMajor;
        for (i = _o = fromIndex, _ref8 = toIndex - 1; _o <= _ref8; i = _o += 1) {
          x = xes[i];
          while (x > xMajor[iMajor]) {
            iMajor += 1;
          }
          if (xMajor[iMajor] === x) {
            continue;
          }
          if (x >= x1) {
            break;
          }
          x = (x | 0) + 0.5;
          g.moveTo(x, ly0);
          g.lineTo(x, ly1);
        }
        Base_Graphics.stroke(g, this.scene.settings.timeAxis.style.minorTimeRuler2);
      }
      align = this.scene.settings.timeAxis.style.showMinorTimeBalloons ? "center" : "left";
      xinc = this.scene.settings.timeAxis.style.showMinorTimeBalloons ? 0 : 3;
      for (i = _p = fromIndex, _ref9 = toIndex - 1; _p <= _ref9; i = _p += 1) {
        x = xes[i];
        t = times[i];
        text = moment(t).utc().format(this.minorFormat);
        value = new Base_Label();
        value.text = text;
        value.textStyle = this.scene.settings.timeAxis.style.minorTimeLabel;
        value.align = align;
        value.baseLine = "top";
        labelRenderer.measure(g, value, value);
        lxtext = x + xinc + value.hwidth;
        labelRenderer.paintWithStyle(g, lxtext, lytext + value.hheight, 1, value, value);
      }
    }
    barSlices = null;
    if (this.scene.settings.timeAxis.style.miniTimeRuler && (barSlices != null) && barSlices.xes[barSlices.fromIndex + 1] - barSlices.xes[barSlices.fromIndex] > 2) {
      ty0 = y0 - 1;
      ty1 = y0 + 3;
      xes = barSlices.xes;
      maI0 = this.majorSlices.fromIndex;
      miI0 = this.minorSlices != null ? this.minorSlices.fromIndex : maI0;
      maX = this.majorSlices.xes;
      miX = this.minorSlices != null ? this.minorSlices.xes : maX;
      g.beginPath();
      maI = maI0;
      miI = miI0;
      counter = 0;
      for (i = _q = _ref10 = barSlices.fromIndex, _ref11 = barSlices.toIndex - 2; _ref10 <= _ref11 ? _q <= _ref11 : _q >= _ref11; i = _ref10 <= _ref11 ? ++_q : --_q) {
        x = xes[i];
        while (x > maX[maI]) {
          maI += 1;
        }
        if (maX[maI] === x) {
          continue;
        }
        while (x > miX[miI]) {
          miI += 1;
        }
        if (miX[miI] === x) {
          continue;
        }
        if (x >= x1) {
          break;
        }
        x = (x | 0) - 0.5;
        g.moveTo(x, ty0);
        g.lineTo(x, ty1);
        counter++;
      }
      if (counter) {
        Base_Graphics.stroke(g, this.scene.settings.timeAxis.style.minorTimeRuler1);
      }
      counter = 0;
      g.beginPath();
      maI = maI0;
      miI = miI0;
      for (i = _r = _ref12 = barSlices.fromIndex, _ref13 = barSlices.toIndex - 2; _ref12 <= _ref13 ? _r <= _ref13 : _r >= _ref13; i = _ref12 <= _ref13 ? ++_r : --_r) {
        x = xes[i];
        while (x > maX[maI]) {
          maI += 1;
        }
        if (maX[maI] === x) {
          continue;
        }
        while (x > miX[miI]) {
          miI += 1;
        }
        if (miX[miI] === x) {
          continue;
        }
        if (x >= x1) {
          break;
        }
        x = (x | 0) + 0.5;
        g.moveTo(x, ty0);
        g.lineTo(x, ty1);
        counter++;
      }
      if (counter) {
        Base_Graphics.stroke(g, this.scene.settings.timeAxis.style.minorTimeRuler2);
      }
    }
    Base_Graphics.popClip(g);
  };

  return Timechart_TimeAxis;

})(Base_ChartElement);
// Generated by CoffeeScript 1.8.0
var Timechart_InfoPopup,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

Timechart_InfoPopup = (function(_super) {
  __extends(Timechart_InfoPopup, _super);

  Timechart_InfoPopup.prototype.animationOrder = 700;

  Timechart_InfoPopup.prototype.paintOrder = 25;

  Timechart_InfoPopup.prototype.updateOrder = 1100;

  function Timechart_InfoPopup(chart) {
    Timechart_InfoPopup.__super__.constructor.call(this, chart);
  }

  Timechart_InfoPopup.prototype.doAnimations = function(event) {
    var t0, t1;
    if (this.chart.selection.isSelecting && this.scene.selectionStart) {
      t0 = this.scene.selectionStart;
      t1 = this.scene.selectionEnd;
      return this.showInfoPopup(t0, t1, null, this.buildContent(t0, t1, null), event);
    }
  };

  Timechart_InfoPopup.prototype.getPopupAreaMouseMoved = function(x, y) {
    var t0, t1;
    if (!(this.scene.displayUnit && this.scene.xyInChartOrBottom(x, y))) {
      return null;
    }
    t0 = this.scene.hoverFrom;
    t1 = this.scene.hoverTo;
    return [t0, t1];
  };

  Timechart_InfoPopup.prototype.buildHeader = function(t0, t1) {
    var biggerUnit, count, date, dateHtml, from, t0m, t1m, to, top, unit, unitName;
    unit = this.scene.displayUnit;
    count = Math.ceil(unit.numberOfUnits(t0, t1));
    unitName = count * unit.count === 1 ? this.scene.settings.localization.timeUnitsNames[unit.unit] : this.scene.settings.localization.timeUnitsNamesPlural[unit.unit];
    if (count === 1) {
      t0m = moment(t0).utc();
      date = t0m.format(this.scene.settings.localization.infoDates.fullTimeFormats[unit.unit]);
      dateHtml = "" + date;
    } else {
      if (unit.unit === "d" || unit.unit === "M" || unit.unit === "y" || unit.unit === "ms") {
        t1 -= 1;
      }
      t0m = moment(t0).utc();
      t1m = moment(t1).utc();
      biggerUnit = unit.getBigger() || unit;
      if (unit.unit !== "y" && biggerUnit.roundTimeDown(t0) === biggerUnit.roundTimeDown(t1)) {
        top = t0m.format(this.scene.settings.localization.infoDates.majorTimeFormats[unit.unit]);
        from = t0m.format(this.scene.settings.localization.infoDates.minorTimeFormats[unit.unit]);
        to = t1m.format(this.scene.settings.localization.infoDates.minorTimeFormats[unit.unit]);
        dateHtml = "" + from + " - " + to + " " + top;
      } else {
        from = t0m.format(this.scene.settings.localization.infoDates.fullTimeFormats[unit.unit]);
        to = t1m.format(this.scene.settings.localization.infoDates.fullTimeFormats[unit.unit]);
        dateHtml = "" + from + " - " + to;
      }
    }
    return "<em></em><strong>" + dateHtml + ("<small>(" + (count * unit.count) + " " + unitName + ")</small></strong>");
  };

  return Timechart_InfoPopup;

})(Linearchart_InfoPopup);
// Generated by CoffeeScript 1.8.0
var Timechart_DataWarehouse;

Timechart_DataWarehouse = (function() {
  function Timechart_DataWarehouse(chart) {
    this.chart = chart;
    this.scene = this.chart.scene;
    this.requests = {};
    this.results = {};
    this.dataSlicesCache = {};
    this.nextRequestId = 0;
    this.hasNewRequests = false;
  }

  Timechart_DataWarehouse.prototype.registerDataProcessingRequest = function(params) {
    this.requests[this.nextRequestId] = params;
    this.results[this.nextRequestId] = {
      leadIn: null,
      leadOut: null,
      times: [],
      xes: [],
      values: [],
      fromIndex: 0,
      toIndex: 0,
      data: [],
      from: 0,
      to: 0,
      slicer: null,
      dataExistsFrom: null,
      dataExistsTo: null
    };
    this.hasNewRequests = true;
    return this.nextRequestId++;
  };

  Timechart_DataWarehouse.prototype.removeDataProcessingRequest = function(id) {
    delete this.requests[id];
    return delete this.results[id];
  };

  Timechart_DataWarehouse.prototype.getData = function(requestId) {
    return this.results[requestId];
  };

  Timechart_DataWarehouse.prototype.clear = function() {
    this.requests = {};
    return this.results = {};
  };

  Timechart_DataWarehouse.prototype.process = function(event) {
    var changes, dataUpdate, forceDataUpdate, i, request, result, _ref, _ref1;
    changes = event.changes;
    if (!(changes.time || changes.data || changes.displayUnit || changes.bounds || changes.settings || this.hasNewRequests)) {
      return;
    }
    if (this.scene.timeStart >= this.scene.timeEnd) {
      _ref = this.requests;
      for (i in _ref) {
        request = _ref[i];
        result = this.results[i];
        result.dataExistsFrom = null;
        result.dataExistsTo = null;
      }
      return;
    }
    this.hasNewRequests = false;
    this.loading = false;
    this.hasSomeData = false;
    forceDataUpdate = changes.data || changes.time;
    _ref1 = this.requests;
    for (i in _ref1) {
      request = _ref1[i];
      result = this.results[i];
      dataUpdate = this.updateData(forceDataUpdate, request, result);
      this.updateSlices(dataUpdate, i, request, result);
    }
    this.scene.loading = this.loading;
    if (this.loading) {
      this.scene.setMessage("noData", this.scene.settings.localization.loadingLabel, 10);
    } else if (!this.hasSomeData) {
      this.scene.setMessage("noData", this.scene.settings.localization.noDataLabel, 999);
    } else {
      this.scene.setMessage("noData", null);
    }
  };

  Timechart_DataWarehouse.prototype.exportData = function(from, to, displayUnit, seriesArray) {
    var aggrValues, data, request, result, ser, series, slicer, source, times, _i, _len;
    slicer = new Timechart_TimeSlicer(this.scene, displayUnit, [], from, to, true, 0);
    times = slicer.times;
    series = [];
    for (_i = 0, _len = seriesArray.length; _i < _len; _i++) {
      ser = seriesArray[_i];
      request = ser.data;
      result = {};
      source = this.chart.getData(request.source);
      data = source.getDataForRange(from, to, displayUnit, null);
      aggrValues = new Array(times.length - 1);
      this.fillValues(data.values, slicer.times, aggrValues, slicer.fromIndex, slicer.toIndex, request, displayUnit);
      series.push(aggrValues);
    }
    return {
      timestamps: slicer.times.slice(slicer.fromIndex, slicer.toIndex - 1),
      values: series
    };
  };

  Timechart_DataWarehouse.prototype.updateData = function(dataUpdate, request, result) {
    var data, dataSource, displayUnit, dt, from, to;
    dataSource = this.chart.getData(request.source);
    displayUnit = this.getUnitToUse(request);
    dt = (this.scene.timeEnd - this.scene.timeStart) * dataSource.dataSettings.prefetchRatio;
    if (dataUpdate || (!result.from && this.scene.timeStart) || (!result.to && this.scene.timeEnd) || result.from >= result.to || this.scene.timeStart - dt < result.from || this.scene.timeEnd + dt > result.to || ((result.dataExistsFrom != null) && result.dataExistsFrom > this.scene.timeEnd) || ((result.dataExistsTo != null) && result.dataExistsTo < this.scene.timeStart)) {
      dataUpdate = true;
      from = this.scene.timeStart - dt * 2;
      to = this.scene.timeEnd + dt * 2;
      data = dataSource.getDataForRange(from, to, displayUnit, (function(_this) {
        return function() {
          return _this._newDataArrived();
        };
      })(this));
      if (!dataSource.noData) {
        this.hasSomeData = true;
      }
      if (data.from > this.scene.timeEnd || data.to < this.scene.timeStart) {
        result.data = [];
        result.from = 0;
        result.to = 0;
        result.dataExistsFrom = null;
        result.datasExistsTo = null;
        this.loading || (this.loading = data.loading);
      } else {
        this.loading || (this.loading = data.loading && (data.from > this.scene.timeStart || data.to < this.scene.timeEnd));
        result.data = data.values;
        result.from = from;
        result.to = to;
        result.dataExistsFrom = data.from;
        result.dataExistsTo = data.to;
      }
    }
    return dataUpdate;
  };

  Timechart_DataWarehouse.prototype.updateSlices = function(dataUpdate, id, request, result) {
    var data, dataFunction, dataIndex, displayUnit, i, slice, sliceNewAfter, sliceNewBefore, sliceOffset, times, values, _ref;
    displayUnit = this.getUnitToUse(request);
    dataIndex = request.index;
    dataFunction = request.valueFunction;
    data = result.data;
    slice = result.slicer = this.getSlice(id, request, displayUnit);
    _ref = slice.update(this.scene.timeStart, this.scene.timeEnd), sliceOffset = _ref[0], sliceNewBefore = _ref[1], sliceNewAfter = _ref[2];
    times = result.times = slice.times;
    result.xes = slice.xes;
    values = result.values = slice.values;
    data = result.data;
    result.fromIndex = slice.fromIndex;
    result.toIndex = slice.toIndex;
    if (!data) {
      result.values = (function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = times.length; _i < _len; _i++) {
          i = times[_i];
          _results.push(null);
        }
        return _results;
      })();
      result.leadIn = null;
      return result.leadOut = null;
    } else {
      if (data.length > 0 && !dataFunction && dataIndex >= data[0].length) {
        return this.chart.error("No data for this DataIndex: " + dataIndex + ", only " + (data[0].length - 1) + " values present");
      } else {
        if (dataUpdate) {
          this.fillValues(data, times, values, slice.fromIndex, slice.toIndex, request, displayUnit);
        } else {
          this.fillValues(data, times, values, slice.fromIndex, sliceNewBefore + 1, request, displayUnit);
          this.fillValues(data, times, values, sliceNewAfter - 1, slice.toIndex, request, displayUnit);
        }
        return this.setLeads(request, result, displayUnit);
      }
    }
  };

  Timechart_DataWarehouse.prototype.getSlice = function(id, request, displayUnit) {
    var cacheIndex, s;
    cacheIndex = "" + id + "-" + (displayUnit.toString());
    if (this.dataSlicesCache.hasOwnProperty(cacheIndex)) {
      s = this.dataSlicesCache[cacheIndex];
    } else {
      s = this.dataSlicesCache[cacheIndex] = new Timechart_TimeSlicer(this.scene, displayUnit, ["values"]);
    }
    return s;
  };

  Timechart_DataWarehouse.prototype.getUnitToUse = function(request) {
    return this.scene.displayUnit;
  };

  Timechart_DataWarehouse.prototype.setLeads = function(request, result, displayUnit) {
    var data, dataFunction, dataIndex, dataPos, fromIndex, leadIn, leadOut, np, t, t0, t1, time, times, toIndex, v, values, x, x0, x1, _ref, _ref1;
    np = request.noDataPolicy;
    dataIndex = request.index;
    dataFunction = request.valueFunction;
    data = result.data;
    values = result.values;
    times = result.times;
    leadIn = null;
    leadOut = null;
    if (np === "join" && data) {
      fromIndex = result.fromIndex;
      if (values[fromIndex] === null) {
        dataPos = Timechart_Data.binSearch(data, times[fromIndex]);
        dataPos = Timechart_Data.linSearchDown(data, dataPos, dataIndex, dataFunction);
        if (dataPos !== -1) {
          time = data[dataPos][0];
          _ref = result.slicer.makeMiniSlice(time), t0 = _ref[0], x0 = _ref[1], t1 = _ref[2], x1 = _ref[3];
          t = [t0, t1];
          x = [x0, x1];
          v = [null, null];
          this.fillValues(data, t, v, 0, 2, request, displayUnit);
          leadIn = {
            times: t,
            xes: x,
            values: v,
            fromIndex: 0,
            toIndex: 2
          };
        }
      }
      toIndex = result.toIndex;
      if (values[toIndex - 2] === null) {
        dataPos = Timechart_Data.binSearch(data, times[toIndex - 1]);
        dataPos = Timechart_Data.linSearchUp(data, dataPos, dataIndex, dataFunction);
        if (dataPos !== -1) {
          time = data[dataPos][0];
          _ref1 = result.slicer.makeMiniSlice(time), t0 = _ref1[0], x0 = _ref1[1], t1 = _ref1[2], x1 = _ref1[3];
          t = [t0, t1];
          x = [x0, x1];
          v = [null, null];
          this.fillValues(data, t, v, 0, 2, request, displayUnit);
          leadOut = {
            times: t,
            xes: x,
            values: v,
            fromIndex: 0,
            toIndex: 2
          };
        }
      }
    }
    result.leadIn = leadIn;
    return result.leadOut = leadOut;
  };

  Timechart_DataWarehouse.prototype.fillValues = function(data, times, values, timesI0, timesI1, request, displayUnit) {
    var agr, dataFunction, dataIndex, i, postAggregationFunction, _i, _ref;
    agr = request.aggregation;
    dataIndex = request.index;
    dataFunction = request.valueFunction;
    postAggregationFunction = request.aggregatedValueFunction;
    if (timesI0 + 1 >= timesI1) {
      return;
    }
    if (agr === "sum") {
      this.fillValueSum(data, times, values, timesI0, timesI1, dataIndex, dataFunction);
    } else if (agr === "min") {
      this.fillValueMin(data, times, values, timesI0, timesI1, dataIndex, dataFunction);
    } else if (agr === "max") {
      this.fillValueMax(data, times, values, timesI0, timesI1, dataIndex, dataFunction);
    } else if (agr === "avg") {
      this.fillValueAvg(data, times, values, timesI0, timesI1, dataIndex, dataFunction);
    } else if (agr === "first") {
      this.fillValueFirst(data, times, values, timesI0, timesI1, dataIndex, dataFunction);
    } else if (agr === "last") {
      this.fillValueLast(data, times, values, timesI0, timesI1, dataIndex, dataFunction);
    } else {
      this.chart.error("Unrecognized aggregation function: " + agr);
    }
    if (postAggregationFunction) {
      for (i = _i = timesI0, _ref = timesI1 - 2; _i <= _ref; i = _i += 1) {
        values[i] = postAggregationFunction(values[i], times[i], displayUnit);
      }
    }
  };

  Timechart_DataWarehouse.prototype.fillValueSum = function(data, times, values, timesI0, timesI1, dataIndex, dataFunction) {
    var acc, count, dataLen, fromIndex, i, toTime, value, _i, _ref;
    dataLen = data.length;
    fromIndex = Timechart_Data.binSearch(data, times[timesI0]);
    for (i = _i = timesI0, _ref = timesI1 - 2; _i <= _ref; i = _i += 1) {
      toTime = times[i + 1];
      acc = 0;
      count = 0;
      while (fromIndex < dataLen && data[fromIndex][0] < toTime) {
        if (dataFunction) {
          value = dataFunction(data[fromIndex]);
        } else {
          value = data[fromIndex][dataIndex];
        }
        fromIndex += 1;
        if (value != null) {
          acc += value;
          count += 1;
        }
      }
      if (count > 0) {
        values[i] = acc;
      } else {
        values[i] = null;
      }
    }
  };

  Timechart_DataWarehouse.prototype.fillValueMin = function(data, times, values, timesI0, timesI1, dataIndex, dataFunction) {
    var acc, count, dataLen, fromIndex, i, toTime, value, _i, _ref;
    dataLen = data.length;
    fromIndex = Timechart_Data.binSearch(data, times[timesI0]);
    for (i = _i = timesI0, _ref = timesI1 - 2; _i <= _ref; i = _i += 1) {
      toTime = times[i + 1];
      acc = Infinity;
      count = 0;
      while (fromIndex < dataLen && data[fromIndex][0] < toTime) {
        if (dataFunction) {
          value = dataFunction(data[fromIndex]);
        } else {
          value = data[fromIndex][dataIndex];
        }
        fromIndex += 1;
        if (value != null) {
          acc = Math.min(acc, value);
          count += 1;
        }
      }
      if (count > 0) {
        values[i] = acc;
      } else {
        values[i] = null;
      }
    }
  };

  Timechart_DataWarehouse.prototype.fillValueMax = function(data, times, values, timesI0, timesI1, dataIndex, dataFunction) {
    var acc, count, dataLen, fromIndex, i, toTime, value, _i, _ref;
    dataLen = data.length;
    fromIndex = Timechart_Data.binSearch(data, times[timesI0]);
    for (i = _i = timesI0, _ref = timesI1 - 2; _i <= _ref; i = _i += 1) {
      toTime = times[i + 1];
      acc = -Infinity;
      count = 0;
      while (fromIndex < dataLen && data[fromIndex][0] < toTime) {
        if (dataFunction) {
          value = dataFunction(data[fromIndex]);
        } else {
          value = data[fromIndex][dataIndex];
        }
        fromIndex += 1;
        if (value != null) {
          count += 1;
          acc = Math.max(acc, value);
        }
      }
      if (count > 0) {
        values[i] = acc;
      } else {
        values[i] = null;
      }
    }
  };

  Timechart_DataWarehouse.prototype.fillValueAvg = function(data, times, values, timesI0, timesI1, dataIndex, dataFunction) {
    var acc, count, dataLen, fromIndex, i, toTime, value, _i, _ref;
    dataLen = data.length;
    fromIndex = Timechart_Data.binSearch(data, times[timesI0]);
    for (i = _i = timesI0, _ref = timesI1 - 2; _i <= _ref; i = _i += 1) {
      toTime = times[i + 1];
      acc = 0;
      count = 0;
      while (fromIndex < dataLen && data[fromIndex][0] < toTime) {
        if (dataFunction) {
          value = dataFunction(data[fromIndex]);
        } else {
          value = data[fromIndex][dataIndex];
        }
        fromIndex += 1;
        if (value != null) {
          acc += value;
          count += 1;
        }
      }
      if (count > 0) {
        values[i] = acc / count;
      } else {
        values[i] = null;
      }
    }
  };

  Timechart_DataWarehouse.prototype.fillValueFirst = function(data, times, values, timesI0, timesI1, dataIndex, dataFunction) {
    var acc, dataLen, fromIndex, i, search, toTime, value, _i, _ref;
    dataLen = data.length;
    fromIndex = Timechart_Data.binSearch(data, times[timesI0]);
    for (i = _i = timesI0, _ref = timesI1 - 2; _i <= _ref; i = _i += 1) {
      toTime = times[i + 1];
      acc = null;
      search = true;
      while (fromIndex < dataLen && data[fromIndex][0] < toTime) {
        if (search) {
          if (dataFunction) {
            value = dataFunction(data[fromIndex]);
          } else {
            value = data[fromIndex][dataIndex];
          }
          if (value != null) {
            acc = value;
            search = false;
          }
        }
        fromIndex += 1;
      }
      values[i] = acc;
    }
  };

  Timechart_DataWarehouse.prototype.fillValueLast = function(data, times, values, timesI0, timesI1, dataIndex, dataFunction) {
    var acc, dataLen, fromIndex, i, toTime, value, _i, _ref;
    dataLen = data.length;
    fromIndex = Timechart_Data.binSearch(data, times[timesI0]);
    for (i = _i = timesI0, _ref = timesI1 - 2; _i <= _ref; i = _i += 1) {
      toTime = times[i + 1];
      acc = null;
      while (fromIndex < dataLen && data[fromIndex][0] < toTime) {
        if (dataFunction) {
          value = dataFunction(data[fromIndex]);
        } else {
          value = data[fromIndex][dataIndex];
        }
        fromIndex += 1;
        if (value != null) {
          acc = value;
        }
      }
      values[i] = acc;
    }
  };

  Timechart_DataWarehouse.prototype._newDataArrived = function() {
    return this.chart.events.notifySceneChanges({
      data: true
    });
  };

  return Timechart_DataWarehouse;

})();
// Generated by CoffeeScript 1.8.0
var Base_Settings;

Base_Settings = (function() {
  Base_Settings.libName = "zoomcharts";

  Base_Settings.perBrowserCustomizations = {
    safari: {},
    chrome: {},
    opera: {},
    firefox: {},
    msie: {}
  };

  Base_Settings.defaults = {
    _doc: {
      doc: "Base settings including multiple configurations around overall chart appearance, interaction and rendering.",
      type: "section"
    },
    container: null,
    container_doc: {
      doc: "Element of the page where the chart will be inserted. For example a div. Any contents of the element will be cleared. Note that a single element can host only one chart.",
      type: "domElement"
    },
    width: null,
    width_doc: {
      doc: "Width of the chart. If undefined the chart width will adapt to container element.",
      type: "float",
      min: 1,
      units: "pixels"
    },
    height: null,
    height_doc: {
      doc: "Height of the chart. If undefined the chart height will adapt to container element.",
      type: "float",
      min: 1,
      units: "pixels"
    },
    minHeight: 165,
    minHeight_doc: {
      doc: "The minimum chart height. Chart will not resize below this.",
      type: "float",
      units: "pixels"
    },
    maxHeight: 20000,
    maxHeight_doc: {
      doc: "The maximum chart height. Chart will not resize below this.",
      type: "float",
      units: "pixels"
    },
    minWidth: 100,
    minWidth_doc: {
      doc: "The minimum chart width. The chart will not resize below this",
      type: "float",
      units: "pixels"
    },
    maxWidth: 20000,
    maxWidth_doc: {
      doc: "The maximum chart width. The chart will not resize below this",
      type: "float",
      units: "pixels"
    },
    theme: null,
    theme_doc: {
      doc: "Theme to apply. Should contain an javascript object with additional settings.",
      type: "object"
    },
    assetsUrlBase: "",
    area: {
      _doc: {
        doc: "Chart area related settings.",
        type: "section"
      },
      style: {
        _doc: {
          doc: "Area style.",
          type: "object"
        },
        fillColor: "transparent",
        fillColor_doc: {
          doc: "Background fill color of chart area",
          type: "color"
        },
        image: null,
        image_doc: {
          doc: "Background image of  chart area.",
          type: "imageUrl"
        },
        overlayColor: null
      }
    },
    data: Base_Data.settings,
    advanced: {
      _doc: {
        doc: "",
        type: "section"
      },
      labelCache: true,
      labelCache_doc: {
        doc: "Whether to store entire label into bitmap. Use it to improve the performance of your application.",
        type: "bool"
      },
      highDPI: true,
      highDpi_doc: {
        doc: "Enables high resolution rendering on high DPI screens. As performance is varied across different browsers, disable this to improve the performance of your application.",
        type: "boolean"
      },
      pointer: {
        _doc: {
          doc: "Pointer related settings.",
          type: "section"
        },
        noClickOnDoubleClick: true,
        noClickOnDoubleClick_doc: {
          doc: "If enabled, normal click event is not sent when user performs a double click. A not so nice side effect is that any on click actions are delayed by the double click timeout. Set to false if you are not relying on double click events.",
          type: "bool"
        },
        dragSensitivity: 10,
        dragSensitivity_doc: {
          doc: "Pixels to move pointer before dragging starts.",
          type: "float",
          units: "pixels"
        },
        doubleClickSensitivity: 40,
        doubleClickSensitivity_doc: {
          doc: "Pixels pointer can move around and still register as double click.",
          type: "float",
          units: "pixels"
        },
        doubleClickTimeout: 300,
        doubleClickTimeout_doc: {
          doc: "Time between clicks to register as double click.",
          type: "integer",
          units: "milliseconds"
        },
        longPressTimeout: 500,
        longPressTimeout_doc: {
          doc: "Time in ms for long press.",
          type: "integer",
          units: "milliseconds"
        },
        speedAveragingPeriod: 200,
        speedAveragingPeriod_doc: {
          doc: "Time window to use for pointer speed estimation.",
          type: "integer",
          units: "milliseconds"
        }
      },
      useAnimationFrame: true,
      useAnimationFrame_doc: {
        doc: "Whether to use requestAnimationFrame for requested paint instead of setTimeout.",
        type: "bool"
      },
      showTouches: false,
      showTouches_doc: {
        doc: "Whether to use debugging option to paint pointer trails on screen.",
        type: "bool"
      },
      showFPS: false,
      showFPS_doc: {
        doc: "Whether to show frames per second on the chart.",
        type: "bool"
      },
      logging: false,
      logging_doc: {
        doc: "Whether to show verbose logging.",
        type: "bool"
      },
      style: {
        _doc: {
          doc: "Miscellaneous style settings.",
          type: "object"
        },
        messageTextStyle: {
          _doc: {
            doc: "Message text",
            type: "object"
          },
          fillColor: "#000",
          font: "15px Arial"
        },
        loadingArcStyle: {
          _doc: {
            doc: "Loading arc animation style",
            type: "object"
          },
          r: 10,
          r_doc: {
            doc: "Loading arc radius.",
            type: "float",
            units: "pixels"
          },
          lineColor: "#444",
          lineWidth: 1
        }
      },
      maxCanvasWidth: 2047,
      maxCanvasWidth_doc: {
        doc: "Maximum width of canvas object. The canvas will be stretched if chart is bigger that this. Note that increasing beyond 2048 is known to cause loss of hardware acceleration on Safari/OSX.",
        type: "float",
        units: "pixels"
      },
      maxCanvasHeight: 2047,
      maxCanvasHeight_doc: {
        doc: "Maximum height of canvas object. The canvas will be stretched if chart is bigger that this. Note that increasing beyond 2048 is known to cause loss of hardware acceleration on Safari/OSX.",
        type: "float",
        units: "pixels"
      },
      themeCSSClass: "DVSL-round",
      themeCSSClass_doc: {
        doc: "CSS class for current theme. Used to reference chart container in CSS files.",
        type: "string"
      },
      assets_applyMethod: "merge",
      assets: ["assets://base.css"],
      assets_doc: {
        doc: "List of assets to load from assets directory. This should be used to load CSS files.",
        type: "url"
      },
      builtinAssets: {
        "logo": Base_images_logo,
        "error.png": Base_images_error
      },
      pdfExportAssets: ["assets://jspdf/jspdf.min.js", "assets://jspdf/jspdf.plugin.addimage.min.js"],
      pdfExportAssets_doc: {
        doc: "Extra assets to be loaded for pdfExport action.",
        type: "array",
        baseObject: "url"
      },
      exportProxyURL: "https://zoomcharts.com/developers/export",
      exportProxyURL_doc: {
        doc: "URL for export proxy requests.",
        type: "url"
      }
    },
    events: {
      _doc: {
        doc: "The events used to handle user interaction with UI elements. See see::interactivity/::events:: for more info.",
        type: "section"
      },
      onError: null,
      onError_doc: {
        doc: "Function called when error occurs, default behavior is log to console.",
        parameters: {
          "message": "error message"
        },
        returns: "",
        type: "function"
      },
      onSettingsChange: null,
      onSettingsChange_doc: {
        doc: "Function called when settings are changed.",
        parameters: {
          "event": "event object attached to event listener"
        },
        returns: "",
        type: "function"
      },
      onClick: null,
      onClick_doc: {
        doc: "Function called when user clicks on chart.",
        parameters: {
          "event": "event object attached to event listener"
        },
        returns: "",
        type: "function"
      },
      onDoubleClick: null,
      onDoubleClick_doc: {
        doc: "Function called when user doubleClicks on chart.",
        parameters: {
          "event": "event object attached to event listener"
        },
        returns: "",
        type: "function"
      },
      onRightClick: null,
      onRightClick_doc: {
        doc: "Function called when user right clicks on chart.",
        parameters: {
          "event": "event object attached to event listener"
        },
        returns: "",
        type: "function"
      },
      onHoverChange: null,
      onHoverChange_doc: {
        doc: "Function called when object pointer is on changes.",
        parameters: {
          "event": "event object attached to event listener"
        },
        returns: "",
        type: "function"
      },
      onSelectionChange: null,
      onSelectionChange_doc: {
        doc: "Function called when selected slices has changed.",
        parameters: {
          "event": "event object attached to event listener"
        },
        returns: "",
        type: "function"
      },
      onChartUpdate: null,
      onChartUpdate_doc: {
        doc: "Function called when whenever current view has changed. Usually after panning and navigation. Use to update any linked views. Note that this is also fired after chart initialization and API methods. Use event.origin field to determine event's origin.",
        parameters: {
          "event": "event object attached to event listener"
        },
        returns: "",
        type: "function"
      },
      onPositionChange: null,
      onPositionChange_doc: {
        doc: "Function called whenever chart placement on screen changes. Note that this is called on every animation frame and is intended for painting overlays only.",
        parameters: {
          "event": "event object attached to event listener"
        },
        returns: "",
        type: "function"
      },
      onAnimationDone: null,
      onAnimationDone_doc: {
        doc: "Function called when chart scrolling animation is finished.",
        parameters: {
          "event": "event object attached to event listener"
        },
        returns: "",
        type: "function"
      },
      chartUpdateDelay: 0,
      chartUpdateDelay_doc: {
        doc: "Time to wait after last action before firing onChartUpdate event.",
        type: "integer"
      }
    },
    interaction: {
      _doc: {
        doc: "Customise chart resize handles or animation duration settings.",
        type: "section"
      },
      resizing: Base_Resizer.settings,
      animation: {
        _doc: {
          doc: "Chart animation settings.",
          type: "section"
        },
        scrollDuration: 500,
        scrollDuration_doc: {
          doc: "Duration of scroll animation.",
          type: "integer",
          units: "milliseconds"
        },
        hoverDuration: 200,
        hoverDuration_doc: {
          doc: "Duration of hover animation.",
          type: "integer",
          units: "milliseconds"
        }
      }
    },
    localization: {
      _doc: {
        doc: "Localizeable strings including export type options and useful default buttons used for chart interaction. Buttons like to navigate back, set the chart on full screen and others.",
        type: "section"
      },
      toolbar: {
        _doc: {
          doc: "Toolbar of localizeable strings.",
          type: "object"
        },
        backButton: "Back",
        backTitle: "Move one step back in navigation",
        fullscreenButton: "Fullscreen",
        fullscreenTitle: "Toggle fullscreen mode",
        zoomoutButton: "Zoom-out",
        zoomoutTitle: "Zoom out",
        exportButton: "Export",
        exportTitle: "Export Data",
        exportJpeg: "For Office and Web (jpeg)",
        exportPNG: "For Photoshop (png)",
        exportPDF: "For Printer (pdf)",
        exportCSV: "Spreadsheet (csv)",
        exportXLS: "Spreadsheet (xls)"
      },
      loadingLabel: "Loading...",
      loadingLabel_doc: {
        doc: "Message to show when data loading is in progress.",
        type: "string"
      },
      dataRequestFailed: "Data request failed",
      dataRequestFailed_doc: {
        doc: "Error message when data request has failed.",
        type: "string"
      }
    },
    toolbar: Base_Toolbar.settings,
    title: Base_Title.settings,
    credits: Base_Credits.settings,
    legend: Base_Legend.settings
  };

  function Base_Settings(defaults) {
    var browser, customizations, k, libName, n, prefix, r, regs, v, _i, _len, _ref;
    this._imageCache = {};
    this._imageLoading = {};
    this._imagesPendingForErrors = [];
    this._loadedAssets = {};
    this._assetsLoaded = true;
    this._assetsToLoad = [];
    this._imgAssets = {};
    this._defaults = defaults;
    this._computedData = [];
    this._computedDataMap = {};
    this.applyDefaults(defaults);
    browser = Base_Helpers.detectBrowser();
    customizations = Base_Settings.perBrowserCustomizations[browser];
    if (customizations) {
      this.applyRec(this, customizations, {}, 0);
    }
    libName = Base_Settings.libName;
    regs = [];
    regs.push(new RegExp("((file:\/\/\/|https?:\/\/)[^\/]+\/.*?)\/?" + libName + "(-dev|\.min|)\.js"));
    regs.push(new RegExp("((file:\/\/\/|https?:\/\/)[^\/]+\/.*\/src)\/?" + libName));
    _ref = document.getElementsByTagName("script");
    for (k in _ref) {
      v = _ref[k];
      if (!v.src) {
        continue;
      }
      for (_i = 0, _len = regs.length; _i < _len; _i++) {
        r = regs[_i];
        if (n = v.src.match(r)) {
          if (n[1][n[1].length - 1] === "/") {
            prefix = "";
          } else {
            prefix = "/";
          }
          this.assetsUrlBase = n[1] + prefix + "assets/";
        }
      }
    }
  }

  Base_Settings.prototype.applyCompatibility = function(settings, compatList) {
    var from, item, to, val, _i, _len, _results;
    _results = [];
    for (_i = 0, _len = compatList.length; _i < _len; _i++) {
      item = compatList[_i];
      from = item.from;
      to = item.to;
      val = Base_Helpers.getProp(settings, from);
      if (val !== void 0) {
        if (item.filter && !item.filter(val)) {
          continue;
        }
        if (to) {
          if (item.transform) {
            val = item.transform(val);
          }
          _results.push(this.applyRec(settings, Base_Helpers.wrapValue(val, to), {}));
        } else {
          _results.push(console.error("Zoomcharts: Setting " + from + " no longer supported. Consider using " + item.alternative + " instead."));
        }
      } else {
        _results.push(void 0);
      }
    }
    return _results;
  };

  Base_Settings.prototype.apply = function(settings) {
    var changes, d, dataArray, dataChanges, t, theme, _i, _len;
    if (settings == null) {
      return;
    }
    changes = {};
    theme = null;
    if (settings.theme != null) {
      theme = settings.theme;
      delete settings.theme;
    }
    if (theme) {
      this.applyRec(this, theme, changes, 0);
      settings.theme = theme;
    }
    if (settings.data) {
      dataChanges = true;
      if (Base_Helpers.isArray(settings.data)) {
        dataArray = settings.data;
        delete settings.data;
      } else {
        dataArray = null;
      }
    }
    this.applyRec(this, settings, changes, 0);
    if (dataChanges) {
      changes.data = true;
      this._computedData = [];
      this._computedDataMap = {};
      if (dataArray) {
        settings.data = dataArray;
        for (_i = 0, _len = dataArray.length; _i < _len; _i++) {
          d = dataArray[_i];
          t = {};
          this.applyRec(t, this._defaults.data, {});
          this.applyRec(t, d, {});
          if (t.name != null) {
            t.id = t.name;
          }
          this._computedData.push(t);
          this._computedDataMap[t.id] = t;
        }
      } else {
        if (this.data.name != null) {
          this.data.id = this.data.name;
        }
        if (!this.data.id) {
          this.data.id = "default";
        }
        this._computedData.push(this.data);
        this._computedDataMap[this.data.id] = this.data;
      }
    }
    return changes;
  };

  Base_Settings.prototype.applyDefaults = function(settings) {
    var theme;
    theme = settings.theme;
    if (theme) {
      delete settings.theme;
      this.apply(settings);
      this.apply(theme);
      return settings.theme = theme;
    } else {
      return this.apply(settings);
    }
  };

  Base_Settings.applyRec = function(target, changes, changedProperties, depth) {
    var a, f, key, method, methodProp, o, oa, oo, origValue, skip, ta, value, vv, _i, _len;
    if (depth == null) {
      depth = 0;
    }
    if (depth > 10) {
      throw "Stack depth greater than 10, seems like recursive settings";
    }
    if (target === void 0) {
      console.error(depth, target, changes);
      throw "Tried to applyRec on undefined";
    }
    for (key in changes) {
      value = changes[key];
      origValue = target[key];
      if (origValue !== void 0 && value === origValue) {
        continue;
      }
      a = Base_Helpers.isArray(value);
      o = Base_Helpers.isObject(value);
      oa = Base_Helpers.isArray(origValue);
      oo = Base_Helpers.isObject(origValue);
      f = Base_Helpers.isFunction(value);
      skip = false;
      if (oa && !a) {
        console.error("Applying settings: Setting expected to be array but got something else: " + key + " = " + value);
        skip = true;
      }
      if (value !== null && oo && !o && !f) {
        console.error("Applying settings: Setting expected to be object but got something else: " + key + " = " + value);
        skip = true;
      }
      if (skip) {
        continue;
      }
      if (o) {
        if (!(origValue != null)) {
          if (a) {
            target[key] = [];
            changedProperties[key] = [];
            oo = true;
          } else {
            target[key] = {};
            changedProperties[key] = {};
            oo = true;
          }
        }
        if (value === null || value === void 0) {
          target[key] = value;
          changedProperties[key] = value;
        }
        if (o && !oo) {
          target[key] = {};
          changedProperties[key] = {};
        }
        if (key === "container") {
          target[key] = value;
          changedProperties[key] = value;
        } else if (a) {
          methodProp = key + "_applyMethod";
          method = changes[methodProp] || target[methodProp];
          if (method === "merge") {
            ta = target[key];
            for (_i = 0, _len = value.length; _i < _len; _i++) {
              vv = value[_i];
              if (!Base_Helpers.arrayContains(ta, vv)) {
                ta.push(vv);
              }
            }
          } else {
            target[key] = value;
          }
          changedProperties[key] = value;
        } else {
          if (!changedProperties.hasOwnProperty(key)) {
            changedProperties[key] = {};
          }
          this.applyRec(target[key], value, changedProperties[key], depth + 1);
        }
      } else if (value === void 0) {
        delete target[key];
        changedProperties[key] = value;
      } else {
        target[key] = value;
        changedProperties[key] = value;
      }
    }
    return 1;
  };

  Base_Settings.extendDefaults = function(base, extend) {
    var r;
    r = Base_Helpers.realClone(base);
    Base_Settings.applyRec(r, extend, {}, 0);
    return r;
  };

  Base_Settings.prototype.applyRec = Base_Settings.applyRec;

  Base_Settings.prototype.applyById = function(target, changes, changedProperties) {
    var c, ch, found, o, _i, _j, _len, _len1, _results;
    _results = [];
    for (_i = 0, _len = changes.length; _i < _len; _i++) {
      c = changes[_i];
      found = false;
      if (c.id) {
        for (_j = 0, _len1 = target.length; _j < _len1; _j++) {
          o = target[_j];
          if (o.id === c.id) {
            ch = {};
            this.applyRec(o, c, ch, 0);
            changedProperties.push(ch);
            found = true;
            break;
          }
        }
      }
      if (!found) {
        target.push(c);
        _results.push(changedProperties.push(c));
      } else {
        _results.push(void 0);
      }
    }
    return _results;
  };

  Base_Settings.prototype.applySeries = function(seriesArray, seriesTypes, seriesDefault) {
    var result, s, series, ss, type, _i, _len;
    if (seriesArray.length === 0) {
      ss = [{}];
    } else {
      ss = seriesArray;
    }
    result = [];
    for (_i = 0, _len = ss.length; _i < _len; _i++) {
      series = ss[_i];
      if (!Base_Helpers.isObject(series)) {
        continue;
      }
      s = {};
      this.applyRec(s, seriesDefault, {});
      type = series.type || s.type;
      if (seriesTypes.hasOwnProperty(type)) {
        this.applyRec(s, seriesTypes[type], {});
      } else {
        throw "Settings: Unrecognized type = " + type;
      }
      this.applyRec(s, series, {});
      result.push(s);
    }
    return result;
  };

  Base_Settings.prototype.getAssetUrl = function(asset) {
    var base;
    if (asset.indexOf("builtin://") === 0) {
      return this.advanced.builtinAssets[asset.slice(10)];
    } else if (asset.indexOf("assets://") === 0) {
      base = this.assetsUrlBase[this.assetsUrlBase.length - 1] === "/" ? this.assetsUrlBase : this.assetsUrlBase + "/";
      return base + asset.slice(9);
    } else {
      return asset;
    }
  };

  Base_Settings.prototype.hasPendingRequests = function() {
    return Base_Helpers.hasProperties(this._imageLoading);
  };

  Base_Settings.prototype.getAssetImage = function(asset, onFirstLoad) {

    /*
     *# onFirstLoad will be called only once on image loading, for whoever is the first to request it.
     */
    var errorFunc, loadFunc, url;
    if (this._imageCache.hasOwnProperty(asset)) {
      return this._imageCache[asset];
    } else if (this._imageLoading.hasOwnProperty(asset)) {
      return null;
    } else {
      url = this.getAssetUrl(asset);
      if (!url) {
        return null;
      }
      loadFunc = (function(_this) {
        return function(image) {
          delete _this._imageLoading[asset];
          _this._imageCache[asset] = image;
          if (onFirstLoad) {
            return onFirstLoad(image);
          }
        };
      })(this);
      errorFunc = (function(_this) {
        return function() {
          var cachedErrorImg, errorImageLoadedFunc, errorResource, img;
          errorResource = "builtin://error.png";
          cachedErrorImg = _this._imageCache[errorResource];
          if (cachedErrorImg) {
            return loadFunc(cachedErrorImg);
          } else {
            _this._imagesPendingForErrors.push(loadFunc);
            if (!_this._imageLoading.hasOwnProperty(errorResource)) {
              errorImageLoadedFunc = function(errorImage) {
                var func, _i, _len, _ref;
                delete _this._imageLoading[errorResource];
                _this._imageCache[errorResource] = errorImage;
                _ref = _this._imagesPendingForErrors;
                for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                  func = _ref[_i];
                  func(errorImage);
                }
                return _this._imagesPendingForErrors = null;
              };
              img = Base_Helpers.buildImage(_this.getAssetUrl(errorResource), errorImageLoadedFunc, (function() {
                return 1;
              }));
              if (!_this._imageCache.hasOwnProperty(errorResource)) {
                return _this._imageLoading[errorResource] = true;
              }
            }
          }
        };
      })(this);
      this._imageLoading[asset] = true;
      Base_Helpers.buildImage(url, loadFunc, errorFunc);
      if (this._imageCache.hasOwnProperty(asset)) {
        return this._imageCache[asset];
      } else {
        return null;
      }
    }
  };

  return Base_Settings;

})();
// Generated by CoffeeScript 1.8.0
var Piechart_Legend,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

Piechart_Legend = (function(_super) {
  "use strict";
  __extends(Piechart_Legend, _super);

  Piechart_Legend.prototype.paintOrder = 20;

  Piechart_Legend.prototype.updateOrder = 1000;

  Piechart_Legend.settings = {
    _doc: {
      doc: "The chart legend by additional interactivity to navigate between the slices or hilight each of them. Note that click on entries acts the same way as click on slice and is dependant of chart interaction mode.",
      type: "section"
    },
    marker: {
      _doc: {
        doc: "Visual element of legend entry with appropriate style to a slice color it corresponds. The content of each legend marker is the same as info popup appearing while hovering on slice.",
        type: "object"
      },
      shape: "rect",
      shape_doc: {
        doc: "Entry marker shape.",
        type: "enum",
        values: ["rect", "circle", "triangle", "romb"]
      }
    }
  };

  function Piechart_Legend(chart) {
    this.chart = chart;
    Piechart_Legend.__super__.constructor.call(this, chart);
  }

  Piechart_Legend.prototype.onSceneChange = function(event) {
    var ch;
    Piechart_Legend.__super__.onSceneChange.call(this, event);
    ch = event.changes;
    if (ch.pie) {
      this.rebuildItems();
      return ch.bounds = true;
    }
  };

  Piechart_Legend.prototype.doAnimations = function() {
    this.hoverObject = this.scene.hoverSlice;
    return this.selectedObjects = this.scene.selection;
  };

  Piechart_Legend.prototype.paintMarker = function(context, cx, cy, radius, item) {
    var markerStyle, slice;
    slice = item.data;
    markerStyle = {
      fillColor: slice.currentFillColor,
      lineColor: this.settings.marker.lineColor
    };
    context.beginPath();
    Base_Graphics.strokeMarker(context, this.settings.marker.shape, cx, cy, radius);
    return Base_Graphics.paint(context, markerStyle);
  };

  Piechart_Legend.prototype.rebuildItems = function() {
    var activePie, items, slice, slices, _i, _len;
    items = [];
    activePie = this.scene.peek();
    if (activePie) {
      slices = activePie.slices;
      for (_i = 0, _len = slices.length; _i < _len; _i++) {
        slice = slices[_i];
        items.push({
          textColor: this.settings.text.fillColor,
          label: slice.label || slice.data.name,
          data: slice
        });
      }
    }
    return this.setItems(items);
  };

  return Piechart_Legend;

})(Base_Legend);
// Generated by CoffeeScript 1.8.0
var Base_Impl,
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  __hasProp = {}.hasOwnProperty;

Base_Impl = (function() {
  Base_Impl.prototype.bigfoot = [0, "https://zoomcharts.com/logo-development.png", "https://zoomcharts.com"];

  Base_Impl.prototype.smallfish = "<?trackHash?>";

  Base_Impl.prototype.onRemove = function() {
    return Base_Helpers.error("Need to override onRemove");
  };

  Base_Impl.prototype.onSettingsChanged = function(changes) {
    return Base_Helpers.error("Need to override onSettingsChanged");
  };

  Base_Impl.prototype.createDataObj = function(dataSettings) {
    return Base_Helpers.error("Need to override createDataObj");
  };

  Base_Impl.prototype.removeData = function(data, sourceId) {
    return Base_Helpers.error("Remove data not implemented for this chart");
  };

  Base_Impl.prototype.hideMenu = function() {
    return 1;
  };

  Base_Impl.prototype.updateFilters = function() {
    return this.events.notifySceneChanges({
      filters: true
    });
  };

  Base_Impl.prototype.updateStyle = function() {
    return this.events.notifySceneChanges({
      style: true
    });
  };

  function Base_Impl(settings, scene) {
    var key, name, value, _ref;
    this.settings = settings;
    this.scene = scene;
    this.notifyAssetsLoaded = __bind(this.notifyAssetsLoaded, this);
    this.defaultError = __bind(this.defaultError, this);
    this.chartUpdateNotify = __bind(this.chartUpdateNotify, this);
    this._containerResize = __bind(this._containerResize, this);
    if (!settings.container) {
      throw "Chart container not set";
    }
    if (!Base_Helpers.isDomObject(settings.container)) {
      throw "Chart container is not a DOM object";
    }
    this.container = this.settings.container;
    this.scene.settings = settings;
    this.data = {};
    this.layers = null;
    this.toolbar = null;
    this.removed = false;
    this.curState = null;
    this.goingBack = false;
    this.chartUpdateOrigin = null;
    this.currentNavigationState = null;
    this.fullScreenMode = false;
    this.fullscreenBeforeW = 0;
    this.fullscreenBeforeH = 0;
    this.previousSizeW = 0;
    this.previousSizeH = 0;
    this.EVENT_NAMES = {};
    _ref = settings.events;
    for (name in _ref) {
      value = _ref[name];
      if (name.indexOf("on") === 0) {
        key = name.charAt(2).toLowerCase() + name.slice(3);
        this.EVENT_NAMES[name] = key;
        this.EVENT_NAMES[key] = key;
      }
    }
  }

  Base_Impl.prototype.initialize = function(api, components) {
    this.api = api;

    /*
      @settings, @scene, @layers must be prepared
     */
    this.eventListeners = {};
    this.assetsLoaded = true;
    this.assetsLoader = new Base_AssetsLoader(this);
    if (this.assetsLoader.load(this.settings.advanced.assets, this.notifyAssetsLoaded)) {
      this.assetsLoaded = false;
    }
    this.container = this.settings.container;
    if (this.container._DVSL_ChartInstance !== void 0 && this.container._DVSL_ChartInstance !== null) {
      this.container._DVSL_ChartInstance.remove();
    }
    this.container.innerHTML = "";
    this.container._DVSL_ChartInstance = this;
    this.container.appendChild(this.layers.container);
    if (typeof G_vmlCanvasManager !== "undefined") {
      G_vmlCanvasManager.init_(document);
      G_vmlCanvasManager.initElement(this.layers.canvas);
    }
    this.events = new Base_ChartEvents(this.layers.mouseTrackLayer, this.layers.canvas, this);
    this.clearData();
    this.title = new Base_Title(this);
    this.credits = new Base_Credits(this, this.scene.settings.credits);
    return this.api._impl = this;
  };

  Base_Impl.prototype.finalInitialize = function() {
    var diff, f, l, messages, s, time;
    this.events.addElement(new Base_KeyShortcuts(this));
    this.events.addElement(this.layers);
    this.events.addElement(this.title);
    this.events.addElement(this.credits);
    this.events.addElement(new Base_Resizer(this));
    this.events.addElement(new Base_MessagesOverlay(this));
    this.events.addElement(new Base_TouchMarkers(this.scene));
    l = this.bigfoot;
    time = new Date().getTime();
    if (l[0] > 0) {
      diff = time - l[0];
      if (diff > 0) {
        messages = ["Trial expired", "Trial expired", "It expired " + (moment.duration(diff).humanize()) + " ago", "Use the link at bottom-right to upgrade"];
        this.scene.setMessage("d", messages[0], 1000);
        this._xcount = 0;
        f = (function(_this) {
          return function() {
            if (_this._xcount < messages.length - 1) {
              _this._xcount += 1;
            } else {
              Base_Helpers.openUrl(l[2]);
            }
            _this.scene.setMessage("d", messages[_this._xcount], 1000);
            return _this.updateSettings({
              area: {
                style: {
                  fillColor: "rgba(255,230,230, " + (Math.min(1, _this._xcount / messages.length)) + ")"
                }
              },
              advanced: {
                style: {
                  messageTextStyle: {
                    font: "" + (15 + _this._xcount * 5) + "px Arial"
                  }
                }
              }
            });
          };
        })(this);
        this.events.addElement({
          previewPointerUp: f
        });
      } else if (diff > -604800000) {
        this.scene.setMessage("d", "Trial ending soon, " + (moment.duration(-diff).humanize()) + " remaining", 1000);
      }
      s = {
        url: l[2],
        image: l[1] + "?t=" + time,
        imageExport: Base_images_logo,
        imageScaling: 1,
        location: "inside",
        enabled: true,
        enabledOnExport: true
      };
      this.events.addElement(new Base_Credits(this, s));
    } else if (l[0] === -2) {
      s = {
        url: l[2],
        image: l[1] + "?t=" + time,
        imageExport: Base_images_logo,
        imageScaling: 1,
        location: "outside",
        enabled: true,
        enabledOnExport: true
      };
      this.events.addElement(new Base_Credits(this, s));
    } else if (l[0] < 0) {
      this.scene.getAssetImage(l[1] + "?t=" + time);
    }
    this.events.notifySceneChanges({
      settings: true,
      settingsChanges: this.scene.settings,
      data: true
    });
    this.updateSize();
    this.updateEvents({}, this.settings.events);
    Base_Helpers.listenResize(this.container, this._containerResize);
    return Base_Helpers.listen(window, 'resize', this._containerResize);
  };

  Base_Impl.prototype.updateSettings = function(newSettings, origin) {
    var changes, old, sceneChanges;
    if (origin == null) {
      origin = null;
    }
    if (newSettings.container && newSettings.container !== this.container) {
      this.error("updateSettings() cannot change the container element");
      newSettings.container = this.container;
    }
    old = Base_Helpers.clone(this.settings.events);
    changes = this.settings.apply(newSettings);
    sceneChanges = {
      settings: true,
      settingsChanges: changes
    };
    if (this.removed) {
      return;
    }
    if (changes.events) {
      this.updateEvents(old, this.settings.events);
    }
    if (changes.advanced && changes.advanced.assets) {
      if (this.assetsLoader.load(this.settings.advanced.assets, this.notifyAssetsLoaded)) {
        this.assetsLoaded = false;
      }
    }
    if (changes.data) {
      this.clearData();
      sceneChanges.data = true;
      sceneChanges.dataDeep = true;
      if (this.navigator) {
        this.navigator.onNewDataObject();
      }
    }
    this.layers.updateSettings(changes);
    this.onSettingsChanged(changes);
    if (changes.toolbar && this.assetsLoaded) {
      if (this.toolbar) {
        this.toolbar.remove();
      }
      this.toolbar = new Base_Toolbar(this, this.settings.toolbar);
    }
    this.events.notifySceneChanges(sceneChanges);
    if (changes.width || changes.height || changes.maxWidth || changes.minWidth || changes.minHeight || changes.maxHeight) {
      this.updateSize(true);
    }
    if (origin) {
      return this.notifySettingsChanged(changes, origin);
    }
  };

  Base_Impl.prototype.getData = function(id) {
    var data, dataSettings;
    if (this.data[id] != null) {
      return this.data[id];
    }
    dataSettings = this.settings._computedDataMap[id];
    if (dataSettings) {
      data = this.createDataObj(dataSettings);
      data.applyPreloadedData();
      this.data[id] = data;
      return data;
    } else {
      throw "No data configured for source ID " + id;
    }
  };

  Base_Impl.prototype.addData = function(data, sourceId) {
    if (this.removed) {
      return;
    }
    return this.getData(sourceId).addData(data);
  };

  Base_Impl.prototype.reloadData = function(sourceId, deep) {
    if (sourceId == null) {
      sourceId = null;
    }
    if (this.removed) {
      return;
    }
    this.log("Reload data");
    if (!sourceId) {
      this.clearData();
    } else {
      if (this.data[sourceId]) {
        this.data[sourceId].remove();
        delete this.data[sourceId];
      }
    }
    this.scene.mainData = this.getData(this.settings._computedData[0].id);
    this.events.notifySceneChanges({
      data: true,
      dataDeep: deep
    });
    if (this.navigator) {
      return this.navigator.onNewDataObject();
    }
  };

  Base_Impl.prototype.replaceData = function(data, sourceId) {
    var dataObj;
    if (sourceId == null) {
      sourceId = "default";
    }
    if (this.removed) {
      return;
    }
    this.events.clearSceneChanges({
      dataArrived: true
    });
    if (this.data[sourceId]) {
      this.data[sourceId].remove();
    }
    this.data[sourceId] = dataObj = this.createDataObj(this.settings._computedDataMap[sourceId]);
    dataObj.addData(data);
    this.scene.mainData = this.getData(this.settings._computedData[0].id);
    this.events.notifySceneChanges({
      data: true
    });
    if (this.navigator) {
      return this.navigator.onNewDataObject();
    }
  };

  Base_Impl.prototype.clearData = function(final) {
    var key, val, _ref;
    if (final == null) {
      final = false;
    }
    _ref = this.data;
    for (key in _ref) {
      val = _ref[key];
      val.remove();
    }
    this.events.clearSceneChanges({
      dataArrived: true
    });
    this.data = {};
    this.scene.mainData = null;
    if (!final) {
      return this.scene.mainData = this.getData(this.settings._computedData[0].id);
    }
  };

  Base_Impl.prototype.hasPendingRequests = function() {
    var data, id, _ref;
    if (this.settings.hasPendingRequests()) {
      return true;
    }
    _ref = this.data;
    for (id in _ref) {
      data = _ref[id];
      if (data.hasPendingRequests()) {
        return true;
      }
    }
    return false;
  };

  Base_Impl.prototype.remove = function() {
    this.cancelChartUpdateNotify();
    this.removed = true;
    if (this.toolbar) {
      this.toolbar.remove();
    }
    this.events.remove();
    this.container.removeChild(this.layers.container);
    this.clearData(true);
    this.onRemove();
    this.layers = null;
    this.scene = null;
    this.events = null;
    this.container._DVSL_ChartInstance = void 0;
    Base_Helpers.unlistenResize(this.container, this._containerResize);
    return Base_Helpers.unlisten(window, 'resize', this._containerResize);
  };

  Base_Impl.prototype._containerResize = function() {
    return this.updateSize(false);
  };

  Base_Impl.prototype.setFullscreen = function(enabled) {
    if (enabled === this.fullScreenMode) {
      return;
    }
    this.fullScreenMode = enabled;
    if (enabled) {
      Base_Helpers.addClass(this.layers.container, "DVSL-fullscreen");
      this.fullscreenBeforeW = this.scene.chartWidth;
      this.fullscreenBeforeH = this.scene.chartHeight;
    } else {
      Base_Helpers.removeClass(this.layers.container, "DVSL-fullscreen");
    }
    return this.updateSize(true);
  };

  Base_Impl.prototype.isFullscreen = function() {
    return this.fullScreenMode;
  };

  Base_Impl.prototype.updateSize = function(force) {
    var clientHeight, clientWidth, minHeight, minWidth;
    if (force == null) {
      force = false;
    }
    if (this.removed) {
      return;
    }
    clientWidth = this.settings.width;
    clientHeight = this.settings.height;
    minWidth = 0;
    minHeight = 0;
    if (this.layers.container.style.display !== "") {
      minWidth = this.settings.minWidth;
      minHeight = this.settings.minHeight;
    }
    if (!clientWidth) {
      clientWidth = parseInt(Math.max(minWidth, Math.min(this.settings.maxWidth, this.scene.settings.container.clientWidth)));
    }
    if (!clientHeight) {
      clientHeight = parseInt(Math.max(minHeight, Math.min(this.settings.maxHeight, this.scene.settings.container.clientHeight)));
    }
    if (this.fullScreenMode) {
      clientWidth = window.innerWidth;
      clientHeight = window.innerHeight;
    } else if (this.fullscreenBeforeW > 0) {
      clientWidth = this.fullscreenBeforeW;
      clientHeight = this.fullscreenBeforeH;
      this.fullscreenBeforeW = 0;
      this.fullscreenBeforeH = 0;
    }
    if (force || (clientWidth >= 2 && clientWidth !== this.previousSizeW) || (clientHeight >= 2 && clientHeight !== this.previousSizeH)) {
      this.layers.container.style.height = clientHeight + "px";
      this.layers.container.style.width = clientWidth + "px";
      this.log("Update size, " + clientHeight + ", " + clientWidth);
      this.previousSizeH = clientHeight;
      this.previousSizeW = clientWidth;
      this.scene.chartWidth = clientWidth;
      this.scene.chartHeight = clientHeight;
      if (this.events != null) {
        this.events.notifySceneChanges({
          bounds: true
        });
      }
    }
    return Base_Helpers.updateResize(this.container);
  };


  /* events */

  Base_Impl.prototype.on = function(event, handler) {
    event = this.EVENT_NAMES[event];
    if (!event) {
      this.error("Unrecognized event name: " + event);
      return;
    }
    if (!this.eventListeners[event]) {
      this.eventListeners[event] = [];
    }
    return this.eventListeners[event].push(handler);
  };

  Base_Impl.prototype.off = function(event, handler) {
    event = this.EVENT_NAMES[event];
    if (!event) {
      this.error("Unrecognized event name: " + event);
      return;
    }
    if (this.eventListeners[event] != null) {
      return Base_Helpers.removeFromArray(this.eventListeners[event], handler);
    }
  };

  Base_Impl.prototype.updateEvents = function(oldSettings, newSettings) {
    var event, prop, _ref, _results;
    _ref = this.EVENT_NAMES;
    _results = [];
    for (prop in _ref) {
      event = _ref[prop];
      if (oldSettings[prop] != null) {
        this.off(event, oldSettings[prop]);
      }
      if (newSettings[prop] != null) {
        _results.push(this.on(event, newSettings[prop]));
      } else {
        _results.push(void 0);
      }
    }
    return _results;
  };

  Base_Impl.prototype.notifyHoverChanged = function(e) {
    e.origin = "user";
    return this.dispatchEventParams("hoverChange", this.extendEventParams(e), null);
  };

  Base_Impl.prototype.notifyDoubleClick = function(e) {
    e.origin = "user";
    return this.dispatchEvent("doubleClick", this.extendEventParams(e), this.defaultDoubleClick);
  };

  Base_Impl.prototype.notifyRightClick = function(e) {
    e.origin = "user";
    return this.dispatchEvent("rightClick", this.extendEventParams(e), this.defaultRightClick);
  };

  Base_Impl.prototype.notifyClick = function(e) {
    e.origin = "user";
    return this.dispatchEvent("click", this.extendEventParams(e), this.defaultClick);
  };

  Base_Impl.prototype.notifyAnimationDone = function() {
    return this.dispatchEventParams("animationDone", this.extendEventParams({}), null);
  };

  Base_Impl.prototype.notifySelectionChanged = function(origin) {
    return this.dispatchEventParams("selectionChange", this.extendEventParams({
      origin: origin
    }), null);
  };

  Base_Impl.prototype.notifySettingsChanged = function(changes, origin) {
    return this.dispatchEventParams("settingsChange", this.extendEventParams({
      changes: changes,
      origin: origin
    }), null);
  };

  Base_Impl.prototype.notifyPositionChange = function(e) {
    e.origin = "user";
    return this.dispatchEventParams("positionChange", this.extendEventParams(e), null);
  };

  Base_Impl.prototype.notifyChartUpdate = function(origin, force) {
    var time, timeout;
    if (force == null) {
      force = false;
    }
    timeout = this.scene.settings.events.chartUpdateDelay;
    time = new Date().getTime();
    if (force) {
      this.chartUpdateForce = true;
    }
    if (origin) {
      this.chartUpdateWasBack = this.goingBack;
      this.chartUpdateOrigin = origin;
      this.chartUpdateTime = time;
    }
    timeout = this.chartUpdateTime + timeout - time;
    if (timeout > 0) {
      return this.chartUpdateTimeout = setTimeout(this.chartUpdateNotify, timeout);
    } else {
      return this.chartUpdateNotify();
    }
  };

  Base_Impl.prototype.cancelChartUpdateNotify = function() {
    this.chartUpdateOrigin = null;
    if (this.chartUpdateTimeout) {
      clearTimeout(this.chartUpdateTimeout);
      return this.chartUpdateTimeout = null;
    }
  };

  Base_Impl.prototype.chartUpdateNotify = function() {
    var origin, state;
    if (!this.chartUpdateOrigin) {
      return;
    }
    state = this.saveNavigation();
    if (state && (!this.curState || JSON.stringify(state) !== JSON.stringify(this.curState))) {
      this.chartUpdateForce = false;
      if (!this.chartUpdateWasBack && this.curState) {
        this.scene.pushBack(this.curState);
      }
      this.curState = state;
      origin = this.chartUpdateOrigin;
      this.chartUpdateOrigin = null;
      return this.doChartUpdateNotify(origin);
    } else if (this.chartUpdateForce) {
      this.chartUpdateForce = false;
      origin = this.chartUpdateOrigin;
      this.chartUpdateOrigin = null;
      return this.doChartUpdateNotify(origin);
    }
  };

  Base_Impl.prototype.back = function(animate, origin) {
    var state;
    if (animate == null) {
      animate = true;
    }
    if (origin == null) {
      origin = "api";
    }
    if (this.scene.backStack.length === 0) {
      return false;
    }
    state = this.scene.backStack.pop();
    this.goingBack = true;
    this.restoreNavigation(state, animate, origin);
    this.goingBack = false;
    return true;
  };

  Base_Impl.prototype.goHome = function(animate, origin) {
    var state;
    if (animate == null) {
      animate = true;
    }
    if (origin == null) {
      origin = "api";
    }
    if (this.scene.backStack.length === 0) {
      return false;
    }
    state = this.scene.backStack[0];
    this.restoreNavigation(state, animate, origin);
    return true;
  };

  Base_Impl.prototype.clearHistory = function() {
    this.scene.backStack = [];
    return true;
  };

  Base_Impl.prototype.saveNavigation = function() {
    return Base_Helpers.error("Need to override saveNavigation");
  };

  Base_Impl.prototype.restoreNavigation = function(state, animate, origin) {
    return Base_Helpers.error("Need to override restoreNavigation");
  };

  Base_Impl.prototype.doChartUpdateNotify = function(origin) {
    return this.dispatchEventParams("chartUpdate", this.extendEventParams({
      origin: origin
    }), null);
  };

  Base_Impl.prototype.dispatchEventParams = function(name, params, defaultFunc) {
    var event, key, value;
    if (!(defaultFunc || ((this.eventListeners[name] != null) && this.eventListeners[name].length > 0))) {
      return {};
    }
    event = Base_Helpers.createEvent(name);
    for (key in params) {
      if (!__hasProp.call(params, key)) continue;
      value = params[key];
      if (event[key] === void 0) {
        event[key] = value;
      }
    }
    return this.dispatchEvent(name, event, defaultFunc);
  };

  Base_Impl.prototype.dispatchEvent = function(name, event, defaultFunc) {
    var l, _i, _len, _ref;
    if (!(defaultFunc || ((this.eventListeners[name] != null) && this.eventListeners[name].length > 0))) {
      return event;
    }
    event.chart = this.api;
    if (this.eventListeners[name] != null) {
      _ref = this.eventListeners[name];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        l = _ref[_i];
        this.log("Call user event handler, " + name, event);
        l.call(this.api, event);
      }
    }
    if (!event.defaultPrevented && (defaultFunc != null)) {
      this.log("Call default event handler, " + name);
      defaultFunc.call(this.api, event);
    }
    return event;
  };

  Base_Impl.prototype.error = function(msg, arg) {
    return this.dispatchEventParams("error", {
      "message": msg,
      "arg": arg
    }, this.defaultError);
  };

  Base_Impl.prototype.log = function(msg, arg) {
    if (this.settings.advanced.logging) {
      return Base_Helpers.log(msg, arg);
    }
  };

  Base_Impl.prototype.deprecated = function(newFunc) {
    var str;
    str = "Deprecated: " + arguments.callee.caller.name + ".";
    if (newFunc) {
      str += " Use " + newFunc + " instead";
    }
    return this.log(str);
  };

  Base_Impl.prototype.defaultError = function(event) {
    if (this.settings.events.onError) {
      this.settings.events.onError(event);
    }
    return Base_Helpers.error(event.message, event.arg ? event.arg : null);
  };

  Base_Impl.prototype.notifyAssetsLoaded = function() {
    this.assetsLoaded = true;
    if (!this.toolbar) {
      this.toolbar = new Base_Toolbar(this, this.settings.toolbar);
      this.events.notifySceneChanges({
        toolbar: true
      });
      this.updateSize(true);
    }
    return Base_Helpers.updateResize(this.container);
  };

  return Base_Impl;

})();
// Generated by CoffeeScript 1.8.0
var Facetchart_InfoPopup,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

Facetchart_InfoPopup = (function(_super) {
  __extends(Facetchart_InfoPopup, _super);

  Facetchart_InfoPopup.prototype.animationOrder = 500;

  Facetchart_InfoPopup.prototype.paintOrder = 25;

  Facetchart_InfoPopup.prototype.updateOrder = 800;

  Facetchart_InfoPopup.settings = {
    _doc: {
      doc: "Rising content field while hovering over bars. Content returned in a form of html and is relevant to context of bar hovered.",
      type: "section"
    },
    enabled: true,
    enabled_doc: {
      doc: "Show/hide info popup.",
      type: "bool"
    },
    contentsFunction: null
  };

  function Facetchart_InfoPopup(chart) {
    Facetchart_InfoPopup.__super__.constructor.call(this, chart);
  }

  Facetchart_InfoPopup.prototype.doAnimations = function(event) {
    if (event.changes.position || event.changes.navigation) {
      return this.updatePopup(event);
    }
  };

  Facetchart_InfoPopup.prototype.getPopupAreaMouseMoved = function(x, y) {
    var facet, t, t0, t1;
    if (!(this.scene.xyInChartOrBottom(x, y) && this.scene.activeFacet)) {
      return null;
    }
    facet = this.scene.activeFacet;
    t = this.scene.xToPosition(x);
    t0 = Math.floor(t);
    t1 = Math.ceil(t);
    if (t0 === t1) {
      t1 = t0 + 1;
    }
    if (t0 < facet.offset || t0 >= facet.items.length + facet.offset) {
      return null;
    }
    return [t0, t1];
  };

  Facetchart_InfoPopup.prototype.buildHeader = function(t0, t1) {
    var facet, item, label;
    facet = this.scene.activeFacet;
    item = facet.items[t0 - facet.offset];
    label = item.label || "";
    return "<em></em><strong>" + label + "</strong>";
  };

  return Facetchart_InfoPopup;

})(Linearchart_InfoPopup);
// Generated by CoffeeScript 1.8.0
var Linearchart_Toolbar;

Linearchart_Toolbar = (function() {
  function Linearchart_Toolbar() {}

  Linearchart_Toolbar.settings = Base_Settings.extendDefaults(Base_Toolbar.settings, {
    enabled: true,
    "export": true,
    back: true,
    zoomOut: true,
    logScale: true,
    logScale_doc: {
      doc: "Whether to show the log scale button.",
      type: "bool"
    }
  });

  return Linearchart_Toolbar;

})();
// Generated by CoffeeScript 1.8.0
var Piechart_Settings,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

Piechart_Settings = (function(_super) {
  __extends(Piechart_Settings, _super);

  Piechart_Settings.FlatTheme = {
    advanced: {
      themeCSSClass: "DVSL-flat",
      assets: []
    },
    pie: {
      theme: "flat"
    }
  };

  Piechart_Settings.BevelTheme = {
    advanced: {
      themeCSSClass: "DVSL-flat",
      assets: []
    },
    pie: {
      theme: "bevel"
    }
  };

  Piechart_Settings.GradientTheme = {
    advanced: {
      themeCSSClass: "DVSL-flat",
      assets: []
    },
    pie: {
      theme: "smoothy"
    }
  };

  Piechart_Settings.CanTheme = {
    advanced: {
      themeCSSClass: "DVSL-flat",
      assets: []
    },
    pie: {
      theme: "can",
      depth: 8
    }
  };

  Piechart_Settings.defaults = Base_Settings.extendDefaults(Base_Settings.defaults, {
    theme: Piechart_Settings.FlatTheme,
    data: Piechart_Data.settings,
    legend: Piechart_Legend.settings,
    navigation: {
      _doc: {
        doc: "Settings to specify initial pie and visible slice offset once the page loaded..",
        type: "section"
      },
      initialDrilldown: "",
      initialDrilldown_doc: {
        doc: "Initial pie drilldown to show. For example ['', 'Firefox', 'Firefox 2.5'] denotes to various browsers grouped by versions.",
        type: "array",
        baseObject: "string"
      },
      initialOffset: 0,
      initialOffset_doc: {
        doc: "Initial offset, number of items from start.",
        type: "integer"
      },
      initialSelection: []
    },
    pie: {
      _doc: {
        doc: "Data values arranged in a circular manner.",
        type: "section"
      },
      radius: null,
      radius_doc: {
        doc: "Pie outer radius.",
        type: "enum",
        values: [
          {
            "null": "radius is determined automatically",
            "number": "radius in pixels"
          }
        ]
      },
      adaptiveRadius: true,
      adaptiveRadius_doc: {
        doc: "Whether to adapt pie outer radius dynamically to allow enough space for labels.",
        type: "bool"
      },
      outerMargin: 1,
      outerMargin_doc: {
        doc: "Pie outer margin.",
        type: "float",
        units: "pixels"
      },
      margin: 2,
      margin_doc: {
        doc: "Pie margin.",
        type: "float",
        units: "pixels"
      },
      centerMargin: 5,
      centerMargin_doc: {
        doc: "Pie center margin.",
        type: "integer",
        units: "pixels"
      },
      showInnerPiesExport: true,
      showInnerPiesExport_doc: {
        doc: "Whether to show inner pies on exported image.",
        type: "bool"
      },
      showInnerPies: true,
      showInnerPies_doc: {
        doc: "Whether to show inner pies on chart.",
        type: "bool"
      },
      innerRadius: 0.3,
      innerRadius_doc: {
        doc: "Pie inner radius. Inner pies are drawn inside this radius.",
        type: "float",
        values: {
          ">=1": "the value is multiplied by current pie radius to get inner radius.",
          "<=1": " inner radius in pixels."
        }
      },
      innerRadiusWhenDrilldown: 0.2,
      innerRadiusWhenDrilldown_doc: {
        doc: "Inner radius is extended to radius * innerRadiusWhenDrilldown when drilled down.",
        type: "float"
      },
      startAngle: -Math.PI / 2,
      startAngle_doc: {
        doc: "Start angle of the pie.",
        type: "float"
      },
      endAngle: Math.PI * 1.5,
      endAngle_doc: {
        doc: "End angle of the pie.",
        type: "float"
      },
      theme: "flat",
      theme_doc: {
        doc: "Default pie rendering theme. See see::examples/style/themes.html::themes:: for some examples.",
        type: "enum",
        values: ["flat", "bevel", "can", "smoothy"]
      },
      depth: 0,
      depth_doc: {
        doc: "Pie depth - used for raised theme.",
        type: "integer"
      },
      x: null,
      x_doc: {
        doc: "Center X coordinate of the pie chart.",
        type: "float",
        values: {
          "null": "coordinate is calculated automatically",
          ">1": " specifies the exact x value in pixels.",
          "<=1": "coordinate is a fraction of chart height"
        },
        units: "pixels"
      },
      y: null,
      y_doc: {
        doc: "Center Y coordinate of the pie chart.",
        type: "float",
        values: {
          "null": "coordinate is calculated automatically",
          ">1": " specifies the exact y value in pixels.",
          "<=1": "coordinate is a fraction of chart height"
        },
        units: "pixels"
      },
      style: {
        _doc: {
          doc: "Default pie rendering style.",
          type: "object",
          baseObject: Piechart_Pie.styleSettings
        },
        fillColor: "transparent",
        sliceColors: ["#2fc32f", "#b0dc0b", "#eab404", "#de672c", "#ec2e2e", "#d5429b", "#6f52b8", "#1c7cd5", "#56b9f7", "#0ae8eb"],
        colorDistribution: "list",
        brightness: 1
      },
      noDataStyle: {
        _doc: {
          doc: "Pie style when no data is present.",
          type: "object",
          baseObject: Piechart_Pie.styleSettings
        },
        fillColor: "#ddd"
      },
      backgroundStyle: {
        _doc: {
          doc: "Pie background style.",
          type: "object",
          baseObject: Piechart_Pie.styleSettings
        }
      },
      backgroundHoveredStyle: {
        _doc: {
          doc: "Hovered pie background style.",
          type: "object",
          baseObject: Piechart_Pie.styleSettings
        },
        brightness: 0.7
      },
      styleFunction: null,
      styleFunction_doc: {
        doc: "Dynamically determine pie style from data.",
        type: "function",
        parameters: {
          "pie": "pie to apply predefined style.",
          "pieData": "data relevant to pie"
        },
        returns: ""
      }
    },
    slice: {
      _doc: {
        doc: "Base unit inside the circle.",
        type: "section"
      },
      margin: 2,
      margin_doc: {
        doc: "Slice margin.",
        type: "float",
        units: "pixels"
      },
      minFraction: 0.0,
      minFraction_doc: {
        doc: "Controls minimal visual size of slice. Use this to make very small sizes visually bigger. The value represents smallest fraction of a full pie a slice will take. The range is between 0 and 1. For example using 0.05, all slices smaller than 5% will be grown up to 5%. Other slices will be made proportionally smaller to accommodate for extra size of small slices.",
        type: "float"
      },
      style: {
        _doc: {
          doc: "Slice style settings",
          type: "object",
          baseObject: Piechart_Slice.styleSettings
        },
        lineBrightness: 0,
        brightness: 1,
        cutoutDistance: 0,
        lineColor: null,
        lineWidth: 1,
        label: null,
        insideLabel: null,
        url: null,
        icon: null,
        lineDash: null
      },
      hoverStyle: {
        _doc: {
          doc: "Hovered slices style.",
          type: "object",
          baseObject: Piechart_Slice.styleSettings
        },
        brightness: 1.2,
        lineBrightness: 2,
        lineWidth: 0.35
      },
      selectedStyle: {
        _doc: {
          doc: "Selected slices style.",
          type: "object",
          baseObject: Piechart_Slice.styleSettings
        },
        cutoutDistance: 15
      },
      backgroundStyle: {
        _doc: {
          doc: "Slice style on background (back navigation) pies.",
          type: "object"
        },
        fillColor: "#e2e2e2",
        fillColor2: "#e0e0e0",
        fillColor2_doc: {
          doc: "Extra property to alternate fill colors on backgrond slices.",
          type: "color"
        }
      },
      backgroundActiveStyle: {
        _doc: {
          doc: "Style to active slices in background (back navigation) pies",
          type: "object"
        },
        brightness: 1.3
      },
      othersStyle: {
        _doc: {
          doc: "Style for others slice.",
          type: "object"
        },
        fillColor: "#ccc",
        lineDecoration: "zigzag",
        lineDecoration_doc: {
          doc: "Circumference decoration of 'others' slice.",
          type: "enum",
          values: ["zigzag"]
        }
      },
      previousStyle: {
        _doc: {
          doc: "'previous' slice  style.",
          type: "object"
        },
        fillColor: "#ccc",
        lineDecoration: "zigzag",
        lineDecoration_doc: {
          doc: "Circumference decoration of 'previous' slice.",
          type: "enum",
          values: ["zigzag"]
        }
      },
      connectorStyle: {
        _doc: {
          doc: "Label connector line style.",
          type: "object"
        },
        lineColor: "#333",
        lineWidth: 1
      },
      labelStyle: {
        _doc: {
          doc: "Outside labels style.",
          type: "object",
          baseObject: Base_Label.styleSettings
        },
        backgroundStyle: null,
        textStyle: {
          fillColor: "#000",
          font: "12px Arial"
        },
        lineSpacing: 0.2,
        margin: 4,
        padding: 0,
        borderRadius: 999
      },
      insideLabelStyle: {
        _doc: {
          doc: "Inside labels style.",
          type: "object",
          baseObject: Base_Label.styleSettings
        },
        textStyle: {
          fillColor: "#fff",
          font: "12px Arial"
        },
        lineSpacing: 0.2,
        margin: 4,
        padding: 0,
        borderRadius: 0
      },
      expandableMarkStyle: {
        _doc: {
          doc: "Expandable slice mark line style",
          type: "object"
        },
        lineWidth: 1,
        lineColor: "rgba(255,255,255,0.8)",
        distance: 4,
        lineDash: null
      },
      styleFunction: null,
      styleFunction_doc: {
        doc: "Dynamically determine slice style from data.",
        type: "function",
        parameters: {
          "slice": "slice to apply predefined style.",
          "sliceData": "slice data including subvalues."
        },
        returns: ""
      }
    },
    filters: {
      _doc: {
        doc: "Configurable conditions to filter the raw data values for subset of drawing slices.",
        type: "section"
      },
      sliceFilter: null,
      sliceFilter_doc: {
        doc: "Function to filter visible slices.",
        parameters: {
          "sliceData": "slice filtering data"
        },
        returns: "true to show the slice, false to hide the slice.",
        type: "function"
      }
    },
    labels: {
      _doc: {
        doc: "Label settings related to internal and external slice text and their connectors.",
        type: "section"
      },
      enabled: true,
      enabled_doc: {
        doc: "Show/hide labels.",
        type: "bool"
      },
      connectors: true,
      connectors_doc: {
        doc: "Whether to show connector lines for labels.",
        type: "bool"
      },
      connectorLength: 20,
      connectorLength_doc: {
        doc: "Minimal connector length from slice to label.",
        type: "integer",
        units: "pixels"
      },
      angle: 0,
      angle_doc: {
        doc: "Label rotation angle.",
        type: "integer"
      },
      insideLabel: "append",
      insideLabel_doc: {
        doc: "Inside label placement method.",
        type: "enum",
        values: {
          "always": "always show",
          "auto": "show only when available area is at least insideLabelVisibilityFraction from label size",
          "append": " same as auto, but append inside label to normal label when it cannot be shown inside."
        }
      },
      insideLabelVisibilityFraction: 0.8,
      insideLabelVisibilityFraction_doc: {
        doc: "Inside label is not shown if the fraction of label that fits inside slice is smaller than this.",
        type: "float"
      },
      interLabelSpacing: 0.6,
      interLabelSpacing_doc: {
        doc: "Min distance between labels, as a fraction of line height.",
        type: "float"
      },
      placement: "aligned",
      placement_doc: {
        doc: "Outside labels placement method.",
        type: "enum",
        values: {
          "aligned": "align labels in vertical lines",
          "wrap": "wrap labels tightly around pie"
        }
      }
    },
    icons: {
      _doc: {
        doc: "Slice icons as an additional element of style to highlight each individual slice or groups.",
        type: "section"
      },
      sizeExtent: [16, 64],
      sizeExtent_doc: {
        doc: "Min and max value of icon size. The icon size is automatically computed from available space.",
        type: "array",
        baseObject: "integer"
      },
      placement: "auto",
      placement_doc: {
        doc: "Icon placement method",
        type: "enum",
        values: {
          "auto": "maximize icon size",
          "center": "always place in center of slice"
        }
      },
      autohideWhenTooSmall: true,
      autohideWhenTooSmall_doc: {
        doc: "Whether to render icons if smaller than min value of sizeExtent.",
        type: "bool"
      }
    },
    advanced: {
      _doc: {
        doc: "Advanced chart settings. Be advised that they are subject to change, backwards compatibility is not guaranteed.",
        type: "section"
      },
      initialAnimation: true,
      initialAnimation_doc: {
        doc: "Enables/disables initial zoom-in animation.",
        type: "bool"
      },
      renderQuality: 1,
      renderQuality_doc: {
        doc: "Chart rendering quality. Note that it affects render performance for raised and gradient themes. Range 0 .. 1.",
        type: "integer"
      },
      backImage: "builtin://piechart-back",
      backImage_doc: {
        doc: "Image to display for back navigation.",
        type: "imageUrl"
      },
      backAlwaysVisible: false,
      backAlwaysVisible_doc: {
        doc: "Controls visibility of the back icon at the center of pie chart. If true, the back button is always visible, otherwise only on hover.",
        type: "bool"
      },
      assets: ["assets://piechart.css"],
      labelInsideTreshold: 1,
      labelInsideTreshold_doc: {
        doc: "Inside labels are not rendered if there is not enough space. So if available space is less than label size * treshold.",
        type: "integer"
      },
      pointer: {
        noClickOnDoubleClick: false
      },
      builtinAssets: {
        "piechart-back": Piechart_images_back
      }
    },
    events: {
      onPieChange: null,
      onPieReadyStateChanged: null
    },
    interaction: {
      _doc: {
        doc: "Configurable interactivity options to navigate among the slices and pie levels to facilitate analysis of the grouped data in different ways.",
        type: "section"
      },
      mode: "drilldown",
      mode_doc: {
        doc: "Interaction mode",
        type: "enum",
        values: {
          "drilldown": "performs drill down on click, if item is not expandable, selects it",
          "select": "selects items",
          "toggle": "toggle selects items."
        }
      },
      selection: {
        _doc: {
          doc: "One of interactivity option to use the data selection.",
          type: "section"
        },
        enabled: true,
        enabled_doc: {
          doc: "Enable/disable selection.",
          type: "bool"
        },
        tolerance: 2,
        tolerance_doc: {
          doc: "Selection distance tolerance.",
          type: "float",
          units: "pixels"
        }
      },
      others: {
        _doc: {
          doc: "Slice including all the values that can not be displayed as a separate slice. Use them to configure 'others' slice rendering space.",
          type: "section"
        },
        enabled: true,
        enabled_doc: {
          doc: "Enable/Disable Others/Previous slices.",
          type: "bool"
        },
        centerGoesToPrevious: false,
        centerGoesToPrevious_doc: {
          doc: "If true, when offset > 0 click on center acts as click on previous slice.",
          type: "bool"
        },
        navigationFraction: 0.15,
        navigationFraction_doc: {
          doc: "Others and Previous slice size as fraction of full pie.",
          type: "float"
        },
        maxSlicesVisible: 15,
        maxSlicesVisible_doc: {
          doc: "Max number of slices to show. All remaining slices will be replaced by 'Others' slice.",
          type: "integer"
        },
        maxOthersFraction: 0.6,
        maxOthersFraction_doc: {
          doc: "Max size of others slice, as a fraction of 1. If others slice is bigger than this, it will be made smaller and other slices proportionally expanded.",
          type: "float"
        },
        minSliceFraction: 0.01,
        minSliceFraction_doc: {
          doc: "Minimum slice size as fraction of full pie. All slices smaller than that are replaced with 'Others' slice.",
          type: "float"
        }
      },
      scrolling: {
        _doc: {
          doc: "One of interactivity option to scroll among data.",
          type: "section"
        },
        enabled: false,
        enabled_doc: {
          doc: "Enable/disable scrolling.",
          type: "bool"
        }
      },
      dragging: {
        _doc: {
          doc: "One of interactivity option to drag the content around the screen.",
          type: "section"
        },
        enabled: false,
        enabled_doc: {
          doc: "Enable/disable dragging.",
          type: "bool"
        }
      }
    },
    info: {
      _doc: {
        doc: "Rising content field while hovering over slice. Content returned in a form of html and is relevant to context of slice hovered.",
        type: "section"
      },
      enabled: true,
      enabled_doc: {
        doc: "Show/hide info popup.",
        type: "bool"
      },
      contentsFunction: null,
      contentsFunction_doc: {
        doc: "Prepare custom info popup contents. May return null and call callback(contents) later.",
        parameters: {
          "sliceData": "slice data including subvalues",
          "slice": "slice object to apply predefined content",
          "callback": "function called to return predefined content"
        },
        returns: "null",
        type: "function"
      }
    },
    toolbar: {
      enabled: false,
      items: ["back", "export"]
    },
    localization: {
      othersLabel: "Others",
      previousLabel: "Previous"
    }
  });

  function Piechart_Settings(settings) {
    Piechart_Settings.__super__.constructor.call(this, Piechart_Settings.defaults);
    this.apply(settings);
  }

  Piechart_Settings.prototype.apply = function(settings) {
    var changes;
    this.applyCompatibility(settings, [
      {
        from: "labels.connectorStyle",
        to: "slice.connectorStyle"
      }, {
        from: "labels.textStyle",
        to: "slice.labelStyle.textStyle"
      }, {
        from: "labels.backgroundStyle",
        to: "slice.labelStyle.backgroundStyle"
      }, {
        from: "labels.insideTextStyle",
        to: "slice.insideLabelStyle.textStyle"
      }, {
        from: "labels.padding",
        to: "slice.labelStyle.padding"
      }, {
        from: "labels.borderRadius",
        to: "slice.labelStyle.borderRadius"
      }, {
        from: "area.initialPieId",
        to: "navigation.initialDrilldown"
      }, {
        from: "area.initialPieOffset",
        to: "navigation.initialOffset"
      }, {
        from: "area.initialSelection",
        to: "navigation.initialSelection"
      }, {
        from: "area.initialAnimation",
        to: "advanced.initialAnimation"
      }
    ]);
    changes = Piechart_Settings.__super__.apply.call(this, settings);
    return changes;
  };

  return Piechart_Settings;

})(Base_Settings);
// Generated by CoffeeScript 1.8.0
var Piechart_Impl,
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

Piechart_Impl = (function(_super) {
  "use strict";
  __extends(Piechart_Impl, _super);

  Piechart_Impl.prototype.api = null;

  function Piechart_Impl(settings, api) {
    this.defaultDoubleClick = __bind(this.defaultDoubleClick, this);
    this.defaultClick = __bind(this.defaultClick, this);
    Piechart_Impl.__super__.constructor.call(this, new Piechart_Settings(settings), new Piechart_Scene());
    this.scene.loading = false;
    this.layers = new Piechart_Layers(this, this.scene);
    this.initialize(api);
    this.events.addElement(new Piechart_Scrolling(this));
    this.selection = this.events.addElement(new Piechart_Selection(this));
    this.scene.view = new Piechart_PieView(this);
    this.popup = this.events.addElement(new Piechart_InfoPopup(this));
    this.legend = this.events.addElement(new Piechart_Legend(this));
    this.events.addElement(new Piechart_Styles(this));
    this.navigator = this.events.addElement(new Piechart_Navigator(this));
    this.events.addElement(this.scene.view);
    this.finalInitialize();
    this.navigator.setPie(this.settings.navigation.initialDrilldown, this.settings.navigation.initialOffset, "init");
  }

  Piechart_Impl.prototype.createDataObj = function(dataSettings) {
    return new Piechart_Data(this, dataSettings);
  };

  Piechart_Impl.prototype.onRemove = function() {
    this.layers = null;
    this.renderer = null;
    return this.scene = null;
  };

  Piechart_Impl.prototype.onSettingsChanged = function(changes) {
    var ch;
    ch = {};
    if (changes.area) {
      if (changes.navigation) {
        this.navigator.setPie(this.settings.navigation.initialDrilldown, this.settings.navigation.initialOffset);
      }
    }
    if (changes.labels || changes.icons || changes.pie || changes.slice || changes.interaction) {
      ch.pie = true;
    }
    return this.events.notifySceneChanges(ch);
  };

  Piechart_Impl.prototype.save = function() {
    var selectionIds;
    selectionIds = this.saveSelection();
    return JSON.stringify({
      pie: this.navigator.getPie(),
      offset: this.navigator.getPieOffset(),
      selection: selectionIds
    });
  };

  Piechart_Impl.prototype.restore = function(stateStr, animate) {
    var pie;
    if (!stateStr) {
      return;
    }
    pie = JSON.parse(stateStr);
    this.setPie(pie.pie, pie.offset, animate);
    return this.setSelection(pie.selection);
  };

  Piechart_Impl.prototype.updateFilters = function() {
    return this.updateFilter(true);
  };

  Piechart_Impl.prototype.updateFilter = function(deep) {
    this.log("Update filter");
    return this.events.notifySceneChanges({
      data: true,
      dataDeep: deep
    });
  };

  Piechart_Impl.prototype.setSelection = function(selection) {
    var n, realSelection, selectionIds, _i, _len;
    this.log("Set selection");
    realSelection = [];
    selectionIds = [];
    for (_i = 0, _len = selection.length; _i < _len; _i++) {
      n = selection[_i];
      if (n instanceof Piechart_Slice) {
        realSelection.push(n);
      } else if (Base_Helpers.isString(n)) {
        selectionIds.push(n);
      } else {
        this.error("SetSelection: Selection contents must be Piechart_Slice object or string, got " + n);
      }
    }
    return this.selection.setSelection(realSelection, selectionIds, false, "api");
  };

  Piechart_Impl.prototype.saveSelection = function() {
    var s, selectionIds, _i, _len, _ref;
    selectionIds = this.scene.selectionIds.splice(0);
    _ref = this.scene.selection;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      s = _ref[_i];
      selectionIds.push(s.id);
    }
    return selectionIds;
  };

  Piechart_Impl.prototype.setPie = function(root, offset, animate, origin) {
    if (animate == null) {
      animate = true;
    }
    if (origin == null) {
      origin = "api";
    }
    this.log("Set pie");
    return this.navigator.setPie(root, offset, origin);
  };

  Piechart_Impl.prototype.setPieOffset = function(offset, animate, origin) {
    if (animate == null) {
      animate = true;
    }
    if (origin == null) {
      origin = "api";
    }
    this.log("Set pie offset");
    return this.navigator.setPie(this.getPie(), offset, origin);
  };

  Piechart_Impl.prototype.getPie = function() {
    return this.navigator.getPie();
  };

  Piechart_Impl.prototype.getActiveSlices = function() {
    var pie, r, _i, _len, _ref;
    r = [];
    _ref = this.scene.stack;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      pie = _ref[_i];
      if (pie.parentSlice) {
        r.push(pie.parentSlice);
      }
    }
    return r;
  };

  Piechart_Impl.prototype.getActivePies = function() {
    return this.scene.stack;
  };

  Piechart_Impl.prototype.expandSlice = function(slice, origin) {
    return this.navigator.expandSlice(slice, origin);
  };

  Piechart_Impl.prototype.getSliceDimensions = function(sliceId, showPartial) {
    var pie, pos, rp, sid, slice, _i, _j, _len, _len1, _ref, _ref1;
    if (!Base_Helpers.isArray(sliceId)) {
      this.error("getSliceDimensions: slice Id must be an array");
      return null;
    }
    if (sliceId.length < 2) {
      return null;
    }
    if (!showPartial && this.scene.stack.length + 1 < sliceId.length) {
      return null;
    }
    pos = 0;
    _ref = this.scene.stack;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      pie = _ref[_i];
      if (pie.id !== sliceId[pos]) {
        return null;
      }
      pos += 1;
      if (pos === sliceId.length - 1) {
        break;
      }
    }
    sid = sliceId[pos];
    _ref1 = pie.slices;
    for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
      slice = _ref1[_j];
      if (slice.id === sid) {
        rp = slice.renderParams;
        if (!rp) {
          return null;
        }
        return [pie.x, pie.y, rp[0], rp[1], rp[2], rp[3]];
      }
    }
    return null;
  };


  /* events */

  Piechart_Impl.prototype.saveNavigation = function() {
    var pie;
    pie = this.scene.peek();
    if (!(pie && !pie.loading)) {
      return null;
    }
    return {
      pie: this.navigator.getPie(),
      offset: this.navigator.getPieOffset()
    };
  };

  Piechart_Impl.prototype.restoreNavigation = function(state, animate, origin) {
    return this.navigator.setPie(state.pie, state.offset, origin);
  };

  Piechart_Impl.prototype.doChartUpdateNotify = function(origin) {
    Piechart_Impl.__super__.doChartUpdateNotify.call(this, origin);
    this.dispatchEventParams("pieChange", this.extendEventParams({
      origin: origin
    }), null);
    return this.dispatchEventParams("pieReadyStateChanged", this.extendEventParams({
      origin: origin
    }), null);
  };

  Piechart_Impl.prototype.extendEventParams = function(p) {
    var pie;
    pie = this.scene.peek();
    p.pie = pie;
    p.offset = pie.offset;
    p.count = pie.count;
    p.slice = this.scene.hoverSlice;
    p.label = this.scene.hoverLabel;
    p.clickSlice = p.slice;
    p.selection = this.scene.selection;
    return p;
  };

  Piechart_Impl.prototype.defaultClick = function(event) {
    var isDrilldown, p, s;
    s = event.slice;
    p = event.clickPie;
    isDrilldown = this.settings.interaction.mode === "drilldown";
    if (isDrilldown || (s && (s === s.pie.othersSlice || s === s.pie.previousSlice))) {
      if (s) {
        if (s.url) {
          Base_Helpers.openUrl(s.url);
          return event.preventDefault();
        } else {
          if (this.navigator.expandSlice(s, "user")) {
            return event.preventDefault();
          }
        }
      } else if (p) {
        this.setSelection([], "user");
        this.navigator.goCenter("user");
        return event.preventDefault();
      }
    }
  };

  Piechart_Impl.prototype.defaultDoubleClick = function(event) {};

  return Piechart_Impl;

})(Base_Impl);
// Generated by CoffeeScript 1.8.0
var Itemschart_Settings,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

Itemschart_Settings = (function(_super) {
  __extends(Itemschart_Settings, _super);

  Itemschart_Settings.defaults = Base_Settings.extendDefaults(Base_Settings.defaults, {
    data: {
      cacheSize: 10000,
      cacheSize_doc: {
        doc: "Count of caching items including only links and nodes.",
        type: "integer"
      },
      random: null,
      randomGridLinkProbability: 0.6,
      randomNodes: 0,
      randomLinks: 0,
      randomTreeDensity: 3,
      requestMaxUnits: 2,
      requestMaxUnits_doc: {
        doc: "Max number of nodes to submit in a single request.",
        type: "integer"
      },
      preloadNodeLinks: false,
      preloadNodeLinks_doc: {
        doc: "Whether to load links for all disabled nodes automatically. Otherwise, links will be loaded only when expanding a node.",
        type: "bool"
      }
    },
    info: {
      _doc: {
        doc: "Info popup for item – menaing links or nodes - with configurable content rendered.",
        type: "section"
      },
      enabled: false,
      enabled_doc: {
        doc: "Show/hide info popup",
        type: "bool"
      },
      nodeContentsFunction: null,
      nodeContentsFunction_doc: {
        doc: "Returns html string to display in passed nodes info popup.",
        type: "function",
        parameters: {
          "node": "node object"
        },
        returns: "a HTML string to display in info popup."
      },
      linkContentsFunction: null,
      linkContentsFunction_doc: {
        doc: "Returns html string to display in passed links info popup.",
        type: "function",
        parameters: {
          "link": "link object"
        },
        returns: "a HTML string to display in info popup."
      }
    },
    interaction: {
      nodesMovable: true,
      nodesMovable_doc: {
        doc: "Whether to allow moving nodes around.",
        type: "bool"
      },
      zooming: {
        _doc: {
          doc: "Zoom in or out by swiping up or down with mouse scroll pad or by using the Zoom-out feature at the top left.",
          type: "section"
        },
        zoomInOnDoubleClick: true,
        zoomInOnDoubleClick_doc: {
          doc: "Enable/Disable zoom in on double click.",
          type: "bool"
        },
        doubleClickZoom: 1.5,
        doubleClickZoom_doc: {
          doc: "A double-click on empty space will trigger zoom in by this value. Set to null or false to disable double click zooming.",
          type: "float"
        },
        sensitivity: 1,
        sensitivity_doc: {
          doc: "Sensitivity of wheel zoom.",
          type: "float"
        },
        wheel: true,
        wheel_doc: {
          doc: "Whether to zoom by mouse wheel.",
          type: "bool"
        },
        fingers: true,
        fingers_doc: {
          doc: "Whether to zoom by two finger pinch.",
          type: "bool"
        }
      },
      panning: {
        _doc: {
          doc: "Move chart vertically and horizontally by clicking on the main chart pane and dragging it on any direction.",
          type: "section"
        },
        enabled: true,
        enabled_doc: {
          doc: "Enables/disables chart panning.",
          type: "bool"
        }
      },
      selection: {
        _doc: {
          doc: "Select node to expand it or getting path.",
          type: "section"
        },
        enabled: true,
        enabled_doc: {
          doc: "Enable/disable selection.",
          type: "bool"
        },
        nodesSelectable: true,
        nodesSelectable_doc: {
          doc: "Whether to set nodes selectable.",
          type: "bool"
        },
        linksSelectable: true,
        linksSelectable_doc: {
          doc: "Whether to set links selectable.",
          type: "bool"
        },
        tolerance: 10,
        tolerance_doc: {
          doc: "Max click distance from object that still counts as click on the object.",
          type: "float",
          units: "pixels"
        }
      }
    },
    nodeMenu: {
      _doc: {
        doc: "Configurable node menu with option to specify a range of displaying buttons.",
        type: "section"
      },
      enabled: true,
      enabled_doc: {
        doc: "Show/hide node menu.",
        type: "bool"
      },
      showData: false,
      showData_doc: {
        doc: "Whether to add a view data button to the menu. Useful for debugging.",
        type: "bool"
      },
      buttons: [],
      buttons_doc: {
        doc: "Buttons to show in node menu.",
        type: "array",
        baseObject: "string"
      },
      contentsFunction: null,
      contentsFunction_doc: {
        doc: "Prepare html string to include in the nodes menu. Called whenever a node menu is about to be shown.",
        type: "function",
        parameters: {
          "data": "node data",
          "node": "the node object",
          "callback": "callback function"
        },
        returns: "a HTML string to include in the menu. Alternatively return null and call callback(string) later."
      }
    },
    linkMenu: {
      _doc: {
        doc: "Configurable link menu with option to specify a range of displaying buttons.",
        type: "section"
      },
      enabled: true,
      enabled_doc: {
        doc: "Show/hide link menu.",
        type: "bool"
      },
      showData: false,
      showData_doc: {
        doc: "Whether to add a view data button to the menu. Useful for debugging.",
        type: "bool"
      },
      contentsFunction: null,
      contentsFunction_doc: {
        doc: "Prepare html string to include in the links menu. Called whenever a link menu is about to be shown.",
        type: "function",
        parameters: {
          "data": "link data",
          "link": "the link object",
          "callback": "callback function"
        },
        returns: "a HTML string to include in the menu. Alternatively return null and call callback(string) later."
      }
    },
    advanced: {
      perNodeLoadingIndicator: true,
      perNodeLoadingIndicator_doc: {
        doc: "Whether to display a loading indicator on every node, otherwise only a global loading indicator.",
        type: "bool"
      },
      style: {
        loadingArcStyle: {
          location: "corner",
          location_doc: {
            doc: "Loading indicator location. If any other value used, location will be in the middle of the chart.",
            type: "string"
          }
        }
      }
    }
  });

  function Itemschart_Settings(defaults) {
    Itemschart_Settings.__super__.constructor.call(this, defaults);
  }

  Itemschart_Settings.prototype.apply = function(settings) {
    var changes, p, r, _ref, _ref1;
    this.applyCompatibility(settings, [
      {
        from: "style.makeImagesCircular",
        to: "style.node.imageCropping"
      }, {
        from: "style.nodeDecorationMinSize",
        to: null,
        alternative: "style.nodeDetailMinSize"
      }, {
        from: "style.nodeLabelMinSize",
        to: "style.nodeDetailMinSize"
      }
    ]);
    changes = Itemschart_Settings.__super__.apply.call(this, settings);
    if (settings.style) {
      if (settings.style.nodeRules) {
        _ref = settings.style.nodeRules;
        for (p in _ref) {
          r = _ref[p];
          this.style.nodeRules[p] = r;
        }
      }
      if (settings.style.linkRules) {
        _ref1 = settings.style.linkRules;
        for (p in _ref1) {
          r = _ref1[p];
          this.style.linkRules[p] = r;
        }
      }
    }
    return changes;
  };

  return Itemschart_Settings;

})(Base_Settings);
// Generated by CoffeeScript 1.8.0
var Itemschart_NodesStyle,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

Itemschart_NodesStyle = (function(_super) {
  __extends(Itemschart_NodesStyle, _super);

  Itemschart_NodesStyle.settings = Base_Settings.extendDefaults(Itemschart_ItemsStyle.settings, {
    multilinkSpacing: 10,
    multilinkSpacing_doc: {
      doc: "Distance between multiple links between two nodes.",
      type: "float",
      units: "pixels"
    },
    nodeRadiusExtent: [10, 150],
    nodeRadiusExtent_doc: {
      doc: "Min and max value of node radius, before zooming is applied.",
      type: "array",
      baseObject: "integer"
    },
    linkRadiusExtent: [0.6, 30],
    linkRadiusExtent_doc: {
      doc: "Min and max value of link half-width before zooming is applied.",
      type: "array",
      baseObject: "float"
    },
    linkStrengthExtent: [0.1, 1],
    linkStrengthExtent_doc: {
      doc: "Min and max value for link strength.",
      type: "array",
      baseObject: "float"
    },
    linkLengthExtent: [0.3, 150],
    linkLengthExtent_doc: {
      doc: "Min and max value of link length before zooming is applied.",
      type: "array",
      baseObject: "float"
    },
    nodeAutoScaling: null,
    nodeAutoScaling_doc: {
      doc: "Controls automatic node scaling.",
      type: "enum",
      values: {
        "null": "scaling disabled",
        "linear": "distribute node radii linearly in the range defined by nodeRadiusExten",
        "logaritmic": "distribute node radii logarithmicaly in the range defined by nodeRadiusExtent."
      }
    },
    linkAutoScaling: null,
    linkAutoScaling_doc: {
      doc: "Link radius auto distribution method.",
      type: "enum",
      values: {
        "null": "scaling disabled",
        "linear": "distribute link radii linearly between min, max value of linkRadiusExtent",
        "logaritmic": "distribute link radii logarithmically between min, max value of linkRadiusExtent."
      }
    },
    linkStrengthAutoScaling: null,
    linkStrengthAutoScaling_doc: {
      doc: "Link strength auto distribution method.",
      type: "enum",
      values: {
        "null": "scaling disabled",
        "linear": "distribute link strengths linearly between min, max value of linkStrengthExtent",
        "logaritmic": " distribute link strengths logarithmically between min, max value of linkStrengthExtent."
      }
    },
    linkLengthAutoScaling: null,
    linkLengthAutoScaling_doc: {
      doc: "Link length auto distribution method.",
      type: "enum",
      values: {
        "null": "scaling disabled",
        "linear": "distribute link lengths linearly between min, max value of linkLengthExtent",
        "logaritmic": " distribute link lengths logarithmically between min, max value of linkLengthExtent."
      }
    },
    selection: {
      _doc: {
        doc: "Selection highlight style. The selection highlight area is determined by sum of `sizeContant` and `sizeProportional` parameters.",
        type: "object"
      },
      fillColor: "lightblue",
      sizeConstant: 5,
      sizeConstant_doc: {
        doc: "Selection size in pixels around the highlight style.",
        type: "float",
        units: "pixels"
      },
      sizeProportional: 0.2,
      sizeProportional_doc: {
        doc: "Selection size as fraction of the object size.",
        type: "float"
      }
    },
    hiddenLinks: {
      _doc: {
        doc: "style for hidden link hints.",
        type: "object"
      },
      fillColor: "#BBB",
      lineColor: "rgba(100,100,100,0.3)",
      lineWidth: 1,
      size: 7
    },
    fadeTime: 600,
    fadeTime_doc: {
      doc: "Removed object fadeout time.",
      type: "integer",
      units: "milliseconds"
    }
  });

  function Itemschart_NodesStyle(styleSettings, fadeout) {
    this.styleSettings = styleSettings;
    this.fadeout = fadeout;
    Itemschart_NodesStyle.__super__.constructor.call(this, this.styleSettings);
  }

  Itemschart_NodesStyle.prototype.updateItems = function(event, layer, isIncremental) {
    var g, id, id2, id3, link1, links, n, node, node1, nodes, removedColor, _i, _len, _ref, _ref1, _ref2;
    if (isIncremental == null) {
      isIncremental = false;
    }
    this.nodeRadiusChanged = Base_Helpers.hasProperties(layer.newNodes) || Base_Helpers.hasProperties(layer.deletedNodes);
    this.linkRadiusChanged = Base_Helpers.hasProperties(layer.newLinks) || Base_Helpers.hasProperties(layer.deletedLinks);
    Itemschart_NodesStyle.__super__.updateItems.call(this, event, layer, isIncremental);
    removedColor = this.styleSettings.removedColor;
    g = event.context;
    this.itemRenderer = event.labelRenderer;
    _ref = layer.modifiedLinks;
    for (id3 in _ref) {
      link1 = _ref[id3];
      if (this.fadeout && link1.relevance < 1) {
        if (link1.fillColor) {
          link1.fillColor = Base_Graphics.blendColors(removedColor, link1.fillColor, link1.relevance);
        }
        if (link1.lineColor) {
          link1.lineColor = Base_Graphics.blendColors(removedColor, link1.lineColor, link1.relevance);
        }
        link1.length = 0.2 + (link1.length - 0.2) * link1.relevance;
      }
      this.postprocessLink(link1, g);
    }
    _ref1 = layer.modifiedNodes;
    for (id in _ref1) {
      node = _ref1[id];
      if (this.fadeout && node.relevance < 1) {
        if (node.fillColor) {
          node.fillColor = Base_Graphics.blendColors(removedColor, node.fillColor, node.relevance);
        }
        if (node.lineColor) {
          node.lineColor = Base_Graphics.blendColors(removedColor, node.lineColor, node.relevance);
        }
      }
    }
    nodes = layer.nodes();
    if (this.nodeRadiusChanged || (this.fadeout && event.changes.navigation)) {
      this.computeNodeSize(nodes, this.styleSettings.nodeAutoScaling, this.styleSettings.nodeRadiusExtent);
      for (_i = 0, _len = nodes.length; _i < _len; _i++) {
        n = nodes[_i];
        this.postprocessNode(n, g);
      }
    } else {
      _ref2 = layer.modifiedNodes;
      for (id2 in _ref2) {
        node1 = _ref2[id2];
        this.postprocessNode(node1, g);
      }
    }
    if (this.linkRadiusChanged || event.changes.navigation) {
      links = layer.links();
      this.computeRadii(links, this.styleSettings.linkAutoScaling, this.styleSettings.linkRadiusExtent);
      this.computeStrengths(links, this.styleSettings.linkStrengthAutoScaling, this.styleSettings.linkStrengthExtent);
      this.computeLengths(links, this.styleSettings.linkLengthAutoScaling, this.styleSettings.linkLengthExtent);
      Base_Helpers.sort(links, function(a, b) {
        if (a.targetRadius === b.targetRadius) {
          return 0;
        }
        if (a.targetRadius > b.targetRadius) {
          return 1;
        } else {
          return -1;
        }
      });
    }
    return Base_Helpers.sort(nodes, function(a, b) {
      return a.zindex - b.zindex;
    });
  };

  Itemschart_NodesStyle.prototype.updateLink = function(link) {
    var r;
    r = link.radius;
    Itemschart_NodesStyle.__super__.updateLink.call(this, link);
    if (r !== link.radius) {
      return this.linkRadiusChanged = true;
    }
  };

  Itemschart_NodesStyle.prototype.updateNode = function(node) {
    var r;
    r = node.radius;
    Itemschart_NodesStyle.__super__.updateNode.call(this, node);
    if (r !== node.radius) {
      this.nodeRadiusChanged = true;
    }
    if ((node.label == null) && node.data) {
      return node.label = node.data.id;
    }
  };

  Itemschart_NodesStyle.prototype.computeNodeSize = function(nodes, mode, extents) {
    var max, maxE, min, minE, mul, obj, r, _i, _j, _k, _l, _len, _len1, _len2, _len3, _len4, _len5, _len6, _m, _n, _o, _results;
    minE = extents[0], maxE = extents[1];
    if (mode === "linear" || mode === "logarithmic" || mode === "square") {
      min = Infinity;
      max = -Infinity;
      for (_i = 0, _len = nodes.length; _i < _len; _i++) {
        obj = nodes[_i];
        if (!obj.removed) {
          r = obj.radius;
          if (Base_Helpers.isNumber(r)) {
            min = Math.min(min, r);
            max = Math.max(max, r);
          } else {
            obj.targetHHeight = minE;
          }
        }
      }
      if (min >= max) {
        for (_j = 0, _len1 = nodes.length; _j < _len1; _j++) {
          obj = nodes[_j];
          if (!obj.removed) {
            obj.targetHHeight = minE;
          }
        }
      } else if (mode === "linear") {
        mul = maxE / max;
        for (_k = 0, _len2 = nodes.length; _k < _len2; _k++) {
          obj = nodes[_k];
          if (!obj.removed) {
            r = obj.radius;
            if (Base_Helpers.isNumber(r)) {
              obj.targetHHeight = Math.max(minE, r * mul);
            }
          }
        }
      } else if (mode === "square") {
        mul = maxE / Math.sqrt(max);
        for (_l = 0, _len3 = nodes.length; _l < _len3; _l++) {
          obj = nodes[_l];
          if (!obj.removed) {
            r = obj.radius;
            if (Base_Helpers.isNumber(r)) {
              obj.targetHHeight = Math.max(minE, Math.sqrt(r) * mul);
            }
          }
        }
      } else {
        min = Math.max(0.0001, min);
        max = Math.max(min + 0.0001, max);
        mul = maxE / Math.log(max);
        for (_m = 0, _len4 = nodes.length; _m < _len4; _m++) {
          obj = nodes[_m];
          if (!obj.removed && Base_Helpers.isNumber(obj.radius)) {
            obj.targetHHeight = Math.max(minE, Math.log(Math.max(0.0001, obj.radius)) * mul);
          }
        }
      }
    } else {
      for (_n = 0, _len5 = nodes.length; _n < _len5; _n++) {
        obj = nodes[_n];
        if (!obj.removed) {
          if (Base_Helpers.isNumber(obj.radius)) {
            obj.targetHHeight = Math.min(Math.max(0.000001, obj.radius), 1e30);
          } else {
            obj.targetHHeight = minE;
          }
        }
      }
    }
    if (this.fadeout) {
      _results = [];
      for (_o = 0, _len6 = nodes.length; _o < _len6; _o++) {
        obj = nodes[_o];
        if (obj.relevance < 1) {
          _results.push(obj.targetHHeight = obj.targetHHeight * obj.relevance);
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    }
  };

  Itemschart_NodesStyle.prototype.computeRadii = function(objects, mode, extents) {
    var max, maxE, min, minE, mul, obj, r, _i, _j, _k, _l, _len, _len1, _len2, _len3, _len4, _len5, _len6, _m, _n, _o, _results;
    minE = extents[0], maxE = extents[1];
    if (mode === "linear" || mode === "logarithmic" || mode === "square") {
      min = Infinity;
      max = -Infinity;
      for (_i = 0, _len = objects.length; _i < _len; _i++) {
        obj = objects[_i];
        if (!obj.removed) {
          r = obj.radius;
          if (Base_Helpers.isNumber(r)) {
            min = Math.min(min, r);
            max = Math.max(max, r);
          } else {
            obj.targetRadius = minE;
          }
        }
      }
      if (min >= max) {
        for (_j = 0, _len1 = objects.length; _j < _len1; _j++) {
          obj = objects[_j];
          if (!obj.removed) {
            obj.targetRadius = minE;
          }
        }
      } else if (mode === "linear") {
        mul = maxE / max;
        for (_k = 0, _len2 = objects.length; _k < _len2; _k++) {
          obj = objects[_k];
          if (!obj.removed) {
            r = obj.radius;
            if (Base_Helpers.isNumber(r)) {
              obj.targetRadius = Math.max(minE, r * mul);
            }
          }
        }
      } else if (mode === "square") {
        mul = maxE / Math.sqrt(max);
        for (_l = 0, _len3 = objects.length; _l < _len3; _l++) {
          obj = objects[_l];
          if (!obj.removed) {
            r = obj.radius;
            if (Base_Helpers.isNumber(r)) {
              obj.targetRadius = Math.max(minE, Math.sqrt(r) * mul);
            }
          }
        }
      } else {
        min = Math.max(0.0001, min);
        max = Math.max(min + 0.0001, max);
        mul = maxE / Math.log(max);
        for (_m = 0, _len4 = objects.length; _m < _len4; _m++) {
          obj = objects[_m];
          if (!obj.removed && Base_Helpers.isNumber(obj.radius)) {
            obj.targetRadius = Math.max(minE, Math.log(Math.max(0.0001, obj.radius)) * mul);
          }
        }
      }
    } else {
      for (_n = 0, _len5 = objects.length; _n < _len5; _n++) {
        obj = objects[_n];
        if (!obj.removed) {
          if (Base_Helpers.isNumber(obj.radius)) {
            obj.targetRadius = Math.min(Math.max(0.000001, obj.radius), 1e30);
          } else {
            obj.targetRadius = minE;
          }
        }
      }
    }
    if (this.fadeout) {
      _results = [];
      for (_o = 0, _len6 = objects.length; _o < _len6; _o++) {
        obj = objects[_o];
        if (obj.relevance < 1) {
          _results.push(obj.targetRadius = obj.targetRadius * obj.relevance);
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    }
  };

  Itemschart_NodesStyle.prototype.computeStrengths = function(objects, mode, extents) {
    var max, maxE, min, minE, mul, obj, r, _i, _j, _k, _l, _len, _len1, _len2, _len3, _len4, _len5, _m, _n, _results, _results1, _results2, _results3, _results4;
    minE = extents[0], maxE = extents[1];
    if (mode === "linear" || mode === "logarithmic" || mode === "square") {
      min = Infinity;
      max = -Infinity;
      for (_i = 0, _len = objects.length; _i < _len; _i++) {
        obj = objects[_i];
        if (!obj.removed) {
          min = Math.min(min, obj.strength);
          max = Math.max(max, obj.strength);
        }
      }
      if (min >= max) {
        _results = [];
        for (_j = 0, _len1 = objects.length; _j < _len1; _j++) {
          obj = objects[_j];
          if (!obj.removed) {
            _results.push(obj.targetStrength = minE);
          } else {
            _results.push(void 0);
          }
        }
        return _results;
      } else if (mode === "linear") {
        mul = maxE / max;
        _results1 = [];
        for (_k = 0, _len2 = objects.length; _k < _len2; _k++) {
          obj = objects[_k];
          if (!obj.removed) {
            _results1.push(obj.targetStrength = Math.min(minE, obj.strength * mul));
          } else {
            _results1.push(void 0);
          }
        }
        return _results1;
      } else if (mode === "square") {
        mul = maxE / Math.sqrt(max);
        _results2 = [];
        for (_l = 0, _len3 = objects.length; _l < _len3; _l++) {
          obj = objects[_l];
          if (!obj.removed) {
            r = obj.strength;
            if (Base_Helpers.isNumber(r)) {
              _results2.push(obj.targetStrength = Math.max(minE, Math.sqrt(r) * mul));
            } else {
              _results2.push(void 0);
            }
          } else {
            _results2.push(void 0);
          }
        }
        return _results2;
      } else {
        min = Math.max(0.0001, min);
        max = Math.max(min + 0.0001, max);
        mul = maxE / Math.log(max);
        _results3 = [];
        for (_m = 0, _len4 = objects.length; _m < _len4; _m++) {
          obj = objects[_m];
          if (!obj.removed) {
            _results3.push(obj.targetStrength = Math.max(minE, Math.log(Math.max(0.0001, obj.strength)) * mul));
          } else {
            _results3.push(void 0);
          }
        }
        return _results3;
      }
    } else {
      _results4 = [];
      for (_n = 0, _len5 = objects.length; _n < _len5; _n++) {
        obj = objects[_n];
        if (!obj.removed) {
          _results4.push(obj.targetStrength = Math.min(Math.max(minE, obj.strength), maxE));
        } else {
          _results4.push(void 0);
        }
      }
      return _results4;
    }
  };

  Itemschart_NodesStyle.prototype.computeLengths = function(objects, mode, extents) {
    var add, max, maxE, min, minE, mul, obj, r, _i, _j, _k, _l, _len, _len1, _len2, _len3, _len4, _len5, _m, _n, _results, _results1, _results2, _results3, _results4;
    minE = extents[0], maxE = extents[1];
    if (mode === "linear" || mode === "logarithmic" || mode === "square") {
      min = Infinity;
      max = -Infinity;
      for (_i = 0, _len = objects.length; _i < _len; _i++) {
        obj = objects[_i];
        if (!obj.removed) {
          min = Math.min(min, obj.length);
          max = Math.max(max, obj.length);
        }
      }
      if (min >= max) {
        _results = [];
        for (_j = 0, _len1 = objects.length; _j < _len1; _j++) {
          obj = objects[_j];
          if (!obj.removed) {
            _results.push(obj.targetLength = minE);
          } else {
            _results.push(void 0);
          }
        }
        return _results;
      } else if (mode === "linear") {
        mul = (maxE - minE) / (max - min);
        add = maxE - max * mul;
        _results1 = [];
        for (_k = 0, _len2 = objects.length; _k < _len2; _k++) {
          obj = objects[_k];
          if (!obj.removed) {
            _results1.push(obj.targetLength = obj.length * mul + add);
          } else {
            _results1.push(void 0);
          }
        }
        return _results1;
      } else if (mode === "square") {
        mul = maxE / Math.sqrt(max);
        _results2 = [];
        for (_l = 0, _len3 = objects.length; _l < _len3; _l++) {
          obj = objects[_l];
          if (!obj.removed) {
            r = obj.length;
            if (Base_Helpers.isNumber(r)) {
              _results2.push(obj.targetLength = Math.max(minE, Math.sqrt(r) * mul));
            } else {
              _results2.push(void 0);
            }
          } else {
            _results2.push(void 0);
          }
        }
        return _results2;
      } else {
        min = Math.max(0.0001, min);
        max = Math.max(min + 0.0001, max);
        mul = (maxE - minE) / Math.log(max / min);
        add = maxE - mul * Math.log(max);
        _results3 = [];
        for (_m = 0, _len4 = objects.length; _m < _len4; _m++) {
          obj = objects[_m];
          if (!obj.removed) {
            _results3.push(obj.targetLength = Math.log(Math.max(0.0001, obj.length)) * mul + add);
          } else {
            _results3.push(void 0);
          }
        }
        return _results3;
      }
    } else {
      _results4 = [];
      for (_n = 0, _len5 = objects.length; _n < _len5; _n++) {
        obj = objects[_n];
        if (!obj.removed) {
          _results4.push(obj.targetLength = Math.min(Math.max(minE, obj.length), maxE));
        } else {
          _results4.push(void 0);
        }
      }
      return _results4;
    }
  };

  Itemschart_NodesStyle.prototype.postprocessNode = function(node, g) {
    var bottom, display, fx, fy, h, hh, ix, iy, l, left, ls, right, scale, sizeScale, top, w, ww, xx, yy, _i, _len, _ref;
    display = node.display;
    l = null;
    node.targetHWidth = node.targetHHeight;
    left = -node.targetHWidth;
    right = node.targetHWidth;
    top = -node.targetHHeight;
    bottom = node.targetHHeight;
    sizeScale = node.targetHHeight / this.styleSettings.nodeLabelScaleBase;
    if (node.label) {
      if (display === "text") {
        h = node.targetHHeight;
        l = new Base_Label(node.labelStyle);
        l.text = node.label.toString();
        l.backgroundStyle = null;
        l.image = null;
        this.itemRenderer.measure(g, l);
        ww = l.hwidth;
        hh = l.hheight;
        w = (ww / hh) * h;
        if (node.image) {
          w += h;
        }
        node.targetHWidth = Math.max(w, h);
        left = -node.targetHWidth;
        right = node.targetHWidth;
      } else if (display === "roundtext") {
        ls = node.labelStyle;
        ls.backgroundStyle.fillColor = "transparent";
        l = new Base_Label(ls);
        l.text = node.label.toString();
        l.aspectRatio = 1;
        l.image = null;
      } else {
        l = new Base_Label(node.labelStyle);
        l.text = node.label.toString();
        this.itemRenderer.measure(g, l);
        if (l.scaleWithSize) {
          scale = sizeScale;
        } else if (l.scaleWithZoom) {
          scale = 1;
        } else {
          scale = 1;
        }
        xx = 0;
        yy = node.targetHHeight + l.hheight * scale * 0.8;
        left = Math.min(left, xx - l.hwidth * scale);
        right = Math.max(right, xx + l.hwidth * scale);
        top = Math.min(top, yy - l.hheight * scale);
        bottom = Math.max(bottom, yy + l.hheight * scale);
      }
    }
    node.currentLabel = l;
    node.currentItems = [];
    this.postprocessItems(node);
    _ref = node.currentItems;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      l = _ref[_i];
      this.itemRenderer.measure(g, l);
      w = node.targetHWidth;
      h = node.targetHHeight;
      if (l.scaleWithSize) {
        scale = sizeScale;
      } else if (l.scaleWithZoom) {
        scale = 1;
      } else {
        scale = 1;
      }
      fx = l.x || 0;
      fy = l.y || 0;
      ix = l.px || 0;
      iy = l.py || 0;
      xx = w * ix + fx;
      yy = h * iy + fy;
      left = Math.min(left, xx - l.hwidth * scale);
      right = Math.max(right, xx + l.hwidth * scale);
      top = Math.min(top, yy - l.hheight * scale);
      bottom = Math.max(bottom, yy + l.hheight * scale);
    }
    node.bLeft = left;
    node.bRight = right;
    node.bTop = top;
    return node.bBottom = bottom;
  };

  Itemschart_NodesStyle.prototype.postprocessLink = function(link, g) {
    var i, items;
    items = [];
    if (link.label) {
      i = new Base_Label(link.labelStyle);
      i.text = link.label.toString();
      i.px = 0;
      i.py = 0;
      items.push(i);
    }
    link.currentItems = items;
    return this.postprocessItems(link);
  };

  return Itemschart_NodesStyle;

})(Itemschart_ItemsStyle);
// Generated by CoffeeScript 1.8.0
var Itemschart_Impl,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

Itemschart_Impl = (function(_super) {
  __extends(Itemschart_Impl, _super);

  function Itemschart_Impl(settings, api) {
    Itemschart_Impl.__super__.constructor.call(this, settings, api);
  }

  Itemschart_Impl.prototype.finalInitialize = function() {
    this.selection = this.events.addElement(new Itemschart_Selection(this));
    return Itemschart_Impl.__super__.finalInitialize.call(this);
  };

  Itemschart_Impl.prototype.setSelection = function(selection) {
    var foundNode, n, realSelection, _i, _len;
    realSelection = [];
    for (_i = 0, _len = selection.length; _i < _len; _i++) {
      n = selection[_i];
      if (n instanceof Itemschart_Node || n instanceof Itemschart_Link) {
        realSelection.push(n);
      } else if (foundNode = this.graph.idToNode[n]) {
        realSelection.push(foundNode);
      } else {
        this.error("SetSelection: Non chart object in selection: " + n);
      }
    }
    return this.selection.setSelection(realSelection, "api");
  };

  return Itemschart_Impl;

})(Base_Impl);
// Generated by CoffeeScript 1.8.0
var Linearchart_Settings,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

Linearchart_Settings = (function(_super) {
  __extends(Linearchart_Settings, _super);

  Linearchart_Settings.defaults = Base_Settings.extendDefaults(Base_Settings.defaults, {
    area: {
      style: {
        noData: {
          _doc: {
            doc: "Style settings when there is no data to display.",
            type: "object"
          },
          fillColor: "#888",
          image: "builtin://linearchart-no-data-dark",
          image_doc: {
            doc: "Image to show when there is no data to display.",
            type: "url"
          }
        },
        zoomHighlight: {
          _doc: {
            doc: "Zoom In/Zoom Out animation highlight settings.",
            type: "object"
          },
          fillColor: "rgba(30,160,220,0.15)",
          fadeIn: 100,
          fadeIn_doc: {
            doc: "Fade in duration.",
            type: "integer"
          },
          fadeOut: 500,
          fadeOut_doc: {
            doc: "Fade in duration.",
            type: "integer"
          },
          fadeCross: 500,
          fadeCross_doc: {
            doc: "Cross fade in duration.",
            type: "integer"
          }
        },
        zoomHighlightInactive: {
          _doc: {
            doc: "Zoom highlight style after zoom animation is finished.",
            type: "object"
          },
          fillColor: "rgba(30,160,220,0.08)"
        }
      }
    },
    legend: Linearchart_Legend.settings,
    valueAxisDefault: Linearchart_ValueAxis.settings,
    valueAxis: {},
    valueAxis_doc: {
      doc: "Map from name to configuration. Currently supported are default and secondary. Default value axis is located on the left hand side of the chart and secondary is located on the right hand side. Both can be configured to be either inside or outside the chart.",
      type: "object",
      baseObject: Linearchart_ValueAxis.settings
    },
    chartTypes: {
      _doc: {
        doc: "Default series settings for each series rendering type. Use this to configure all series of specific type to get line or column chart or combination of them.",
        type: "section"
      },
      columns: {
        _doc: {
          doc: "Series type to render values as vertical bars.",
          type: "section"
        },
        style: {
          _doc: {
            doc: "Default column style.",
            type: "object"
          },
          minHeight: 4,
          minHeight_doc: {
            doc: "Minimum height of a column in px.",
            type: "integer"
          },
          gradient: 0.8,
          gradient_doc: {
            doc: "A linear gradient for color change along a line between the column bottom and upper side.",
            type: "float",
            values: {
              "1": "no gradient",
              ">0 and <1": "bottom part of columns will be darker"
            }
          },
          lineColor: "",
          lineColor_doc: {
            doc: "Outline color.",
            type: "color"
          },
          fillColor: "limegreen",
          fillColor_doc: {
            doc: "Fill color.",
            type: "color"
          },
          lineWidth: 1,
          lineWidth_doc: {
            doc: "Outline width in px.",
            type: "integer"
          },
          lineDash: false,
          lineDash_doc: {
            doc: "Array of line dash pattern to have a dashed line. The array contains length of dash followed by length of space in pixels. A sequence of multiple dash-space values is supported.",
            type: "bool"
          },
          padding: [3, 3],
          padding_doc: {
            doc: "Padding for column in px. 0th element - left padding, 1st element - right padding.",
            type: "array",
            baseObject: "integer"
          },
          shadowOffsetX: 1,
          shadowOffsetX_doc: {
            doc: "Shadow direction, x component.",
            type: "integer"
          },
          shadowOffsetY: -1,
          shadowOffsetY_doc: {
            doc: "Shadow direction, y component.",
            type: "integer"
          },
          shadowBlur: 3,
          shadowBlur_doc: {
            doc: "Shadow blur effect range.",
            type: "integer"
          },
          shadowBlur: 3,
          shadowBlur_doc: {
            doc: "Shadow blur effect range.",
            type: "integer"
          },
          shadowColor: null,
          shadowColor_doc: {
            doc: "Shadow color of column. If undefined, no shadow will be applied. Leave empty to use default shadow or set your own shadow color.",
            type: "color"
          },
          previewLineColor: "rgba(255,255,255,.5)",
          previewData: false,
          previewData_doc: {
            doc: "",
            type: "bool",
            hide: true
          },
          depth: 0,
          depth_doc: {
            doc: "Depth in px for column. Use it to achieve 3D effect.",
            type: "float"
          },
          depthBrightness: 0.5,
          depthBrightness_doc: {
            doc: "Brightness applied to depth components.",
            type: "float"
          }
        }
      },
      line: {
        _doc: {
          doc: "Series type to connect value points by lines.",
          type: "section"
        },
        style: {
          _doc: {
            doc: "Default style for line type series.",
            type: "object"
          },
          lineColor: "#f00",
          lineColor_doc: {
            doc: "Line color",
            type: "color"
          },
          lineDash: false,
          lineDash_doc: {
            doc: "Array of line dash pattern to have a dashed line. The array contains length of dash followed by length of space in pixels. A sequence of multiple dash-space values is supported.",
            type: "bool"
          },
          fillColor: "",
          fillColor_doc: {
            doc: "Color to fill area between the line and the zero line.",
            type: "color"
          },
          fillGradient: null,
          fillGradient_doc: {
            doc: "Fill gradient. Allows building a gradient fill, bound to values. Contains array of value-color pairs. For example: [[-20, 'rgba(0,0,255,0.4)'],[30,'rgba(255,0,0,0.7)']].",
            type: "array",
            baseObject: "array"
          },
          lineWidth: 1,
          lineWidth_doc: {
            doc: "Width of the line.",
            type: "float",
            units: "pixels"
          },
          shadowOffsetX: 1,
          shadowOffsetX_doc: {
            doc: "Shadow direction, x component.",
            type: "integer"
          },
          shadowOffsetY: -1,
          shadowOffsetY_doc: {
            doc: "Shadow direction, y component.",
            type: "integer"
          },
          shadowBlur: 5,
          shadowBlur_doc: {
            doc: "Shadow blur radius.",
            type: "integer"
          },
          shadowColor: false,
          shadowColor_doc: {
            doc: "The shadow color of line. ",
            type: "enum",
            values: {
              "null": "disable the shadow",
              "false": "set automatically depending on theme",
              "true": "set any other color you want to force it"
            }
          },
          smoothing: false,
          smoothing_doc: {
            doc: "Whether to draw smoothed line.",
            type: "bool"
          },
          steps: false,
          steps_doc: {
            doc: "Whether to draw the line using horizontal segments instead of oblique.",
            type: "bool"
          },
          marker: {
            _doc: {
              doc: "Marker highlight data points on line. They can be in different sizes, shapes and colors.",
              type: "object"
            },
            shape: null,
            shape_doc: {
              doc: "Marker shapes.",
              type: "enum",
              values: ["circle", "square", "romb", "triangle"]
            },
            width: 10,
            width_doc: {
              doc: "The width of the marker. In case when circle - interpreted as the diameter.",
              type: "integer"
            },
            fillColor: "",
            fillColor_doc: {
              doc: "Marker fill color. Note that it must be set to the preferred color in order to display them.",
              type: "color"
            }
          }
        }
      }
    },
    stacks: {
      _doc: {
        doc: "Defines stack settings to use in series. Each property is a stack name and value is stack settings.",
        type: "objArray",
        section: true,
        baseObject: ".default"
      },
      "default": {
        _doc: {
          doc: "Values stack of each series on top of each other in the specified series order. Those, stacked bars help to visualize data that is a sum of parts, each of which is in a series.",
          type: "object"
        },
        name: "",
        name_doc: {
          doc: "The display name in info popup.",
          type: "string"
        },
        type: "normal",
        type_doc: {
          doc: "Different representation of stacked series values.",
          type: "enum",
          values: {
            "normal": "a regular stack, values of series are added up",
            "proportional": "absolute values shown as percentage of from sum of given stack",
            "based": "all series are aligned to zero line"
          }
        },
        separateNegativeValues: null,
        separateNegativeValues_doc: {
          doc: "Whether to separate negative values.",
          type: "bool"
        }
      }
    },
    seriesDefault: {
      _doc: {
        doc: "The default series used as the chart dominant data. Use settings.series array to specify actual series.",
        type: "section"
      },
      enabled: true,
      enabled_doc: {
        doc: "Enable/disable series.",
        type: "bool"
      },
      type: "columns",
      type_doc: {
        doc: "Series type.",
        type: "enum",
        values: ["column", "line"]
      },
      valueAxis: "default",
      valueAxis_doc: {
        doc: "Id of value axis to use. See see::api-reference/settings/valueAxis/::value axis:: for more info.",
        type: "string"
      },
      name: null,
      name_doc: {
        doc: "Name to show in legend and info popup.",
        type: "string"
      },
      showInLegend: true,
      showInLegend_doc: {
        doc: "Whether to show the series name in legend and info popup.",
        type: "bool"
      },
      stack: null,
      stack_doc: {
        doc: "Stack identifier. Series with same stack ID are placed in the same stack. Define a stack with the same identifier to tune the stack.",
        type: "string"
      },
      cluster: null,
      cluster_doc: {
        doc: "Cluster identifier. Columns with the same cluster id will be placed in same cluster.",
        type: "string"
      },
      data: {
        _doc: {
          doc: "Data manipulation settings used for default series.",
          type: "section"
        },
        source: "default",
        source_doc: {
          doc: "Data source to use if multiple data sources are available.",
          type: "enum",
          values: ["default"]
        },
        index: 1,
        index_doc: {
          doc: "Index in value array to use.",
          type: "integer"
        },
        field: null,
        valueFunction: null,
        valueFunction_doc: {
          doc: "Before data aggregation prepare value taken from entry in data values array.",
          parameters: {
            "data": "entry in data values array"
          },
          returns: "value to pass to aggregation",
          type: "function"
        },
        aggregation: "sum",
        aggregation_doc: {
          doc: "Aggregation function to use. Used when data source does not provide data in needed display unit.",
          type: "enum",
          values: ["sum", "min", "max", "first", "last", "avg"]
        },
        aggregatedValueFunction: null,
        aggregatedValueFunction_doc: {
          doc: "Prepare displaying value after data aggregation.",
          parameters: {
            "value": "aggregated value that is about to be displayed.",
            "time": "time display unit time stamp in ms.",
            "units": "display unit."
          },
          returns: "the value to display.",
          type: "function"
        },
        noDataPolicy: "join",
        noDataPolicy_doc: {
          doc: "Method used to fill in time intervals that have no data. Used only for line series.",
          type: "enum",
          values: {
            "join": "links data points with straight line",
            "skip": "do not draw in this interval.",
            "zero": "draw as the value is zero."
          }
        }
      },
      style: {},
      style_doc: {
        doc: "Custom style based on series type. See see::api-reference/settings/chartTypes/::available types::.",
        type: "object"
      }
    },
    series: [],
    series_doc: {
      doc: "Array of series in the chart. Each of the series can be different type, can use different data source, aggregation. Additionally, series can be clustered and stacked.",
      type: "array",
      section: true,
      baseObject: "..seriesDefault"
    },
    info: {
      _doc: {
        doc: "Info popup when hovering over columns or lines. Content returned in a form of html and is relevant to context of series hovered.",
        type: "section"
      },
      enabled: true,
      enabled_doc: {
        doc: "Show/hide info popup",
        type: "bool"
      },
      showNoData: true,
      showNoData_doc: {
        doc: "Whether to show series with no data in hovered time period.",
        type: "bool"
      },
      valueFormatterFunction: null,
      valueFormatterFunction_doc: {
        doc: "Prepare custom format values to display in info popup. See see::api-reference/settings/series/::series:: for available settings.",
        parameters: {
          "values": "object containing {sum, min, max, first, last, count, avg, change}",
          "series": "series object for the value"
        },
        returns: "HTML text to place as the value.",
        type: "function"
      },
      aggregations: [],
      aggregations_doc: {
        doc: "List of aggregations for on-screen selection. Available aggregations: sum (default), count, first, last, min, max, avg, change",
        type: "enum",
        values: {
          "sum": "Default aggregation.The sum of data values",
          "count": "The count of data values",
          "first": "The first one of data values",
          "last": "The last one of data values",
          "min": "The min of data values",
          "max": "The max of data values",
          "avg": "The average of data values",
          "change": "The difference between first and last"
        }
      },
      style: {
        _doc: {
          doc: "Info popup style.",
          type: "object"
        },
        highlight: {
          _doc: {
            doc: "Highlight style",
            type: "object"
          },
          fillColor: "rgba(30,160,220,0.15)",
          fadeIn: 200,
          fadeIn_doc: {
            doc: "Fade in duration.",
            type: "integer",
            units: "milliseconds"
          },
          fadeOut: 200,
          fadeOut_doc: {
            doc: "Fade out duration.",
            type: "integer",
            units: "milliseconds"
          }
        }
      },
      advanced: {
        _doc: {
          doc: "Advanced settings relevant to info popup appearance.",
          type: "section"
        },
        contentsFunction: null,
        contentsFunction_doc: {
          doc: "Create custom info contents to display in info popup. It may return null and call callback(contents) later.",
          parameters: {
            "sliceData": "slice data including subvalues",
            "slice": "slice object to apply predefined content",
            "callback": "function called to return predefined content"
          },
          returns: "null or string",
          type: "function"
        },
        showOnlyHoveredSeries: false,
        showOnlyHoveredSeries_doc: {
          doc: "Whether to show only the series under cursor in info popup.",
          type: "bool"
        },
        scope: null,
        scope_doc: {
          doc: "Info popup scope.",
          type: "enum",
          values: ["stack", "value", "auto"]
        }
      }
    },

    /* FOLLOWING SETTINGS SHOULD BE CHANGED WITH CAUTION! */
    interaction: {
      _doc: {
        doc: "A variety of interaction options that includes scrolling, zooming and swipe.",
        type: "section"
      },
      swipeSensitivity: 0.6,
      swipeSensitivity_doc: {
        doc: "Sensitivity of Left/Right/Up/Down swipes.",
        type: "float",
        min: 0,
        max: 1
      },
      scrolling: {
        _doc: {
          doc: "Configurable settings to manage scroll interaction.",
          type: "section"
        },
        enabled: true,
        enabled_doc: {
          doc: "Enables/Disables scrolling.",
          type: "bool"
        },
        swipePageFlipping: true,
        swipePageFlipping_doc: {
          doc: "Whether to use scrolling by full page instead of kinetic scrolling.",
          type: "bool"
        },
        keyboardScrollingFactor: 1,
        keyboardScrollingFactor_doc: {
          doc: "How far to scroll when Left or Right keys are pressed. Multiples of chart width.",
          type: "float"
        },
        kineticFriction: 2,
        kineticFriction_doc: {
          doc: "Scrolling friction coefficient (chartWidth/sec^2).",
          type: "float"
        }
      },
      zooming: {
        _doc: {
          doc: "Configurable settings to enhance and alleviate zoom interaction.",
          type: "section"
        },
        enabled: true,
        enabled_doc: {
          doc: "Enable/Disable zooming options.",
          type: "bool"
        },
        wheel: false,
        wheel_doc: {
          doc: "Whether to zoom by mouse wheel.",
          type: "bool"
        },
        swipe: true,
        swipe_doc: {
          doc: "Whether to zoom by swiping up or down.",
          type: "bool"
        },
        fingers: true,
        fingers_doc: {
          doc: "Whether to zoom by two finger pinch.",
          type: "bool"
        },
        fingersMaxZoom: 10,
        fingersMaxZoom_doc: {
          doc: "Max zoom difference when using pinch gesture.",
          type: "float"
        },
        sensitivity: 1,
        sensitivity_doc: {
          doc: "Mouse zooming sensitivity. Note that bigger values correspond to faster zooming.",
          type: "float"
        },
        keyboardFactor: 2,
        keyboardFactor_doc: {
          doc: "Chart is zoomed in or out by this factor when pressing Up or Down keys.",
          type: "float"
        },
        upDownTreshold: 10,
        upDownTreshold_doc: {
          doc: "How far pointer must be moved up or down in pixels before zooming activates.",
          type: "float"
        },
        zoomHighlightThreshold: 1.5,
        zoomHighlightThreshold_doc: {
          doc: "Zoomed area is highlighted if zoom is changed more number of times than this.",
          type: "float"
        }
      }
    },
    localization: {
      valueUnits: {
        "K": 1e3,
        "M": 1e6,
        "G": 1e9,
        "T": 1e12,
        "E": 1e15
      },
      valueUnits_doc: {
        doc: "Map from unit prefix to multiplier. Used for value axis formatting.",
        type: "objArray",
        baseObject: "integer"
      },
      toolbar: {
        linButton: "Lin",
        linButton_doc: {
          doc: "Linear mode button text.",
          type: "string"
        },
        logButton: "Log",
        logButton_doc: {
          doc: "Logarithmic mode button text.",
          type: "string"
        },
        linLogTitle: "Switch lin/log scale",
        linLogTitle_doc: {
          doc: "Lin/Log button title.",
          type: "string"
        }
      }
    }
  });

  function Linearchart_Settings(defaults) {
    this._computedValueAxisList = [];
    this._computedValueAxis = {};
    this._computedSeries = [];
    Linearchart_Settings.__super__.constructor.call(this, defaults);
  }

  Linearchart_Settings.prototype.apply = function(settings) {
    var availableAxisIds, changes, defV, defaultUsed, id, s, series, v, va, value, _i, _j, _len, _len1, _ref, _ref1, _ref2, _ref3, _ref4;
    if (settings.series) {
      series = settings.series;
      delete settings.series;
    } else {
      series = null;
    }
    this.applyCompatibility(settings, [
      {
        from: "valueAxis.default",
        to: "valueAxisDefault"
      }, {
        from: "valueAxisDefault.style.baseLineColor",
        to: "valueAxisDefault.style.baseLine.lineColor"
      }, {
        from: "valueAxisDefault.style.baseLineWidth",
        to: "valueAxisDefault.style.baseLine.lineWidth"
      }, {
        from: "valueAxisDefault.style.hgridLineColor",
        to: "valueAxisDefault.style.hgrid.lineColor"
      }
    ]);
    changes = Linearchart_Settings.__super__.apply.call(this, settings);
    if (changes.stacks) {
      this._computedStacks = {};
      _ref = this.stacks;
      for (id in _ref) {
        value = _ref[id];
        v = {};
        this.applyRec(v, Linearchart_Settings.defaults.stacks["default"], {});
        this.applyRec(v, value, {});
        this._computedStacks[id] = v;
      }
    }
    if (series) {
      settings.series = series;
      if (!this.series) {
        this.series = [];
      }
      changes.series = [];
      this.applyById(this.series, series, changes.series);
    }
    if (series || changes.chartTypes || changes.seriesDefault) {
      this._computedSeries = this.applySeries(this.series, this.chartTypes, this.seriesDefault);
      changes._computedSeries = this._computedSeries;
      availableAxisIds = {
        "default": true
      };
      _ref1 = this.valueAxis;
      for (id in _ref1) {
        va = _ref1[id];
        availableAxisIds[id] = true;
      }
      _ref2 = this._computedSeries;
      for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
        s = _ref2[_i];
        if (!availableAxisIds[s.valueAxis]) {
          throw "Settings: Unrecognized value axis: " + s.valueAxis;
        }
        if (s.data.index === 0) {
          throw "Settings: series.data.index = 0, not allowed";
        }
      }
    }
    if (changes.valueAxis || changes.valueAxisDefault || !this._computedValueAxisList.length) {
      defaultUsed = false;
      _ref3 = this._computedSeries;
      for (_j = 0, _len1 = _ref3.length; _j < _len1; _j++) {
        s = _ref3[_j];
        defaultUsed || (defaultUsed = s.valueAxis === "default");
      }
      this._computedValueAxisList = [];
      this._computedValueAxis = {};
      defV = this.valueAxisDefault;
      _ref4 = this.valueAxis;
      for (id in _ref4) {
        value = _ref4[id];
        v = {};
        this.applyRec(v, defV, {});
        this.applyRec(v, value, {});
        v.id = id;
        this.applyCompatibility(v, [
          {
            from: "style.baseLineColor",
            to: "style.baseLine.lineColor"
          }, {
            from: "style.baseLineWidth",
            to: "style.baseLine.lineWidth"
          }, {
            from: "style.hgridLineColor",
            to: "style.hgrid.lineColor"
          }
        ]);
        this._computedValueAxis[id] = v;
        this._computedValueAxisList.push(v);
      }
      if (defaultUsed && !this.valueAxis["default"]) {
        v = {};
        this.applyRec(v, defV, {});
        v.id = "default";
        this._computedValueAxis[id] = v;
        this._computedValueAxisList.push(v);
      }
      this._computedValueAxisList.sort(function(a, b) {
        return a.id.localeCompare(b.id);
      });
      changes._computedValueAxis = this._computedValueAxis;
      changes._computedValueAxisList = this._computedValueAxisList;
    }
    return changes;
  };

  return Linearchart_Settings;

})(Base_Settings);
// Generated by CoffeeScript 1.8.0
var Timechart_Toolbar;

Timechart_Toolbar = (function() {
  function Timechart_Toolbar() {}

  Timechart_Toolbar.periodSettings = {
    _doc: {
      doc: "Display period.",
      type: "object"
    },
    name: null,
    name_doc: {
      doc: "Named time interval.",
      type: "string"
    },
    displayAnchor: null,
    displayAnchor_doc: {
      doc: "Reference time for passed data.",
      type: "string"
    },
    displayPeriod: null,
    displayPeriod_doc: {
      doc: "Display period.",
      type: "string"
    },
    displayUnit: null,
    displayUnit_doc: {
      doc: "Units in which to show data.",
      type: "enum",
      values: ["auto", "M", "d", "h", "m", "s", "ms"]
    }
  };

  Timechart_Toolbar.settings = Base_Settings.extendDefaults(Linearchart_Toolbar.settings, {
    enabled: true,
    logScale: true,
    displayUnit: true,
    displayUnit_doc: {
      doc: "Whether to show the display unit dropdown.",
      type: "bool"
    },
    displayPeriod: true,
    displayPeriod_doc: {
      doc: "Whether to show display period dropdown.",
      type: "bool"
    },
    zoomOut: true,
    periods: [
      {
        name: "Last second",
        displayAnchor: "now",
        displayPeriod: "1 s",
        displayUnit: "25 ms"
      }, {
        name: "Last minute",
        displayAnchor: "now",
        displayPeriod: "1 m",
        displayUnit: "1 s"
      }, {
        name: "Last hour",
        displayAnchor: "now",
        displayPeriod: "1 h",
        displayUnit: "1 m"
      }, {
        name: "Last day",
        displayAnchor: "now",
        displayPeriod: "1 d",
        displayUnit: "1 h"
      }, {
        name: "Last week",
        displayAnchor: "now",
        displayPeriod: "1 w",
        displayUnit: "6 h"
      }, {
        name: "Last month",
        displayAnchor: "now",
        displayPeriod: "1 M",
        displayUnit: "1 d"
      }, {
        name: "Last year",
        displayAnchor: "now",
        displayPeriod: "1 y",
        displayUnit: "1 M"
      }, {
        name: "All data",
        displayAnchor: "newestData",
        displayPeriod: "max",
        displayUnit: "auto"
      }
    ],
    periods_doc: {
      doc: "Time periods",
      type: "array",
      baseObject: Timechart_Toolbar.periodSettings
    },
    items_doc: {
      doc: "An array of toolbar items. Set to completely override the items in toolbar.",
      type: "array",
      baseObject: Base_Toolbar.itemSettings
    },
    items: [
      {
        item: "back",
        align: "left"
      }, {
        item: "zoomOut",
        align: "left"
      }, {
        item: "logScale",
        align: "right"
      }, {
        item: "displayPeriod",
        align: "right"
      }, {
        item: "displayUnit",
        align: "right"
      }, {
        item: "export",
        align: "right"
      }
    ]
  });

  return Timechart_Toolbar;

})();
// Generated by CoffeeScript 1.8.0
var Timechart_TimeUpdater,
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

Timechart_TimeUpdater = (function(_super) {
  "use strict";
  __extends(Timechart_TimeUpdater, _super);

  Timechart_TimeUpdater.prototype.animationOrder = 100;

  Timechart_TimeUpdater.prototype.paintOrder = 35;

  Timechart_TimeUpdater.prototype.updateOrder = 900;

  Timechart_TimeUpdater.settingsCurTime = {
    _doc: {
      doc: "Moving time line that represents the current time, mainly to analyze real-time data changes. To achieve it, use server time of page load and adjust time zone offset.",
      type: "section"
    },
    enabled: true,
    enabled_doc: {
      doc: "Show/hide current time updater.",
      type: "bool"
    },
    label: "",
    style: {
      _doc: {
        doc: "Time updater style.",
        type: "object"
      },
      lineColor: "red",
      fillColor: "red"
    },
    serverTime: null,
    serverTime_doc: {
      doc: "Time on server at the moment of page load. Use it to adjust time zone offsets.",
      type: "integer"
    },
    _computedTimeOffset: 0
  };

  function Timechart_TimeUpdater(chart) {
    var m;
    this.chart = chart;
    this.dataTick = __bind(this.dataTick, this);
    this.timerTick = __bind(this.timerTick, this);
    this.settings = this.chart.settings;
    this.scene = this.chart.scene;
    this.events = this.chart.events;
    this.timerUnit = new Base_TimeStep(1, "ms");
    if (this.settings.currentTime.enabled) {
      m = new Linearchart_Marker();
      m.time = this.scene.getCurTime();
      m.style = this.scene.settings.currentTime.style;
      m.label = this.scene.settings.currentTime.label;
      this.scene.markers.push(m);
    }
    if (this.settings.advanced.timeUpdateInterval) {
      this.timeTimer = setTimeout(this.timerTick, this.settings.advanced.timeUpdateInterval);
    }
    if (this.settings.advanced.dataUpdateInterval) {
      this.dataTimer = setTimeout(this.dataTick, this.settings.advanced.dataUpdateInterval);
    }
  }

  Timechart_TimeUpdater.prototype.timerTick = function() {
    this.timeTimer = null;
    if (this.chart.removed) {
      return;
    }
    this.updateCurTime();
    return this.updateVisiblePeriod();
  };

  Timechart_TimeUpdater.prototype.dataTick = function() {
    var callback, curTime, data, id, _ref;
    this.dataTimer = null;
    if (this.chart.removed) {
      return;
    }
    if (this.scene.displayUnit) {
      curTime = this.scene.getCurTime();
      callback = (function(_this) {
        return function() {
          _this.updateVisiblePeriod();
          return _this.events.notifySceneChanges({
            data: true
          });
        };
      })(this);
      _ref = this.chart.data;
      for (id in _ref) {
        data = _ref[id];
        data.updateData(this.scene.displayUnit.unit, curTime, callback);
      }
    }
    return this.dataTimer = setTimeout(this.dataTick, this.settings.advanced.dataUpdateInterval);
  };

  Timechart_TimeUpdater.prototype.doAnimations = function(event) {
    if (this.scene.displayUnit && !this.scene.displayUnit.isEqual(this.timerUnit)) {
      this.updateCurTime();
      this.timerUnit = this.scene.displayUnit;
    }
    if (event.changes.data) {
      return this.updateVisiblePeriod();
    }
  };

  Timechart_TimeUpdater.prototype.updateCurTime = function() {
    var curTime, interval, markerUpdated, unit, x;
    if (this.timeTimer) {
      clearTimeout(this.timeTimer);
    }
    unit = this.scene.displayUnit;
    interval = this.settings.advanced.timeUpdateInterval;
    if (unit && this.settings.currentTime.enabled) {
      curTime = this.scene.getCurTime();
      this.scene.markers[0].time = curTime;
      x = this.scene.timeToX(curTime);
      markerUpdated = x + 200 > this.scene.x0 && x - 200 < this.scene.x0 + this.scene.width;
      if (markerUpdated) {
        interval = Math.min(interval, this.scene.dxToDtime(1));
        this.events.notifySceneChanges({
          markers: true
        });
      }
    }
    return this.timeTimer = setTimeout(this.timerTick, interval);
  };

  Timechart_TimeUpdater.prototype.updateVisiblePeriod = function() {
    var curTime, dt, latestDataTime, timeEnd, timeStart, unit;
    if (!(this.scene.displayUnit && (this.scene.timeEnd != null))) {
      return;
    }
    curTime = this.scene.getCurTime();
    latestDataTime = this.scene.getDataLimits()[1];
    timeEnd = this.scene.timeEnd;
    timeStart = this.scene.timeStart;
    if (this.settings.area.followAnchor) {
      if (this.scene.anchor === "now" && timeEnd < curTime) {
        unit = this.scene.displayUnit;
        dt = unit.roundTimeUp(curTime) - timeEnd;
        this.chart.scrolling.setTimeRangeSnap(timeStart + dt, timeEnd + dt, timeEnd + dt, this.scene.displayUnit, true, "timer", true, false);
      }
      if (this.scene.anchor === "newestData" && timeEnd < latestDataTime) {
        unit = this.scene.displayUnit;
        dt = unit.roundTimeUp(latestDataTime) - timeEnd;
        return this.chart.scrolling.setTimeRangeSnap(timeStart + dt, timeEnd + dt, timeEnd + dt, this.scene.displayUnit, true, "timer", true, false);
      }
    }
  };

  return Timechart_TimeUpdater;

})(Base_ChartElement);
// Generated by CoffeeScript 1.8.0
var Linearchart_Impl,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

Linearchart_Impl = (function(_super) {
  "use strict";
  __extends(Linearchart_Impl, _super);

  Linearchart_Impl.prototype.scrolling = null;

  Linearchart_Impl.prototype.renderer = null;

  function Linearchart_Impl(settings, scene) {
    Linearchart_Impl.__super__.constructor.call(this, settings, scene);
  }

  Linearchart_Impl.prototype.replaceSeries = function(newSeries) {
    this.settings.series = [];
    return this.updateSettings({
      series: newSeries
    });
  };

  Linearchart_Impl.prototype.setLogScale = function(enabled, origin) {
    var id, va, vaChanges, _ref;
    vaChanges = {};
    _ref = this.settings.valueAxis;
    for (id in _ref) {
      va = _ref[id];
      vaChanges[id] = {
        logScale: enabled
      };
    }
    return this.updateSettings({
      valueAxisDefault: {
        logScale: enabled
      },
      valueAxis: vaChanges
    }, origin);
  };

  Linearchart_Impl.prototype.finalInitialize = function() {
    Linearchart_Impl.__super__.finalInitialize.call(this);
    return this.legend = this.events.addElement(new Linearchart_Legend(this));
  };

  return Linearchart_Impl;

})(Base_Impl);
// Generated by CoffeeScript 1.8.0
var Facetchart_Toolbar;

Facetchart_Toolbar = (function() {
  function Facetchart_Toolbar() {}

  Facetchart_Toolbar.settings = Base_Settings.extendDefaults(Linearchart_Toolbar.settings, {
    enabled: true,
    items: [
      {
        item: "back",
        align: "left"
      }, {
        item: "zoomOut",
        align: "left"
      }, {
        item: "logScale",
        align: "right"
      }, {
        item: "export",
        align: "right"
      }
    ]
  });

  return Facetchart_Toolbar;

})();
// Generated by CoffeeScript 1.8.0
var Linearchart_Renderer;

Linearchart_Renderer = (function() {
  "use strict";
  function Linearchart_Renderer(chart, valueAxisSet) {
    this.chart = chart;
    this.valueAxisSet = valueAxisSet;
    this.scene = this.chart.scene;
    this.clusters = [];
    this.buildSeries();
  }

  Linearchart_Renderer.prototype.buildSeries = function() {
    var cluster, defaultCluster, defaultStackConfig, id, idToCluster, lineStackClusters, s, series, stack, _i, _j, _len, _len1, _ref, _ref1, _results;
    this.clusters = [];
    idToCluster = {};
    defaultCluster = null;
    lineStackClusters = {};
    defaultStackConfig = Linearchart_Settings.defaults.stacks["default"];
    _ref = this.scene.settings._computedSeries;
    for (id = _i = 0, _len = _ref.length; _i < _len; id = ++_i) {
      series = _ref[id];
      if (!series.enabled) {
        continue;
      }
      if (series.cluster) {
        cluster = idToCluster[series.cluster];
        if (!cluster) {
          cluster = idToCluster[series.cluster] = new Linearchart_Series_Cluster(this.scene);
          this.clusters.push(cluster);
        }
      } else {
        if (series.type === "line") {
          if (series.stack) {
            if (lineStackClusters.hasOwnProperty(series.stack)) {
              cluster = lineStackClusters[series.stack];
            } else {
              cluster = lineStackClusters[series.stack] = new Linearchart_Series_Cluster(this.scene);
              this.clusters.push(cluster);
            }
          } else {
            cluster = new Linearchart_Series_Cluster(this.scene);
            this.clusters.push(cluster);
          }
        } else {
          if (!defaultCluster) {
            defaultCluster = new Linearchart_Series_Cluster(this.scene);
            this.clusters.push(defaultCluster);
          }
          cluster = defaultCluster;
        }
      }
      stack = this.scene.settings._computedStacks[series.stack] || defaultStackConfig;
      cluster.addSeries(id, series, stack, this.valueAxisSet.getAxis(series.valueAxis));
    }
    _ref1 = this.clusters;
    _results = [];
    for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
      s = _ref1[_j];
      _results.push(s.afterInit());
    }
    return _results;
  };

  Linearchart_Renderer.prototype.process = function(newData) {
    var x, _i, _len, _ref, _results;
    _ref = this.clusters;
    _results = [];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      x = _ref[_i];
      _results.push(x.process(newData));
    }
    return _results;
  };

  Linearchart_Renderer.prototype.afterProcess = function() {
    var x, _i, _len, _ref, _results;
    _ref = this.clusters;
    _results = [];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      x = _ref[_i];
      _results.push(x.afterProcess());
    }
    return _results;
  };

  Linearchart_Renderer.prototype.paint = function(event) {
    var context, o, _i, _len, _ref, _results;
    context = event.context;
    _ref = this.clusters;
    _results = [];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      o = _ref[_i];
      _results.push(o.paint(context));
    }
    return _results;
  };

  Linearchart_Renderer.prototype.hitTest = function(x, y) {
    var dist, distance, i, item, o, tolerance, _i, _j, _len, _ref, _ref1, _ref2, _ref3;
    tolerance = 4;
    item = null;
    distance = Infinity;
    _ref = this.clusters;
    for (_i = _ref.length - 1; _i >= 0; _i += -1) {
      o = _ref[_i];
      _ref1 = o.hitTest(x, y, tolerance), i = _ref1[0], dist = _ref1[1];
      if (dist < distance) {
        item = i;
        distance = dist;
      }
    }
    if (distance > tolerance) {
      distance = Infinity;
      item = null;
      _ref2 = this.clusters;
      for (_j = 0, _len = _ref2.length; _j < _len; _j++) {
        o = _ref2[_j];
        _ref3 = o.hitTestStack(x, y, tolerance), i = _ref3[0], dist = _ref3[1];
        if (dist < distance) {
          item = i;
          distance = dist;
        }
      }
    }
    return item;
  };

  Linearchart_Renderer.prototype.exportData = function(from, to) {
    var cluster, result, _i, _len, _ref;
    result = [];
    _ref = this.clusters;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      cluster = _ref[_i];
      cluster.exportData(from, to, result);
    }
    return result;
  };

  return Linearchart_Renderer;

})();
// Generated by CoffeeScript 1.8.0
var PieChart,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

PieChart = (function(_super) {
  "use strict";
  __extends(PieChart, _super);

  PieChart.themes = {
    "flat": Piechart_Settings.FlatTheme,
    "bevel": Piechart_Settings.BevelTheme,
    "gradient": Piechart_Settings.GradientTheme,
    "raised": Piechart_Settings.CanTheme
  };

  PieChart.settings = Piechart_Settings;

  function PieChart(settings) {

    /*
    Executed when **new NetChart(settings)** is called. Will create new chart, filling the whole container, load data and display.
     */
    this._impl = new Piechart_Impl(settings, this);
    this.settings = this._impl.settings;
    this._scene = this._impl.scene;
    return this;
  }

  PieChart.prototype.updateFilter = function() {
    this._impl.updateFilter();
    return this;
  };

  PieChart.prototype.selection = function(selected) {

    /*
      Set/get selection in javascript timestamp (milliseconds).
      Use null, null to remove selection.
      returns [from, to] in list form.
     */
    if (selected != null) {
      this._impl.setSelection(selected);
    }
    return this._scene.selection;
  };

  PieChart.prototype.getPie = function() {
    return this._impl.getPie();
  };

  PieChart.prototype.getPieOffset = function() {
    return this._impl.navigator.getPieOffset();
  };

  PieChart.prototype.setPie = function(pieId, offset) {
    if (offset == null) {
      offset = 0;
    }
    this._impl.setPie(pieId, offset, "api");
    return this;
  };

  PieChart.prototype.setPieOffset = function(offset) {
    this._impl.setPieOffset(offset, "api");
    return this;
  };

  PieChart.prototype.getActiveSlices = function() {
    return this._impl.getActiveSlices();
  };

  PieChart.prototype.getActivePies = function() {
    return this._impl.getActivePies();
  };

  PieChart.prototype.getActivePie = function() {
    var p;
    p = this._impl.getActivePies();
    return p[p.length - 1];
  };

  PieChart.prototype.expandSlice = function(slice) {
    return this._impl.expandSlice(slice, "api");
  };

  PieChart.prototype.getSliceDimensions = function(sliceId, showPartial) {
    if (showPartial == null) {
      showPartial = false;
    }
    return this._impl.getSliceDimensions(sliceId, showPartial);
  };

  return PieChart;

})(Base_Api);
// Generated by CoffeeScript 1.8.0
var Netchart_Settings,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

Netchart_Settings = (function(_super) {
  __extends(Netchart_Settings, _super);

  Netchart_Settings.FlatTheme = {
    advanced: {
      themeCSSClass: "DVSL-flat",
      assets: ["assets://netchart.css"]
    }
  };

  Netchart_Settings.defaults = Base_Settings.extendDefaults(Itemschart_Settings.defaults, {
    theme: Netchart_Settings.FlatTheme,
    data: Netchart_Data.settings,
    area: {
      centerX: 0.5,
      centerX_doc: {
        doc: "The center of the chart. Fraction of chart width. 0 = left side, 1 = right side.",
        type: "float"
      },
      centerY: 0.5,
      centerY_doc: {
        doc: "The center of the chart. Fraction of chart height, 0 = top, 1 = botom.",
        type: "float"
      },
      paddingTop: 0,
      paddingTop_doc: {
        doc: "Inner top padding, nodes will avoid this area.",
        type: "float",
        values: {
          "<= 1": "the value is a fraction of chart width",
          ">1": "padding in pixels"
        },
        units: "pixels"
      },
      paddingLeft: 0,
      paddingLeft_doc: {
        doc: "Inner left padding, nodes will avoid this area.",
        type: "float",
        values: {
          "<= 1": "the value is a fraction of chart width",
          ">1": "padding in pixels"
        },
        units: "pixels"
      },
      paddingRight: 0,
      paddingRight_doc: {
        doc: "Inner right padding, nodes will avoid this area.",
        type: "float",
        values: {
          "<= 1": "the value is a fraction of chart width",
          ">1": "padding in pixels"
        },
        units: "pixels"
      },
      paddingBottom: 0,
      paddingBottom_doc: {
        doc: "Inner bottom padding, nodes will avoid this area.",
        type: "float",
        values: {
          "<= 1": "the value is a fraction of chart width",
          ">1": "padding in pixels"
        },
        units: "pixels"
      }
    },
    style: Itemschart_NodesStyle.settings,
    style_doc: {
      doc: "Chart style settings.",
      type: "section"
    },
    layout: Netchart_Layout.settings,
    filters: {
      _doc: {
        doc: "Configurable conditions to filter the raw data values for subset of drawing nodes and links.",
        type: "section"
      },
      nodeFilter: null,
      nodeFilter_doc: {
        doc: "Determine if node should be displayed. Invoked whenever a new node is about to be shown.",
        type: "function",
        parameters: {
          "nodeData": "node data object",
          "arrayOfLinkData": "array of link data objects."
        },
        returns: ""
      },
      linkFilter: null,
      linkFilter_doc: {
        doc: "Determine if link should be displayed. Invoked whenever a new link is about to be shown. ",
        type: "function",
        parameters: {
          "linkData": "link data object",
          "fromNodeData": "from node data object",
          "toNodeData": "to node data object"
        },
        returns: ""
      },
      nodeLinksProcessor: null,
      nodeLinksProcessor_doc: {
        doc: "Select links to show from a node.",
        type: "function",
        parameters: {
          "nodeData": "node data object.",
          "links": "array of link data objects. All links are connected to the node."
        },
        returns: "array of links to show."
      },
      multilinkProcessor: null,
      multilinkProcessor_doc: {
        doc: "Function called whenever there are more than one link between two nodes.",
        type: "function",
        parameters: {
          "arrayOfLinkData": "array of link data objects",
          "fromData": "from node data object",
          "toData": "to node data object"
        },
        returns: "a single link to replace the multilinks or new array of linkData for replacement"
      }
    },
    interaction: {
      zooming: {
        autoZoomAfterClick: false,
        autoZoomAfterClick_doc: {
          doc: "Whether to auto zoom every time user clicks on the chart.",
          type: "bool"
        },
        initialAutoZoom: "overview",
        initialAutoZoom_doc: {
          doc: "Auto zoom mode on chart initialization.",
          type: "enum",
          values: {
            "overview": "show whole network",
            "true": "use basic auto zoom",
            "false": "no auto zoom."
          }
        },
        zoomExtent: [0.5, 4],
        zoomExtent_doc: {
          doc: "Zoom value limits while in auto-zoom mode. Contains array of [min, max] values.",
          type: "array",
          baseObject: "float"
        },
        autoZoomExtent: [0.5, 1],
        autoZoomExtent_doc: {
          doc: "Zoom value limits when user zooms in and out. Contains array of [min, max] values. If the network is big, the min value is adjusted so that whole network can be shown.",
          type: "array",
          baseObject: "float"
        },
        autoZoomSize: 0.98,
        autoZoomSize_doc: {
          doc: "Fraction of the chart to use in auto zoom mode. This governs the white space area around network in auto zoom mode.",
          type: "float"
        }
      },
      selection: {
        lockNodesOnMove: true,
        lockNodesOnMove_doc: {
          doc: "Whether to retain nodes location after being moved by the user.",
          type: "bool"
        },
        allowMoveNodesOffscreen: true,
        allowMoveNodesOffscreen_doc: {
          doc: "Whether to move nodes outside of screen area.",
          type: "bool"
        }
      }
    },
    navigation: Netchart_Navigator.settings,
    nodeMenu: {
      buttons: ["hide", "expand", "focus", "lock"]
    },
    toolbar: Netchart_Toolbar.settings,
    localization: {
      closeButton: "Close",
      closeButton_doc: {
        doc: "Node/link close button by using localizeable string.",
        type: "string"
      },
      toolbar: {
        rearrangeButton: "Rearrange",
        rearrangeTitle: "Rearrange elements",
        freezeButton: "Freeze",
        freezeTitle: "Lock all",
        unfreezeTitle: "Unlock all",
        fitButton: "Fit",
        fitTitle: "Fit to screen"
      },
      menu: {
        _doc: {
          doc: "Node/link menu by using localizeable strings.",
          type: "object"
        },
        dynaminc: "Dynamic",
        fixed: "Fixed",
        focus: "Focus",
        unfocus: "Unfocus",
        collapse: "Collapse",
        expand: "Expand",
        hide: "Hide"
      }
    },
    legend: Netchart_Legend.settings
  });

  function Netchart_Settings(settings) {
    Netchart_Settings.__super__.constructor.call(this, Netchart_Settings.defaults);
    this.apply(settings);
  }

  Netchart_Settings.prototype.apply = function(settings) {
    var changes;
    changes = Netchart_Settings.__super__.apply.call(this, settings);
    return changes;
  };

  return Netchart_Settings;

})(Itemschart_Settings);
// Generated by CoffeeScript 1.8.0
var Netchart_Impl,
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

Netchart_Impl = (function(_super) {
  "use strict";
  __extends(Netchart_Impl, _super);

  Netchart_Impl.prototype.api = null;

  Netchart_Impl.prototype.renderer = null;

  Netchart_Impl.prototype.scrolling = null;

  Netchart_Impl.prototype.selection = null;

  function Netchart_Impl(settings, api) {
    this.defaultDoubleClick = __bind(this.defaultDoubleClick, this);
    this.defaultRightClick = __bind(this.defaultRightClick, this);
    this.defaultClick = __bind(this.defaultClick, this);
    var useFadeout;
    Netchart_Impl.__super__.constructor.call(this, new Netchart_Settings(settings), new Netchart_Scene());
    useFadeout = this.settings.navigation.mode === "focusnodes" && this.settings.navigation.focusAutoFadeout;
    this.layer = new Itemschart_NodesLayer(this.scene, this.settings, useFadeout);
    this.graph = new Netchart_Graph(this, this.layer);
    this.navigator = new Netchart_Navigator(this);
    this.scrolling = new Netchart_Scrolling(this);
    this.layout = new Netchart_Layout(this);
    this.layers = new Netchart_Layers(this);
    this.initialize(api);
    this.renderer = new Netchart_Renderer(this);
    this.legend = new Netchart_Legend(this);
    this.info = new Itemschart_InfoPopup(this);
    this.menu = new Itemschart_Menu(this);
    this.events.addElement(this.navigator);
    this.events.addElement(this.layout);
    this.events.addElement(this.scrolling);
    this.autoZoom = this.events.addElement(new Netchart_AutoZoom(this));
    this.events.addElement(this.legend);
    this.events.addElement(this.renderer);
    this.events.addElement(this.menu);
    this.events.addElement(this.info);
    this.autoZoom.resetZoom = true;
    this.scene.loading = false;
    this.navigator.onNewDataObject();
    this.navigator.showInitialNodes();
    this.finalInitialize();
  }

  Netchart_Impl.prototype.createDataObj = function(settings) {
    return new Netchart_Data(this, settings);
  };

  Netchart_Impl.prototype.onRemove = function() {
    return this.renderer = null;
  };

  Netchart_Impl.prototype.onSettingsChanged = function(changes) {
    var ch, reinitChart;
    ch = {};
    this.layer.onSettingsChanged(changes);
    reinitChart = changes.navigation && (changes.navigation.mode || changes.navigation.initialNodes);
    if ((changes.data != null) && (changes.data.dataFunction || changes.data.format || changes.data.preloaded || changes.data.url || changes.data.randomNodes)) {
      this.navigator.onNewDataObject();
      reinitChart = true;
    }
    if (reinitChart) {
      this.navigator.showInitialNodes();
      this.autoZoom.resetZoom = true;
    }
    if (changes.filters) {
      ch.filters = true;
    }
    if (changes.style) {
      ch.style = true;
    }
    return this.events.notifySceneChanges(ch);
  };

  Netchart_Impl.prototype.save = function() {
    var nav, xy;
    xy = this.graph.save();
    nav = this.navigator.save();
    return JSON.stringify({
      xy: xy,
      nav: nav
    });
  };

  Netchart_Impl.prototype.restore = function(stateStr, animate) {
    var nav, state, xy;
    if (!stateStr) {
      return;
    }
    state = JSON.parse(stateStr);
    xy = state.xy;
    nav = state.nav;
    if (nav) {
      this.navigator.restore(nav);
    }
    if (xy) {
      this.graph.restore(xy);
    }
    return this.autoZoom.resetZoom = true;
  };

  Netchart_Impl.prototype.saveNavigation = function() {
    var s;
    s = JSON.stringify(this.navigator.save());
    return s;
  };

  Netchart_Impl.prototype.restoreNavigation = function(state) {
    return this.navigator.restore(JSON.parse(state));
  };

  Netchart_Impl.prototype.getCurrentNodes = function() {
    var n, nodes, _i, _len, _ref;
    nodes = [];
    _ref = this.layer.nodes();
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      n = _ref[_i];
      if (!n.removed) {
        nodes.push(n);
      }
    }
    return nodes;
  };

  Netchart_Impl.prototype.getCurrentLinks = function() {
    var links, n, _i, _len, _ref;
    links = [];
    _ref = this.layer.links();
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      n = _ref[_i];
      if (!n.removed) {
        links.push(n);
      }
    }
    return links;
  };

  Netchart_Impl.prototype.getNodeDimensions = function(node) {
    var r, w, x, y, _ref;
    if (!Base_Helpers.isObject(node)) {
      node = this.getNode(node);
    }
    if (!node) {
      return null;
    }
    _ref = this.scene.toDisplay(node.x, node.y), x = _ref[0], y = _ref[1];
    r = node.hHeight * this.scene.zoom;
    w = node.hWidth * this.scene.zoom;
    return {
      x: x,
      y: y,
      radius: r,
      hwidth: w
    };
  };

  Netchart_Impl.prototype.lockNode = function(id, x, y) {
    if (Base_Helpers.isObject(id)) {
      id = id.id;
    }
    return this.graph.lockNode(id, x, y);
  };

  Netchart_Impl.prototype.unlockNode = function(id) {
    if (Base_Helpers.isObject(id)) {
      id = id.id;
    }
    return this.graph.unlockNode(id);
  };

  Netchart_Impl.prototype.addFocusNode = function(id, levels) {
    if (Base_Helpers.isObject(id)) {
      id = id.id;
    }
    if (this.settings.navigation.autoZoomOnFocus) {
      this.scene.autoZoomMode = true;
    }
    return this.navigator.addFocusNode(id, levels, "api");
  };

  Netchart_Impl.prototype.clearFocus = function() {
    return this.navigator.clear("api");
  };

  Netchart_Impl.prototype.removeFocusNode = function(id) {
    if (Base_Helpers.isObject(id)) {
      id = id.id;
    }
    return this.navigator.unexpandNode(id, "api");
  };

  Netchart_Impl.prototype.expandNode = function(id) {
    if (Base_Helpers.isObject(id)) {
      id = id.id;
    }
    return this.navigator.expandNode(id, "api");
  };

  Netchart_Impl.prototype.collapseNode = function(id) {
    if (Base_Helpers.isObject(id)) {
      id = id.id;
    }
    return this.navigator.collapseNode(id, "api");
  };

  Netchart_Impl.prototype.uncollapseNode = function(id) {
    if (Base_Helpers.isObject(id)) {
      id = id.id;
    }
    return this.navigator.uncollapseNode(id, "api");
  };

  Netchart_Impl.prototype.hideNode = function(id) {
    if (Base_Helpers.isObject(id)) {
      id = id.id;
    }
    return this.navigator.hideNode(id, "api");
  };

  Netchart_Impl.prototype.getNode = function(id) {
    return this.layer.idToNode[id];
  };

  Netchart_Impl.prototype.getLink = function(id) {
    return this.layer.idToLink[id];
  };

  Netchart_Impl.prototype.setZoom = function(zoomValue) {
    return this.autoZoom.setZoom(zoomValue, true);
  };

  Netchart_Impl.prototype.resetLayout = function() {
    this.layout.resetLayout();
    this.scene.settings.layout.mode = "dynamic";
    this.autoZoom.setZoom("overview", false);
    return this.events.notifySceneChanges({
      layout: true
    });
  };

  Netchart_Impl.prototype.removeData = function(data, sourceId) {
    var dataObj, node, _i, _len, _ref;
    if (sourceId == null) {
      sourceId = "default";
    }
    if (this.removed) {
      return;
    }
    if (data.nodes) {
      _ref = data.nodes;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        node = _ref[_i];
        this.navigator.removeNode(node.id.toString());
      }
    }
    dataObj = this.getData(sourceId);
    dataObj.removeData(data);
    return this.events.notifySceneChanges({
      data: true
    });
  };

  Netchart_Impl.prototype.exportData = function(visibleOnly, exportCoords) {
    var r;
    if (visibleOnly) {
      r = this.graph.exportData();
    } else {
      r = this.scene.mainData.exportData();
    }
    if (exportCoords) {
      this.graph.exportCoordinates(r.nodes);
    }
    return r;
  };

  Netchart_Impl.prototype.hideMenu = function() {
    return this.menu.hideMenu();
  };


  /* events */

  Netchart_Impl.prototype.extendEventParams = function(p) {
    var _ref;
    if (p.x || p.y) {
      _ref = this.scene.fromDisplay(p.x, p.y), p.chartX = _ref[0], p.chartY = _ref[1];
    }
    p.nodes = this.layer.nodes();
    p.links = this.layer.links();
    p.hoverLink = this.scene.hoverLink;
    p.hoverNode = this.scene.hoverNode;
    p.hoverItem = this.scene.hoverItem;
    p.selection = this.scene.selection;
    return p;
  };

  Netchart_Impl.prototype.defaultClick = function(event) {
    var node;
    if (event.clickNode != null) {
      node = event.clickNode;
      if (this.scene.settings.navigation.expandOnClick) {
        if (!node.expanded) {
          this.expandNode(node.id);
          return event.preventDefault();
        } else if (node.expanded && this.scene.settings.navigation.mode === "manual") {
          this.collapseNode(node.id);
          return event.preventDefault();
        }
      }
    }
  };

  Netchart_Impl.prototype.defaultRightClick = function(event) {
    if (event.clickNode != null) {
      this.scene.mainData.getNodeLinks(event.clickNode.id);
      this.menu.toggleNodeMenu(event.clickNode);
      event.preventDefault();
    }
    if (event.clickLink != null) {
      this.menu.toggleLinkMenu(event.x, event.y, event.clickLink);
      return event.preventDefault();
    }
  };

  Netchart_Impl.prototype.defaultDoubleClick = function(event) {
    var node;
    node = event.clickNode;
    if (node) {
      this.addFocusNode(node.id, -1);
      return event.preventDefault();
    }
  };

  return Netchart_Impl;

})(Itemschart_Impl);
// Generated by CoffeeScript 1.8.0
var Timechart_Settings,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

Timechart_Settings = (function(_super) {
  __extends(Timechart_Settings, _super);

  Timechart_Settings.StaticChart = {
    interaction: {
      zooming: {
        enabled: false
      },
      selection: {
        enabled: false
      },
      scrolling: {
        enabled: false
      }
    }
  };

  Timechart_Settings.FlatTheme = {
    advanced: {
      themeCSSClass: "DVSL-flat",
      assets: []
    },
    area: {
      style: {
        noData: {
          fillColor: "#DDD",
          image: "builtin://linearchart-no-data-light"
        },
        loadingData: {
          fillColor: "#EEE"
        }
      }
    },
    chartTypes: {
      columns: {
        style: {
          gradient: 1,
          depth: 0
        }
      }
    },
    timeAxis: {
      style: {
        showMajorTimeBalloons: false,
        showMinorTimeBalloons: false,
        majorTimeLabel: {
          fillColor: "#000",
          shadowColor: null
        },
        minorTimeLabel: {
          fillColor: "#000",
          shadowColor: null
        },
        dateLighten: {
          fillColor: "rgba(0,0,0,0.05)"
        }
      }
    }
  };

  Timechart_Settings.RoundTheme = {
    advanced: {
      themeCSSClass: "DVSL-round",
      assets: []
    },
    valueAxisDefault: {
      style: {
        valueLabel: {
          fillColor: "#000000",
          font: "11px Arial",
          shadowOffsetX: 0,
          shadowOffsetY: 1,
          shadowBlur: 0,
          shadowColor: "rgba(255,255,255,0.5)"
        }
      }
    },
    timeAxis: {
      style: {
        showMinorTimeBalloons: false,
        showMajorTimeBalloons: true,
        minorTimeBalloonStyle: {
          fillColor: "#FFF",
          shadowOffsetX: 0,
          shadowOffsetY: 2,
          shadowBlur: 2,
          shadowColor: "#888"
        },
        majorTimeBalloonStyle: {
          fillColor: "AAA",
          shadowOffsetX: 0,
          shadowOffsetY: -1,
          shadowBlur: 0,
          shadowColor: "rgba(0,0,0,0.3)"
        },
        minorTimeLabel: {
          fillColor: "#000000",
          font: "12px Arial",
          shadowOffsetX: 0,
          shadowOffsetY: 1,
          shadowBlur: 0,
          shadowColor: "rgba(255,255,255,0.5)"
        },
        majorTimeLabel: {
          fillColor: "#FFF",
          font: "11px Arial",
          shadowOffsetX: 0,
          shadowOffsetY: 1,
          shadowBlur: 1,
          shadowColor: "#7c7c7c"
        },
        dateLighten: {
          fillColor: "rgba(0,0,0,0.05)"
        },
        minorTimeRuler1: {
          lineColor: "rgba(0,0,0,0.2)"
        },
        minorTimeRuler2: {
          lineColor: "rgba(255,255,255,0.1)"
        }
      }
    },
    chartTypes: {
      columns: {
        style: {
          gradient: 0.8,
          depth: 3
        }
      }
    },
    area: {
      style: {
        noData: {
          image: "builtin://linearchart-no-data-dark"
        }
      }
    }
  };

  Timechart_Settings.GradientTheme = {
    advanced: {
      themeCSSClass: "DVSL-gradient",
      assets: []
    },
    valueAxisDefault: {
      style: {
        valueLabel: {
          fillColor: "#000000",
          font: "11px Arial",
          shadowOffsetX: 0,
          shadowOffsetY: 1,
          shadowBlur: 0,
          shadowColor: "rgba(255,255,255,0.5)"
        }
      }
    },
    timeAxis: {
      style: {
        showMinorTimeBalloons: false,
        showMajorTimeBalloons: true,
        minorTimeBalloonStyle: {
          fillColor: "#FFF",
          shadowOffsetX: 0,
          shadowOffsetY: 2,
          shadowBlur: 2,
          shadowColor: "#888"
        },
        majorTimeBalloonStyle: {
          fillColor: "AAA",
          shadowOffsetX: 0,
          shadowOffsetY: -1,
          shadowBlur: 0,
          shadowColor: "rgba(0,0,0,0.3)"
        },
        minorTimeLabel: {
          fillColor: "#000000",
          font: "12px Arial",
          shadowOffsetX: 0,
          shadowOffsetY: 1,
          shadowBlur: 0,
          shadowColor: "rgba(255,255,255,0.5)"
        },
        majorTimeLabel: {
          fillColor: "#FFF",
          font: "11px Arial",
          shadowOffsetX: 0,
          shadowOffsetY: 1,
          shadowBlur: 1,
          shadowColor: "#7c7c7c"
        },
        dateLighten: {
          fillColor: "rgba(255,255,255,0.2)"
        },
        minorTimeRuler1: {
          lineColor: "rgba(0,0,0,0.2)"
        },
        minorTimeRuler2: {
          lineColor: "rgba(255,255,255,0.1)"
        }
      }
    },
    chartTypes: {
      columns: {
        style: {
          gradient: 0.8,
          depth: 3
        }
      }
    },
    area: {
      style: {
        noData: {
          image: "builtin://linearchart-no-data-dark"
        }
      }
    }
  };

  Timechart_Settings.defaults = Base_Settings.extendDefaults(Linearchart_Settings.defaults, {
    theme: Timechart_Settings.FlatTheme,
    navigation: {
      _doc: {
        doc: "Settings to specify initial view once the page loaded.",
        type: "section"
      },
      initialDisplayAnchor: "newestData",
      initialDisplayAnchor_doc: {
        doc: "Specifies anchor position for initial time period. Use it together with initialDisplayPeriod from which beginning is calculated.",
        type: "enum",
        values: {
          "now": "set end of the period to current time",
          "newestData": "set end of the period to newest data",
          "oldestData": "set beginning of the period to oldest data",
          "timeStamp": "set period end time in milliseconds"
        }
      },
      initialDisplayPeriod: "max",
      initialDisplayPeriod_doc: {
        doc: "Time period to show initially. Use in combination with intitialDisplayAnchor.",
        type: "enum",
        values: {
          "max": "show all data",
          "timestamp > timestamp": "show time range specified by two timestamps, in milliseconds.",
          "custom": "specify time period to show like '10 seconds','5 minutes'."
        }
      },
      initialDisplayUnit: "auto",
      initialDisplayUnit_doc: {
        doc: "Data display unit to use for initial view.",
        type: "enum",
        values: {
          "auto": "determine automatically based on time range.",
          "": "'1 m', '3 weeks', ... - specify custom time unit."
        }
      },
      followAnchor: false,
      followAnchor_doc: {
        doc: "Whether to allow the chart view to follow display anchor. Use it for real-time updates.",
        type: "bool"
      }
    },
    area: {
      displayUnits_doc: {
        doc: "List of time units to use for data aggregation.",
        type: "array",
        baseObject: {
          _doc: {
            doc: "Display unit.",
            type: "object"
          },
          unit: null,
          unit_doc: {
            doc: "Used units.",
            type: "string"
          },
          name: null,
          name_doc: {
            doc: "Name of used units.",
            type: "string"
          }
        }
      },
      displayUnits: [
        {
          unit: "1 s",
          name: "second"
        }, {
          unit: "5 s",
          name: "5 seconds"
        }, {
          unit: "1 m",
          name: "minute"
        }, {
          unit: "5 m",
          name: "5 minutes"
        }, {
          unit: "1 h",
          name: "hour"
        }, {
          unit: "6 h",
          name: "6 hours"
        }, {
          unit: "1 d",
          name: "day"
        }, {
          unit: "1 M",
          name: "month"
        }, {
          unit: "1 y",
          name: "year"
        }
      ],
      displayPeriods_doc: {
        doc: "List of display periods to show in time axis and snap the chart to.",
        type: "array",
        baseObject: Timechart_Toolbar.periodSettings
      },
      displayPeriods: [
        {
          displayPeriod: "10 ms"
        }, {
          displayPeriod: "100 ms"
        }, {
          displayPeriod: "s"
        }, {
          displayPeriod: "m"
        }, {
          displayPeriod: "h"
        }, {
          displayPeriod: "d"
        }, {
          displayPeriod: "M"
        }, {
          displayPeriod: "y"
        }, {
          displayPeriod: "10 y"
        }, {
          displayPeriod: "100 y"
        }
      ],
      noData: true,
      style: {
        _doc: {
          doc: "Area style settings.",
          type: "object"
        },
        loadingData: {
          _doc: {
            doc: "",
            type: "object",
            hide: true
          },
          fillColor: "#BBB"
        },
        markerText: {
          _doc: {
            doc: "Text style for all markers.",
            type: "object"
          },
          font: "12px Arial"
        },
        selection: {
          _doc: {
            doc: "Time period selection style.",
            type: "object"
          },
          lineColor: "#000000",
          lineWidth: 1,
          fillColor: "rgba(30,160,220,0.15)"
        },
        selectionLabel: {
          _doc: {
            doc: "Time period selection text style.",
            type: "object"
          },
          fillColor: "#000000",
          font: "12px Arial"
        }
      }
    },
    currentTime: Timechart_TimeUpdater.settingsCurTime,
    timeAxis: Timechart_TimeAxis.settings,
    data: Timechart_Data.settings,
    toolbar: Timechart_Toolbar.settings,
    localization: {
      calendar: {
        _doc: {
          doc: "Calendar specific localization settings. This section is used to initialize moment.js locale. See moment.js documentation for detailed description: http://momentjs.com/docs/#/customization/ .",
          type: "object"
        },
        months: ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'],
        monthsShort: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'],
        weekdays: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'],
        weekdaysShort: ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'],
        weekdaysMin: ['Su', 'Mo', 'Tu', 'We', 'Th', 'Fr', 'Sa'],
        week: {
          dow: 1,
          doy: 4
        }
      },
      holidayWeekdays: [6, 7],
      holidayWeekdays_doc: {
        doc: "Weekdays that are considered holidays.",
        type: "array",
        baseObject: "integer"
      },
      toolbar: {
        customPeriod: "Custom",
        customPeriod_doc: {
          doc: "Text to show in display periods drop-down when current period does not match any of the presets.",
          type: "string"
        },
        periodDropdownTitle: "Select units in which to show the data",
        periodDropdownTitle_doc: {
          doc: "Display period dropdown title.",
          type: "string"
        },
        unitDropdownTitle: "Select units in which to show the data",
        unitDropdownTitle_doc: {
          doc: "Display unit dropdown title.",
          type: "string"
        },
        zoomoutButton: "Zoom-out",
        zoomoutButton_doc: {
          doc: "Zoom out button text.",
          type: "string"
        },
        zoomoutTitle: "Zoom out",
        zoomoutTitle_doc: {
          doc: "Zoom out button title.",
          type: "string"
        }
      },
      timeUnitsNames: {
        ms: "millisecond",
        s: "second",
        m: "minute",
        h: "hour",
        d: "day",
        "w": "week",
        M: "month",
        y: "year"
      },
      timeUnitsNames_doc: {
        doc: "Named time units.",
        type: "objArray",
        baseObject: "string"
      },
      timeUnitsNamesPlural: {
        ms: "milliseconds",
        s: "seconds",
        m: "minutes",
        h: "hours",
        d: "days",
        "w": "weeks",
        M: "months",
        y: "years"
      },
      timeUnitsNamesPlural_doc: {
        doc: "Plural forms of time units.",
        type: "objArray",
        baseObject: "string"
      },
      markerDates: {
        _doc: {
          doc: "Localizable strings for markers.",
          type: "section"
        },
        timeFormats: {
          ms: "HH:mm:ss",
          s: "HH:mm:ss",
          m: "HH:mm:ss",
          h: "HH:mm",
          d: "D, HH:mm",
          w: "MMM D",
          M: "MMM D",
          y: "YYYY, MMM D"
        },
        timeFormats_doc: {
          doc: "Time formatting strings for time marker date.",
          type: "objArray",
          baseObject: "string"
        }
      },
      infoDates: {
        _doc: {
          doc: "Localizable strings displayed in info popup.",
          type: "section"
        },
        majorTimeFormats: {
          y: null,
          M: "YYYY",
          w: "YYYY",
          d: "YYYY",
          h: "MMM D, YYYY",
          m: "MMM D, YYYY",
          s: "MMM D, YYYY",
          ms: "MMM D, YYYY"
        },
        majorTimeFormats_doc: {
          doc: "Time formatting strings for time marker date.",
          type: "objArray",
          baseObject: "string"
        },
        minorTimeFormats: {
          y: "YYYY",
          M: "MMM",
          w: "[Week] W",
          d: "MMM D",
          h: "HH:mm",
          m: "HH:mm",
          s: "HH:mm:ss",
          ms: "ss.SSS"
        },
        minorTimeFormats_doc: {
          doc: "Time formatting strings for info popup time display.",
          type: "objArray",
          baseObject: "string"
        },
        fullTimeFormats: {
          ms: "MMM D, YYYY HH:mm:ss",
          s: "MMM D, YYYY HH:mm:ss",
          m: "MMM D, YYYY, HH:mm",
          h: "MMM D, YYYY HH:00",
          d: "MMM D, YYYY",
          w: "[Week] W, YYYY",
          M: "MMM YYYY",
          y: "YYYY"
        },
        fullTimeFormats_doc: {
          doc: "Time formatting strings to display full time for given time unit.",
          type: "objArray",
          baseObject: "string"
        }
      },
      timeAxisDates: {
        _doc: {
          doc: "Localizable strings displayed in time axis.",
          type: "section"
        },
        minorLabelTimeFormats: {
          ms: "ss.SSS",
          s: "HH:mm:ss",
          m: "HH:mm",
          h: "HH:00",
          d: "MMM D",
          w: "MMM D",
          M: "MMM",
          y: "YYYY"
        },
        minorLabelTimeFormats_doc: {
          doc: "Time formatting strings for minor time units in top line of time axis.",
          type: "objArray",
          baseObject: "string"
        },
        majorLabelTimeFormats: {
          ms: "MMM D, YYYY HH:mm:ss",
          s: "MMM D, YYYY HH:mm:ss",
          m: "MMM D, YYYY",
          h: "MMM D, YYYY HH:00",
          d: "MMM D, YYYY",
          w: "[Week] W, YYYY",
          M: "MMM YYYY",
          y: "YYYY"
        },
        majorLabelTimeFormats_doc: {
          doc: "Time formatting strings for major time units in bottom line of time axis.",
          type: "objArray",
          baseObject: "string"
        },
        majorLabelFullTimeFormats: {
          ms: "MMM D, YYYY HH:mm:ss",
          s: "MMM D, YYYY HH:mm:ss",
          m: "MMM D, YYYY",
          h: "MMM D, YYYY HH:00",
          d: "MMM D, YYYY",
          w: "[Week] W, YYYY",
          M: "MMM YYYY",
          y: "YYYY"
        },
        majorLabelFullTimeFormats_doc: {
          doc: "Time formatting strings for major time units in bottom line of time axis.",
          type: "objArray",
          baseObject: "string"
        }
      },
      noDataLabel: "No data",
      noDataLabel_doc: {
        doc: "Text to show when there is no data to display.",
        type: "string"
      },
      determiningDataBounds: "Determining data bounds",
      determiningDataBounds_doc: {
        doc: "Message being displayed while loading initial data.",
        type: "string"
      },
      loadingLabel: "Loading..."
    },
    events: {
      onTimeChange: null,
      chartUpdateDelay: 400
    },
    interaction: {
      snapMode: "displayUnit",
      snapMode_doc: {
        doc: "Snap mode determines how the chart locks on to data periods after dragging, scrolling and other actions.",
        type: "enum",
        values: {
          "unit": "snap to full display unit (one column).",
          "period": "snap to full calendar period (one month, one day). Periods are defined in settings.area.displayPeriods.",
          "multiPeriod": "snap to one or several periods.",
          "null": "no snap, chart will remain at any position"
        }
      },
      selection: Timechart_Selection.settings,
      scrolling: Timechart_Scrolling.settings
    },
    advanced: {
      timeUpdateInterval: 1000,
      timeUpdateInterval_doc: {
        doc: "Time interval in which current time marker is updated, in ms.",
        type: "integer"
      },
      dataUpdateInterval: null,
      dataUpdateInterval_doc: {
        doc: "Determines how frequently to poll for new data. If set to null data polling is disabled.",
        type: "integer"
      },
      maxUnitsToDisplay: 20000,
      maxUnitsToDisplay_doc: {
        doc: "Maximum data points to render in one view. Note that TimeChart will not allow to select such time unit that will result in more points being rendered.",
        type: "integer"
      },
      builtinAssets: {
        "linearchart-no-data-light": builtinImages["no-data-light.png"],
        "linearchart-no-data-dark": builtinImages["no-data-dark.png"]
      },
      assets: ["assets://timechart.css"]
    }
  });

  function Timechart_Settings(settings) {
    Timechart_Settings.__super__.constructor.call(this, Timechart_Settings.defaults);
    this.area._minUnit = null;
    this.area._minDisplayRange = 10;
    this.currentTime._computedTimeOffset = -new Date().getTimezoneOffset() * 1000 * 60;
    this.apply(settings);
  }

  Timechart_Settings.prototype.apply = function(settings) {
    var changes;
    this.applyCompatibility(settings, [
      {
        from: "toolbars",
        to: "toolbar"
      }, {
        from: "toolbar.periodSelection",
        to: "toolbar.displayPeriod"
      }, {
        from: "toolbar.zoomOutButton",
        to: "toolbar.zoomOut"
      }, {
        from: "toolbar.backButton",
        to: "toolbar.back"
      }, {
        from: "interaction.scrolling.noData",
        to: "interaction.scrolling.limitMode"
      }, {
        from: "interaction.scrolling.noDataSnapBackProportion",
        to: "interaction.scrolling.overscrollProportion",
        transform: function(v) {
          return 1 - v;
        }
      }, {
        from: "area.initialDisplayPeriod",
        to: "navigation.initialDisplayPeriod"
      }, {
        from: "area.initialDisplayAnchor",
        to: "navigation.initialDisplayAnchor"
      }, {
        from: "area.initialDisplayUnit",
        to: "navigation.initialDisplayUnit"
      }, {
        from: "area.followAnchor",
        to: "navigation.followAnchor"
      }, {
        from: "timeAxis.style.vgrid",
        to: "timeAxis.style.vgrid.lineColor",
        filter: function(v) {
          return typeof v === "string";
        }
      }
    ]);
    changes = Timechart_Settings.__super__.apply.call(this, settings);
    this._calcMinUnit();
    if (Base_Helpers.hasProp(this, "area.displayUnits")) {
      this.area._displayUnitsParsed = this._parseUnits(this.area.displayUnits);
    }
    if (Base_Helpers.hasProp(this, "area.displayPeriods")) {
      this.area._displayPeriodsParsed = this._parsePeriods(this.area.displayPeriods);
    }
    if (Base_Helpers.isNumber(Base_Helpers.getProp(settings, "currentTime.serverTime"))) {
      this.currentTime._computedTimeOffset = settings.currentTime.serverTime - new Date().getTime() - new Date().getTimezoneOffset() * 1000 * 60;
    }
    return changes;
  };

  Timechart_Settings.prototype._parseUnits = function(unitList) {
    var r, s, t, _i, _len;
    r = [];
    for (_i = 0, _len = unitList.length; _i < _len; _i++) {
      s = unitList[_i];
      t = Base_TimeStep.parse(s);
      if (t === null) {
        Base_Helpers.error("Settings: unknown time unit '" + s + "'");
      } else if (this.area._minUnit.isSmallerOrEqual(t)) {
        r.push(t);
      }
    }
    return r;
  };

  Timechart_Settings.prototype._parsePeriods = function(unitList) {
    var p, r, s, u, x, _i, _len;
    r = [];
    for (_i = 0, _len = unitList.length; _i < _len; _i++) {
      s = unitList[_i];
      x = Base_Helpers.clone(s);
      x.displayUnit = u = Base_TimeStep.parse(s.displayUnit);
      x.displayPeriod = p = Base_TimeStep.parse(s.displayPeriod);
      if ((p === null || this.area._minUnit.isSmallerOrEqual(p)) && (u === null || this.area._minUnit.isSmallerOrEqual(u))) {
        r.push(x);
      }
    }
    return r;
  };

  Timechart_Settings.prototype._filterPeriods = function(list) {
    var p, r, s, u, _i, _len;
    r = [];
    for (_i = 0, _len = list.length; _i < _len; _i++) {
      s = list[_i];
      u = Base_TimeStep.parse(s.displayUnit);
      p = Base_TimeStep.parse(s.displayPeriod);
      if ((p === null || this.area._minUnit.isSmallerOrEqual(p)) && (u === null || this.area._minUnit.isSmallerOrEqual(u))) {
        r.push(s);
      }
    }
    return r;
  };

  Timechart_Settings.prototype._calcMinUnit = function() {
    var data, minUnit, minUnit2, s, ss, step, unit, _i, _j, _k, _len, _len1, _len2, _ref, _ref1, _ref2;
    minUnit = new Base_TimeStep("y", 1e6);
    _ref = this.area.displayUnits;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      s = _ref[_i];
      ss = Base_TimeStep.parse(s);
      if (ss.isSmaller(minUnit)) {
        minUnit = ss;
      }
    }
    minUnit2 = new Base_TimeStep("y", 1e6);
    _ref1 = this._computedSeries;
    for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
      s = _ref1[_j];
      data = this._computedDataMap[s.data.source];
      if (data != null ? data.units : void 0) {
        _ref2 = data.units;
        for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
          unit = _ref2[_k];
          step = new Base_TimeStep(unit, 1);
          if (step.isSmaller(minUnit2)) {
            minUnit2 = step;
          }
        }
      }
    }
    if (minUnit2.isBigger(minUnit)) {
      minUnit = minUnit2;
    }
    this.area._minUnit = minUnit;
    return this.area._minDisplayRange = minUnit.approxTime() * 10;
  };

  return Timechart_Settings;

})(Linearchart_Settings);
// Generated by CoffeeScript 1.8.0
var Facetchart_Settings,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

Facetchart_Settings = (function(_super) {
  __extends(Facetchart_Settings, _super);

  Facetchart_Settings.defaults = Base_Settings.extendDefaults(Linearchart_Settings.defaults, {
    theme: null,
    data: Piechart_Data.settings,
    filters: {
      _doc: {
        doc: "Configurable conditions to filter the raw data values for subset of drawing facets.",
        type: "section"
      },
      sliceFilter: null,
      sliceFilter_doc: {
        doc: "Determine whether to show item or not.",
        type: "function",
        parameters: {
          "item": "the item to test."
        },
        returns: "true to show, false to not show."
      }
    },
    navigation: {
      _doc: {
        doc: "Settings to specify initial view once the page loaded.",
        type: "section"
      },
      initialDrilldown: "",
      initialDrilldown_doc: {
        doc: "Initial facet drilldown to show. For example ['', 'Firefox', 'Firefox 2.5'] denotes to various browsers grouped by versions.",
        type: "array",
        baseObject: "string"
      },
      initialOffset: 0,
      initialOffset_doc: {
        doc: "Initial scroll offset, number of items from start.",
        type: "integer"
      },
      initialSelection: []
    },
    items: {
      _doc: {
        doc: "Series cluster including name placed on facet axis.",
        type: "section"
      },
      style: {
        _doc: {
          doc: "Facet item style.",
          type: "object"
        },
        label: null,
        _doc: {
          doc: "Facet item text",
          type: "string"
        },
        expandable: true,
        expandable_doc: {
          doc: "Whether to open series item on click",
          type: "bool"
        }
      },
      styleFunction: null,
      styleFunction_doc: {
        doc: "Dynamically determine item style from data.",
        type: "function",
        parameters: {
          "item": "item to apply predefined style.",
          "itemData": "data relevant to item"
        },
        returns: ""
      }
    },
    facetAxis: Facetchart_FacetAxis.settings,
    events: {
      onPieChange: null,
      onPieReadyStateChanged: null
    },
    interaction: {
      selection: Facetchart_Selection.settings
    },
    info: Facetchart_InfoPopup.settings,
    toolbar: Facetchart_Toolbar.settings,
    legend: Linearchart_Legend.settings,
    localization: {
      toolbar: {
        zoomoutTitle: "Zoom-out to previous level"
      }
    }
  });

  function Facetchart_Settings(settings) {
    Facetchart_Settings.__super__.constructor.call(this, Facetchart_Settings.defaults);
    this.apply(settings);
  }

  Facetchart_Settings.prototype.apply = function(settings) {
    var changes;
    this.applyCompatibility(settings, [
      {
        from: "area.initialPieId",
        to: "navigation.initialDrilldown"
      }, {
        from: "area.initialPieOffset",
        to: "navigation.initialOffset"
      }, {
        from: "area.initialSelection",
        to: "navigation.initialSelection"
      }
    ]);
    changes = Facetchart_Settings.__super__.apply.call(this, settings);
    return changes;
  };

  return Facetchart_Settings;

})(Linearchart_Settings);
// Generated by CoffeeScript 1.8.0
var Timechart_Renderer;

Timechart_Renderer = (function() {
  "use strict";
  Timechart_Renderer.prototype.animationOrder = 400;

  Timechart_Renderer.prototype.paintOrder = 5;

  Timechart_Renderer.prototype.updateOrder = 1500;

  function Timechart_Renderer(chart, dataWarehouse) {
    this.chart = chart;
    this.dataWarehouse = dataWarehouse;
    this.scene = this.chart.scene;
    this.events = this.chart.events;
    this.buildSeries();
    this.shades = new Linearchart_DataLimitRenderer(this);
  }

  Timechart_Renderer.prototype.buildSeries = function() {
    var series, _i, _len, _ref, _results;
    this.valueAxis = new Linearchart_ValueAxisSet(this.chart, this.scene.settings._computedValueAxisList);
    this.r = new Linearchart_Renderer(this.chart, this.valueAxis);
    this.dataWarehouse.clear();
    this.requestIds = [];
    _ref = this.scene.settings._computedSeries;
    _results = [];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      series = _ref[_i];
      _results.push(this.requestIds.push(this.dataWarehouse.registerDataProcessingRequest(series.data)));
    }
    return _results;
  };

  Timechart_Renderer.prototype.onSceneChange = function(event) {
    var changes;
    changes = event.changes;
    if (changes.settings) {
      if (changes.settingsChanges._computedSeries || changes.settingsChanges._computedValueAxis) {
        this.buildSeries();
      }
      if (changes.settingsChanges._computedValueAxis) {
        changes.bounds = true;
      }
    }
    if (changes.bounds || changes.settings) {
      return changes.time = true;
    }
  };

  Timechart_Renderer.prototype.getPanels = function() {
    return this.valueAxis.getPanels();
  };

  Timechart_Renderer.prototype.doAnimations = function(event) {
    var changes, data, id, _i, _len, _ref;
    changes = event.changes;
    this.dataWarehouse.process(event);
    if (this.scene.displayUnit != null) {
      if (this.displayUnit !== this.scene.displayUnit) {
        this.displayUnit = this.scene.displayUnit;
        changes.displayUnit = true;
      }
      data = [];
      _ref = this.requestIds;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        id = _ref[_i];
        data.push(this.dataWarehouse.getData(id));
      }
      if (changes.time || changes.data || changes.displayUnit || changes.bounds) {
        this.r.process(data);
      }
      this.valueAxis.updateMinMax(event);
      this.r.afterProcess();
      return this.valueAxis.doAnimations(event);
    }
  };

  Timechart_Renderer.prototype.paintScene = function(event) {
    var context, h, w, x, y, _ref;
    context = event.context;
    _ref = [this.scene.x0, this.scene.y0, this.scene.width, this.scene.height], x = _ref[0], y = _ref[1], w = _ref[2], h = _ref[3];
    this.valueAxis.paintUnder(event);
    Base_Graphics.pushClip(context, x, y, w, h);
    this.r.paint(event);
    this.shades.paint(context);
    Base_Graphics.popClip(context);
    return this.valueAxis.paint(event);
  };

  Timechart_Renderer.prototype.hitTest = function(x, y) {
    if (!this.scene.xyInChart(x, y)) {
      return null;
    }
    return this.r.hitTest(x, y, this.scene.settings.interaction.selection.tolerance);
  };

  Timechart_Renderer.prototype.exportData = function(from, to) {
    return this.r.exportData(from, to);
  };

  return Timechart_Renderer;

})();
// Generated by CoffeeScript 1.8.0
var Facetchart_Layer, Facetchart_Renderer,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

Facetchart_Layer = (function() {
  function Facetchart_Layer(event, chart, facet) {
    this.chart = chart;
    this.facet = facet;
    this.scene = this.chart.scene;
    this.valueAxis = new Linearchart_ValueAxisSet(this.chart, this.scene.settings._computedValueAxisList);
    this.xes = [];
    this.facetAxis = new Facetchart_FacetAxis(chart, facet);
    this.r = new Linearchart_Renderer(this.chart, this.valueAxis);
  }

  Facetchart_Layer.prototype.getPanels = function() {
    var panels;
    panels = this.valueAxis.getPanels();
    panels.push(this.facetAxis.getPanel());
    return panels;
  };

  Facetchart_Layer.prototype.setPanels = function(panels) {
    return this.facetAxis.panel = panels[panels.length - 1];
  };

  Facetchart_Layer.prototype.doAnimations = function(event, bounds) {
    var changes, h, i, item, itemValue, left, max, min, offset, right, series, si, styleArray, times, tradd, trmul, valueArray, values, w, x, x0, x1, xes, y, _i, _j, _k, _len, _ref, _ref1, _ref2;
    x = bounds[0], y = bounds[1], w = bounds[2], h = bounds[3];
    offset = this.facet.offset;
    left = this.facet.left;
    right = this.facet.right;
    left = x + w * left;
    right = x + w * right;
    x0 = Math.max(x, left);
    x1 = Math.min(x + w, right);
    this.bounds = [x0, y, x1 - x0, h];
    changes = event.changes;
    if (changes.position || changes.data || changes.bounds || changes.items) {
      trmul = (right - left) / (this.facet.to - this.facet.from);
      tradd = left - this.facet.from * trmul;
      times = [];
      xes = [];
      min = Math.max(offset, Math.floor(this.facet.from - 1));
      max = Math.min(offset + this.facet.count, Math.ceil(this.facet.to + 1));
      for (i = _i = min, _ref = max - 1; _i <= _ref; i = _i += 1) {
        times.push(i);
        xes.push(i * trmul + tradd);
      }
      times.push(max);
      xes.push(max * trmul + tradd);
      this.xes = xes;
      values = [];
      _ref1 = this.scene.settings._computedSeries;
      for (si = _j = 0, _len = _ref1.length; _j < _len; si = ++_j) {
        series = _ref1[si];
        valueArray = [];
        styleArray = [];
        for (i = _k = min, _ref2 = max - 1; _k <= _ref2; i = _k += 1) {
          item = this.facet.items[i - offset];
          itemValue = item.values[si];
          valueArray.push(itemValue.value);
          styleArray.push(itemValue);
        }
        values.push({
          xes: xes,
          times: times,
          fromIndex: 0,
          toIndex: times.length,
          values: valueArray,
          style: styleArray
        });
      }
      this.r.process(values);
    }
    this.valueAxis.updateMinMax(event);
    this.r.afterProcess();
    return this.valueAxis.doAnimations(event);
  };

  Facetchart_Layer.prototype.paintScene = function(event) {
    var context, h, w, x, y, _ref;
    context = event.context;
    _ref = this.bounds, x = _ref[0], y = _ref[1], w = _ref[2], h = _ref[3];
    context.globalAlpha = this.facet.opacity;
    this.valueAxis.paintUnder(event);
    Base_Graphics.pushClip(context, x, y, w, h);
    this.r.paint(event);
    Base_Graphics.popClip(context);
    this.facetAxis.paint(event, this.bounds[0], this.bounds[2], this.xes);
    this.valueAxis.paint(event);
    return context.globalAlpha = 1;
  };

  return Facetchart_Layer;

})();

Facetchart_Renderer = (function(_super) {
  "use strict";
  __extends(Facetchart_Renderer, _super);

  Facetchart_Renderer.prototype.animationOrder = 400;

  Facetchart_Renderer.prototype.paintOrder = 5;

  Facetchart_Renderer.prototype.updateOrder = 1200;

  function Facetchart_Renderer(chart) {
    this.chart = chart;
    this.scene = this.chart.scene;
    this.events = this.chart.events;
    this.layers = [];
    this.panels = [];
  }

  Facetchart_Renderer.prototype.onSceneChange = function(event) {
    var changes, f, i, l, layer, sc, _i, _j, _len, _len1, _ref, _ref1, _results;
    changes = event.changes;
    if (changes.settings || changes.navigation) {
      if (changes.settings) {
        sc = changes.settingsChanges;
        if (sc._computedValueAxis || sc._computedSeries) {
          this.layers = [];
        }
        if (sc._computedValueAxis || sc.facetAxis) {
          changes.bounds = true;
        }
        if (sc._computedSeries) {
          this.layers = [];
        }
      }
      _ref = this.layers;
      for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
        layer = _ref[i];
        if (layer.facet !== this.scene.stack[i]) {
          this.layers = this.layers.slice(0, i);
        }
      }
      while (this.layers.length < this.scene.stack.length) {
        f = this.scene.stack[this.layers.length];
        l = new Facetchart_Layer(event, this.chart, f);
        this.layers.push(l);
      }
      if (this.layers.length === 0) {
        this.layers.push(new Facetchart_Layer(event, this.chart, new Facetchart_Facet()));
      }
      this.panels = [];
      this.panels = this.layers[0].getPanels();
      _ref1 = this.layers;
      _results = [];
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        l = _ref1[_j];
        _results.push(l.setPanels(this.panels));
      }
      return _results;
    }
  };

  Facetchart_Renderer.prototype.getPanels = function() {
    return this.panels;
  };

  Facetchart_Renderer.prototype.doAnimations = function(event) {
    var h, layer, w, x, y, _i, _len, _ref, _results;
    x = this.scene.x0;
    y = this.scene.y0;
    w = this.scene.width;
    h = this.scene.height;
    _ref = this.layers;
    _results = [];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      layer = _ref[_i];
      _results.push(layer.doAnimations(event, [x, y, w, h]));
    }
    return _results;
  };

  Facetchart_Renderer.prototype.paintScene = function(event) {
    var layer, _i, _len, _ref, _results;
    _ref = this.layers;
    _results = [];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      layer = _ref[_i];
      _results.push(layer.paintScene(event));
    }
    return _results;
  };

  Facetchart_Renderer.prototype.exportData = function(from, to) {
    return this.layers[this.layers.length - 1].r.exportData(from, to);
  };

  Facetchart_Renderer.prototype.hitTest = function(x, y) {
    if (!(this.scene.xyInChart(x, y) && this.layers.length > 0)) {
      return null;
    }
    return this.layers[this.layers.length - 1].r.hitTest(x, y, this.scene.settings.interaction.selection.tolerance);
  };

  return Facetchart_Renderer;

})(Base_ChartElement);
// Generated by CoffeeScript 1.8.0
var NetChart,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

NetChart = (function(_super) {
  "use strict";
  __extends(NetChart, _super);

  NetChart.settings = Netchart_Settings;

  function NetChart(settings) {

    /*
    Executed when **new NetChart(settings)** is called. Will create new chart, filling the whole container, load data and display.
     */
    this._impl = new Netchart_Impl(settings, this);
    this.settings = this._impl.settings;
    this._scene = this._impl.scene;
    return this;
  }

  NetChart.prototype.getNode = function(id) {
    return this._impl.getNode(id);
  };

  NetChart.prototype.getLink = function(id) {
    return this._impl.getLink(id);
  };

  NetChart.prototype.showNode = function(id) {
    return this._impl.addFocusNode(id, 0.9);
  };

  NetChart.prototype.hideNode = function(id) {
    return this._impl.hideNode(id);
  };

  NetChart.prototype.expandNode = function(id) {
    return this._impl.expandNode(id);
  };

  NetChart.prototype.addFocusNode = function(id, range) {
    if (range == null) {
      range = -1;
    }
    return this._impl.addFocusNode(id, range);
  };

  NetChart.prototype.removeFocusNode = function(id) {
    return this._impl.removeFocusNode(id);
  };

  NetChart.prototype.clearFocus = function() {
    return this._impl.clearFocus();
  };

  NetChart.prototype.collapseNode = function(id) {
    return this._impl.collapseNode(id);
  };

  NetChart.prototype.lockNode = function(id, x, y) {
    return this._impl.lockNode(id, x, y);
  };

  NetChart.prototype.unlockNode = function(id) {
    return this._impl.unlockNode(id);
  };

  NetChart.prototype.zoom = function(zoomValue) {
    if (zoomValue) {
      this._impl.setZoom(zoomValue);
    }
    return this._impl.scene.zoom;
  };

  NetChart.prototype.resetLayout = function() {
    return this._impl.resetLayout();
  };

  NetChart.prototype.selection = function(selected) {

    /*
      Set/get selection in javascript timestamp (milliseconds).
      Use null, null to remove selection.
      returns [from, to] in list form.
     */
    if (selected != null) {
      this._impl.setSelection(selected);
    }
    return this._scene.selection;
  };

  NetChart.prototype.zoomIn = function(objects, animate) {
    if (animate == null) {
      animate = true;
    }

    /*
      Zooms in to list of objects
     */
    return this._impl.zoomIn(objects, animate);
  };

  NetChart.prototype.nodes = function() {

    /*
      Returns list of visible nodes
     */
    return this._impl.getCurrentNodes();
  };

  NetChart.prototype.links = function() {

    /*
      Returns list of visible links
     */
    return this._impl.getCurrentLinks();
  };

  NetChart.prototype.getNodeDimensions = function(node) {
    return this._impl.getNodeDimensions(node);
  };

  NetChart.prototype.exportData = function(visibleOnly, exportCoordinates) {
    if (visibleOnly == null) {
      visibleOnly = true;
    }
    if (exportCoordinates == null) {
      exportCoordinates = true;
    }
    return this._impl.exportData(visibleOnly, exportCoordinates);
  };

  return NetChart;

})(Base_Api);
// Generated by CoffeeScript 1.8.0
var Timechart_Impl,
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

Timechart_Impl = (function(_super) {
  "use strict";
  __extends(Timechart_Impl, _super);

  Timechart_Impl.prototype.timeStart = 0;

  Timechart_Impl.prototype.timeEnd = 0;

  Timechart_Impl.prototype.displayUnit = null;

  Timechart_Impl.prototype.selectionStart = 0;

  Timechart_Impl.prototype.selectionEnd = 0;

  function Timechart_Impl(settings, api) {
    this.defaultRightClick = __bind(this.defaultRightClick, this);
    this.defaultClick = __bind(this.defaultClick, this);
    Timechart_Impl.__super__.constructor.call(this, new Timechart_Settings(settings), new Timechart_Scene());
    this.layers = new Linearchart_Layers(this);
    this.initialize(api);
    this.dataWarehouse = new Timechart_DataWarehouse(this);
    this.renderer = this.events.addElement(new Timechart_Renderer(this, this.dataWarehouse));
    this.scrolling = this.events.addElement(new Timechart_Scrolling(this));
    this.selection = this.events.addElement(new Timechart_Selection(this));
    this.navigator = this.events.addElement(new Timechart_Navigator(this));
    this.events.addElement(new Timechart_ClickNotifier(this));
    this.infoPopup = this.events.addElement(new Timechart_InfoPopup(this));
    this.timeAxis = this.events.addElement(new Timechart_TimeAxis(this));
    this.events.addElement(new Timechart_TimeUpdater(this));
    this.events.addElement(new Linearchart_Markers(this));
    this.events.addElement(new Linearchart_Highlights(this));
    this.finalInitialize();
    moment.locale("zc", this.settings.localization.calendar);
  }

  Timechart_Impl.prototype.createDataObj = function(dataSettings) {
    return new Timechart_Data(this, dataSettings);
  };

  Timechart_Impl.prototype.onRemove = function() {
    this.layers = null;
    this.renderer = null;
    return this.scene = null;
  };

  Timechart_Impl.prototype.onSettingsChanged = function(changes) {
    var newUnit, s, _ref;
    if (changes.data != null) {
      changes.toolbars = true;
    } else if (Base_Helpers.hasProp(changes, "area.displayUnits")) {
      s = new Timechart_TimeSetup(this.settings);
      if (!s.isAllowedDisplayUnit(this.scene.displayUnit)) {
        newUnit = s.computeDisplayUnit(this.scene.timeStart, this.scene.timeEnd, this.scene.displayUnit, this.scene.timeStart, this.scene.timeEnd, this.scene);
        this.scrolling.setTimeRangeSnap(this.scene.timeStart, this.scene.timeEnd, null, newUnit, true, "api", true, true);
      }
    }
    if ((_ref = changes.localization) != null ? _ref.calendar : void 0) {
      moment.locale("zc", this.settings.localization.calendar);
    }
    return this.events.notifySceneChanges({
      time: true
    });
  };

  Timechart_Impl.prototype.save = function() {
    return JSON.stringify({
      from: this.timeStart,
      to: this.timeEnd,
      unit: this.displayUnit.toString(),
      selFrom: this.scene.selectionStart,
      selTo: this.scene.selectionEnd,
      anchor: this.scene.anchor,
      period: this.scene.period
    });
  };

  Timechart_Impl.prototype.restore = function(stateStr, animate) {
    var state, unit;
    if (!stateStr) {
      return;
    }
    state = JSON.parse(stateStr);
    unit = Base_TimeStep.parse(state.unit);
    if (!unit) {
      this.error("Restore state: illegal display  unit: " + state.unit);
      return;
    }
    this.scrolling.setTimeRange(state.from, state.to, unit, animate, "api", state.anchor, state.period);
    return this.setSelection(state.selFrom, state.selTo);
  };

  Timechart_Impl.prototype.setSelection = function(from, to, origin) {
    if (origin == null) {
      origin = "api";
    }
    if (this.scene.selectionStart === from && this.scene.selectionEnd === to) {
      return;
    }
    this.scene.selectionStart = from;
    this.scene.selectionEnd = to;
    this.events.notifySceneChanges({
      selection: true
    });
    return this.notifySelectionChanged(origin);
  };

  Timechart_Impl.prototype.setTimeRange = function(from, to, unit, animate, origin) {
    if (origin == null) {
      origin = "api";
    }
    this.setSelection(null, null, origin);
    return this.scrolling.setTimeRange(from, to, unit, animate, origin);
  };

  Timechart_Impl.prototype.setDisplayPeriod = function(displayPeriod, displayAnchor, displayUnit, animate, origin) {
    if (displayAnchor == null) {
      displayAnchor = null;
    }
    if (displayUnit == null) {
      displayUnit = null;
    }
    if (animate == null) {
      animate = true;
    }
    if (origin == null) {
      origin = "api";
    }
    if (displayAnchor == null) {
      displayAnchor = this.scene.anchor;
    }
    this.setSelection(null, null);
    if (typeof displayAnchor === "string") {
      displayAnchor = displayAnchor.trim();
    }
    if (typeof displayPeriod === "string") {
      displayPeriod = displayPeriod.trim();
    }
    return this.navigator.computeDisplayPeriod(displayPeriod, displayAnchor, displayUnit, (function(_this) {
      return function(form, to, unit) {
        return _this.scrolling.setTimeRange(form, to, unit, animate, origin, displayAnchor, displayPeriod);
      };
    })(this));
  };

  Timechart_Impl.prototype.scrollIntoView = function(time, visibleFraction) {
    if (visibleFraction == null) {
      visibleFraction = 0.2;
    }
    return this.error("ScrollIntoView: not implemented");
  };

  Timechart_Impl.prototype.scroll = function(amount, animate) {
    var count, direction, from, s, to, unit, units, _ref;
    units = amount.trim().split(" ");
    if (units.length !== 3) {
      this.error("Incorrect scroll format: " + amount);
      return;
    }
    direction = units[0];
    count = parseInt(units[1]);
    unit = units[2];
    if ((direction !== "<" && direction !== ">") || typeof count !== "number") {
      this.error("Scroll:Incorrect scroll format: " + amount);
      return;
    }
    s = new Timechart_TimeSetup(this.settings);
    _ref = s.scroll(this.timeStart, this.timeEnd, this.displayUnit, direction, count, unit), from = _ref[0], to = _ref[1];
    return this.scrolling.setTimeRange(from, to, this.displayUnit, animate, "api", null, this.scene.period);
  };

  Timechart_Impl.prototype.zoomOut = function(unit, animate, origin) {
    if (animate == null) {
      animate = true;
    }
    if (origin == null) {
      origin = "api";
    }
    this.setSelection(null, null);
    this.scrolling.zoomOut(unit, this.scene.timeStart, this.scene.timeEnd, animate, origin);
    return this.scene.period = null;
  };

  Timechart_Impl.prototype.zoomIn = function(unit, center, animate, origin) {
    if (center == null) {
      center = null;
    }
    if (animate == null) {
      animate = true;
    }
    if (origin == null) {
      origin = "api";
    }
    this.setSelection(null, null);
    this.scrolling.zoomIn(unit, center, this.scene.timeStart, this.scene.timeEnd, animate, origin);
    return this.scene.period = null;
  };

  Timechart_Impl.prototype.getMinSelectableUnit = function() {
    var maxUnitTime, maxUnits;
    maxUnits = this.settings.advanced.maxUnitsToDisplay;
    maxUnitTime = (this.timeEnd - this.timeStart) / maxUnits;
    return new Timechart_TimeSetup(this.settings).getMinUnitForTime(maxUnitTime);
  };

  Timechart_Impl.prototype.setDisplayUnit = function(unitStr, animate, rescale, origin) {
    var anchor, from, minUnit, period, to, unit, viewChanged, _, _ref;
    if (rescale == null) {
      rescale = false;
    }
    if (origin == null) {
      origin = "api";
    }
    unit = Base_TimeStep.parse(unitStr);
    if (unit == null) {
      return;
    }
    viewChanged = false;
    if (rescale) {
      minUnit = this.getMinSelectableUnit();
      if (minUnit.approxTime() > unit.approxTime()) {
        unit = minUnit;
      }
      _ref = this.scrolling.snap(this.timeStart, this.timeEnd, null, unit, false, true), from = _ref[0], to = _ref[1], _ = _ref[2], period = _ref[3], anchor = _ref[4];
      if (to - from > this.timeEnd - this.timeStart) {
        viewChanged = true;
      }
    }
    if (viewChanged) {
      return this.scrolling.setTimeRange(from, to, unit, animate, origin, period, anchor);
    } else {
      return this.scrolling.setTimeRange(this.timeStart, this.timeEnd, unit, false, origin, this.scene.anchor, this.scene.period);
    }
  };

  Timechart_Impl.prototype.exportVisibleData = function() {
    var data, headers, i, j, result, row, s, series, t, timeFormat, timestamps, values, _i, _j, _k, _len, _len1, _len2;
    series = this.settings._computedSeries;
    data = this.dataWarehouse.exportData(this.timeStart, this.timeEnd, this.displayUnit, series);
    timeFormat = this.settings.localization.infoDates.fullTimeFormats[this.displayUnit.unit];
    timestamps = data.timestamps;
    values = data.values;
    headers = ["timestamp", "time"];
    for (_i = 0, _len = series.length; _i < _len; _i++) {
      s = series[_i];
      headers.push(s.name || s.id || "");
    }
    result = [headers];
    for (i = _j = 0, _len1 = timestamps.length; _j < _len1; i = ++_j) {
      t = timestamps[i];
      row = [t, moment(t).utc().format(timeFormat)];
      for (j = _k = 0, _len2 = series.length; _k < _len2; j = ++_k) {
        s = series[j];
        row.push(values[j][i]);
      }
      result.push(row);
    }
    return result;
  };


  /*
    Tests if the display period is currently displayed.
   */

  Timechart_Impl.prototype.isThisDisplayPeriod = function(periodStr, anchorStr) {
    var from, to, unit, _ref;
    if (!this.displayUnit) {
      return false;
    }
    from = this.scene.mainData.dataFrom;
    to = this.scene.mainData.dataTo;
    _ref = this.scrolling.computeDisplayPeriod(periodStr, anchorStr, this.displayUnit, from, to), from = _ref[0], to = _ref[1], unit = _ref[2];
    return from === this.timeStart && to === this.timeEnd;
  };


  /* events */

  Timechart_Impl.prototype.notifyTimeChanged = function(from, to, unit, origin) {
    this.timeStart = from;
    this.timeEnd = to;
    this.displayUnit = unit;
    return this.notifyChartUpdate(origin);
  };

  Timechart_Impl.prototype.saveNavigation = function() {
    if (!this.displayUnit) {
      return null;
    }
    return [this.timeStart, this.timeEnd, this.displayUnit, this.scene.anchor, this.scene.period];
  };

  Timechart_Impl.prototype.restoreNavigation = function(state, animate, origin) {
    var anchor, period;
    this.timeStart = state[0];
    this.timeEnd = state[1];
    this.displayUnit = state[2];
    anchor = state[3];
    period = state[4];
    return this.scrolling.setTimeRange(this.timeStart, this.timeEnd, this.displayUnit, animate, origin, anchor, period);
  };

  Timechart_Impl.prototype.doChartUpdateNotify = function(origin) {
    Timechart_Impl.__super__.doChartUpdateNotify.call(this, origin);
    return this.dispatchEventParams("timeChange", this.extendEventParams({
      origin: origin
    }), null);
  };

  Timechart_Impl.prototype.extendEventParams = function(p) {
    p.timeStart = this.timeStart;
    p.timeEnd = this.timeEnd;
    p.displayUnit = this.displayUnit != null ? this.displayUnit.toString() : null;
    p.selectionStart = this.scene.selectionStart;
    p.selectionEnd = this.scene.selectionEnd;
    p.hoverStart = this.scene.hoverFrom;
    p.hoverEnd = this.scene.hoverTo;
    if (this.scene.hoverSeriesItem !== null) {
      p.hoverSeries = this.scene.settings.series[this.scene.hoverSeriesItem.seriesIndex];
      p.hoverMarker = this.scene.hoverSeriesItem.isMarker;
    }
    return p;
  };


  /* Click handlers */

  Timechart_Impl.prototype.defaultClick = function(event) {
    this.setSelection(null, null, "user");
    return this.scrolling.setTimeRangeSnap(event.clickStart, event.clickEnd, null, null, true, "user", false, true);
  };

  Timechart_Impl.prototype.defaultRightClick = function(event) {
    this.infoPopup.show(event);
    return event.preventDefault();
  };

  return Timechart_Impl;

})(Linearchart_Impl);
// Generated by CoffeeScript 1.8.0
var Facetchart_Impl,
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

Facetchart_Impl = (function(_super) {
  "use strict";
  __extends(Facetchart_Impl, _super);

  Facetchart_Impl.prototype.api = null;

  function Facetchart_Impl(settings, api) {
    this.defaultDoubleClick = __bind(this.defaultDoubleClick, this);
    this.defaultClick = __bind(this.defaultClick, this);
    Facetchart_Impl.__super__.constructor.call(this, new Facetchart_Settings(settings), new Facetchart_Scene());
    this.layers = new Linearchart_Layers(this);
    this.initialize(api);
    this.builder = new Facetchart_Builder(this);
    this.renderer = this.events.addElement(new Facetchart_Renderer(this));
    this.scrolling = this.events.addElement(new Facetchart_Scrolling(this));
    this.selection = this.events.addElement(new Facetchart_Selection(this));
    this.events.addElement(new Facetchart_Styles(this));
    this.events.addElement(new Facetchart_InfoPopup(this));
    this.events.addElement(new Linearchart_Highlights(this));
    this.finalInitialize();
    this.scrolling.setState(this.settings.navigation.initialDrilldown, this.settings.navigation.initialOffset, 0, "init");
  }

  Facetchart_Impl.prototype.createDataObj = function(settings) {
    return new Piechart_Data(this, settings);
  };

  Facetchart_Impl.prototype.onRemove = function() {
    this.layers = null;
    this.renderer = null;
    return this.scene = null;
  };

  Facetchart_Impl.prototype.onSettingsChanged = function(changes) {
    var ch;
    ch = {
      settings: true,
      settingsChanges: changes
    };
    if (changes.navigation) {
      if (changes.navigation) {
        this.scrolling.setState(this.settings.navigation.initialDrilldown, this.settings.navigation.initialOffset, null, "api");
      }
    }
    if (changes.labels || changes.series || changes.interaction) {
      ch.items = true;
    }
    this.events.notifySceneChanges(ch);
    if (changes.data || changes.facetAxis || changes._computedValueAxis) {
      return this.updateSize(true);
    }
  };

  Facetchart_Impl.prototype.updateFilters = function() {
    return this.updateFilter(true);
  };

  Facetchart_Impl.prototype.updateFilter = function(deep) {
    this.log("Update filter");
    return this.events.notifySceneChanges({
      data: true,
      dataDeep: deep
    });
  };

  Facetchart_Impl.prototype.setSelection = function(selection, origin) {
    var n, realSelection, selectionIds, _i, _len;
    if (origin == null) {
      origin = "api";
    }
    this.log("Set selection");
    realSelection = [];
    selectionIds = [];
    for (_i = 0, _len = selection.length; _i < _len; _i++) {
      n = selection[_i];
      if (n instanceof Facetchart_Item) {
        realSelection.push(n);
      } else if (Base_Helpers.isString(n)) {
        selectionIds.push(n);
      } else {
        this.error("SetSelection: Selection contents must be Facetchart_Item object or string, got " + n);
      }
    }
    return this.selection.setSelection(realSelection, selectionIds, false, origin);
  };

  Facetchart_Impl.prototype.setPie = function(root, offset, count, animate) {
    if (count == null) {
      count = null;
    }
    if (animate == null) {
      animate = true;
    }
    this.log("Set pie");
    return this.scrolling.setState(root, offset, count, "api");
  };

  Facetchart_Impl.prototype.getPie = function() {
    return this.scrolling.getState()[0];
  };

  Facetchart_Impl.prototype.getPieOffset = function() {
    return this.scrolling.getState()[1];
  };

  Facetchart_Impl.prototype.getActiveItems = function() {
    var pie, r, _i, _len, _ref;
    r = [];
    _ref = this.scene.stack;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      pie = _ref[_i];
      if (pie.parentItem) {
        r.push(pie.parentItem);
      }
    }
    return r;
  };

  Facetchart_Impl.prototype.getActiveFacets = function() {
    return this.scene.stack;
  };

  Facetchart_Impl.prototype.zoomOut = function(unused, animate, origin) {
    if (animate == null) {
      animate = true;
    }
    if (origin == null) {
      origin = "api";
    }
    return this.scrolling.goUp(origin);
  };

  Facetchart_Impl.prototype.expandItem = function(item, origin) {
    var facet, id;
    facet = item.facet;
    if (facet === this.scene.peek()) {
      id = item.id;
      if (item.expandable && this.scene.mainData.canExpand(id)) {
        this.setSelection([]);
        this.scrolling.drillDown(id, origin);
        return true;
      }
    }
    return false;
  };


  /* events */

  Facetchart_Impl.prototype.saveNavigation = function() {
    var pie;
    pie = this.scene.peek();
    if (!pie || pie.loading || pie.count === 0 || this.scrolling.isActive()) {
      return null;
    }
    return this.scrolling.getState();
  };

  Facetchart_Impl.prototype.restoreNavigation = function(state, animate, origin) {
    return this.scrolling.setState(state[0], state[1], state[2], origin);
  };

  Facetchart_Impl.prototype.save = function() {
    var s, selectionIds, state, _i, _len, _ref;
    selectionIds = this.scene.selectionIds.splice(0);
    _ref = this.scene.selection;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      s = _ref[_i];
      selectionIds.push(s.id);
    }
    state = this.scrolling.getState();
    return JSON.stringify({
      pie: state[0],
      offset: state[1],
      count: state[2],
      selection: selectionIds
    });
  };

  Facetchart_Impl.prototype.restore = function(stateStr, animate) {
    var pie;
    if (!stateStr) {
      return;
    }
    pie = JSON.parse(stateStr);
    this.setPie(pie.pie, pie.offset, pie.count, animate);
    return this.setSelection(pie.selection);
  };

  Facetchart_Impl.prototype.doChartUpdateNotify = function(origin) {
    Facetchart_Impl.__super__.doChartUpdateNotify.call(this, origin);
    this.dispatchEventParams("pieChange", this.extendEventParams({
      origin: origin
    }), null);
    return this.dispatchEventParams("pieReadyStateChanged", this.extendEventParams({
      origin: origin
    }), null);
  };

  Facetchart_Impl.prototype.extendEventParams = function(p) {
    p.facet = this.scene.peek();
    p.offset = p.facet.offset;
    p.count = p.facet.count;
    p.hoverItem = this.scene.hoverItem;
    p.selection = this.scene.selection;
    p.pie = p.facet;
    p.slice = p.clickItem;
    p.clickSlice = p.clickItem;
    p.clickPie = p.clickFacet;
    return p;
  };

  Facetchart_Impl.prototype.defaultClick = function(event) {
    var p, s;
    s = event.slice;
    p = event.clickPie;
    if (s) {
      if (s.url) {
        Base_Helpers.openUrl(s.url);
        return event.preventDefault();
      } else {
        if (this.expandItem(s, "user")) {
          return event.preventDefault();
        }
      }
    }
  };

  Facetchart_Impl.prototype.defaultDoubleClick = function(event) {};

  return Facetchart_Impl;

})(Linearchart_Impl);
// Generated by CoffeeScript 1.8.0

/*
  Creates time chart ghaphical widget.
 */
var TimeChart,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

TimeChart = (function(_super) {
  "use strict";
  __extends(TimeChart, _super);

  TimeChart.themes = {
    "flat": Timechart_Settings.FlatTheme,
    "round": Timechart_Settings.RoundTheme,
    "gradient": Timechart_Settings.GradientTheme,
    "static": Timechart_Settings.StaticChart
  };

  TimeChart.settings = Timechart_Settings;

  function TimeChart(settings) {

    /*
    Executed when **new TimeChart(settings)** is called. Will create new chart, filling the whole container, load data and display.
     */
    this._impl = new Timechart_Impl(settings, this);
    this.settings = this._impl.settings;
    this._scene = this._impl.scene;
    return this;
  }

  TimeChart.prototype.time = function(from, to, animate) {
    if (animate == null) {
      animate = true;
    }

    /*
      Set/get displayed time range in javascript timestamp (milliseconds).
      returns [from, to] in list form.
     */
    if (from !== void 0 && to !== void 0) {
      this._impl.setTimeRange(from, to, null, animate);
    }
    return [this._impl.timeStart, this._impl.timeEnd];
  };


  /*
    Set displayed time range using period and anchor.
    See settings for possible period / anchor values.
   */

  TimeChart.prototype.setDisplayPeriod = function(period, anchor, animate) {
    return this._impl.setDisplayPeriod(period, anchor, null, animate);
  };

  TimeChart.prototype.displayUnit = function(unit, animate, rescale, rescaleCenter) {
    if (animate == null) {
      animate = true;
    }
    if (rescale == null) {
      rescale = false;
    }
    if (rescaleCenter == null) {
      rescaleCenter = null;
    }

    /*
      Get/set current bar unit.
      Examples: m, s, h, 2 h, 10 m
     */
    if (unit != null) {
      this._impl.setDisplayUnit(unit, animate, rescale, rescaleCenter);
    }
    if (this._impl.displayUnit != null) {
      return this._impl.displayUnit.toString();
    } else {
      return null;
    }
  };

  TimeChart.prototype.selection = function(from, to) {

    /*
      Set/get selection in javascript timestamp (milliseconds).
      Use null, null to remove selection.
      returns [from, to] in list form.
     */
    if (from !== void 0 && to !== void 0) {
      this._impl.setSelection(from, to);
    }
    return [this._scene.selectionStart, this._scene.selectionEnd];
  };

  TimeChart.prototype.scroll = function(amount, animate) {
    if (animate == null) {
      animate = true;
    }

    /*
       Scrools left or right.
       Amount format is the following: ** </> amount unit **
    
       * < scrolls to the left, > scrolls to the right
       * amount: integer amount of units to scroll
       * unit: one of page,bar,y,M,d,w,h,m,s,ms
    
       Examples:
       * scroll("< 1 s") scrolls left 1 second, no animation
       * scroll("> 10 y", true) scrolls right, 10 years with animation
     */
    return this._impl.scroll(amount, animate);
  };

  TimeChart.prototype.zoomOut = function(unit, animate) {
    if (unit == null) {
      unit = null;
    }
    if (animate == null) {
      animate = true;
    }

    /*
       Zooms out.
     */
    return this._impl.zoomOut(unit, animate, "api");
  };

  TimeChart.prototype.zoomIn = function(unit, center, animate) {
    if (unit == null) {
      unit = null;
    }
    if (center == null) {
      center = null;
    }
    if (animate == null) {
      animate = true;
    }

    /*
       Zooms out.
     */
    return this._impl.zoomIn(unit, center, animate, "api");
  };

  TimeChart.prototype.replaceSeries = function(series) {
    return this._impl.replaceSeries(series);
  };

  TimeChart.prototype.exportVisibleData = function() {
    return this._impl.exportVisibleData();
  };

  return TimeChart;

})(Base_Api);
// Generated by CoffeeScript 1.8.0
var FacetChart,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

FacetChart = (function(_super) {
  "use strict";
  __extends(FacetChart, _super);

  FacetChart.settings = Facetchart_Settings;

  function FacetChart(settings) {

    /*
    Executed when **new NetChart(settings)** is called. Will create new chart, filling the whole container, load data and display.
     */
    this._impl = new Facetchart_Impl(settings, this);
    this.settings = this._impl.settings;
    this._scene = this._impl.scene;
    return this;
  }

  FacetChart.prototype.updateFilter = function() {
    this._impl.updateFilter();
    return this;
  };

  FacetChart.prototype.selection = function(selected) {

    /*
      Set/get selection in javascript timestamp (milliseconds).
      Use null, null to remove selection.
      returns [from, to] in list form.
     */
    if (selected != null) {
      this._impl.setSelection(selected);
    }
    return this._scene.selection;
  };

  FacetChart.prototype.setPie = function(pieId, offset, count) {
    if (offset == null) {
      offset = 0;
    }
    if (count == null) {
      count = null;
    }
    this._impl.setPie(pieId, offset, count, "api");
    return this;
  };

  FacetChart.prototype.getPie = function() {
    return this._impl.getPie();
  };

  FacetChart.prototype.getPieOffset = function() {
    return this._impl.getPieOffset();
  };

  FacetChart.prototype.getActiveItems = function() {
    return this._impl.getActiveItems();
  };

  FacetChart.prototype.getActiveFacets = function() {
    return this._impl.getActiveFacets();
  };

  FacetChart.prototype.getActiveFacet = function() {
    var p;
    p = this._impl.getActiveFacets();
    return p[p.length - 1];
  };

  FacetChart.prototype.expandSlice = function(slice) {
    return this._impl.expandItem(slice, "api");
  };

  FacetChart.prototype.replaceSeries = function(series) {
    return this._impl.replaceSeries(series);
  };

  return FacetChart;

})(Base_Api);

this.NetChart = NetChart;
this.TimeChart = TimeChart;
this.PieChart = PieChart;
this.FacetChart = FacetChart;
}).call(this);
